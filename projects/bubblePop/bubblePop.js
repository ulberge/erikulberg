var Module;if(!Module)Module=(typeof Module!=="undefined"?Module:null)||{};var moduleOverrides={};for(var key in Module)if(Module.hasOwnProperty(key))moduleOverrides[key]=Module[key];var ENVIRONMENT_IS_NODE=typeof process==="object"&&typeof require==="function";var ENVIRONMENT_IS_WEB=typeof window==="object";var ENVIRONMENT_IS_WORKER=typeof importScripts==="function";var ENVIRONMENT_IS_SHELL=!ENVIRONMENT_IS_WEB&&!ENVIRONMENT_IS_NODE&&!ENVIRONMENT_IS_WORKER;
if(ENVIRONMENT_IS_NODE){if(!Module["print"])Module["print"]=function print(x){process["stdout"].write(x+"\n")};if(!Module["printErr"])Module["printErr"]=function printErr(x){process["stderr"].write(x+"\n")};var nodeFS=require("fs");var nodePath=require("path");Module["read"]=function read(filename,binary){filename=nodePath["normalize"](filename);var ret=nodeFS["readFileSync"](filename);if(!ret&&filename!=nodePath["resolve"](filename)){filename=path.join(__dirname,"..","src",filename);ret=nodeFS["readFileSync"](filename)}if(ret&&
!binary)ret=ret.toString();return ret};Module["readBinary"]=function readBinary(filename){return Module["read"](filename,true)};Module["load"]=function load(f){globalEval(read(f))};Module["arguments"]=process["argv"].slice(2);module["exports"]=Module}else if(ENVIRONMENT_IS_SHELL){if(!Module["print"])Module["print"]=print;if(typeof printErr!="undefined")Module["printErr"]=printErr;if(typeof read!="undefined")Module["read"]=read;else Module["read"]=function read(){throw"no read() available (jsc?)";
};Module["readBinary"]=function readBinary(f){return read(f,"binary")};if(typeof scriptArgs!="undefined")Module["arguments"]=scriptArgs;else if(typeof arguments!="undefined")Module["arguments"]=arguments;this["Module"]=Module}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){Module["read"]=function read(url){var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText};if(typeof arguments!="undefined")Module["arguments"]=arguments;if(typeof console!=="undefined"){if(!Module["print"])Module["print"]=
function print(x){console.log(x)};if(!Module["printErr"])Module["printErr"]=function printErr(x){console.log(x)}}else{var TRY_USE_DUMP=false;if(!Module["print"])Module["print"]=TRY_USE_DUMP&&typeof dump!=="undefined"?function(x){dump(x)}:function(x){}}if(ENVIRONMENT_IS_WEB)window["Module"]=Module;else Module["load"]=importScripts}else throw"Unknown runtime environment. Where are we?";function globalEval(x){eval.call(null,x)}if(!Module["load"]=="undefined"&&Module["read"])Module["load"]=function load(f){globalEval(Module["read"](f))};
if(!Module["print"])Module["print"]=function(){};if(!Module["printErr"])Module["printErr"]=Module["print"];if(!Module["arguments"])Module["arguments"]=[];Module.print=Module["print"];Module.printErr=Module["printErr"];Module["preRun"]=[];Module["postRun"]=[];for(var key in moduleOverrides)if(moduleOverrides.hasOwnProperty(key))Module[key]=moduleOverrides[key];
var Runtime={setTempRet0:function(value){tempRet0=value},getTempRet0:function(){return tempRet0},stackSave:function(){return STACKTOP},stackRestore:function(stackTop){STACKTOP=stackTop},forceAlign:function(target,quantum){quantum=quantum||4;if(quantum==1)return target;if(isNumber(target)&&isNumber(quantum))return Math.ceil(target/quantum)*quantum;else if(isNumber(quantum)&&isPowerOfTwo(quantum))return"((("+target+")+"+(quantum-1)+")&"+-quantum+")";return"Math.ceil(("+target+")/"+quantum+")*"+quantum},
isNumberType:function(type){return type in Runtime.INT_TYPES||type in Runtime.FLOAT_TYPES},isPointerType:function isPointerType(type){return type[type.length-1]=="*"},isStructType:function isStructType(type){if(isPointerType(type))return false;if(isArrayType(type))return true;if(/<?\{ ?[^}]* ?\}>?/.test(type))return true;return type[0]=="%"},INT_TYPES:{"i1":0,"i8":0,"i16":0,"i32":0,"i64":0},FLOAT_TYPES:{"float":0,"double":0},or64:function(x,y){var l=x|0|(y|0);var h=(Math.round(x/4294967296)|Math.round(y/
4294967296))*4294967296;return l+h},and64:function(x,y){var l=(x|0)&(y|0);var h=(Math.round(x/4294967296)&Math.round(y/4294967296))*4294967296;return l+h},xor64:function(x,y){var l=(x|0)^(y|0);var h=(Math.round(x/4294967296)^Math.round(y/4294967296))*4294967296;return l+h},getNativeTypeSize:function(type){switch(type){case "i1":case "i8":return 1;case "i16":return 2;case "i32":return 4;case "i64":return 8;case "float":return 4;case "double":return 8;default:if(type[type.length-1]==="*")return Runtime.QUANTUM_SIZE;
else if(type[0]==="i"){var bits=parseInt(type.substr(1));assert(bits%8===0);return bits/8}else return 0}},getNativeFieldSize:function(type){return Math.max(Runtime.getNativeTypeSize(type),Runtime.QUANTUM_SIZE)},dedup:function dedup(items,ident){var seen={};if(ident)return items.filter(function(item){if(seen[item[ident]])return false;seen[item[ident]]=true;return true});else return items.filter(function(item){if(seen[item])return false;seen[item]=true;return true})},set:function set(){var args=typeof arguments[0]===
"object"?arguments[0]:arguments;var ret={};for(var i=0;i<args.length;i++)ret[args[i]]=0;return ret},STACK_ALIGN:8,getAlignSize:function(type,size,vararg){if(!vararg&&(type=="i64"||type=="double"))return 8;if(!type)return Math.min(size,8);return Math.min(size||(type?Runtime.getNativeFieldSize(type):0),Runtime.QUANTUM_SIZE)},calculateStructAlignment:function calculateStructAlignment(type){type.flatSize=0;type.alignSize=0;var diffs=[];var prev=-1;var index=0;type.flatIndexes=type.fields.map(function(field){index++;
var size,alignSize;if(Runtime.isNumberType(field)||Runtime.isPointerType(field)){size=Runtime.getNativeTypeSize(field);alignSize=Runtime.getAlignSize(field,size)}else if(Runtime.isStructType(field))if(field[1]==="0"){size=0;if(Types.types[field])alignSize=Runtime.getAlignSize(null,Types.types[field].alignSize);else alignSize=type.alignSize||QUANTUM_SIZE}else{size=Types.types[field].flatSize;alignSize=Runtime.getAlignSize(null,Types.types[field].alignSize)}else if(field[0]=="b"){size=field.substr(1)|
0;alignSize=1}else if(field[0]==="<")size=alignSize=Types.types[field].flatSize;else if(field[0]==="i"){size=alignSize=parseInt(field.substr(1))/8;assert(size%1===0,"cannot handle non-byte-size field "+field)}else assert(false,"invalid type for calculateStructAlignment");if(type.packed)alignSize=1;type.alignSize=Math.max(type.alignSize,alignSize);var curr=Runtime.alignMemory(type.flatSize,alignSize);type.flatSize=curr+size;if(prev>=0)diffs.push(curr-prev);prev=curr;return curr});if(type.name_&&type.name_[0]===
"[")type.flatSize=parseInt(type.name_.substr(1))*type.flatSize/2;type.flatSize=Runtime.alignMemory(type.flatSize,type.alignSize);if(diffs.length==0)type.flatFactor=type.flatSize;else if(Runtime.dedup(diffs).length==1)type.flatFactor=diffs[0];type.needsFlattening=type.flatFactor!=1;return type.flatIndexes},generateStructInfo:function(struct,typeName,offset){var type,alignment;if(typeName){offset=offset||0;type=(typeof Types==="undefined"?Runtime.typeInfo:Types.types)[typeName];if(!type)return null;
if(type.fields.length!=struct.length){printErr("Number of named fields must match the type for "+typeName+": possibly duplicate struct names. Cannot return structInfo");return null}alignment=type.flatIndexes}else{var type={fields:struct.map(function(item){return item[0]})};alignment=Runtime.calculateStructAlignment(type)}var ret={__size__:type.flatSize};if(typeName)struct.forEach(function(item,i){if(typeof item==="string")ret[item]=alignment[i]+offset;else{var key;for(var k in item)key=k;ret[key]=
Runtime.generateStructInfo(item[key],type.fields[i],alignment[i])}});else struct.forEach(function(item,i){ret[item[1]]=alignment[i]});return ret},dynCall:function(sig,ptr,args){if(args&&args.length){if(!args.splice)args=Array.prototype.slice.call(args);args.splice(0,0,ptr);return Module["dynCall_"+sig].apply(null,args)}else return Module["dynCall_"+sig].call(null,ptr)},functionPointers:[],addFunction:function(func){for(var i=0;i<Runtime.functionPointers.length;i++)if(!Runtime.functionPointers[i]){Runtime.functionPointers[i]=
func;return 2*(1+i)}throw"Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.";},removeFunction:function(index){Runtime.functionPointers[(index-2)/2]=null},getAsmConst:function(code,numArgs){if(!Runtime.asmConstCache)Runtime.asmConstCache={};var func=Runtime.asmConstCache[code];if(func)return func;var args=[];for(var i=0;i<numArgs;i++)args.push(String.fromCharCode(36)+i);var source=Pointer_stringify(code);if(source[0]==='"')if(source.indexOf('"',1)===source.length-
1)source=source.substr(1,source.length-2);else abort("invalid EM_ASM input |"+source+"|. Please use EM_ASM(..code..) (no quotes) or EM_ASM({ ..code($0).. }, input) (to input values)");try{var evalled=eval("(function("+args.join(",")+"){ "+source+" })")}catch(e){Module.printErr("error in executing inline EM_ASM code: "+e+" on: \n\n"+source+"\n\nwith args |"+args+"| (make sure to use the right one out of EM_ASM, EM_ASM_ARGS, etc.)");throw e;}return Runtime.asmConstCache[code]=evalled},warnOnce:function(text){if(!Runtime.warnOnce.shown)Runtime.warnOnce.shown=
{};if(!Runtime.warnOnce.shown[text]){Runtime.warnOnce.shown[text]=1;Module.printErr(text)}},funcWrappers:{},getFuncWrapper:function(func,sig){assert(sig);if(!Runtime.funcWrappers[func])Runtime.funcWrappers[func]=function dynCall_wrapper(){return Runtime.dynCall(sig,func,arguments)};return Runtime.funcWrappers[func]},UTF8Processor:function(){var buffer=[];var needed=0;this.processCChar=function(code){code=code&255;if(buffer.length==0){if((code&128)==0)return String.fromCharCode(code);buffer.push(code);
if((code&224)==192)needed=1;else if((code&240)==224)needed=2;else needed=3;return""}if(needed){buffer.push(code);needed--;if(needed>0)return""}var c1=buffer[0];var c2=buffer[1];var c3=buffer[2];var c4=buffer[3];var ret;if(buffer.length==2)ret=String.fromCharCode((c1&31)<<6|c2&63);else if(buffer.length==3)ret=String.fromCharCode((c1&15)<<12|(c2&63)<<6|c3&63);else{var codePoint=(c1&7)<<18|(c2&63)<<12|(c3&63)<<6|c4&63;ret=String.fromCharCode(Math.floor((codePoint-65536)/1024)+55296,(codePoint-65536)%
1024+56320)}buffer.length=0;return ret};this.processJSString=function processJSString(string){string=unescape(encodeURIComponent(string));var ret=[];for(var i=0;i<string.length;i++)ret.push(string.charCodeAt(i));return ret}},getCompilerSetting:function(name){throw"You must build with -s RETAIN_COMPILER_SETTINGS=1 for Runtime.getCompilerSetting or emscripten_get_compiler_setting to work";},stackAlloc:function(size){var ret=STACKTOP;STACKTOP=STACKTOP+size|0;STACKTOP=STACKTOP+7&-8;return ret},staticAlloc:function(size){var ret=
STATICTOP;STATICTOP=STATICTOP+size|0;STATICTOP=STATICTOP+7&-8;return ret},dynamicAlloc:function(size){var ret=DYNAMICTOP;DYNAMICTOP=DYNAMICTOP+size|0;DYNAMICTOP=DYNAMICTOP+7&-8;if(DYNAMICTOP>=TOTAL_MEMORY)enlargeMemory();return ret},alignMemory:function(size,quantum){var ret=size=Math.ceil(size/(quantum?quantum:8))*(quantum?quantum:8);return ret},makeBigInt:function(low,high,unsigned){var ret=unsigned?+(low>>>0)+ +(high>>>0)*+4294967296:+(low>>>0)+ +(high|0)*+4294967296;return ret},GLOBAL_BASE:8,
QUANTUM_SIZE:4,__dummy__:0};Module["Runtime"]=Runtime;var __THREW__=0;var ABORT=false;var EXITSTATUS=0;var undef=0;var tempValue,tempInt,tempBigInt,tempInt2,tempBigInt2,tempPair,tempBigIntI,tempBigIntR,tempBigIntS,tempBigIntP,tempBigIntD,tempDouble,tempFloat;var tempI64,tempI64b;var tempRet0,tempRet1,tempRet2,tempRet3,tempRet4,tempRet5,tempRet6,tempRet7,tempRet8,tempRet9;function assert(condition,text){if(!condition)abort("Assertion failed: "+text)}var globalScope=this;
function getCFunc(ident){var func=Module["_"+ident];if(!func)try{func=eval("_"+ident)}catch(e){}assert(func,"Cannot call unknown function "+ident+" (perhaps LLVM optimizations or closure removed it?)");return func}var cwrap,ccall;
(function(){var stack=0;var JSfuncs={"stackSave":function(){stack=Runtime.stackSave()},"stackRestore":function(){Runtime.stackRestore(stack)},"arrayToC":function(arr){var ret=Runtime.stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret},"stringToC":function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){ret=Runtime.stackAlloc(str.length+1);writeStringToMemory(str,ret)}return ret}};var toC={"string":JSfuncs["stringToC"],"array":JSfuncs["arrayToC"]};ccall=function ccallFunc(ident,
returnType,argTypes,args){var func=getCFunc(ident);var cArgs=[];if(args)for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=Runtime.stackSave();cArgs[i]=converter(args[i])}else cArgs[i]=args[i]}var ret=func.apply(null,cArgs);if(returnType==="string")ret=Pointer_stringify(ret);if(stack!==0)JSfuncs["stackRestore"]();return ret};var sourceRegex=/^function\s*\(([^)]*)\)\s*{\s*([^*]*?)[\s;]*(?:return\s*(.*?)[;\s]*)?}$/;function parseJSFunc(jsfunc){var parsed=
jsfunc.toString().match(sourceRegex).slice(1);return{arguments:parsed[0],body:parsed[1],returnValue:parsed[2]}}var JSsource={};for(var fun in JSfuncs)if(JSfuncs.hasOwnProperty(fun))JSsource[fun]=parseJSFunc(JSfuncs[fun]);cwrap=function cwrap(ident,returnType,argTypes){var cfunc=getCFunc(ident);var numericArgs=argTypes.every(function(type){return type==="number"});var numericRet=returnType!=="string";if(numericRet&&numericArgs)return cfunc;var argNames=argTypes.map(function(x,i){return"$"+i});var funcstr=
"(function("+argNames.join(",")+") {";var nargs=argTypes.length;if(!numericArgs){funcstr+=JSsource["stackSave"].body+";";for(var i=0;i<nargs;i++){var arg=argNames[i],type=argTypes[i];if(type==="number")continue;var convertCode=JSsource[type+"ToC"];funcstr+="var "+convertCode.arguments+" = "+arg+";";funcstr+=convertCode.body+";";funcstr+=arg+"="+convertCode.returnValue+";"}}var cfuncname=parseJSFunc(function(){return cfunc}).returnValue;funcstr+="var ret = "+cfuncname+"("+argNames.join(",")+");";if(!numericRet){var strgfy=
parseJSFunc(function(){return Pointer_stringify}).returnValue;funcstr+="ret = "+strgfy+"(ret);"}if(!numericArgs)funcstr+=JSsource["stackRestore"].body+";";funcstr+="return ret})";return eval(funcstr)}})();Module["cwrap"]=cwrap;Module["ccall"]=ccall;
function setValue(ptr,value,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case "i1":HEAP8[ptr>>0]=value;break;case "i8":HEAP8[ptr>>0]=value;break;case "i16":HEAP16[ptr>>1]=value;break;case "i32":HEAP32[ptr>>2]=value;break;case "i64":tempI64=[value>>>0,(tempDouble=value,+Math_abs(tempDouble)>=+1?tempDouble>+0?(Math_min(+Math_floor(tempDouble/+4294967296),+4294967295)|0)>>>0:~~+Math_ceil((tempDouble-+(~~tempDouble>>>0))/+4294967296)>>>0:0)],HEAP32[ptr>>2]=
tempI64[0],HEAP32[ptr+4>>2]=tempI64[1];break;case "float":HEAPF32[ptr>>2]=value;break;case "double":HEAPF64[ptr>>3]=value;break;default:abort("invalid type for setValue: "+type)}}Module["setValue"]=setValue;
function getValue(ptr,type,noSafe){type=type||"i8";if(type.charAt(type.length-1)==="*")type="i32";switch(type){case "i1":return HEAP8[ptr>>0];case "i8":return HEAP8[ptr>>0];case "i16":return HEAP16[ptr>>1];case "i32":return HEAP32[ptr>>2];case "i64":return HEAP32[ptr>>2];case "float":return HEAPF32[ptr>>2];case "double":return HEAPF64[ptr>>3];default:abort("invalid type for setValue: "+type)}return null}Module["getValue"]=getValue;var ALLOC_NORMAL=0;var ALLOC_STACK=1;var ALLOC_STATIC=2;
var ALLOC_DYNAMIC=3;var ALLOC_NONE=4;Module["ALLOC_NORMAL"]=ALLOC_NORMAL;Module["ALLOC_STACK"]=ALLOC_STACK;Module["ALLOC_STATIC"]=ALLOC_STATIC;Module["ALLOC_DYNAMIC"]=ALLOC_DYNAMIC;Module["ALLOC_NONE"]=ALLOC_NONE;
function allocate(slab,types,allocator,ptr){var zeroinit,size;if(typeof slab==="number"){zeroinit=true;size=slab}else{zeroinit=false;size=slab.length}var singleType=typeof types==="string"?types:null;var ret;if(allocator==ALLOC_NONE)ret=ptr;else ret=[_malloc,Runtime.stackAlloc,Runtime.staticAlloc,Runtime.dynamicAlloc][allocator===undefined?ALLOC_STATIC:allocator](Math.max(size,singleType?1:types.length));if(zeroinit){var ptr=ret,stop;assert((ret&3)==0);stop=ret+(size&~3);for(;ptr<stop;ptr+=4)HEAP32[ptr>>
2]=0;stop=ret+size;while(ptr<stop)HEAP8[ptr++>>0]=0;return ret}if(singleType==="i8"){if(slab.subarray||slab.slice)HEAPU8.set(slab,ret);else HEAPU8.set(new Uint8Array(slab),ret);return ret}var i=0,type,typeSize,previousType;while(i<size){var curr=slab[i];if(typeof curr==="function")curr=Runtime.getFunctionIndex(curr);type=singleType||types[i];if(type===0){i++;continue}if(type=="i64")type="i32";setValue(ret+i,curr,type);if(previousType!==type){typeSize=Runtime.getNativeTypeSize(type);previousType=type}i+=
typeSize}return ret}Module["allocate"]=allocate;
function Pointer_stringify(ptr,length){var hasUtf=false;var t;var i=0;while(1){t=HEAPU8[ptr+i>>0];if(t>=128)hasUtf=true;else if(t==0&&!length)break;i++;if(length&&i==length)break}if(!length)length=i;var ret="";if(!hasUtf){var MAX_CHUNK=1024;var curr;while(length>0){curr=String.fromCharCode.apply(String,HEAPU8.subarray(ptr,ptr+Math.min(length,MAX_CHUNK)));ret=ret?ret+curr:curr;ptr+=MAX_CHUNK;length-=MAX_CHUNK}return ret}var utf8=new Runtime.UTF8Processor;for(i=0;i<length;i++){t=HEAPU8[ptr+i>>0];ret+=
utf8.processCChar(t)}return ret}Module["Pointer_stringify"]=Pointer_stringify;function UTF16ToString(ptr){var i=0;var str="";while(1){var codeUnit=HEAP16[ptr+i*2>>1];if(codeUnit==0)return str;++i;str+=String.fromCharCode(codeUnit)}}Module["UTF16ToString"]=UTF16ToString;function stringToUTF16(str,outPtr){for(var i=0;i<str.length;++i){var codeUnit=str.charCodeAt(i);HEAP16[outPtr+i*2>>1]=codeUnit}HEAP16[outPtr+str.length*2>>1]=0}Module["stringToUTF16"]=stringToUTF16;
function UTF32ToString(ptr){var i=0;var str="";while(1){var utf32=HEAP32[ptr+i*4>>2];if(utf32==0)return str;++i;if(utf32>=65536){var ch=utf32-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}else str+=String.fromCharCode(utf32)}}Module["UTF32ToString"]=UTF32ToString;
function stringToUTF32(str,outPtr){var iChar=0;for(var iCodeUnit=0;iCodeUnit<str.length;++iCodeUnit){var codeUnit=str.charCodeAt(iCodeUnit);if(codeUnit>=55296&&codeUnit<=57343){var trailSurrogate=str.charCodeAt(++iCodeUnit);codeUnit=65536+((codeUnit&1023)<<10)|trailSurrogate&1023}HEAP32[outPtr+iChar*4>>2]=codeUnit;++iChar}HEAP32[outPtr+iChar*4>>2]=0}Module["stringToUTF32"]=stringToUTF32;
function demangle(func){var i=3;var basicTypes={"v":"void","b":"bool","c":"char","s":"short","i":"int","l":"long","f":"float","d":"double","w":"wchar_t","a":"signed char","h":"unsigned char","t":"unsigned short","j":"unsigned int","m":"unsigned long","x":"long long","y":"unsigned long long","z":"..."};var subs=[];var first=true;function dump(x){if(x)Module.print(x);Module.print(func);var pre="";for(var a=0;a<i;a++)pre+=" ";Module.print(pre+"^")}function parseNested(){i++;if(func[i]==="K")i++;var parts=
[];while(func[i]!=="E"){if(func[i]==="S"){i++;var next=func.indexOf("_",i);var num=func.substring(i,next)||0;parts.push(subs[num]||"?");i=next+1;continue}if(func[i]==="C"){parts.push(parts[parts.length-1]);i+=2;continue}var size=parseInt(func.substr(i));var pre=size.toString().length;if(!size||!pre){i--;break}var curr=func.substr(i+pre,size);parts.push(curr);subs.push(curr);i+=pre+size}i++;return parts}function parse(rawList,limit,allowVoid){limit=limit||Infinity;var ret="",list=[];function flushList(){return"("+
list.join(", ")+")"}var name;if(func[i]==="N"){name=parseNested().join("::");limit--;if(limit===0)return rawList?[name]:name}else{if(func[i]==="K"||first&&func[i]==="L")i++;var size=parseInt(func.substr(i));if(size){var pre=size.toString().length;name=func.substr(i+pre,size);i+=pre+size}}first=false;if(func[i]==="I"){i++;var iList=parse(true);var iRet=parse(true,1,true);ret+=iRet[0]+" "+name+"<"+iList.join(", ")+">"}else ret=name;paramLoop:while(i<func.length&&limit-- >0){var c=func[i++];if(c in basicTypes)list.push(basicTypes[c]);
else switch(c){case "P":list.push(parse(true,1,true)[0]+"*");break;case "R":list.push(parse(true,1,true)[0]+"&");break;case "L":i++;var end=func.indexOf("E",i);var size=end-i;list.push(func.substr(i,size));i+=size+2;break;case "A":var size=parseInt(func.substr(i));i+=size.toString().length;if(func[i]!=="_")throw"?";i++;list.push(parse(true,1,true)[0]+" ["+size+"]");break;case "E":break paramLoop;default:ret+="?"+c;break paramLoop}}if(!allowVoid&&list.length===1&&list[0]==="void")list=[];if(rawList){if(ret)list.push(ret+
"?");return list}else return ret+flushList()}try{if(func=="Object._main"||func=="_main")return"main()";if(typeof func==="number")func=Pointer_stringify(func);if(func[0]!=="_")return func;if(func[1]!=="_")return func;if(func[2]!=="Z")return func;switch(func[3]){case "n":return"operator new()";case "d":return"operator delete()"}return parse()}catch(e){return func}}function demangleAll(text){return text.replace(/__Z[\w\d_]+/g,function(x){var y=demangle(x);return x===y?x:x+" ["+y+"]"})}
function stackTrace(){var stack=(new Error).stack;return stack?demangleAll(stack):"(no stack trace available)"}var PAGE_SIZE=4096;function alignMemoryPage(x){return x+4095&-4096}var HEAP;var HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;var STATIC_BASE=0,STATICTOP=0,staticSealed=false;var STACK_BASE=0,STACKTOP=0,STACK_MAX=0;var DYNAMIC_BASE=0,DYNAMICTOP=0;
function enlargeMemory(){abort("Cannot enlarge memory arrays. Either (1) compile with -s TOTAL_MEMORY=X with X higher than the current value "+TOTAL_MEMORY+", (2) compile with ALLOW_MEMORY_GROWTH which adjusts the size at runtime but prevents some optimizations, or (3) set Module.TOTAL_MEMORY before the program runs.")}var TOTAL_STACK=Module["TOTAL_STACK"]||5242880;var TOTAL_MEMORY=Module["TOTAL_MEMORY"]||33554432;var FAST_MEMORY=Module["FAST_MEMORY"]||2097152;var totalMemory=4096;
while(totalMemory<TOTAL_MEMORY||totalMemory<2*TOTAL_STACK)if(totalMemory<16*1024*1024)totalMemory*=2;else totalMemory+=16*1024*1024;if(totalMemory!==TOTAL_MEMORY){Module.printErr("increasing TOTAL_MEMORY to "+totalMemory+" to be more reasonable");TOTAL_MEMORY=totalMemory}assert(typeof Int32Array!=="undefined"&&typeof Float64Array!=="undefined"&&!!(new Int32Array(1))["subarray"]&&!!(new Int32Array(1))["set"],"JS engine does not provide full typed array support");var buffer=new ArrayBuffer(TOTAL_MEMORY);
HEAP8=new Int8Array(buffer);HEAP16=new Int16Array(buffer);HEAP32=new Int32Array(buffer);HEAPU8=new Uint8Array(buffer);HEAPU16=new Uint16Array(buffer);HEAPU32=new Uint32Array(buffer);HEAPF32=new Float32Array(buffer);HEAPF64=new Float64Array(buffer);HEAP32[0]=255;assert(HEAPU8[0]===255&&HEAPU8[3]===0,"Typed arrays 2 must be run on a little-endian system");Module["HEAP"]=HEAP;Module["HEAP8"]=HEAP8;Module["HEAP16"]=HEAP16;Module["HEAP32"]=HEAP32;Module["HEAPU8"]=HEAPU8;Module["HEAPU16"]=HEAPU16;
Module["HEAPU32"]=HEAPU32;Module["HEAPF32"]=HEAPF32;Module["HEAPF64"]=HEAPF64;function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback();continue}var func=callback.func;if(typeof func==="number")if(callback.arg===undefined)Runtime.dynCall("v",func);else Runtime.dynCall("vi",func,[callback.arg]);else func(callback.arg===undefined?null:callback.arg)}}var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];
var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length)addOnPreRun(Module["preRun"].shift())}callRuntimeCallbacks(__ATPRERUN__)}function ensureInitRuntime(){if(runtimeInitialized)return;runtimeInitialized=true;callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}
function exitRuntime(){callRuntimeCallbacks(__ATEXIT__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length)addOnPostRun(Module["postRun"].shift())}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}Module["addOnPreRun"]=Module.addOnPreRun=addOnPreRun;function addOnInit(cb){__ATINIT__.unshift(cb)}Module["addOnInit"]=Module.addOnInit=addOnInit;
function addOnPreMain(cb){__ATMAIN__.unshift(cb)}Module["addOnPreMain"]=Module.addOnPreMain=addOnPreMain;function addOnExit(cb){__ATEXIT__.unshift(cb)}Module["addOnExit"]=Module.addOnExit=addOnExit;function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}Module["addOnPostRun"]=Module.addOnPostRun=addOnPostRun;function intArrayFromString(stringy,dontAddNull,length){var ret=(new Runtime.UTF8Processor).processJSString(stringy);if(length)ret.length=length;if(!dontAddNull)ret.push(0);return ret}
Module["intArrayFromString"]=intArrayFromString;function intArrayToString(array){var ret=[];for(var i=0;i<array.length;i++){var chr=array[i];if(chr>255)chr&=255;ret.push(String.fromCharCode(chr))}return ret.join("")}Module["intArrayToString"]=intArrayToString;function writeStringToMemory(string,buffer,dontAddNull){var array=intArrayFromString(string,dontAddNull);var i=0;while(i<array.length){var chr=array[i];HEAP8[buffer+i>>0]=chr;i=i+1}}Module["writeStringToMemory"]=writeStringToMemory;
function writeArrayToMemory(array,buffer){for(var i=0;i<array.length;i++)HEAP8[buffer+i>>0]=array[i]}Module["writeArrayToMemory"]=writeArrayToMemory;function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;i++)HEAP8[buffer+i>>0]=str.charCodeAt(i);if(!dontAddNull)HEAP8[buffer+str.length>>0]=0}Module["writeAsciiToMemory"]=writeAsciiToMemory;function unSign(value,bits,ignore){if(value>=0)return value;return bits<=32?2*Math.abs(1<<bits-1)+value:Math.pow(2,bits)+value}
function reSign(value,bits,ignore){if(value<=0)return value;var half=bits<=32?Math.abs(1<<bits-1):Math.pow(2,bits-1);if(value>=half&&(bits<=32||value>half))value=-2*half+value;return value}if(!Math["imul"]||Math["imul"](4294967295,5)!==-5)Math["imul"]=function imul(a,b){var ah=a>>>16;var al=a&65535;var bh=b>>>16;var bl=b&65535;return al*bl+(ah*bl+al*bh<<16)|0};Math.imul=Math["imul"];var Math_abs=Math.abs;var Math_cos=Math.cos;var Math_sin=Math.sin;var Math_tan=Math.tan;var Math_acos=Math.acos;
var Math_asin=Math.asin;var Math_atan=Math.atan;var Math_atan2=Math.atan2;var Math_exp=Math.exp;var Math_log=Math.log;var Math_sqrt=Math.sqrt;var Math_ceil=Math.ceil;var Math_floor=Math.floor;var Math_pow=Math.pow;var Math_imul=Math.imul;var Math_fround=Math.fround;var Math_min=Math.min;var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;
function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"])Module["monitorRunDependencies"](runDependencies)}Module["addRunDependency"]=addRunDependency;
function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"])Module["monitorRunDependencies"](runDependencies);if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["removeRunDependency"]=removeRunDependency;Module["preloadedImages"]={};Module["preloadedAudios"]={};var memoryInitializer=null;
var __ZTVN10__cxxabiv117__class_type_infoE=9E3;var __ZTVN10__cxxabiv120__si_class_type_infoE=9040;STATIC_BASE=8;STATICTOP=STATIC_BASE+Runtime.alignMemory(9715);__ATINIT__.push({func:function(){__GLOBAL__I_a()}});
allocate([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,152,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,49,53,82,97,121,67,97,115,116,67,97,108,108,98,97,99,107,0,0,0,0,0,0,0,49,55,98,50,82,97,121,67,97,115,116,67,97,108,108,98,97,99,107,0,0,0,0,0,48,35,0,0,120,0,0,0,88,35,0,0,96,0,0,0,144,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,3,0,0,0,4,0,0,0,2,0,0,0,1,0,0,0,3,0,0,0,0,0,0,0,49,55,81,117,101,114,121,65,65,66,66,67,97,108,108,
98,97,99,107,0,0,0,0,0,49,53,98,50,81,117,101,114,121,67,97,108,108,98,97,99,107,0,0,0,0,0,0,0,48,35,0,0,224,0,0,0,88,35,0,0,200,0,0,0,248,0,0,0,0,0,0,0,0,0,0,0,128,1,0,0,5,0,0,0,6,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,2,0,0,0,2,0,0,0,3,0,0,0,4,0,0,0,50,50,98,50,87,111,114,108,100,67,111,110,116,97,99,116,76,105,115,116,101,110,101,114,0,0,0,0,0,0,0,0,49,55,98,50,67,111,110,116,97,99,116,76,105,115,116,101,110,101,114,0,0,0,0,0,48,35,0,0,96,1,0,0,88,35,0,0,64,1,0,0,120,1,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,56,2,0,0,7,0,0,0,8,0,0,0,4,0,0,0,1,0,0,0,2,0,0,0,1,0,0,0,1,0,0,0,3,0,0,0,1,0,0,0,0,0,0,0,49,49,98,50,69,100,103,101,83,104,97,112,101,0,0,0,55,98,50,83,104,97,112,101,0,0,0,0,0,0,0,0,48,35,0,0,32,2,0,0,88,35,0,0,16,2,0,0,48,2,0,0,0,0,0,0,0,0,0,0,144,2,0,0,9,0,0,0,10,0,0,0,5,0,0,0,2,0,0,0,3,0,0,0,2,0,0,0,2,0,0,0,4,0,0,0,2,0,0,0,0,0,0,0,49,52,98,50,
80,111,108,121,103,111,110,83,104,97,112,101,0,0,0,0,0,0,0,0,88,35,0,0,120,2,0,0,48,2,0,0,0,0,0,0,0,0,0,0,224,2,0,0,11,0,0,0,12,0,0,0,6,0,0,0,3,0,0,0,4,0,0,0,3,0,0,0,3,0,0,0,5,0,0,0,3,0,0,0,0,0,0,0,49,51,98,50,67,105,114,99,108,101,83,104,97,112,101,0,88,35,0,0,208,2,0,0,48,2,0,0,0,0,0,0,0,0,0,0,48,3,0,0,13,0,0,0,14,0,0,0,7,0,0,0,4,0,0,0,5,0,0,0,4,0,0,0,4,0,0,0,6,0,0,0,4,0,0,0,0,0,0,0,49,50,98,50,67,104,97,105,110,83,104,97,112,101,0,0,88,35,0,0,32,3,0,0,48,2,0,0,0,0,0,0,0,0,0,0,120,3,0,0,15,0,0,
0,16,0,0,0,6,0,0,0,1,0,0,0,2,0,0,0,0,0,0,0,49,53,98,50,67,111,110,116,97,99,116,70,105,108,116,101,114,0,0,0,0,0,0,0,48,35,0,0,96,3,0,0,0,0,0,0,224,3,0,0,3,0,0,0,4,0,0,0,5,0,0,0,1,0,0,0,17,0,0,0,5,0,0,0,18,0,0,0,19,0,0,0,6,0,0,0,7,0,0,0,8,0,0,0,0,0,0,0,49,50,98,50,77,111,117,115,101,74,111,105,110,116,0,0,55,98,50,74,111,105,110,116,0,0,0,0,0,0,0,0,48,35,0,0,200,3,0,0,88,35,0,0,184,3,0,0,216,3,0,0,0,0,0,0,77,111,117,115,101,32,106,111,105,110,116,32,100,117,109,112,105,110,103,32,105,115,32,110,111,
116,32,115,117,112,112,111,114,116,101,100,46,10,0,0,0,0,0,0,200,5,0,0,8,0,0,0,9,0,0,0,6,0,0,0,2,0,0,0,20,0,0,0,10,0,0,0,21,0,0,0,22,0,0,0,11,0,0,0,12,0,0,0,9,0,0,0,0,0,0,0,32,32,98,50,77,111,116,111,114,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,
111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,105,110,101,97,114,79,102,102,115,101,116,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,97,110,103,117,108,97,114,79,102,102,115,101,116,32,61,32,37,46,49,53,108,101,102,59,10,0,0,32,32,106,100,46,109,97,120,70,111,114,99,101,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,32,32,106,100,46,109,97,120,84,111,114,113,117,101,
32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,32,32,106,100,46,99,111,114,114,101,99,116,105,111,110,70,97,99,116,111,114,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,50,98,50,77,111,116,111,114,74,111,105,110,116,0,0,88,35,0,0,184,5,0,0,216,3,0,0,0,0,0,0,0,0,0,0,152,7,0,0,13,0,0,0,14,0,0,0,7,0,0,0,3,0,0,0,23,0,0,0,10,0,0,
0,24,0,0,0,25,0,0,0,15,0,0,0,16,0,0,0,10,0,0,0,0,0,0,0,32,32,98,50,68,105,115,116,97,110,99,101,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,
46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,101,110,103,116,104,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,100,46,102,114,101,113,117,101,110,99,121,72,122,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,32,32,106,100,46,100,
97,109,112,105,110,103,82,97,116,105,111,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,53,98,50,68,105,115,116,97,110,99,101,74,111,105,110,116,0,0,0,0,0,0,0,88,35,0,0,128,7,0,0,216,3,0,0,0,0,0,0,0,0,0,0,80,9,0,0,17,0,0,0,18,0,0,0,8,0,0,0,4,0,0,0,26,0,0,0,10,0,0,0,27,0,0,0,28,0,0,0,19,0,0,0,20,0,0,0,11,0,0,0,0,0,0,0,32,32,98,50,70,114,105,
99,116,105,111,110,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,
108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,109,97,120,70,111,114,99,101,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,32,32,106,100,46,109,97,120,84,111,114,113,117,101,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,
62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,53,98,50,70,114,105,99,116,105,111,110,74,111,105,110,116,0,0,0,0,0,0,0,88,35,0,0,56,9,0,0,216,3,0,0,0,0,0,0,0,0,0,0,24,11,0,0,21,0,0,0,22,0,0,0,9,0,0,0,5,0,0,0,29,0,0,0,10,0,0,0,30,0,0,0,31,0,0,0,23,0,0,0,24,0,0,0,12,0,0,0,0,0,0,0,32,32,98,50,87,101,108,100,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,
100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,
102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,114,101,102,101,114,101,110,99,101,65,110,103,108,101,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,100,46,102,114,101,113,117,101,110,99,121,72,122,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,32,32,106,100,46,100,97,109,112,105,110,103,82,97,116,105,111,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,
0,0,0,0,0,0,49,49,98,50,87,101,108,100,74,111,105,110,116,0,0,0,88,35,0,0,8,11,0,0,216,3,0,0,0,0,0,0,0,0,0,0,120,12,0,0,25,0,0,0,26,0,0,0,10,0,0,0,6,0,0,0,32,0,0,0,10,0,0,0,33,0,0,0,34,0,0,0,27,0,0,0,28,0,0,0,13,0,0,0,0,0,0,0,32,32,98,50,71,101,97,114,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,
0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,106,111,105,110,116,49,32,61,32,106,111,105,110,116,115,91,37,100,93,59,10,0,0,0,0,0,0,32,32,106,100,46,106,111,105,110,116,50,32,61,32,106,111,105,110,116,115,91,37,100,93,59,10,0,0,0,0,0,0,32,32,106,100,46,114,97,116,105,111,32,61,32,37,46,49,53,108,101,102,59,10,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,
45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,49,98,50,71,101,97,114,74,111,105,110,116,0,0,0,88,35,0,0,104,12,0,0,216,3,0,0,0,0,0,0,0,0,0,0,8,15,0,0,29,0,0,0,30,0,0,0,11,0,0,0,7,0,0,0,35,0,0,0,10,0,0,0,36,0,0,0,37,0,0,0,31,0,0,0,32,0,0,0,14,0,0,0,0,0,0,0,32,32,98,50,80,114,105,115,109,97,116,105,99,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,
32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,
108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,120,105,115,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,32,32,106,100,46,114,101,102,101,114,101,110,99,101,65,110,103,108,101,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,100,46,101,110,97,98,108,101,76,105,109,105,116,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,32,32,106,100,46,108,111,119,101,114,84,114,97,110,115,108,97,116,105,111,110,32,61,32,37,46,49,53,108,101,102,59,
10,0,0,0,0,0,0,0,32,32,106,100,46,117,112,112,101,114,84,114,97,110,115,108,97,116,105,111,110,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,32,32,106,100,46,101,110,97,98,108,101,77,111,116,111,114,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,32,32,106,100,46,109,111,116,111,114,83,112,101,101,100,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,32,32,106,100,46,109,97,120,77,111,116,111,114,70,111,114,99,101,32,61,32,37,46,49,53,108,101,102,59,10,0,0,32,32,106,111,105,110,116,115,91,
37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,54,98,50,80,114,105,115,109,97,116,105,99,74,111,105,110,116,0,0,0,0,0,0,88,35,0,0,240,14,0,0,216,3,0,0,0,0,0,0,0,0,0,0,144,16,0,0,33,0,0,0,34,0,0,0,12,0,0,0,8,0,0,0,38,0,0,0,10,0,0,0,39,0,0,0,40,0,0,0,35,0,0,0,36,0,0,0,15,0,0,0,0,0,0,0,32,32,98,50,82,111,112,101,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,
105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,
116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,109,97,120,76,101,110,103,116,104,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,49,98,50,82,111,112,101,74,111,105,110,116,0,0,0,88,35,0,0,128,16,0,0,216,3,0,0,0,0,0,0,0,0,0,0,216,3,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,41,0,0,0,10,0,
0,0,42,0,0,0,43,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,47,47,32,68,117,109,112,32,105,115,32,110,111,116,32,115,117,112,112,111,114,116,101,100,32,102,111,114,32,116,104,105,115,32,106,111,105,110,116,32,116,121,112,101,46,10,0,0,0,0,0,0,80,19,0,0,37,0,0,0,38,0,0,0,13,0,0,0,9,0,0,0,44,0,0,0,10,0,0,0,45,0,0,0,46,0,0,0,39,0,0,0,40,0,0,0,16,0,0,0,0,0,0,0,32,32,98,50,82,101,118,111,108,117,116,101,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,
98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,
46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,114,101,102,101,114,101,110,99,101,65,110,103,108,101,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,100,46,101,110,97,98,108,101,76,105,109,105,116,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,32,32,106,100,46,108,111,119,101,114,65,110,103,108,101,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,32,32,106,100,46,117,112,112,101,114,65,110,103,108,101,32,61,32,37,46,49,53,108,101,
102,59,10,0,0,0,0,0,32,32,106,100,46,101,110,97,98,108,101,77,111,116,111,114,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,32,32,106,100,46,109,111,116,111,114,83,112,101,101,100,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,32,32,106,100,46,109,97,120,77,111,116,111,114,84,111,114,113,117,101,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,
0,49,53,98,50,82,101,118,111,108,117,116,101,74,111,105,110,116,0,0,0,0,0,0,0,88,35,0,0,56,19,0,0,216,3,0,0,0,0,0,0,0,0,0,0,128,21,0,0,41,0,0,0,42,0,0,0,14,0,0,0,10,0,0,0,47,0,0,0,10,0,0,0,48,0,0,0,49,0,0,0,43,0,0,0,44,0,0,0,17,0,0,0,0,0,0,0,32,32,98,50,87,104,101,101,108,74,111,105,110,116,68,101,102,32,106,100,59,10,0,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,
93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,
120,105,115,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,32,32,106,100,46,101,110,97,98,108,101,77,111,116,111,114,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,32,32,106,100,46,109,111,116,111,114,83,112,101,101,100,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,32,32,106,100,46,109,97,120,77,111,116,111,114,84,111,114,113,117,101,32,61,32,37,46,49,53,108,101,102,59,10,0,32,32,106,100,46,102,114,101,113,117,101,110,99,121,72,122,32,61,32,37,46,49,53,108,
101,102,59,10,0,0,0,0,32,32,106,100,46,100,97,109,112,105,110,103,82,97,116,105,111,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,50,98,50,87,104,101,101,108,74,111,105,110,116,0,0,88,35,0,0,112,21,0,0,216,3,0,0,0,0,0,0,0,0,0,0,160,23,0,0,45,0,0,0,46,0,0,0,15,0,0,0,11,0,0,0,50,0,0,0,47,0,0,0,51,0,0,0,52,0,0,0,48,0,0,0,49,0,0,0,18,0,0,0,
0,0,0,0,32,32,98,50,80,117,108,108,101,121,74,111,105,110,116,68,101,102,32,106,100,59,10,0,32,32,106,100,46,98,111,100,121,65,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,98,111,100,121,66,32,61,32,98,111,100,105,101,115,91,37,100,93,59,10,0,0,0,0,0,0,0,32,32,106,100,46,99,111,108,108,105,100,101,67,111,110,110,101,99,116,101,100,32,61,32,98,111,111,108,40,37,100,41,59,10,0,0,0,0,0,0,32,32,106,100,46,103,114,111,117,110,100,65,110,99,104,111,114,65,46,83,101,
116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,32,32,106,100,46,103,114,111,117,110,100,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,65,46,83,101,116,40,37,46,49,53,108,101,102,44,32,37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,111,99,97,108,65,110,99,104,111,114,66,46,83,101,116,40,37,46,49,53,108,101,102,44,32,
37,46,49,53,108,101,102,41,59,10,0,0,0,0,0,0,0,32,32,106,100,46,108,101,110,103,116,104,65,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,0,32,32,106,100,46,108,101,110,103,116,104,66,32,61,32,37,46,49,53,108,101,102,59,10,0,0,0,0,0,0,0,0,32,32,106,100,46,114,97,116,105,111,32,61,32,37,46,49,53,108,101,102,59,10,0,0,32,32,106,111,105,110,116,115,91,37,100,93,32,61,32,109,95,119,111,114,108,100,45,62,67,114,101,97,116,101,74,111,105,110,116,40,38,106,100,41,59,10,0,0,0,0,0,0,49,51,98,50,80,117,
108,108,101,121,74,111,105,110,116,0,88,35,0,0,144,23,0,0,216,3,0,0,0,0,0,0,0,0,0,0,0,24,0,0,7,0,0,0,53,0,0,0,54,0,0,0,0,0,0,0,50,52,98,50,67,104,97,105,110,65,110,100,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,0,0,0,0,0,57,98,50,67,111,110,116,97,99,116,0,0,0,0,0,0,48,35,0,0,232,23,0,0,88,35,0,0,200,23,0,0,248,23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,23,0,0,1,0,0,0,55,0,0,0,56,0,0,0,0,0,0,0,0,0,0,0,40,25,0,0,8,0,0,0,57,0,0,0,58,0,0,0,0,0,0,0,50,53,98,50,80,111,108,121,103,111,110,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,88,35,0,0,8,25,0,0,248,23,0,0,0,0,0,0,0,0,0,0,104,25,
0,0,9,0,0,0,59,0,0,0,60,0,0,0,0,0,0,0,49,53,98,50,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,0,0,88,35,0,0,80,25,0,0,248,23,0,0,0,0,0,0,0,0,0,0,176,25,0,0,10,0,0,0,61,0,0,0,62,0,0,0,0,0,0,0,50,50,98,50,69,100,103,101,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,0,0,0,88,35,0,0,144,25,0,0,248,23,0,0,0,0,0,0,0,0,0,0,248,25,0,0,11,0,0,0,63,0,0,0,64,0,0,0,0,0,0,0,50,51,98,50,67,104,97,105,110,65,110,100,67,105,114,99,108,101,67,111,110,116,97,99,116,0,0,0,0,0,0,0,
88,35,0,0,216,25,0,0,248,23,0,0,0,0,0,0,0,0,0,0,64,26,0,0,12,0,0,0,65,0,0,0,66,0,0,0,0,0,0,0,50,51,98,50,69,100,103,101,65,110,100,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,0,0,0,0,0,0,88,35,0,0,32,26,0,0,248,23,0,0,0,0,0,0,0,0,0,0,128,26,0,0,13,0,0,0,67,0,0,0,68,0,0,0,0,0,0,0,49,54,98,50,80,111,108,121,103,111,110,67,111,110,116,97,99,116,0,0,0,0,0,0,88,35,0,0,104,26,0,0,248,23,0,0,0,0,0,0,72,3,0,0,0,0,0,0,168,26,0,0,0,0,0,0,0,0,0,0,120,1,0,0,69,0,0,0,70,0,0,0,50,0,0,0,51,0,0,0,1,0,0,
0,1,0,0,0,2,0,0,0,2,0,0,0,5,0,0,0,6,0,0,0,0,0,0,0,120,27,0,0,71,0,0,0,72,0,0,0,19,0,0,0,1,0,0,0,20,0,0,0,14,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,49,52,83,111,108,118,101,67,111,108,108,105,115,105,111,110,69,82,75,49,48,98,50,84,105,109,101,83,116,101,112,69,50,50,83,111,108,118,101,67,111,108,108,105,115,105,111,110,67,97,108,108,98,97,99,107,0,0,0,0,51,48,98,50,70,105,120,116,117,114,101,80,97,114,116,105,99,108,101,81,117,101,114,121,67,97,108,108,98,97,99,
107,0,0,0,0,0,0,0,0,88,35,0,0,64,27,0,0,248,0,0,0,0,0,0,0,88,35,0,0,240,26,0,0,104,27,0,0,0,0,0,0,0,0,0,0,240,27,0,0,73,0,0,0,74,0,0,0,19,0,0,0,1,0,0,0,20,0,0,0,15,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,49,56,85,112,100,97,116,101,66,111,100,121,67,111,110,116,97,99,116,115,69,118,69,50,54,85,112,100,97,116,101,66,111,100,121,67,111,110,116,97,99,116,115,67,97,108,108,98,97,99,107,0,88,35,0,0,168,27,0,0,104,27,0,0,0,0,0,0,0,0,0,0,168,28,0,0,75,0,0,0,76,0,0,0,16,
0,0,0,0,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,50,48,85,112,100,97,116,101,80,97,105,114,115,65,110,100,84,114,105,97,100,115,69,105,105,82,75,78,83,95,49,54,67,111,110,110,101,99,116,105,111,110,70,105,108,116,101,114,69,69,50,48,85,112,100,97,116,101,84,114,105,97,100,115,67,97,108,108,98,97,99,107,0,0,0,0,78,49,54,98,50,86,111,114,111,110,111,105,68,105,97,103,114,97,109,49,50,78,111,100,101,67,97,108,108,98,97,99,107,69,0,0,0,0,0,0,48,35,0,0,120,28,0,0,88,
35,0,0,24,28,0,0,160,28,0,0,0,0,0,0,0,0,0,0,96,29,0,0,77,0,0,0,78,0,0,0,21,0,0,0,7,0,0,0,3,0,0,0,0,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,52,49,85,112,100,97,116,101,80,97,105,114,115,65,110,100,84,114,105,97,100,115,87,105,116,104,82,101,97,99,116,105,118,101,80,97,114,116,105,99,108,101,115,69,118,69,49,52,82,101,97,99,116,105,118,101,70,105,108,116,101,114,0,0,0,0,0,0,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,49,54,67,111,110,110,101,
99,116,105,111,110,70,105,108,116,101,114,69,0,0,48,35,0,0,48,29,0,0,88,35,0,0,216,28,0,0,88,29,0,0,0,0,0,0,0,0,0,0,88,29,0,0,79,0,0,0,80,0,0,0,22,0,0,0,7,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,16,30,0,0,81,0,0,0,82,0,0,0,22,0,0,0,8,0,0,0,4,0,0,0,0,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,49,56,74,111,105,110,80,97,114,116,105,99,108,101,71,114,111,117,112,115,69,80,49,53,98,50,80,97,114,116,105,99,108,101,71,114,111,117,112,83,49,95,69,50,52,74,111,105,110,80,97,114,116,
105,99,108,101,71,114,111,117,112,115,70,105,108,116,101,114,0,0,0,0,0,0,0,88,35,0,0,176,29,0,0,88,29,0,0,0,0,0,0,0,0,0,0,208,30,0,0,83,0,0,0,84,0,0,0,23,0,0,0,5,0,0,0,9,0,0,0,5,0,0,0,5,0,0,0,17,0,0,0,16,0,0,0,0,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,51,51,67,114,101,97,116,101,80,97,114,116,105,99,108,101,115,87,105,116,104,83,104,97,112,101,115,70,111,114,71,114,111,117,112,69,80,75,80,75,55,98,50,83,104,97,112,101,105,82,75,49,56,98,50,80,97,114,116,105,99,
108,101,71,114,111,117,112,68,101,102,82,75,49,49,98,50,84,114,97,110,115,102,111,114,109,69,49,52,67,111,109,112,111,115,105,116,101,83,104,97,112,101,0,0,0,0,0,88,35,0,0,80,30,0,0,48,2,0,0,0,0,0,0,0,0,0,0,112,31,0,0,85,0,0,0,86,0,0,0,24,0,0,0,10,0,0,0,3,0,0,0,0,0,0,0,90,78,49,54,98,50,80,97,114,116,105,99,108,101,83,121,115,116,101,109,50,51,68,101,115,116,114,111,121,80,97,114,116,105,99,108,101,115,73,110,83,104,97,112,101,69,82,75,55,98,50,83,104,97,112,101,82,75,49,49,98,50,84,114,97,110,115,
102,111,114,109,98,69,51,49,68,101,115,116,114,111,121,80,97,114,116,105,99,108,101,115,73,110,83,104,97,112,101,67,97,108,108,98,97,99,107,0,0,0,0,0,0,88,35,0,0,0,31,0,0,248,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,16,0,0,0,32,0,0,0,64,0,0,0,96,0,0,0,128,0,0,0,160,0,0,0,192,0,0,0,224,0,0,0,0,1,0,0,64,1,0,0,128,1,0,0,192,1,0,0,0,2,0,0,128,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,76,105,113,117,105,100,70,117,110,32,49,46,49,46,48,0,104,34,0,0,0,0,0,0,25,0,0,0,0,0,0,0,52,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,83,116,57,116,121,112,101,95,105,110,102,111,0,0,0,0,48,35,0,0,160,34,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,54,95,95,115,104,105,109,95,116,121,112,101,95,105,110,
102,111,69,0,0,0,0,0,0,0,0,88,35,0,0,184,34,0,0,176,34,0,0,0,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,49,55,95,95,99,108,97,115,115,95,116,121,112,101,95,105,110,102,111,69,0,0,0,0,0,0,0,88,35,0,0,240,34,0,0,224,34,0,0,0,0,0,0,0,0,0,0,24,35,0,0,87,0,0,0,88,0,0,0,89,0,0,0,90,0,0,0,11,0,0,0,6,0,0,0,1,0,0,0,18,0,0,0,0,0,0,0,160,35,0,0,87,0,0,0,91,0,0,0,89,0,0,0,90,0,0,0,11,0,0,0,7,0,0,0,2,0,0,0,19,0,0,0,78,49,48,95,95,99,120,120,97,98,105,118,49,50,48,95,95,115,105,95,99,108,97,115,115,95,116,
121,112,101,95,105,110,102,111,69,0,0,0,0,88,35,0,0,120,35,0,0,24,35,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,232,37,0,0,92,0,0,0,93,0,0,0,6,0,0,0,0,0,0,0,115,116,100,58,58,98,97,100,95,97,108,108,111,99,0,0,83,116,57,98,97,100,95,97,108,108,111,99,0,0,0,0,88,35,0,0,216,37,0,0,0,0,0,0,0,0,0,0],"i8",ALLOC_NONE,Runtime.GLOBAL_BASE);var tempDoublePtr=Runtime.alignMemory(allocate(12,"i8",ALLOC_STATIC),8);assert(tempDoublePtr%8==0);
function copyTempFloat(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3]}function copyTempDouble(ptr){HEAP8[tempDoublePtr]=HEAP8[ptr];HEAP8[tempDoublePtr+1]=HEAP8[ptr+1];HEAP8[tempDoublePtr+2]=HEAP8[ptr+2];HEAP8[tempDoublePtr+3]=HEAP8[ptr+3];HEAP8[tempDoublePtr+4]=HEAP8[ptr+4];HEAP8[tempDoublePtr+5]=HEAP8[ptr+5];HEAP8[tempDoublePtr+6]=HEAP8[ptr+6];HEAP8[tempDoublePtr+7]=HEAP8[ptr+7]}
function _cosf(){return Math_cos.apply(null,arguments)}function ___cxa_pure_virtual(){ABORT=true;throw"Pure virtual function called!";}function _b2WorldEndContactBody(contactPtr){b2World.EndContactBody(contactPtr)}function _floorf(){return Math_floor.apply(null,arguments)}function __ZSt18uncaught_exceptionv(){return!!__ZSt18uncaught_exceptionv.uncaught_exception}
function ___cxa_is_number_type(type){var isNumber=false;try{if(type==__ZTIi)isNumber=true}catch(e){}try{if(type==__ZTIj)isNumber=true}catch(e){}try{if(type==__ZTIl)isNumber=true}catch(e){}try{if(type==__ZTIm)isNumber=true}catch(e){}try{if(type==__ZTIx)isNumber=true}catch(e){}try{if(type==__ZTIy)isNumber=true}catch(e){}try{if(type==__ZTIf)isNumber=true}catch(e){}try{if(type==__ZTId)isNumber=true}catch(e){}try{if(type==__ZTIe)isNumber=true}catch(e){}try{if(type==__ZTIc)isNumber=true}catch(e){}try{if(type==
__ZTIa)isNumber=true}catch(e){}try{if(type==__ZTIh)isNumber=true}catch(e){}try{if(type==__ZTIs)isNumber=true}catch(e){}try{if(type==__ZTIt)isNumber=true}catch(e){}return isNumber}
function ___cxa_does_inherit(definiteType,possibilityType,possibility){if(possibility==0)return false;if(possibilityType==0||possibilityType==definiteType)return true;var possibility_type_info;if(___cxa_is_number_type(possibilityType))possibility_type_info=possibilityType;else{var possibility_type_infoAddr=HEAP32[possibilityType>>2]-8;possibility_type_info=HEAP32[possibility_type_infoAddr>>2]}switch(possibility_type_info){case 0:var definite_type_infoAddr=HEAP32[definiteType>>2]-8;var definite_type_info=
HEAP32[definite_type_infoAddr>>2];if(definite_type_info==0){var defPointerBaseAddr=definiteType+8;var defPointerBaseType=HEAP32[defPointerBaseAddr>>2];var possPointerBaseAddr=possibilityType+8;var possPointerBaseType=HEAP32[possPointerBaseAddr>>2];return ___cxa_does_inherit(defPointerBaseType,possPointerBaseType,possibility)}else return false;case 1:return false;case 2:var parentTypeAddr=possibilityType+8;var parentType=HEAP32[parentTypeAddr>>2];return ___cxa_does_inherit(definiteType,parentType,
possibility);default:return false}}var ___cxa_last_thrown_exception=0;function ___resumeException(ptr){if(!___cxa_last_thrown_exception)___cxa_last_thrown_exception=ptr;throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";}var ___cxa_exception_header_size=8;
function ___cxa_find_matching_catch(thrown,throwntype){if(thrown==-1)thrown=___cxa_last_thrown_exception;header=thrown-___cxa_exception_header_size;if(throwntype==-1)throwntype=HEAP32[header>>2];var typeArray=Array.prototype.slice.call(arguments,2);if(throwntype!=0&&!___cxa_is_number_type(throwntype)){var throwntypeInfoAddr=HEAP32[throwntype>>2]-8;var throwntypeInfo=HEAP32[throwntypeInfoAddr>>2];if(throwntypeInfo==0)thrown=HEAP32[thrown>>2]}for(var i=0;i<typeArray.length;i++)if(___cxa_does_inherit(typeArray[i],
throwntype,thrown))return(asm["setTempRet0"](typeArray[i]),thrown)|0;return(asm["setTempRet0"](throwntype),thrown)|0}
function ___cxa_throw(ptr,type,destructor){if(!___cxa_throw.initialized){try{HEAP32[__ZTVN10__cxxabiv119__pointer_type_infoE>>2]=0}catch(e){}try{HEAP32[__ZTVN10__cxxabiv117__class_type_infoE>>2]=1}catch(e){}try{HEAP32[__ZTVN10__cxxabiv120__si_class_type_infoE>>2]=2}catch(e){}___cxa_throw.initialized=true}var header=ptr-___cxa_exception_header_size;HEAP32[header>>2]=type;HEAP32[header+4>>2]=destructor;___cxa_last_thrown_exception=ptr;if(!("uncaught_exception"in __ZSt18uncaught_exceptionv))__ZSt18uncaught_exceptionv.uncaught_exception=
1;else __ZSt18uncaught_exceptionv.uncaught_exception++;throw ptr+" - Exception catching is disabled, this exception cannot be caught. Compile with -s DISABLE_EXCEPTION_CATCHING=0 or DISABLE_EXCEPTION_CATCHING=2 to catch.";}Module["_memset"]=_memset;function _b2WorldRayCastCallback(fixturePtr,pointX,pointY,normalX,normalY,fraction){return b2World.RayCast(fixturePtr,pointX,pointY,normalX,normalY,fraction)}var _FtoIHigh=true;function __exit(status){Module["exit"](status)}
function _exit(status){__exit(status)}function __ZSt9terminatev(){_exit(-1234)}function _abort(){Module["abort"]()}function _b2WorldBeginContactBody(contactPtr){b2World.BeginContactBody(contactPtr)}var ___cxa_caught_exceptions=[];function ___cxa_begin_catch(ptr){__ZSt18uncaught_exceptionv.uncaught_exception--;___cxa_caught_exceptions.push(___cxa_last_thrown_exception);return ptr}function _sinf(){return Math_sin.apply(null,arguments)}
function _b2WorldPostSolve(contactPtr,impulsePtr){b2World.PostSolve(contactPtr,impulsePtr)}Module["_strlen"]=_strlen;function _sqrtf(){return Math_sqrt.apply(null,arguments)}function _b2WorldQueryAABB(fixturePtr){return b2World.QueryAABB(fixturePtr)}Module["_i64Add"]=_i64Add;
function _sbrk(bytes){var self=_sbrk;if(!self.called){DYNAMICTOP=alignMemoryPage(DYNAMICTOP);self.called=true;assert(Runtime.dynamicAlloc);self.alloc=Runtime.dynamicAlloc;Runtime.dynamicAlloc=function(){abort("cannot dynamically allocate, sbrk now has control")}}var ret=DYNAMICTOP;if(bytes!=0)self.alloc(bytes);return ret}function _emscripten_memcpy_big(dest,src,num){HEAPU8.set(HEAPU8.subarray(src,src+num),dest);return dest}Module["_memcpy"]=_memcpy;Module["_memmove"]=_memmove;var ___errno_state=0;
function ___setErrNo(value){HEAP32[___errno_state>>2]=value;return value}function ___errno_location(){return ___errno_state}var _FtoILow=true;function __ZNSt9exceptionD2Ev(){}function _b2WorldPreSolve(contactPtr,oldManifoldPtr){b2World.PreSolve(contactPtr,oldManifoldPtr)}
var ERRNO_CODES={EPERM:1,ENOENT:2,ESRCH:3,EINTR:4,EIO:5,ENXIO:6,E2BIG:7,ENOEXEC:8,EBADF:9,ECHILD:10,EAGAIN:11,EWOULDBLOCK:11,ENOMEM:12,EACCES:13,EFAULT:14,ENOTBLK:15,EBUSY:16,EEXIST:17,EXDEV:18,ENODEV:19,ENOTDIR:20,EISDIR:21,EINVAL:22,ENFILE:23,EMFILE:24,ENOTTY:25,ETXTBSY:26,EFBIG:27,ENOSPC:28,ESPIPE:29,EROFS:30,EMLINK:31,EPIPE:32,EDOM:33,ERANGE:34,ENOMSG:42,EIDRM:43,ECHRNG:44,EL2NSYNC:45,EL3HLT:46,EL3RST:47,ELNRNG:48,EUNATCH:49,ENOCSI:50,EL2HLT:51,EDEADLK:35,ENOLCK:37,EBADE:52,EBADR:53,EXFULL:54,
ENOANO:55,EBADRQC:56,EBADSLT:57,EDEADLOCK:35,EBFONT:59,ENOSTR:60,ENODATA:61,ETIME:62,ENOSR:63,ENONET:64,ENOPKG:65,EREMOTE:66,ENOLINK:67,EADV:68,ESRMNT:69,ECOMM:70,EPROTO:71,EMULTIHOP:72,EDOTDOT:73,EBADMSG:74,ENOTUNIQ:76,EBADFD:77,EREMCHG:78,ELIBACC:79,ELIBBAD:80,ELIBSCN:81,ELIBMAX:82,ELIBEXEC:83,ENOSYS:38,ENOTEMPTY:39,ENAMETOOLONG:36,ELOOP:40,EOPNOTSUPP:95,EPFNOSUPPORT:96,ECONNRESET:104,ENOBUFS:105,EAFNOSUPPORT:97,EPROTOTYPE:91,ENOTSOCK:88,ENOPROTOOPT:92,ESHUTDOWN:108,ECONNREFUSED:111,EADDRINUSE:98,
ECONNABORTED:103,ENETUNREACH:101,ENETDOWN:100,ETIMEDOUT:110,EHOSTDOWN:112,EHOSTUNREACH:113,EINPROGRESS:115,EALREADY:114,EDESTADDRREQ:89,EMSGSIZE:90,EPROTONOSUPPORT:93,ESOCKTNOSUPPORT:94,EADDRNOTAVAIL:99,ENETRESET:102,EISCONN:106,ENOTCONN:107,ETOOMANYREFS:109,EUSERS:87,EDQUOT:122,ESTALE:116,ENOTSUP:95,ENOMEDIUM:123,EILSEQ:84,EOVERFLOW:75,ECANCELED:125,ENOTRECOVERABLE:131,EOWNERDEAD:130,ESTRPIPE:86};
var ERRNO_MESSAGES={0:"Success",1:"Not super-user",2:"No such file or directory",3:"No such process",4:"Interrupted system call",5:"I/O error",6:"No such device or address",7:"Arg list too long",8:"Exec format error",9:"Bad file number",10:"No children",11:"No more processes",12:"Not enough core",13:"Permission denied",14:"Bad address",15:"Block device required",16:"Mount device busy",17:"File exists",18:"Cross-device link",19:"No such device",20:"Not a directory",21:"Is a directory",22:"Invalid argument",
23:"Too many open files in system",24:"Too many open files",25:"Not a typewriter",26:"Text file busy",27:"File too large",28:"No space left on device",29:"Illegal seek",30:"Read only file system",31:"Too many links",32:"Broken pipe",33:"Math arg out of domain of func",34:"Math result not representable",35:"File locking deadlock error",36:"File or path name too long",37:"No record locks available",38:"Function not implemented",39:"Directory not empty",40:"Too many symbolic links",42:"No message of desired type",
43:"Identifier removed",44:"Channel number out of range",45:"Level 2 not synchronized",46:"Level 3 halted",47:"Level 3 reset",48:"Link number out of range",49:"Protocol driver not attached",50:"No CSI structure available",51:"Level 2 halted",52:"Invalid exchange",53:"Invalid request descriptor",54:"Exchange full",55:"No anode",56:"Invalid request code",57:"Invalid slot",59:"Bad font file fmt",60:"Device not a stream",61:"No data (for no delay io)",62:"Timer expired",63:"Out of streams resources",
64:"Machine is not on the network",65:"Package not installed",66:"The object is remote",67:"The link has been severed",68:"Advertise error",69:"Srmount error",70:"Communication error on send",71:"Protocol error",72:"Multihop attempted",73:"Cross mount point (not really error)",74:"Trying to read unreadable message",75:"Value too large for defined data type",76:"Given log. name not unique",77:"f.d. invalid for this operation",78:"Remote address changed",79:"Can   access a needed shared lib",80:"Accessing a corrupted shared lib",
81:".lib section in a.out corrupted",82:"Attempting to link in too many libs",83:"Attempting to exec a shared library",84:"Illegal byte sequence",86:"Streams pipe error",87:"Too many users",88:"Socket operation on non-socket",89:"Destination address required",90:"Message too long",91:"Protocol wrong type for socket",92:"Protocol not available",93:"Unknown protocol",94:"Socket type not supported",95:"Not supported",96:"Protocol family not supported",97:"Address family not supported by protocol family",
98:"Address already in use",99:"Address not available",100:"Network interface is not configured",101:"Network is unreachable",102:"Connection reset by network",103:"Connection aborted",104:"Connection reset by peer",105:"No buffer space available",106:"Socket is already connected",107:"Socket is not connected",108:"Can't send after socket shutdown",109:"Too many references",110:"Connection timed out",111:"Connection refused",112:"Host is down",113:"Host is unreachable",114:"Socket already connected",
115:"Connection already in progress",116:"Stale file handle",122:"Quota exceeded",123:"No medium (in tape drive)",125:"Operation canceled",130:"Previous owner died",131:"State not recoverable"};
var TTY={ttys:[],init:function(){},shutdown:function(){},register:function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open:function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty)throw new FS.ErrnoError(ERRNO_CODES.ENODEV);stream.tty=tty;stream.seekable=false},close:function(stream){if(stream.tty.output.length)stream.tty.ops.put_char(stream.tty,10)},read:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char)throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO);}if(result===undefined&&bytesRead===0)throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead)stream.node.timestamp=Date.now();return bytesRead},write:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char)throw new FS.ErrnoError(ERRNO_CODES.ENXIO);
for(var i=0;i<length;i++)try{stream.tty.ops.put_char(stream.tty,buffer[offset+i])}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO);}if(length)stream.node.timestamp=Date.now();return i}},default_tty_ops:{get_char:function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){result=process["stdin"]["read"]();if(!result){if(process["stdin"]["_readableState"]&&process["stdin"]["_readableState"]["ended"])return null;return undefined}}else if(typeof window!="undefined"&&typeof window.prompt==
"function"){result=window.prompt("Input: ");if(result!==null)result+="\n"}else if(typeof readline=="function"){result=readline();if(result!==null)result+="\n"}if(!result)return null;tty.input=intArrayFromString(result,true)}return tty.input.shift()},put_char:function(tty,val){if(val===null||val===10){Module["print"](tty.output.join(""));tty.output=[]}else tty.output.push(TTY.utf8.processCChar(val))}},default_tty1_ops:{put_char:function(tty,val){if(val===null||val===10){Module["printErr"](tty.output.join(""));
tty.output=[]}else tty.output.push(TTY.utf8.processCChar(val))}}};
var MEMFS={ops_table:null,mount:function(mount){return MEMFS.createNode(null,"/",16384|511,0)},createNode:function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode))throw new FS.ErrnoError(ERRNO_CODES.EPERM);if(!MEMFS.ops_table)MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},
stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}};
var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;
node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent)parent.contents[name]=node;return node},getFileDataAsRegularArray:function(node){if(node.contents&&node.contents.subarray){var arr=[];for(var i=0;i<node.usedBytes;++i)arr.push(node.contents[i]);return arr}return node.contents},getFileDataAsTypedArray:function(node){if(node.contents&&node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage:function(node,
newCapacity){if(node.contents&&node.contents.subarray&&newCapacity>node.contents.length){node.contents=MEMFS.getFileDataAsRegularArray(node);node.usedBytes=node.contents.length}if(!node.contents||node.contents.subarray){var prevCapacity=node.contents?node.contents.buffer.byteLength:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)|0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,
256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0);return}if(!node.contents&&newCapacity>0)node.contents=[];while(node.contents.length<newCapacity)node.contents.push(0)},resizeFileStorage:function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0;return}if(!node.contents||node.contents.subarray){var oldContents=node.contents;node.contents=new Uint8Array(new ArrayBuffer(newSize));
node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)));node.usedBytes=newSize;return}if(!node.contents)node.contents=[];if(node.contents.length>newSize)node.contents.length=newSize;else while(node.contents.length<newSize)node.contents.push(0);node.usedBytes=newSize},node_ops:{getattr:function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode))attr.size=4096;
else if(FS.isFile(node.mode))attr.size=node.usedBytes;else if(FS.isLink(node.mode))attr.size=node.link.length;else attr.size=0;attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr:function(node,attr){if(attr.mode!==undefined)node.mode=attr.mode;if(attr.timestamp!==undefined)node.timestamp=attr.timestamp;if(attr.size!==undefined)MEMFS.resizeFileStorage(node,attr.size)},
lookup:function(parent,name){throw FS.genericErrors[ERRNO_CODES.ENOENT];},mknod:function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename:function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node)for(var i in new_node.contents)throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);}delete old_node.parent.contents[old_node.name];old_node.name=new_name;new_dir.contents[new_name]=old_node;old_node.parent=
new_dir},unlink:function(parent,name){delete parent.contents[name]},rmdir:function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents)throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);delete parent.contents[name]},readdir:function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key))continue;entries.push(key)}return entries},symlink:function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;
return node},readlink:function(node){if(!FS.isLink(node.mode))throw new FS.ErrnoError(ERRNO_CODES.EINVAL);return node.link}},stream_ops:{read:function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);assert(size>=0);if(size>8&&contents.subarray)buffer.set(contents.subarray(position,position+size),offset);else for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i];return size},
write:function(stream,buffer,offset,length,position,canOwn){if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray))if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=new Uint8Array(buffer.subarray(offset,offset+length));node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,
offset+length),position);return length}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray)node.contents.set(buffer.subarray(offset,offset+length),position);else for(var i=0;i<length;i++)node.contents[position+i]=buffer[offset+i];node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek:function(stream,offset,whence){var position=offset;if(whence===1)position+=stream.position;else if(whence===2)if(FS.isFile(stream.node.mode))position+=stream.node.usedBytes;
if(position<0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);stream.ungotten=[];stream.position=position;return position},allocate:function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap:function(stream,buffer,offset,length,position,prot,flags){if(!FS.isFile(stream.node.mode))throw new FS.ErrnoError(ERRNO_CODES.ENODEV);var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&(contents.buffer===
buffer||contents.buffer===buffer.buffer)){allocated=false;ptr=contents.byteOffset}else{if(position>0||position+length<stream.node.usedBytes)if(contents.subarray)contents=contents.subarray(position,position+length);else contents=Array.prototype.slice.call(contents,position,position+length);allocated=true;ptr=_malloc(length);if(!ptr)throw new FS.ErrnoError(ERRNO_CODES.ENOMEM);buffer.set(contents,ptr)}return{ptr:ptr,allocated:allocated}}}};
var IDBFS={dbs:{},indexedDB:function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function(mount){return MEMFS.mount.apply(null,arguments)},syncfs:function(mount,populate,callback){IDBFS.getLocalSet(mount,function(err,local){if(err)return callback(err);IDBFS.getRemoteSet(mount,function(err,remote){if(err)return callback(err);var src=populate?remote:local;var dst=populate?local:remote;IDBFS.reconcile(src,dst,
callback)})})},getDB:function(name,callback){var db=IDBFS.dbs[name];if(db)return callback(null,db);var req;try{req=IDBFS.indexedDB().open(name,IDBFS.DB_VERSION)}catch(e){return callback(e)}req.onupgradeneeded=function(e){var db=e.target.result;var transaction=e.target.transaction;var fileStore;if(db.objectStoreNames.contains(IDBFS.DB_STORE_NAME))fileStore=transaction.objectStore(IDBFS.DB_STORE_NAME);else fileStore=db.createObjectStore(IDBFS.DB_STORE_NAME);fileStore.createIndex("timestamp","timestamp",
{unique:false})};req.onsuccess=function(){db=req.result;IDBFS.dbs[name]=db;callback(null,db)};req.onerror=function(){callback(this.error)}},getLocalSet:function(mount,callback){var entries={};function isRealDir(p){return p!=="."&&p!==".."}function toAbsolute(root){return function(p){return PATH.join2(root,p)}}var check=FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));while(check.length){var path=check.pop();var stat;try{stat=FS.stat(path)}catch(e){return callback(e)}if(FS.isDir(stat.mode))check.push.apply(check,
FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));entries[path]={timestamp:stat.mtime}}return callback(null,{type:"local",entries:entries})},getRemoteSet:function(mount,callback){var entries={};IDBFS.getDB(mount.mountpoint,function(err,db){if(err)return callback(err);var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readonly");transaction.onerror=function(){callback(this.error)};var store=transaction.objectStore(IDBFS.DB_STORE_NAME);var index=store.index("timestamp");index.openKeyCursor().onsuccess=
function(event){var cursor=event.target.result;if(!cursor)return callback(null,{type:"remote",db:db,entries:entries});entries[cursor.primaryKey]={timestamp:cursor.key};cursor.continue()}})},loadLocalEntry:function(path,callback){var stat,node;try{var lookup=FS.lookupPath(path);node=lookup.node;stat=FS.stat(path)}catch(e){return callback(e)}if(FS.isDir(stat.mode))return callback(null,{timestamp:stat.mtime,mode:stat.mode});else if(FS.isFile(stat.mode)){node.contents=MEMFS.getFileDataAsTypedArray(node);
return callback(null,{timestamp:stat.mtime,mode:stat.mode,contents:node.contents})}else return callback(new Error("node type not supported"))},storeLocalEntry:function(path,entry,callback){try{if(FS.isDir(entry.mode))FS.mkdir(path,entry.mode);else if(FS.isFile(entry.mode))FS.writeFile(path,entry.contents,{encoding:"binary",canOwn:true});else return callback(new Error("node type not supported"));FS.utime(path,entry.timestamp,entry.timestamp)}catch(e){return callback(e)}callback(null)},removeLocalEntry:function(path,
callback){try{var lookup=FS.lookupPath(path);var stat=FS.stat(path);if(FS.isDir(stat.mode))FS.rmdir(path);else if(FS.isFile(stat.mode))FS.unlink(path)}catch(e){return callback(e)}callback(null)},loadRemoteEntry:function(store,path,callback){var req=store.get(path);req.onsuccess=function(event){callback(null,event.target.result)};req.onerror=function(){callback(this.error)}},storeRemoteEntry:function(store,path,entry,callback){var req=store.put(entry,path);req.onsuccess=function(){callback(null)};
req.onerror=function(){callback(this.error)}},removeRemoteEntry:function(store,path,callback){var req=store.delete(path);req.onsuccess=function(){callback(null)};req.onerror=function(){callback(this.error)}},reconcile:function(src,dst,callback){var total=0;var create=[];Object.keys(src.entries).forEach(function(key){var e=src.entries[key];var e2=dst.entries[key];if(!e2||e.timestamp>e2.timestamp){create.push(key);total++}});var remove=[];Object.keys(dst.entries).forEach(function(key){var e=dst.entries[key];
var e2=src.entries[key];if(!e2){remove.push(key);total++}});if(!total)return callback(null);var errored=false;var completed=0;var db=src.type==="remote"?src.db:dst.db;var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readwrite");var store=transaction.objectStore(IDBFS.DB_STORE_NAME);function done(err){if(err){if(!done.errored){done.errored=true;return callback(err)}return}if(++completed>=total)return callback(null)}transaction.onerror=function(){done(this.error)};create.sort().forEach(function(path){if(dst.type===
"local")IDBFS.loadRemoteEntry(store,path,function(err,entry){if(err)return done(err);IDBFS.storeLocalEntry(path,entry,done)});else IDBFS.loadLocalEntry(path,function(err,entry){if(err)return done(err);IDBFS.storeRemoteEntry(store,path,entry,done)})});remove.sort().reverse().forEach(function(path){if(dst.type==="local")IDBFS.removeLocalEntry(path,done);else IDBFS.removeRemoteEntry(store,path,done)})}};
var NODEFS={isWindows:false,staticInit:function(){NODEFS.isWindows=!!process.platform.match(/^win/)},mount:function(mount){assert(ENVIRONMENT_IS_NODE);return NODEFS.createNode(null,"/",NODEFS.getMode(mount.opts.root),0)},createNode:function(parent,name,mode,dev){if(!FS.isDir(mode)&&!FS.isFile(mode)&&!FS.isLink(mode))throw new FS.ErrnoError(ERRNO_CODES.EINVAL);var node=FS.createNode(parent,name,mode);node.node_ops=NODEFS.node_ops;node.stream_ops=NODEFS.stream_ops;return node},getMode:function(path){var stat;
try{stat=fs.lstatSync(path);if(NODEFS.isWindows)stat.mode=stat.mode|(stat.mode&146)>>1}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}return stat.mode},realPath:function(node){var parts=[];while(node.parent!==node){parts.push(node.name);node=node.parent}parts.push(node.mount.opts.root);parts.reverse();return PATH.join.apply(null,parts)},flagsToPermissionStringMap:{0:"r",1:"r+",2:"r+",64:"r",65:"r+",66:"r+",129:"rx+",193:"rx+",514:"w+",577:"w",578:"w+",705:"wx",706:"wx+",
1024:"a",1025:"a",1026:"a+",1089:"a",1090:"a+",1153:"ax",1154:"ax+",1217:"ax",1218:"ax+",4096:"rs",4098:"rs+"},flagsToPermissionString:function(flags){if(flags in NODEFS.flagsToPermissionStringMap)return NODEFS.flagsToPermissionStringMap[flags];else return flags},node_ops:{getattr:function(node){var path=NODEFS.realPath(node);var stat;try{stat=fs.lstatSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}if(NODEFS.isWindows&&!stat.blksize)stat.blksize=4096;if(NODEFS.isWindows&&
!stat.blocks)stat.blocks=(stat.size+stat.blksize-1)/stat.blksize|0;return{dev:stat.dev,ino:stat.ino,mode:stat.mode,nlink:stat.nlink,uid:stat.uid,gid:stat.gid,rdev:stat.rdev,size:stat.size,atime:stat.atime,mtime:stat.mtime,ctime:stat.ctime,blksize:stat.blksize,blocks:stat.blocks}},setattr:function(node,attr){var path=NODEFS.realPath(node);try{if(attr.mode!==undefined){fs.chmodSync(path,attr.mode);node.mode=attr.mode}if(attr.timestamp!==undefined){var date=new Date(attr.timestamp);fs.utimesSync(path,
date,date)}if(attr.size!==undefined)fs.truncateSync(path,attr.size)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},lookup:function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);var mode=NODEFS.getMode(path);return NODEFS.createNode(parent,name,mode)},mknod:function(parent,name,mode,dev){var node=NODEFS.createNode(parent,name,mode,dev);var path=NODEFS.realPath(node);try{if(FS.isDir(node.mode))fs.mkdirSync(path,node.mode);else fs.writeFileSync(path,"",{mode:node.mode})}catch(e){if(!e.code)throw e;
throw new FS.ErrnoError(ERRNO_CODES[e.code]);}return node},rename:function(oldNode,newDir,newName){var oldPath=NODEFS.realPath(oldNode);var newPath=PATH.join2(NODEFS.realPath(newDir),newName);try{fs.renameSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},unlink:function(parent,name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.unlinkSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},rmdir:function(parent,
name){var path=PATH.join2(NODEFS.realPath(parent),name);try{fs.rmdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},readdir:function(node){var path=NODEFS.realPath(node);try{return fs.readdirSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},symlink:function(parent,newName,oldPath){var newPath=PATH.join2(NODEFS.realPath(parent),newName);try{fs.symlinkSync(oldPath,newPath)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);
}},readlink:function(node){var path=NODEFS.realPath(node);try{return fs.readlinkSync(path)}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}}},stream_ops:{open:function(stream){var path=NODEFS.realPath(stream.node);try{if(FS.isFile(stream.node.mode))stream.nfd=fs.openSync(path,NODEFS.flagsToPermissionString(stream.flags))}catch(e){if(!e.code)throw e;throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},close:function(stream){try{if(FS.isFile(stream.node.mode)&&stream.nfd)fs.closeSync(stream.nfd)}catch(e){if(!e.code)throw e;
throw new FS.ErrnoError(ERRNO_CODES[e.code]);}},read:function(stream,buffer,offset,length,position){var nbuffer=new Buffer(length);var res;try{res=fs.readSync(stream.nfd,nbuffer,0,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code]);}if(res>0)for(var i=0;i<res;i++)buffer[offset+i]=nbuffer[i];return res},write:function(stream,buffer,offset,length,position){var nbuffer=new Buffer(buffer.subarray(offset,offset+length));var res;try{res=fs.writeSync(stream.nfd,nbuffer,0,length,position)}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code]);
}return res},llseek:function(stream,offset,whence){var position=offset;if(whence===1)position+=stream.position;else if(whence===2)if(FS.isFile(stream.node.mode))try{var stat=fs.fstatSync(stream.nfd);position+=stat.size}catch(e){throw new FS.ErrnoError(ERRNO_CODES[e.code]);}if(position<0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);stream.position=position;return position}}};var _stdin=allocate(1,"i32*",ALLOC_STATIC);var _stdout=allocate(1,"i32*",ALLOC_STATIC);var _stderr=allocate(1,"i32*",ALLOC_STATIC);
function _fflush(stream){}
var FS={root:null,mounts:[],devices:[null],streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},handleFSError:function(e){if(!(e instanceof FS.ErrnoError))throw e+" : "+stackTrace();return ___setErrNo(e.errno)},lookupPath:function(path,opts){path=PATH.resolve(FS.cwd(),path);opts=opts||{};var defaults={follow_mount:true,recurse_count:0};for(var key in defaults)if(opts[key]===undefined)opts[key]=
defaults[key];if(opts.recurse_count>8)throw new FS.ErrnoError(ERRNO_CODES.ELOOP);var parts=PATH.normalizeArray(path.split("/").filter(function(p){return!!p}),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent)break;current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current))if(!islast||islast&&opts.follow_mount)current=current.mounted.root;if(!islast||opts.follow){var count=
0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count});current=lookup.node;if(count++>40)throw new FS.ErrnoError(ERRNO_CODES.ELOOP);}}}return{path:current_path,node:current}},getPath:function(node){var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=
path?node.name+"/"+path:node.name;node=node.parent}},hashName:function(parentid,name){var hash=0;for(var i=0;i<name.length;i++)hash=(hash<<5)-hash+name.charCodeAt(i)|0;return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode:function(node){var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode:function(node){var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node)FS.nameTable[hash]=node.name_next;else{var current=
FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode:function(parent,name){var err=FS.mayLookup(parent);if(err)throw new FS.ErrnoError(err);var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name)return node}return FS.lookup(parent,name)},createNode:function(parent,name,mode,rdev){if(!FS.FSNode){FS.FSNode=
function(parent,name,mode,rdev){if(!parent)parent=this;this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev};FS.FSNode.prototype={};var readMode=292|73;var writeMode=146;Object.defineProperties(FS.FSNode.prototype,{read:{get:function(){return(this.mode&readMode)===readMode},set:function(val){val?this.mode|=readMode:this.mode&=~readMode}},write:{get:function(){return(this.mode&writeMode)===
writeMode},set:function(val){val?this.mode|=writeMode:this.mode&=~writeMode}},isFolder:{get:function(){return FS.isDir(this.mode)}},isDevice:{get:function(){return FS.isChrdev(this.mode)}}})}var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode:function(node){FS.hashRemoveNode(node)},isRoot:function(node){return node===node.parent},isMountpoint:function(node){return!!node.mounted},isFile:function(mode){return(mode&61440)===32768},isDir:function(mode){return(mode&
61440)===16384},isLink:function(mode){return(mode&61440)===40960},isChrdev:function(mode){return(mode&61440)===8192},isBlkdev:function(mode){return(mode&61440)===24576},isFIFO:function(mode){return(mode&61440)===4096},isSocket:function(mode){return(mode&49152)===49152},flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function(str){var flags=FS.flagModes[str];if(typeof flags===
"undefined")throw new Error("Unknown file open mode: "+str);return flags},flagsToPermissionString:function(flag){var accmode=flag&2097155;var perms=["r","w","rw"][accmode];if(flag&512)perms+="w";return perms},nodePermissions:function(node,perms){if(FS.ignorePermissions)return 0;if(perms.indexOf("r")!==-1&&!(node.mode&292))return ERRNO_CODES.EACCES;else if(perms.indexOf("w")!==-1&&!(node.mode&146))return ERRNO_CODES.EACCES;else if(perms.indexOf("x")!==-1&&!(node.mode&73))return ERRNO_CODES.EACCES;
return 0},mayLookup:function(dir){return FS.nodePermissions(dir,"x")},mayCreate:function(dir,name){try{var node=FS.lookupNode(dir,name);return ERRNO_CODES.EEXIST}catch(e){}return FS.nodePermissions(dir,"wx")},mayDelete:function(dir,name,isdir){var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var err=FS.nodePermissions(dir,"wx");if(err)return err;if(isdir){if(!FS.isDir(node.mode))return ERRNO_CODES.ENOTDIR;if(FS.isRoot(node)||FS.getPath(node)===FS.cwd())return ERRNO_CODES.EBUSY}else if(FS.isDir(node.mode))return ERRNO_CODES.EISDIR;
return 0},mayOpen:function(node,flags){if(!node)return ERRNO_CODES.ENOENT;if(FS.isLink(node.mode))return ERRNO_CODES.ELOOP;else if(FS.isDir(node.mode))if((flags&2097155)!==0||flags&512)return ERRNO_CODES.EISDIR;return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd:function(fd_start,fd_end){fd_start=fd_start||0;fd_end=fd_end||FS.MAX_OPEN_FDS;for(var fd=fd_start;fd<=fd_end;fd++)if(!FS.streams[fd])return fd;throw new FS.ErrnoError(ERRNO_CODES.EMFILE);},getStream:function(fd){return FS.streams[fd]},
createStream:function(stream,fd_start,fd_end){if(!FS.FSStream){FS.FSStream=function(){};FS.FSStream.prototype={};Object.defineProperties(FS.FSStream.prototype,{object:{get:function(){return this.node},set:function(val){this.node=val}},isRead:{get:function(){return(this.flags&2097155)!==1}},isWrite:{get:function(){return(this.flags&2097155)!==0}},isAppend:{get:function(){return this.flags&1024}}})}var newStream=new FS.FSStream;for(var p in stream)newStream[p]=stream[p];stream=newStream;var fd=FS.nextfd(fd_start,
fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream:function(fd){FS.streams[fd]=null},getStreamFromPtr:function(ptr){return FS.streams[ptr-1]},getPtrForStream:function(stream){return stream?stream.fd+1:0},chrdev_stream_ops:{open:function(stream){var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open)stream.stream_ops.open(stream)},llseek:function(){throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);}},major:function(dev){return dev>>8},minor:function(dev){return dev&
255},makedev:function(ma,mi){return ma<<8|mi},registerDevice:function(dev,ops){FS.devices[dev]={stream_ops:ops}},getDevice:function(dev){return FS.devices[dev]},getMounts:function(mount){var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts)}return mounts},syncfs:function(populate,callback){if(typeof populate==="function"){callback=populate;populate=false}var mounts=FS.getMounts(FS.root.mount);var completed=0;function done(err){if(err){if(!done.errored){done.errored=
true;return callback(err)}return}if(++completed>=mounts.length)callback(null)}mounts.forEach(function(mount){if(!mount.type.syncfs)return done(null);mount.type.syncfs(mount,populate,done)})},mount:function(type,opts,mountpoint){var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root)throw new FS.ErrnoError(ERRNO_CODES.EBUSY);else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node))throw new FS.ErrnoError(ERRNO_CODES.EBUSY);
if(!FS.isDir(node.mode))throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root)FS.root=mountRoot;else if(node){node.mounted=mount;if(node.mount)node.mount.mounts.push(mount)}return mountRoot},unmount:function(mountpoint){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node))throw new FS.ErrnoError(ERRNO_CODES.EINVAL);var node=
lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(function(hash){var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.indexOf(current.mount)!==-1)FS.destroyNode(current);current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);assert(idx!==-1);node.mount.mounts.splice(idx,1)},lookup:function(parent,name){return parent.node_ops.lookup(parent,name)},mknod:function(path,mode,dev){var lookup=FS.lookupPath(path,
{parent:true});var parent=lookup.node;var name=PATH.basename(path);var err=FS.mayCreate(parent,name);if(err)throw new FS.ErrnoError(err);if(!parent.node_ops.mknod)throw new FS.ErrnoError(ERRNO_CODES.EPERM);return parent.node_ops.mknod(parent,name,mode,dev)},create:function(path,mode){mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir:function(path,mode){mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdev:function(path,
mode,dev){if(typeof dev==="undefined"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink:function(oldpath,newpath){var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;var newname=PATH.basename(newpath);var err=FS.mayCreate(parent,newname);if(err)throw new FS.ErrnoError(err);if(!parent.node_ops.symlink)throw new FS.ErrnoError(ERRNO_CODES.EPERM);return parent.node_ops.symlink(parent,newname,oldpath)},rename:function(old_path,new_path){var old_dirname=PATH.dirname(old_path);
var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;try{lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EBUSY);}if(old_dir.mount!==new_dir.mount)throw new FS.ErrnoError(ERRNO_CODES.EXDEV);var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH.relative(old_path,new_dirname);if(relative.charAt(0)!==
".")throw new FS.ErrnoError(ERRNO_CODES.EINVAL);relative=PATH.relative(new_path,old_dirname);if(relative.charAt(0)!==".")throw new FS.ErrnoError(ERRNO_CODES.ENOTEMPTY);var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node)return;var isdir=FS.isDir(old_node.mode);var err=FS.mayDelete(old_dir,old_name,isdir);if(err)throw new FS.ErrnoError(err);err=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(err)throw new FS.ErrnoError(err);if(!old_dir.node_ops.rename)throw new FS.ErrnoError(ERRNO_CODES.EPERM);
if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node))throw new FS.ErrnoError(ERRNO_CODES.EBUSY);if(new_dir!==old_dir){err=FS.nodePermissions(old_dir,"w");if(err)throw new FS.ErrnoError(err);}try{if(FS.trackingDelegate["willMovePath"])FS.trackingDelegate["willMovePath"](old_path,new_path)}catch(e){console.log("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name)}catch(e){throw e;
}finally{FS.hashAddNode(old_node)}try{if(FS.trackingDelegate["onMovePath"])FS.trackingDelegate["onMovePath"](old_path,new_path)}catch(e){console.log("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: "+e.message)}},rmdir:function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,true);if(err)throw new FS.ErrnoError(err);if(!parent.node_ops.rmdir)throw new FS.ErrnoError(ERRNO_CODES.EPERM);
if(FS.isMountpoint(node))throw new FS.ErrnoError(ERRNO_CODES.EBUSY);try{if(FS.trackingDelegate["willDeletePath"])FS.trackingDelegate["willDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}},
readdir:function(path){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir)throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);return node.node_ops.readdir(node)},unlink:function(path){var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var err=FS.mayDelete(parent,name,false);if(err){if(err===ERRNO_CODES.EISDIR)err=ERRNO_CODES.EPERM;throw new FS.ErrnoError(err);}if(!parent.node_ops.unlink)throw new FS.ErrnoError(ERRNO_CODES.EPERM);
if(FS.isMountpoint(node))throw new FS.ErrnoError(ERRNO_CODES.EBUSY);try{if(FS.trackingDelegate["willDeletePath"])FS.trackingDelegate["willDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: "+e.message)}parent.node_ops.unlink(parent,name);FS.destroyNode(node);try{if(FS.trackingDelegate["onDeletePath"])FS.trackingDelegate["onDeletePath"](path)}catch(e){console.log("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: "+e.message)}},
readlink:function(path){var lookup=FS.lookupPath(path);var link=lookup.node;if(!link.node_ops.readlink)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);return link.node_ops.readlink(link)},stat:function(path,dontFollow){var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node.node_ops.getattr)throw new FS.ErrnoError(ERRNO_CODES.EPERM);return node.node_ops.getattr(node)},lstat:function(path){return FS.stat(path,true)},chmod:function(path,mode,dontFollow){var node;if(typeof path===
"string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else node=path;if(!node.node_ops.setattr)throw new FS.ErrnoError(ERRNO_CODES.EPERM);node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})},lchmod:function(path,mode){FS.chmod(path,mode,true)},fchmod:function(fd,mode){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);FS.chmod(stream.node,mode)},chown:function(path,uid,gid,dontFollow){var node;if(typeof path==="string"){var lookup=
FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else node=path;if(!node.node_ops.setattr)throw new FS.ErrnoError(ERRNO_CODES.EPERM);node.node_ops.setattr(node,{timestamp:Date.now()})},lchown:function(path,uid,gid){FS.chown(path,uid,gid,true)},fchown:function(fd,uid,gid){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);FS.chown(stream.node,uid,gid)},truncate:function(path,len){if(len<0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);var node;if(typeof path===
"string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else node=path;if(!node.node_ops.setattr)throw new FS.ErrnoError(ERRNO_CODES.EPERM);if(FS.isDir(node.mode))throw new FS.ErrnoError(ERRNO_CODES.EISDIR);if(!FS.isFile(node.mode))throw new FS.ErrnoError(ERRNO_CODES.EINVAL);var err=FS.nodePermissions(node,"w");if(err)throw new FS.ErrnoError(err);node.node_ops.setattr(node,{size:len,timestamp:Date.now()})},ftruncate:function(fd,len){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(ERRNO_CODES.EBADF);
if((stream.flags&2097155)===0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);FS.truncate(stream.node,len)},utime:function(path,atime,mtime){var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})},open:function(path,flags,mode,fd_start,fd_end){flags=typeof flags==="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode==="undefined"?438:mode;if(flags&64)mode=mode&4095|32768;else mode=0;var node;if(typeof path==="object")node=
path;else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}if(flags&64)if(node){if(flags&128)throw new FS.ErrnoError(ERRNO_CODES.EEXIST);}else node=FS.mknod(path,mode,0);if(!node)throw new FS.ErrnoError(ERRNO_CODES.ENOENT);if(FS.isChrdev(node.mode))flags&=~512;var err=FS.mayOpen(node,flags);if(err)throw new FS.ErrnoError(err);if(flags&512)FS.truncate(node,0);flags&=~(128|512);var stream=FS.createStream({node:node,path:FS.getPath(node),
flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false},fd_start,fd_end);if(stream.stream_ops.open)stream.stream_ops.open(stream);if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1;Module["printErr"]("read file: "+path)}}try{if(FS.trackingDelegate["onOpenFile"]){var trackingFlags=0;if((flags&2097155)!==1)trackingFlags|=FS.tracking.openFlags.READ;if((flags&2097155)!==0)trackingFlags|=FS.tracking.openFlags.WRITE;
FS.trackingDelegate["onOpenFile"](path,trackingFlags)}}catch(e){console.log("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: "+e.message)}return stream},close:function(stream){try{if(stream.stream_ops.close)stream.stream_ops.close(stream)}catch(e){throw e;}finally{FS.closeStream(stream.fd)}},llseek:function(stream,offset,whence){if(!stream.seekable||!stream.stream_ops.llseek)throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);return stream.stream_ops.llseek(stream,offset,whence)},
read:function(stream,buffer,offset,length,position){if(length<0||position<0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);if((stream.flags&2097155)===1)throw new FS.ErrnoError(ERRNO_CODES.EBADF);if(FS.isDir(stream.node.mode))throw new FS.ErrnoError(ERRNO_CODES.EISDIR);if(!stream.stream_ops.read)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);var seeking=true;if(typeof position==="undefined"){position=stream.position;seeking=false}else if(!stream.seekable)throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);var bytesRead=
stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:function(stream,buffer,offset,length,position,canOwn){if(length<0||position<0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);if((stream.flags&2097155)===0)throw new FS.ErrnoError(ERRNO_CODES.EBADF);if(FS.isDir(stream.node.mode))throw new FS.ErrnoError(ERRNO_CODES.EISDIR);if(!stream.stream_ops.write)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);if(stream.flags&1024)FS.llseek(stream,
0,2);var seeking=true;if(typeof position==="undefined"){position=stream.position;seeking=false}else if(!stream.seekable)throw new FS.ErrnoError(ERRNO_CODES.ESPIPE);var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;try{if(stream.path&&FS.trackingDelegate["onWriteToFile"])FS.trackingDelegate["onWriteToFile"](stream.path)}catch(e){console.log("FS.trackingDelegate['onWriteToFile']('"+path+"') threw an exception: "+e.message)}return bytesWritten},
allocate:function(stream,offset,length){if(offset<0||length<=0)throw new FS.ErrnoError(ERRNO_CODES.EINVAL);if((stream.flags&2097155)===0)throw new FS.ErrnoError(ERRNO_CODES.EBADF);if(!FS.isFile(stream.node.mode)&&!FS.isDir(node.mode))throw new FS.ErrnoError(ERRNO_CODES.ENODEV);if(!stream.stream_ops.allocate)throw new FS.ErrnoError(ERRNO_CODES.EOPNOTSUPP);stream.stream_ops.allocate(stream,offset,length)},mmap:function(stream,buffer,offset,length,position,prot,flags){if((stream.flags&2097155)===1)throw new FS.ErrnoError(ERRNO_CODES.EACCES);
if(!stream.stream_ops.mmap)throw new FS.ErrnoError(ERRNO_CODES.ENODEV);return stream.stream_ops.mmap(stream,buffer,offset,length,position,prot,flags)},ioctl:function(stream,cmd,arg){if(!stream.stream_ops.ioctl)throw new FS.ErrnoError(ERRNO_CODES.ENOTTY);return stream.stream_ops.ioctl(stream,cmd,arg)},readFile:function(path,opts){opts=opts||{};opts.flags=opts.flags||"r";opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary")throw new Error('Invalid encoding type "'+
opts.encoding+'"');var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret="";var utf8=new Runtime.UTF8Processor;for(var i=0;i<length;i++)ret+=utf8.processCChar(buf[i])}else if(opts.encoding==="binary")ret=buf;FS.close(stream);return ret},writeFile:function(path,data,opts){opts=opts||{};opts.flags=opts.flags||"w";opts.encoding=opts.encoding||"utf8";if(opts.encoding!=="utf8"&&
opts.encoding!=="binary")throw new Error('Invalid encoding type "'+opts.encoding+'"');var stream=FS.open(path,opts.flags,opts.mode);if(opts.encoding==="utf8"){var utf8=new Runtime.UTF8Processor;var buf=new Uint8Array(utf8.processJSString(data));FS.write(stream,buf,0,buf.length,0,opts.canOwn)}else if(opts.encoding==="binary")FS.write(stream,data,0,data.length,0,opts.canOwn);FS.close(stream)},cwd:function(){return FS.currentPath},chdir:function(path){var lookup=FS.lookupPath(path,{follow:true});if(!FS.isDir(lookup.node.mode))throw new FS.ErrnoError(ERRNO_CODES.ENOTDIR);
var err=FS.nodePermissions(lookup.node,"x");if(err)throw new FS.ErrnoError(err);FS.currentPath=lookup.path},createDefaultDirectories:function(){FS.mkdir("/tmp")},createDefaultDevices:function(){FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:function(){return 0},write:function(){return 0}});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,
0));FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp")},createStandardStreams:function(){if(Module["stdin"])FS.createDevice("/dev","stdin",Module["stdin"]);else FS.symlink("/dev/tty","/dev/stdin");if(Module["stdout"])FS.createDevice("/dev","stdout",null,Module["stdout"]);else FS.symlink("/dev/tty","/dev/stdout");if(Module["stderr"])FS.createDevice("/dev","stderr",null,Module["stderr"]);else FS.symlink("/dev/tty1","/dev/stderr");var stdin=FS.open("/dev/stdin","r");HEAP32[_stdin>>2]=FS.getPtrForStream(stdin);
assert(stdin.fd===0,"invalid handle for stdin ("+stdin.fd+")");var stdout=FS.open("/dev/stdout","w");HEAP32[_stdout>>2]=FS.getPtrForStream(stdout);assert(stdout.fd===1,"invalid handle for stdout ("+stdout.fd+")");var stderr=FS.open("/dev/stderr","w");HEAP32[_stderr>>2]=FS.getPtrForStream(stderr);assert(stderr.fd===2,"invalid handle for stderr ("+stderr.fd+")")},ensureErrnoError:function(){if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno){this.errno=errno;for(var key in ERRNO_CODES)if(ERRNO_CODES[key]===
errno){this.code=key;break}this.message=ERRNO_MESSAGES[errno]};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[ERRNO_CODES.ENOENT].forEach(function(code){FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>"})},staticInit:function(){FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices()},init:function(input,output,error){assert(!FS.init.initialized,
"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams()},quit:function(){FS.init.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream)continue;FS.close(stream)}},
getMode:function(canRead,canWrite){var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode},joinPath:function(parts,forceRelative){var path=PATH.join.apply(null,parts);if(forceRelative&&path[0]=="/")path=path.substr(1);return path},absolutePath:function(relative,base){return PATH.resolve(base,relative)},standardizePath:function(path){return PATH.normalize(path)},findObject:function(path,dontResolveLastLink){var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists)return ret.object;
else{___setErrNo(ret.error);return null}},analyzePath:function(path,dontResolveLastLink){try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});
ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/"}catch(e){ret.error=e.errno}return ret},createFolder:function(parent,name,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.mkdir(path,mode)},createPath:function(parent,path,canRead,canWrite){parent=typeof parent==="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=
parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile:function(parent,name,properties,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile:function(parent,name,data,canRead,canWrite,canOwn){var path=name?PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name):parent;var mode=FS.getMode(canRead,
canWrite);var node=FS.create(path,mode);if(data){if(typeof data==="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,"w");FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}return node},createDevice:function(parent,name,input,output){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=
64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:function(stream){stream.seekable=false},close:function(stream){if(output&&output.buffer&&output.buffer.length)output(10)},read:function(stream,buffer,offset,length,pos){var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO);}if(result===undefined&&bytesRead===0)throw new FS.ErrnoError(ERRNO_CODES.EAGAIN);if(result===null||result===undefined)break;bytesRead++;
buffer[offset+i]=result}if(bytesRead)stream.node.timestamp=Date.now();return bytesRead},write:function(stream,buffer,offset,length,pos){for(var i=0;i<length;i++)try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(ERRNO_CODES.EIO);}if(length)stream.node.timestamp=Date.now();return i}});return FS.mkdev(path,mode,dev)},createLink:function(parent,name,target,canRead,canWrite){var path=PATH.join2(typeof parent==="string"?parent:FS.getPath(parent),name);return FS.symlink(target,path)},forceLoadFile:function(obj){if(obj.isDevice||
obj.isFolder||obj.link||obj.contents)return true;var success=true;if(typeof XMLHttpRequest!=="undefined")throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");else if(Module["read"])try{obj.contents=intArrayFromString(Module["read"](obj.url),true);obj.usedBytes=obj.contents.length}catch(e){success=false}else throw new Error("Cannot load without read() or XMLHttpRequest.");
if(!success)___setErrNo(ERRNO_CODES.EIO);return success},createLazyFile:function(parent,name,url,canRead,canWrite){function LazyUint8Array(){this.lengthKnown=false;this.chunks=[]}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0)return undefined;var chunkOffset=idx%this.chunkSize;var chunkNum=Math.floor(idx/this.chunkSize);return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=
getter};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=
function(from,to){if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);if(typeof Uint8Array!="undefined")xhr.responseType="arraybuffer";if(xhr.overrideMimeType)xhr.overrideMimeType("text/plain; charset=x-user-defined");xhr.send(null);if(!(xhr.status>=
200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined)return new Uint8Array(xhr.response||[]);else return intArrayFromString(xhr.responseText||"",true)};var lazyArray=this;lazyArray.setDataGetter(function(chunkNum){var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]==="undefined")lazyArray.chunks[chunkNum]=doXHR(start,end);if(typeof lazyArray.chunks[chunkNum]===
"undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]});this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true};if(typeof XMLHttpRequest!=="undefined"){if(!ENVIRONMENT_IS_WORKER)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperty(lazyArray,"length",{get:function(){if(!this.lengthKnown)this.cacheLength();return this._length}});Object.defineProperty(lazyArray,
"chunkSize",{get:function(){if(!this.lengthKnown)this.cacheLength();return this._chunkSize}});var properties={isDevice:false,contents:lazyArray}}else var properties={isDevice:false,url:url};var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents)node.contents=properties.contents;else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperty(node,"usedBytes",{get:function(){return this.contents.length}});var stream_ops={};var keys=Object.keys(node.stream_ops);
keys.forEach(function(key){var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){if(!FS.forceLoadFile(node))throw new FS.ErrnoError(ERRNO_CODES.EIO);return fn.apply(null,arguments)}});stream_ops.read=function stream_ops_read(stream,buffer,offset,length,position){if(!FS.forceLoadFile(node))throw new FS.ErrnoError(ERRNO_CODES.EIO);var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);assert(size>=0);if(contents.slice)for(var i=
0;i<size;i++)buffer[offset+i]=contents[position+i];else for(var i=0;i<size;i++)buffer[offset+i]=contents.get(position+i);return size};node.stream_ops=stream_ops;return node},createPreloadedFile:function(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn){Browser.init();var fullname=name?PATH.resolve(PATH.join2(parent,name)):parent;function processData(byteArray){function finish(byteArray){if(!dontCreateFile)FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn);if(onload)onload();
removeRunDependency("cp "+fullname)}var handled=false;Module["preloadPlugins"].forEach(function(plugin){if(handled)return;if(plugin["canHandle"](fullname)){plugin["handle"](byteArray,fullname,finish,function(){if(onerror)onerror();removeRunDependency("cp "+fullname)});handled=true}});if(!handled)finish(byteArray)}addRunDependency("cp "+fullname);if(typeof url=="string")Browser.asyncLoad(url,function(byteArray){processData(byteArray)},onerror);else processData(url)},indexedDB:function(){return window.indexedDB||
window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:function(){return"EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(paths,onload,onerror){onload=onload||function(){};onerror=onerror||function(){};var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=function openRequest_onupgradeneeded(){console.log("creating db");var db=openRequest.result;
db.createObjectStore(FS.DB_STORE_NAME)};openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(function(path){var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=function putRequest_onsuccess(){ok++;if(ok+fail==total)finish()};
putRequest.onerror=function putRequest_onerror(){fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror},loadFilesFromDB:function(paths,onload,onerror){onload=onload||function(){};onerror=onerror||function(){};var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=function openRequest_onsuccess(){var db=openRequest.result;try{var transaction=
db.transaction([FS.DB_STORE_NAME],"readonly")}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(function(path){var getRequest=files.get(path);getRequest.onsuccess=function getRequest_onsuccess(){if(FS.analyzePath(path).exists)FS.unlink(path);FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish()};getRequest.onerror=
function getRequest_onerror(){fail++;if(ok+fail==total)finish()}});transaction.onerror=onerror};openRequest.onerror=onerror}};
var PATH={splitPath:function(filename){var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last===".")parts.splice(i,1);else if(last===".."){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot)for(;up--;up)parts.unshift("..");return parts},normalize:function(path){var isAbsolute=path.charAt(0)===
"/",trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter(function(p){return!!p}),!isAbsolute).join("/");if(!path&&!isAbsolute)path=".";if(path&&trailingSlash)path+="/";return(isAbsolute?"/":"")+path},dirname:function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir)return".";if(dir)dir=dir.substr(0,dir.length-1);return root+dir},basename:function(path){if(path==="/")return"/";var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;
return path.substr(lastSlash+1)},extname:function(path){return PATH.splitPath(path)[3]},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))},join2:function(l,r){return PATH.normalize(l+"/"+r)},resolve:function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!=="string")throw new TypeError("Arguments to path.resolve must be strings");else if(!path)continue;
resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=path.charAt(0)==="/"}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter(function(p){return!!p}),!resolvedAbsolute).join("/");return(resolvedAbsolute?"/":"")+resolvedPath||"."},relative:function(from,to){from=PATH.resolve(from).substr(1);to=PATH.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++)if(arr[start]!=="")break;var end=arr.length-1;for(;end>=0;end--)if(arr[end]!=="")break;if(start>end)return[];
return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++)if(fromParts[i]!==toParts[i]){samePartsLength=i;break}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++)outputParts.push("..");outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")}};
var Browser={mainLoop:{scheduler:null,method:"",shouldPause:false,paused:false,queue:[],pause:function(){Browser.mainLoop.shouldPause=true},resume:function(){if(Browser.mainLoop.paused){Browser.mainLoop.paused=false;Browser.mainLoop.scheduler()}Browser.mainLoop.shouldPause=false},updateStatus:function(){if(Module["setStatus"]){var message=Module["statusMessage"]||"Please wait...";var remaining=Browser.mainLoop.remainingBlockers;var expected=Browser.mainLoop.expectedBlockers;if(remaining)if(remaining<
expected)Module["setStatus"](message+" ("+(expected-remaining)+"/"+expected+")");else Module["setStatus"](message);else Module["setStatus"]("")}}},isFullScreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function(){if(!Module["preloadPlugins"])Module["preloadPlugins"]=[];if(Browser.initted||ENVIRONMENT_IS_WORKER)return;Browser.initted=true;try{new Blob;Browser.hasBlobConstructor=true}catch(e){Browser.hasBlobConstructor=false;console.log("warning: no blob constructor, cannot create blobs with mimetypes")}Browser.BlobBuilder=
typeof MozBlobBuilder!="undefined"?MozBlobBuilder:typeof WebKitBlobBuilder!="undefined"?WebKitBlobBuilder:!Browser.hasBlobConstructor?console.log("warning: no BlobBuilder"):null;Browser.URLObject=typeof window!="undefined"?window.URL?window.URL:window.webkitURL:undefined;if(!Module.noImageDecoding&&typeof Browser.URLObject==="undefined"){console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");Module.noImageDecoding=true}var imagePlugin=
{};imagePlugin["canHandle"]=function imagePlugin_canHandle(name){return!Module.noImageDecoding&&/\.(jpg|jpeg|png|bmp)$/i.test(name)};imagePlugin["handle"]=function imagePlugin_handle(byteArray,name,onload,onerror){var b=null;if(Browser.hasBlobConstructor)try{b=new Blob([byteArray],{type:Browser.getMimetype(name)});if(b.size!==byteArray.length)b=new Blob([(new Uint8Array(byteArray)).buffer],{type:Browser.getMimetype(name)})}catch(e){Runtime.warnOnce("Blob constructor present but fails: "+e+"; falling back to blob builder")}if(!b){var bb=
new Browser.BlobBuilder;bb.append((new Uint8Array(byteArray)).buffer);b=bb.getBlob()}var url=Browser.URLObject.createObjectURL(b);var img=new Image;img.onload=function img_onload(){assert(img.complete,"Image "+name+" could not be decoded");var canvas=document.createElement("canvas");canvas.width=img.width;canvas.height=img.height;var ctx=canvas.getContext("2d");ctx.drawImage(img,0,0);Module["preloadedImages"][name]=canvas;Browser.URLObject.revokeObjectURL(url);if(onload)onload(byteArray)};img.onerror=
function img_onerror(event){console.log("Image "+url+" could not be decoded");if(onerror)onerror()};img.src=url};Module["preloadPlugins"].push(imagePlugin);var audioPlugin={};audioPlugin["canHandle"]=function audioPlugin_canHandle(name){return!Module.noAudioDecoding&&name.substr(-4)in{".ogg":1,".wav":1,".mp3":1}};audioPlugin["handle"]=function audioPlugin_handle(byteArray,name,onload,onerror){var done=false;function finish(audio){if(done)return;done=true;Module["preloadedAudios"][name]=audio;if(onload)onload(byteArray)}
function fail(){if(done)return;done=true;Module["preloadedAudios"][name]=new Audio;if(onerror)onerror()}if(Browser.hasBlobConstructor){try{var b=new Blob([byteArray],{type:Browser.getMimetype(name)})}catch(e){return fail()}var url=Browser.URLObject.createObjectURL(b);var audio=new Audio;audio.addEventListener("canplaythrough",function(){finish(audio)},false);audio.onerror=function audio_onerror(event){if(done)return;console.log("warning: browser could not fully decode audio "+name+", trying slower base64 approach");
function encode64(data){var BASE="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var PAD="=";var ret="";var leftchar=0;var leftbits=0;for(var i=0;i<data.length;i++){leftchar=leftchar<<8|data[i];leftbits+=8;while(leftbits>=6){var curr=leftchar>>leftbits-6&63;leftbits-=6;ret+=BASE[curr]}}if(leftbits==2){ret+=BASE[(leftchar&3)<<4];ret+=PAD+PAD}else if(leftbits==4){ret+=BASE[(leftchar&15)<<2];ret+=PAD}return ret}audio.src="data:audio/x-"+name.substr(-3)+";base64,"+encode64(byteArray);
finish(audio)};audio.src=url;Browser.safeSetTimeout(function(){finish(audio)},1E4)}else return fail()};Module["preloadPlugins"].push(audioPlugin);var canvas=Module["canvas"];if(canvas){canvas.requestPointerLock=canvas["requestPointerLock"]||canvas["mozRequestPointerLock"]||canvas["webkitRequestPointerLock"]||canvas["msRequestPointerLock"]||function(){};canvas.exitPointerLock=document["exitPointerLock"]||document["mozExitPointerLock"]||document["webkitExitPointerLock"]||document["msExitPointerLock"]||
function(){};canvas.exitPointerLock=canvas.exitPointerLock.bind(document);function pointerLockChange(){Browser.pointerLock=document["pointerLockElement"]===canvas||document["mozPointerLockElement"]===canvas||document["webkitPointerLockElement"]===canvas||document["msPointerLockElement"]===canvas}document.addEventListener("pointerlockchange",pointerLockChange,false);document.addEventListener("mozpointerlockchange",pointerLockChange,false);document.addEventListener("webkitpointerlockchange",pointerLockChange,
false);document.addEventListener("mspointerlockchange",pointerLockChange,false);if(Module["elementPointerLock"])canvas.addEventListener("click",function(ev){if(!Browser.pointerLock&&canvas.requestPointerLock){canvas.requestPointerLock();ev.preventDefault()}},false)}},createContext:function(canvas,useWebGL,setInModule,webGLContextAttributes){var ctx;var errorInfo="?";function onContextCreationError(event){errorInfo=event.statusMessage||errorInfo}try{if(useWebGL){var contextAttributes={antialias:false,
alpha:false};if(webGLContextAttributes)for(var attribute in webGLContextAttributes)contextAttributes[attribute]=webGLContextAttributes[attribute];canvas.addEventListener("webglcontextcreationerror",onContextCreationError,false);try{["experimental-webgl","webgl"].some(function(webglId){return ctx=canvas.getContext(webglId,contextAttributes)})}finally{canvas.removeEventListener("webglcontextcreationerror",onContextCreationError,false)}}else ctx=canvas.getContext("2d");if(!ctx)throw":(";}catch(e){Module.print("Could not create canvas: "+
[errorInfo,e]);return null}if(useWebGL)canvas.style.backgroundColor="black";if(setInModule){GLctx=Module.ctx=ctx;Module.useWebGL=useWebGL;Browser.moduleContextCreatedCallbacks.forEach(function(callback){callback()});Browser.init()}return ctx},destroyContext:function(canvas,useWebGL,setInModule){},fullScreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullScreen:function(lockPointer,resizeCanvas){Browser.lockPointer=lockPointer;Browser.resizeCanvas=resizeCanvas;if(typeof Browser.lockPointer===
"undefined")Browser.lockPointer=true;if(typeof Browser.resizeCanvas==="undefined")Browser.resizeCanvas=false;var canvas=Module["canvas"];function fullScreenChange(){Browser.isFullScreen=false;var canvasContainer=canvas.parentNode;if((document["webkitFullScreenElement"]||document["webkitFullscreenElement"]||document["mozFullScreenElement"]||document["mozFullscreenElement"]||document["fullScreenElement"]||document["fullscreenElement"]||document["msFullScreenElement"]||document["msFullscreenElement"]||
document["webkitCurrentFullScreenElement"])===canvasContainer){canvas.cancelFullScreen=document["cancelFullScreen"]||document["mozCancelFullScreen"]||document["webkitCancelFullScreen"]||document["msExitFullscreen"]||document["exitFullscreen"]||function(){};canvas.cancelFullScreen=canvas.cancelFullScreen.bind(document);if(Browser.lockPointer)canvas.requestPointerLock();Browser.isFullScreen=true;if(Browser.resizeCanvas)Browser.setFullScreenCanvasSize()}else{canvasContainer.parentNode.insertBefore(canvas,
canvasContainer);canvasContainer.parentNode.removeChild(canvasContainer);if(Browser.resizeCanvas)Browser.setWindowedCanvasSize()}if(Module["onFullScreen"])Module["onFullScreen"](Browser.isFullScreen);Browser.updateCanvasDimensions(canvas)}if(!Browser.fullScreenHandlersInstalled){Browser.fullScreenHandlersInstalled=true;document.addEventListener("fullscreenchange",fullScreenChange,false);document.addEventListener("mozfullscreenchange",fullScreenChange,false);document.addEventListener("webkitfullscreenchange",
fullScreenChange,false);document.addEventListener("MSFullscreenChange",fullScreenChange,false)}var canvasContainer=document.createElement("div");canvas.parentNode.insertBefore(canvasContainer,canvas);canvasContainer.appendChild(canvas);canvasContainer.requestFullScreen=canvasContainer["requestFullScreen"]||canvasContainer["mozRequestFullScreen"]||canvasContainer["msRequestFullscreen"]||(canvasContainer["webkitRequestFullScreen"]?function(){canvasContainer["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"])}:
null);canvasContainer.requestFullScreen()},requestAnimationFrame:function requestAnimationFrame(func){if(typeof window==="undefined")setTimeout(func,1E3/60);else{if(!window.requestAnimationFrame)window.requestAnimationFrame=window["requestAnimationFrame"]||window["mozRequestAnimationFrame"]||window["webkitRequestAnimationFrame"]||window["msRequestAnimationFrame"]||window["oRequestAnimationFrame"]||window["setTimeout"];window.requestAnimationFrame(func)}},safeCallback:function(func){return function(){if(!ABORT)return func.apply(null,
arguments)}},safeRequestAnimationFrame:function(func){return Browser.requestAnimationFrame(function(){if(!ABORT)func()})},safeSetTimeout:function(func,timeout){Module["noExitRuntime"]=true;return setTimeout(function(){if(!ABORT)func()},timeout)},safeSetInterval:function(func,timeout){Module["noExitRuntime"]=true;return setInterval(function(){if(!ABORT)func()},timeout)},getMimetype:function(name){return{"jpg":"image/jpeg","jpeg":"image/jpeg","png":"image/png","bmp":"image/bmp","ogg":"audio/ogg","wav":"audio/wav",
"mp3":"audio/mpeg"}[name.substr(name.lastIndexOf(".")+1)]},getUserMedia:function(func){if(!window.getUserMedia)window.getUserMedia=navigator["getUserMedia"]||navigator["mozGetUserMedia"];window.getUserMedia(func)},getMovementX:function(event){return event["movementX"]||event["mozMovementX"]||event["webkitMovementX"]||0},getMovementY:function(event){return event["movementY"]||event["mozMovementY"]||event["webkitMovementY"]||0},getMouseWheelDelta:function(event){var delta=0;switch(event.type){case "DOMMouseScroll":delta=
event.detail;break;case "mousewheel":delta=-event.wheelDelta;break;case "wheel":delta=event.deltaY;break;default:throw"unrecognized mouse wheel event: "+event.type;}return Math.max(-1,Math.min(1,delta))},mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function(event){if(Browser.pointerLock){if(event.type!="mousemove"&&"mozMovementX"in event)Browser.mouseMovementX=Browser.mouseMovementY=0;else{Browser.mouseMovementX=Browser.getMovementX(event);Browser.mouseMovementY=
Browser.getMovementY(event)}if(typeof SDL!="undefined"){Browser.mouseX=SDL.mouseX+Browser.mouseMovementX;Browser.mouseY=SDL.mouseY+Browser.mouseMovementY}else{Browser.mouseX+=Browser.mouseMovementX;Browser.mouseY+=Browser.mouseMovementY}}else{var rect=Module["canvas"].getBoundingClientRect();var cw=Module["canvas"].width;var ch=Module["canvas"].height;var scrollX=typeof window.scrollX!=="undefined"?window.scrollX:window.pageXOffset;var scrollY=typeof window.scrollY!=="undefined"?window.scrollY:window.pageYOffset;
if(event.type==="touchstart"||event.type==="touchend"||event.type==="touchmove"){var touch=event.touch;if(touch===undefined)return;var adjustedX=touch.pageX-(scrollX+rect.left);var adjustedY=touch.pageY-(scrollY+rect.top);adjustedX=adjustedX*(cw/rect.width);adjustedY=adjustedY*(ch/rect.height);var coords={x:adjustedX,y:adjustedY};if(event.type==="touchstart"){Browser.lastTouches[touch.identifier]=coords;Browser.touches[touch.identifier]=coords}else if(event.type==="touchend"||event.type==="touchmove"){Browser.lastTouches[touch.identifier]=
Browser.touches[touch.identifier];Browser.touches[touch.identifier]={x:adjustedX,y:adjustedY}}return}var x=event.pageX-(scrollX+rect.left);var y=event.pageY-(scrollY+rect.top);x=x*(cw/rect.width);y=y*(ch/rect.height);Browser.mouseMovementX=x-Browser.mouseX;Browser.mouseMovementY=y-Browser.mouseY;Browser.mouseX=x;Browser.mouseY=y}},xhrLoad:function(url,onload,onerror){var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=function xhr_onload(){if(xhr.status==
200||xhr.status==0&&xhr.response)onload(xhr.response);else onerror()};xhr.onerror=onerror;xhr.send(null)},asyncLoad:function(url,onload,onerror,noRunDep){Browser.xhrLoad(url,function(arrayBuffer){assert(arrayBuffer,'Loading data file "'+url+'" failed (no arrayBuffer).');onload(new Uint8Array(arrayBuffer));if(!noRunDep)removeRunDependency("al "+url)},function(event){if(onerror)onerror();else throw'Loading data file "'+url+'" failed.';});if(!noRunDep)addRunDependency("al "+url)},resizeListeners:[],
updateResizeListeners:function(){var canvas=Module["canvas"];Browser.resizeListeners.forEach(function(listener){listener(canvas.width,canvas.height)})},setCanvasSize:function(width,height,noUpdates){var canvas=Module["canvas"];Browser.updateCanvasDimensions(canvas,width,height);if(!noUpdates)Browser.updateResizeListeners()},windowedWidth:0,windowedHeight:0,setFullScreenCanvasSize:function(){if(typeof SDL!="undefined"){var flags=HEAPU32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2];flags=flags|8388608;HEAP32[SDL.screen+
Runtime.QUANTUM_SIZE*0>>2]=flags}Browser.updateResizeListeners()},setWindowedCanvasSize:function(){if(typeof SDL!="undefined"){var flags=HEAPU32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2];flags=flags&~8388608;HEAP32[SDL.screen+Runtime.QUANTUM_SIZE*0>>2]=flags}Browser.updateResizeListeners()},updateCanvasDimensions:function(canvas,wNative,hNative){if(wNative&&hNative){canvas.widthNative=wNative;canvas.heightNative=hNative}else{wNative=canvas.widthNative;hNative=canvas.heightNative}var w=wNative;var h=hNative;
if(Module["forcedAspectRatio"]&&Module["forcedAspectRatio"]>0)if(w/h<Module["forcedAspectRatio"])w=Math.round(h*Module["forcedAspectRatio"]);else h=Math.round(w/Module["forcedAspectRatio"]);if((document["webkitFullScreenElement"]||document["webkitFullscreenElement"]||document["mozFullScreenElement"]||document["mozFullscreenElement"]||document["fullScreenElement"]||document["fullscreenElement"]||document["msFullScreenElement"]||document["msFullscreenElement"]||document["webkitCurrentFullScreenElement"])===
canvas.parentNode&&typeof screen!="undefined"){var factor=Math.min(screen.width/w,screen.height/h);w=Math.round(w*factor);h=Math.round(h*factor)}if(Browser.resizeCanvas){if(canvas.width!=w)canvas.width=w;if(canvas.height!=h)canvas.height=h;if(typeof canvas.style!="undefined"){canvas.style.removeProperty("width");canvas.style.removeProperty("height")}}else{if(canvas.width!=wNative)canvas.width=wNative;if(canvas.height!=hNative)canvas.height=hNative;if(typeof canvas.style!="undefined")if(w!=wNative||
h!=hNative){canvas.style.setProperty("width",w+"px","important");canvas.style.setProperty("height",h+"px","important")}else{canvas.style.removeProperty("width");canvas.style.removeProperty("height")}}}};function _time(ptr){var ret=Math.floor(Date.now()/1E3);if(ptr)HEAP32[ptr>>2]=ret;return ret}
function _sysconf(name){switch(name){case 30:return PAGE_SIZE;case 132:case 133:case 12:case 137:case 138:case 15:case 235:case 16:case 17:case 18:case 19:case 20:case 149:case 13:case 10:case 236:case 153:case 9:case 21:case 22:case 159:case 154:case 14:case 77:case 78:case 139:case 80:case 81:case 79:case 82:case 68:case 67:case 164:case 11:case 29:case 47:case 48:case 95:case 52:case 51:case 46:return 200809;case 27:case 246:case 127:case 128:case 23:case 24:case 160:case 161:case 181:case 182:case 242:case 183:case 184:case 243:case 244:case 245:case 165:case 178:case 179:case 49:case 50:case 168:case 169:case 175:case 170:case 171:case 172:case 97:case 76:case 32:case 173:case 35:return-1;
case 176:case 177:case 7:case 155:case 8:case 157:case 125:case 126:case 92:case 93:case 129:case 130:case 131:case 94:case 91:return 1;case 74:case 60:case 69:case 70:case 4:return 1024;case 31:case 42:case 72:return 32;case 87:case 26:case 33:return 2147483647;case 34:case 1:return 47839;case 38:case 36:return 99;case 43:case 37:return 2048;case 0:return 2097152;case 3:return 65536;case 28:return 32768;case 44:return 32767;case 75:return 16384;case 39:return 1E3;case 89:return 700;case 71:return 256;
case 40:return 255;case 2:return 100;case 180:return 64;case 25:return 20;case 5:return 16;case 6:return 6;case 73:return 4;case 84:return 1}___setErrNo(ERRNO_CODES.EINVAL);return-1}function _malloc(bytes){var ptr=Runtime.dynamicAlloc(bytes+8);return ptr+8&4294967288}Module["_malloc"]=_malloc;function ___cxa_allocate_exception(size){var ptr=_malloc(size+___cxa_exception_header_size);return ptr+___cxa_exception_header_size}
var __ZTISt9exception=allocate([allocate([1,0,0,0,0,0,0],"i8",ALLOC_STATIC)+8,0],"i32",ALLOC_STATIC);___errno_state=Runtime.staticAlloc(4);HEAP32[___errno_state>>2]=0;Module["requestFullScreen"]=function Module_requestFullScreen(lockPointer,resizeCanvas){Browser.requestFullScreen(lockPointer,resizeCanvas)};Module["requestAnimationFrame"]=function Module_requestAnimationFrame(func){Browser.requestAnimationFrame(func)};
Module["setCanvasSize"]=function Module_setCanvasSize(width,height,noUpdates){Browser.setCanvasSize(width,height,noUpdates)};Module["pauseMainLoop"]=function Module_pauseMainLoop(){Browser.mainLoop.pause()};Module["resumeMainLoop"]=function Module_resumeMainLoop(){Browser.mainLoop.resume()};Module["getUserMedia"]=function Module_getUserMedia(){Browser.getUserMedia()};FS.staticInit();__ATINIT__.unshift({func:function(){if(!Module["noFSInit"]&&!FS.init.initialized)FS.init()}});
__ATMAIN__.push({func:function(){FS.ignorePermissions=false}});__ATEXIT__.push({func:function(){FS.quit()}});Module["FS_createFolder"]=FS.createFolder;Module["FS_createPath"]=FS.createPath;Module["FS_createDataFile"]=FS.createDataFile;Module["FS_createPreloadedFile"]=FS.createPreloadedFile;Module["FS_createLazyFile"]=FS.createLazyFile;Module["FS_createLink"]=FS.createLink;Module["FS_createDevice"]=FS.createDevice;__ATINIT__.unshift({func:function(){TTY.init()}});__ATEXIT__.push({func:function(){TTY.shutdown()}});
TTY.utf8=new Runtime.UTF8Processor;if(ENVIRONMENT_IS_NODE){var fs=require("fs");NODEFS.staticInit()}STACK_BASE=STACKTOP=Runtime.alignMemory(STATICTOP);staticSealed=true;STACK_MAX=STACK_BASE+5242880;DYNAMIC_BASE=DYNAMICTOP=Runtime.alignMemory(STACK_MAX);assert(DYNAMIC_BASE<TOTAL_MEMORY,"TOTAL_MEMORY not big enough for stack");
var ctlz_i8=allocate([8,7,6,6,5,5,5,5,4,4,4,4,4,4,4,4,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"i8",ALLOC_DYNAMIC);
var cttz_i8=allocate([8,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,7,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,6,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,5,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0,
4,0,1,0,2,0,1,0,3,0,1,0,2,0,1,0],"i8",ALLOC_DYNAMIC);var Math_min=Math.min;function invoke_diiiiid(index,a1,a2,a3,a4,a5,a6){try{return Module["dynCall_diiiiid"](index,a1,a2,a3,a4,a5,a6)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_ii(index,a1){try{return Module["dynCall_ii"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_viiiii(index,a1,a2,a3,a4,a5){try{Module["dynCall_viiiii"](index,a1,a2,a3,a4,a5)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_did(index,a1,a2){try{return Module["dynCall_did"](index,a1,a2)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_vi(index,a1){try{Module["dynCall_vi"](index,a1)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_diiiid(index,a1,a2,a3,a4,a5){try{return Module["dynCall_diiiid"](index,a1,a2,a3,a4,a5)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_vii(index,a1,a2){try{Module["dynCall_vii"](index,a1,a2)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_iiii(index,a1,a2,a3){try{return Module["dynCall_iiii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_viii(index,a1,a2,a3){try{Module["dynCall_viii"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_v(index){try{Module["dynCall_v"](index)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_viid(index,a1,a2,a3){try{Module["dynCall_viid"](index,a1,a2,a3)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_iiiii(index,a1,a2,a3,a4){try{return Module["dynCall_iiiii"](index,a1,a2,a3,a4)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){try{Module["dynCall_viiiiii"](index,a1,a2,a3,a4,a5,a6)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_iii(index,a1,a2){try{return Module["dynCall_iii"](index,a1,a2)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function invoke_iiiiii(index,a1,a2,a3,a4,a5){try{return Module["dynCall_iiiiii"](index,a1,a2,a3,a4,a5)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}
function invoke_viiii(index,a1,a2,a3,a4){try{Module["dynCall_viiii"](index,a1,a2,a3,a4)}catch(e){if(typeof e!=="number"&&e!=="longjmp")throw e;asm["setThrew"](1,0)}}function asmPrintInt(x,y){Module.print("int "+x+","+y)}function asmPrintFloat(x,y){Module.print("float "+x+","+y)}
var asm=function(global,env,buffer){"use asm";var a=new global.Int8Array(buffer);var b=new global.Int16Array(buffer);var c=new global.Int32Array(buffer);var d=new global.Uint8Array(buffer);var e=new global.Uint16Array(buffer);var f=new global.Uint32Array(buffer);var g=new global.Float32Array(buffer);var h=new global.Float64Array(buffer);var i=env.STACKTOP|0;var j=env.STACK_MAX|0;var k=env.tempDoublePtr|0;var l=env.ABORT|0;var m=env.cttz_i8|0;var n=env.ctlz_i8|0;var o=env.__ZTISt9exception|0;var p=
0;var q=0;var r=0;var s=0;var t=+env.NaN,u=+env.Infinity;var v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0;var E=0;var F=0;var G=0;var H=0;var I=0;var J=0;var K=0;var L=0;var M=0;var N=0;var O=global.Math.floor;var P=global.Math.abs;var Q=global.Math.sqrt;var R=global.Math.pow;var S=global.Math.cos;var T=global.Math.sin;var U=global.Math.tan;var V=global.Math.acos;var W=global.Math.asin;var X=global.Math.atan;var Y=global.Math.atan2;var Z=global.Math.exp;var _=global.Math.log;var $=global.Math.ceil;var aa=
global.Math.imul;var ba=env.abort;var ca=env.assert;var da=env.asmPrintInt;var ea=env.asmPrintFloat;var fa=env.min;var ga=env.invoke_diiiiid;var ha=env.invoke_ii;var ia=env.invoke_viiiii;var ja=env.invoke_did;var ka=env.invoke_vi;var la=env.invoke_diiiid;var ma=env.invoke_vii;var na=env.invoke_iiii;var oa=env.invoke_viii;var pa=env.invoke_v;var qa=env.invoke_viid;var ra=env.invoke_iiiii;var sa=env.invoke_viiiiii;var ta=env.invoke_iii;var ua=env.invoke_iiiiii;var va=env.invoke_viiii;var wa=env._cosf;
var xa=env.__ZSt9terminatev;var ya=env._b2WorldPreSolve;var za=env.___cxa_is_number_type;var Aa=env.___cxa_allocate_exception;var Ba=env.___cxa_find_matching_catch;var Ca=env._fflush;var Da=env._time;var Ea=env.__exit;var Fa=env.___setErrNo;var Ga=env._sbrk;var Ha=env.___cxa_begin_catch;var Ia=env._sinf;var Ja=env.___resumeException;var Ka=env.__ZSt18uncaught_exceptionv;var La=env._b2WorldRayCastCallback;var Ma=env._emscripten_memcpy_big;var Na=env._floorf;var Oa=env._sqrtf;var Pa=env._b2WorldBeginContactBody;
var Qa=env.___errno_location;var Ra=env.__ZNSt9exceptionD2Ev;var Sa=env.___cxa_throw;var Ta=env._sysconf;var Ua=env._abort;var Va=env.___cxa_does_inherit;var Wa=env._b2WorldEndContactBody;var Xa=env._b2WorldQueryAABB;var Ya=env._b2WorldPostSolve;var Za=env._exit;var _a=env.___cxa_pure_virtual;var $a=0;function $k(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;d=i;i=i+64|0;e=d;f=d+16|0;g[e>>2]=3.4028234663852886E38;g[e+4>>2]=3.4028234663852886E38;
h=e+8|0;g[h>>2]=-3.4028234663852886E38;g[e+12>>2]=-3.4028234663852886E38;j=c[a+44>>2]|0;if((j|0)>0){k=c[a+104>>2]|0;l=c[a+96>>2]|0;m=+g[b>>2];n=3.4028234663852886E38;o=3.4028234663852886E38;p=-3.4028234663852886E38;q=-3.4028234663852886E38;r=0;do{s=k+(r<<3)|0;t=+g[s>>2];u=+g[s+4>>2];s=l+(r<<3)|0;v=+g[s>>2];w=+g[s+4>>2];x=v+t*m;t=u*m+w;u=v<x?v:x;y=w<t?w:t;n=n<u?n:u;o=o<y?o:y;y=+n;u=+o;s=e;g[s>>2]=y;g[s+4>>2]=u;u=v>x?v:x;x=w>t?w:t;p=p>u?p:u;q=q>x?q:x;x=+p;u=+q;s=h;g[s>>2]=x;g[s+4>>2]=u;r=r+1|0}while((r|
0)<(j|0))}c[f+4>>2]=a;c[f>>2]=6872;j=f+8|0;c[j+0>>2]=c[b+0>>2];c[j+4>>2]=c[b+4>>2];c[j+8>>2]=c[b+8>>2];c[j+12>>2]=c[b+12>>2];c[j+16>>2]=c[b+16>>2];c[j+20>>2]=c[b+20>>2];c[j+24>>2]=c[b+24>>2];Dj(c[a+400>>2]|0,f,e);i=d;return}function al(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=
0;e=i;i=i+48|0;f=e;h=e+16|0;j=b+44|0;k=c[j>>2]|0;if((k|0)>0){l=c[b+88>>2]|0;m=b+104|0;n=0;do{if((c[l+(n<<2)>>2]&1028|0)==1028){o=c[m>>2]|0;g[o+(n<<3)>>2]=0;g[o+(n<<3)+4>>2]=0}n=n+1|0}while((n|0)<(k|0))}p=+g[d>>2]*2.5;k=b+252|0;if((c[k>>2]|0)<=0){i=e;return}n=b+248|0;m=b+96|0;l=f+8|0;o=b+144|0;q=b+104|0;r=h+16|0;s=h+20|0;t=h+4|0;u=b+32|0;v=b+320|0;w=d+4|0;d=b+88|0;x=b+21|0;y=b+112|0;z=0;do{A=c[n>>2]|0;a:do if((c[A+(z*20|0)+8>>2]&1024|0)!=0){B=c[A+(z*20|0)>>2]|0;C=c[A+(z*20|0)+4>>2]|0;D=c[m>>2]|0;E=
D+(B<<3)|0;F=+g[E>>2];G=+g[E+4>>2];E=D+(C<<3)|0;H=+g[E>>2];I=+g[E+4>>2];J=+(F<H?F:H);K=+(G<I?G:I);E=f;g[E>>2]=J;g[E+4>>2]=K;K=+(F>H?F:H);J=+(G>I?G:I);E=l;g[E>>2]=K;g[E+4>>2]=J;E=c[o>>2]|0;D=c[E+(B<<2)>>2]|0;L=c[E+(C<<2)>>2]|0;if((D|0)!=0?(c[D+12>>2]&2|0)!=0:0){nk(D);J=+g[D+56>>2];M=+g[D+48>>2]-J*(G-+g[D+44>>2]);N=J*(F-+g[D+40>>2])+ +g[D+52>>2]}else{E=(c[q>>2]|0)+(B<<3)|0;J=+g[E>>2];M=J;N=+g[E+4>>2]}if((L|0)!=0?(c[L+12>>2]&2|0)!=0:0){nk(L);J=+g[L+56>>2];O=+g[L+48>>2]-J*(I-+g[L+44>>2]);P=J*(H-+g[L+
40>>2])+ +g[L+52>>2]}else{E=(c[q>>2]|0)+(C<<3)|0;J=+g[E>>2];O=J;P=+g[E+4>>2]}J=H-F;H=I-G;I=O-M;K=P-N;Nk(h,b,f);E=c[r>>2]|0;C=c[s>>2]|0;if(E>>>0<C>>>0){B=c[h>>2]|0;R=c[t>>2]|0;S=E;while(1){E=c[S+4>>2]&1048575;T=S;S=S+8|0;c[r>>2]=S;if(E>>>0<B>>>0|E>>>0>R>>>0)if(S>>>0<C>>>0){S=S;continue}else break;E=c[T>>2]|0;if(!((E|0)>-1))break a;T=(c[m>>2]|0)+(E<<3)|0;U=+g[T>>2];V=+g[T+4>>2];T=c[(c[o>>2]|0)+(E<<2)>>2]|0;b:do if(!((D|0)==(T|0)|(L|0)==(T|0))){W=(T|0)==0;if(!W?(c[T+12>>2]&2|0)!=0:0){nk(T);X=+g[T+56>>
2];Y=+g[T+48>>2]-X*(V-+g[T+44>>2]);Z=X*(U-+g[T+40>>2])+ +g[T+52>>2]}else{_=(c[q>>2]|0)+(E<<3)|0;X=+g[_>>2];Y=X;Z=+g[_+4>>2]}X=U-F;$=V-G;aa=Y-M;ba=Z-N;ca=I*ba-K*aa;da=J*ba-H*aa-(K*X-I*$);ea=J*$-H*X;do if(ca==0){if(da==0)break b;fa=-ea/da;if(!(fa>=0&fa<p))break b;ga=J+I*fa;ha=H+K*fa;ia=(ga*(X+aa*fa)+ha*($+ba*fa))/(ga*ga+ha*ha);if(ia>=0&ia<=1)ja=ia;else break b}else{ia=da*da-ea*4*ca;if(ia<0)break b;ha=+Q(+ia);ia=ca*2;ga=(-da-ha)/ia;fa=(ha-da)/ia;_=ga>fa;ia=_?fa:ga;ha=_?ga:fa;fa=J+I*ia;ga=H+K*ia;ka=(fa*
(X+aa*ia)+ga*($+ba*ia))/(fa*fa+ga*ga);if(ia>=0&ia<p?ka>=0&ka<=1:0){ja=ka;break}if(!(ha>=0&ha<p))break b;ka=J+I*ha;ia=H+K*ha;ga=(ka*(X+aa*ha)+ia*($+ba*ha))/(ka*ka+ia*ia);if(ga>=0&ga<=1)ja=ga;else break b}while(0);ba=M+I*ja-Y;$=N+K*ja-Z;aa=+g[u>>2]*.75;X=aa*+g[v>>2]*aa;aa=ba*X;da=$*X;if(!W?(c[T+12>>2]&2|0)!=0:0){nk(T);X=+g[T+32>>2];nk(T);ca=+g[T+36>>2];if(X>0){ea=1/X;_=T+48|0;g[_>>2]=aa*ea+ +g[_>>2];_=T+52|0;g[_>>2]=da*ea+ +g[_>>2]}if(ca>0){nk(T);_=T+40|0;ea=+g[_>>2];la=T+56|0;g[la>>2]=(da*(U-ea)-aa*
(V-+g[_+4>>2]))/ca+ +g[la>>2]}}else{la=c[q>>2]|0;_=la+(E<<3)|0;g[_>>2]=ba+ +g[_>>2];_=la+(E<<3)+4|0;g[_>>2]=$+ +g[_>>2]}$=-+g[w>>2];ba=aa*$;aa=da*$;if(ba!=0|aa!=0?(c[(c[d>>2]|0)+(E<<2)>>2]&4|0)==0:0){if((a[x>>0]|0)==0){xn(c[y>>2]|0,0,c[j>>2]<<3|0)|0;a[x>>0]=1}_=c[y>>2]|0;la=_+(E<<3)|0;g[la>>2]=ba+ +g[la>>2];la=_+(E<<3)+4|0;g[la>>2]=aa+ +g[la>>2]}}while(0);if(!(S>>>0<C>>>0))break}}}while(0);z=z+1|0}while((z|0)<(c[k>>2]|0));i=e;return}function bl(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,
o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,aa=0,ba=0,ca=0,da=0,ea=0,ga=0;e=i;i=i+48|0;f=e+32|0;h=e+28|0;j=e;k=b+44|0;l=c[k>>2]|0;if((l|0)==0){i=e;return}m=c[b+280>>2]|0;a:do if((m|0)!=0){n=b+296|0;o=n;p=+g[d>>2]/+g[b+396>>2]*4294967296;q=zn(~~p>>>0|0,(+P(p)>=1?p>0?(fa(+O(p/4294967296),4294967295)|0)>>>0:~~+$((p-+(~~p>>>0))/4294967296)>>>0:0)|0,c[o>>2]|0,c[o+4>>2]|0)|0;o=E;r=n;c[r>>2]=q;c[r+4>>2]=o;r=c[b+
288>>2]|0;q=b+304|0;if((a[q>>0]|0)!=0){c[h>>2]=m;sl(r,r+(l<<2)|0,h);a[q>>0]=0}if((l|0)>0){q=b+88|0;n=l;do{n=n+-1|0;s=c[r+(n<<2)>>2]|0;t=c[m+(s<<2)>>2]|0;if((o|0)<(t|0)|(t|0)<1)break a;Ak(b,s,c[(c[q>>2]|0)+(s<<2)>>2]|2)}while((n|0)>0)}}while(0);m=b+8|0;if((c[m>>2]&2|0)!=0)xk(b);l=b+12|0;if((a[l>>0]|0)!=0){c[m>>2]=0;h=c[k>>2]|0;if((h|0)>0){n=c[b+88>>2]|0;q=0;o=0;do{q=c[n+(o<<2)>>2]|q;c[m>>2]=q;o=o+1|0}while((o|0)!=(h|0))}a[l>>0]=0}l=b+20|0;if((a[l>>0]|0)!=0){h=b+16|0;c[h>>2]=0;o=c[b+312>>2]|0;if((o|
0)!=0){q=0;n=o;do{q=c[n+12>>2]|q;c[h>>2]=q;n=c[n+24>>2]|0}while((n|0)!=0)}a[l>>0]=0}if((a[b>>0]|0)!=0){i=e;return}l=b+24|0;c[l>>2]=0;n=d+20|0;if((c[n>>2]|0)<=0){i=e;return}q=b+4|0;h=j+4|0;o=b+116|0;r=b+236|0;s=b+232|0;t=b+220|0;u=b+216|0;v=b+16|0;w=b+21|0;x=b+324|0;y=b+400|0;z=b+104|0;A=b+32|0;B=b+88|0;C=b+96|0;D=b+372|0;F=b+144|0;G=b+132|0;H=b+368|0;I=b+364|0;J=b+36|0;K=b+28|0;L=b+112|0;M=f+4|0;do{c[q>>2]=(c[q>>2]|0)+1;c[j+0>>2]=c[d+0>>2];c[j+4>>2]=c[d+4>>2];c[j+8>>2]=c[d+8>>2];c[j+12>>2]=c[d+12>>
2];c[j+16>>2]=c[d+16>>2];c[j+20>>2]=c[d+20>>2];c[j+24>>2]=c[d+24>>2];p=+(c[n>>2]|0);N=+g[j>>2]/p;g[j>>2]=N;R=+g[h>>2]*p;g[h>>2]=R;Gk(b,0);Yk(b);xn(c[o>>2]|0,0,c[k>>2]<<2|0)|0;S=c[r>>2]|0;if((S|0)>0){T=c[s>>2]|0;U=c[o>>2]|0;V=0;do{W=U+(c[T+(V*28|0)>>2]<<2)|0;g[W>>2]=+g[T+(V*28|0)+12>>2]+ +g[W>>2];V=V+1|0}while((V|0)!=(S|0))}S=c[t>>2]|0;if((S|0)>0){V=c[u>>2]|0;T=c[o>>2]|0;U=0;do{W=c[V+(U*24|0)+4>>2]|0;p=+g[V+(U*24|0)+8>>2];X=T+(c[V+(U*24|0)>>2]<<2)|0;g[X>>2]=p+ +g[X>>2];X=T+(W<<2)|0;g[X>>2]=p+ +g[X>>
2];U=U+1|0}while((U|0)!=(S|0))}if((c[v>>2]&16|0)!=0)Mk(b);S=c[m>>2]|0;if((S&4096|0)==0)Y=S;else{S=c[B>>2]|0;c[f>>2]=7360;c[M>>2]=S;Hk(b,0,c[k>>2]|0,f);if((c[k>>2]|0)>0){S=c[B>>2]|0;U=0;do{T=S+(U<<2)|0;c[T>>2]=c[T>>2]&-4097;U=U+1|0}while((U|0)<(c[k>>2]|0))}U=c[m>>2]&-4097;c[m>>2]=U;Y=U}if((a[w>>0]|0)!=0){p=+g[J>>2]*1.3333333730697632;Z=N*p*+g[K>>2]*p;U=c[k>>2]|0;if((U|0)>0){S=c[z>>2]|0;T=c[L>>2]|0;V=0;do{p=Z*+g[T+(V<<3)+4>>2];X=S+(V<<3)|0;g[X>>2]=Z*+g[T+(V<<3)>>2]+ +g[X>>2];X=S+(V<<3)+4|0;g[X>>2]=
p+ +g[X>>2];V=V+1|0}while((V|0)!=(U|0))}a[w>>0]=0}if((Y&32|0)==0)_=Y;else{cl(b);_=c[m>>2]|0}if((_&8192|0)!=0?(Z=+g[I>>2]*+g[A>>2]*R,U=c[t>>2]|0,(U|0)>0):0){V=c[u>>2]|0;S=0;do{do if((c[V+(S*24|0)+20>>2]&8192|0)!=0){T=c[V+(S*24|0)>>2]|0;X=c[V+(S*24|0)+4>>2]|0;W=c[F>>2]|0;if((c[W+(T<<2)>>2]|0)==(c[W+(X<<2)>>2]|0))break;W=V+(S*24|0)+12|0;N=+g[W>>2];p=Z*+g[V+(S*24|0)+8>>2];aa=p*N;N=p*+g[W+4>>2];W=c[z>>2]|0;ba=W+(T<<3)|0;g[ba>>2]=+g[ba>>2]-aa;ba=W+(T<<3)+4|0;g[ba>>2]=+g[ba>>2]-N;ba=W+(X<<3)|0;g[ba>>2]=
aa+ +g[ba>>2];ba=W+(X<<3)+4|0;g[ba>>2]=N+ +g[ba>>2]}while(0);S=S+1|0}while((S|0)!=(U|0))}if((_&64|0)!=0?(Z=+g[H>>2]*+g[A>>2]*R,U=c[t>>2]|0,(U|0)>0):0){S=c[u>>2]|0;V=0;do{do if((c[S+(V*24|0)+20>>2]&64|0)!=0){N=+g[S+(V*24|0)+8>>2];if(!(N>.25))break;ba=c[S+(V*24|0)>>2]|0;X=c[S+(V*24|0)+4>>2]|0;W=S+(V*24|0)+12|0;aa=+g[W>>2];p=Z*(N+-.25);N=p*aa;aa=p*+g[W+4>>2];W=c[z>>2]|0;T=W+(ba<<3)|0;g[T>>2]=+g[T>>2]-N;T=W+(ba<<3)+4|0;g[T>>2]=+g[T>>2]-aa;T=W+(X<<3)|0;g[T>>2]=N+ +g[T>>2];T=W+(X<<3)+4|0;g[T>>2]=aa+ +g[T>>
2]}while(0);V=V+1|0}while((V|0)!=(U|0))}if((_&128|0)!=0)dl(b,j);if((c[v>>2]&1|0)!=0?(Z=+g[h>>2]*+g[D>>2],U=c[t>>2]|0,(U|0)>0):0){V=c[u>>2]|0;S=c[F>>2]|0;T=0;do{X=c[V+(T*24|0)>>2]|0;W=c[V+(T*24|0)+4>>2]|0;if((c[S+(X<<2)>>2]|0)!=(c[S+(W<<2)>>2]|0)){ba=V+(T*24|0)+12|0;R=+g[ba>>2];ca=c[G>>2]|0;aa=+g[V+(T*24|0)+8>>2]*Z*(+g[ca+(X<<2)>>2]+ +g[ca+(W<<2)>>2]);N=R*aa;R=+g[ba+4>>2]*aa;ba=c[z>>2]|0;ca=ba+(X<<3)|0;g[ca>>2]=+g[ca>>2]-N;ca=ba+(X<<3)+4|0;g[ca>>2]=+g[ca>>2]-R;ca=ba+(W<<3)|0;g[ca>>2]=N+ +g[ca>>2];
ca=ba+(W<<3)+4|0;g[ca>>2]=R+ +g[ca>>2]}T=T+1|0}while((T|0)!=(U|0))}if((c[m>>2]&256|0)!=0)el(b);Z=+g[j>>2]*+g[x>>2];U=(c[y>>2]|0)+102980|0;R=+g[U>>2];N=Z*R;R=Z*+g[U+4>>2];U=c[k>>2]|0;if((U|0)>0){T=c[z>>2]|0;V=0;do{S=T+(V<<3)|0;g[S>>2]=N+ +g[S>>2];S=T+(V<<3)+4|0;g[S>>2]=R+ +g[S>>2];V=V+1|0}while((V|0)!=(U|0))}if((c[m>>2]&2048|0)!=0)fl(b,j);gl(b,j);hl(b,j);U=c[m>>2]|0;if((U&2048|0)==0)da=U;else{il(b);da=c[m>>2]|0}if((da&16|0)==0)ea=da;else{jl(b,j);ea=c[m>>2]|0}if((ea&8|0)!=0)kl(b,j);R=+g[A>>2]*+g[h>>
2];N=R*R;U=c[k>>2]|0;if((U|0)>0){V=c[z>>2]|0;T=0;do{S=V+(T<<3)|0;R=+g[S>>2];ca=V+(T<<3)+4|0;Z=+g[ca>>2];aa=R*R+Z*Z;if(aa>N){p=+Q(+(N/aa));g[S>>2]=R*p;g[ca>>2]=Z*p}T=T+1|0}while((T|0)!=(U|0))}if((c[v>>2]&2|0)!=0)ll(b);if((c[m>>2]&1024|0)!=0)al(b,j);$k(b,j);if((c[v>>2]&2|0)!=0)ml(b,j);U=c[k>>2]|0;do if((c[m>>2]&4|0)==0)ga=95;else{if((U|0)<=0)break;T=c[B>>2]|0;V=0;do{if((c[T+(V<<2)>>2]&4|0)!=0){ca=c[z>>2]|0;g[ca+(V<<3)>>2]=0;g[ca+(V<<3)+4>>2]=0}V=V+1|0}while((V|0)!=(U|0));ga=95}while(0);do if((ga|0)==
95){ga=0;if((U|0)<=0)break;V=c[C>>2]|0;N=+g[j>>2];T=c[z>>2]|0;ca=0;do{p=N*+g[T+(ca<<3)+4>>2];S=V+(ca<<3)|0;g[S>>2]=N*+g[T+(ca<<3)>>2]+ +g[S>>2];S=V+(ca<<3)+4|0;g[S>>2]=p+ +g[S>>2];ca=ca+1|0}while((ca|0)<(U|0))}while(0);U=(c[l>>2]|0)+1|0;c[l>>2]=U}while((U|0)<(c[n>>2]|0));i=e;return}function cl(a){a=a|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;d=i;e=+g[a+352>>2];f=c[a+236>>2]|0;if((f|0)>0){h=a+96|0;j=a+104|0;k=a+36|0;l=
a+28|0;m=c[a+232>>2]|0;n=c[a+88>>2]|0;o=0;do{p=c[m+(o*28|0)>>2]|0;if((c[n+(p<<2)>>2]&32|0)!=0?(q=c[m+(o*28|0)+4>>2]|0,r=(c[h>>2]|0)+(p<<3)|0,s=+g[r>>2],t=+g[r+4>>2],r=q+88|0,u=+g[r>>2],v=q+60|0,w=q+64|0,x=q+80|0,y=q+84|0,z=c[j>>2]|0,A=z+(p<<3)|0,B=+g[A>>2],C=z+(p<<3)+4|0,D=+g[C>>2],E=+g[m+(o*28|0)+12>>2]*e*+g[m+(o*28|0)+24>>2],F=E*(+g[x>>2]-u*(t-+g[w>>2])-B),G=E*(u*(s-+g[v>>2])+ +g[y>>2]-D),u=+g[k>>2]*1.3333333730697632,E=u*+g[l>>2]*u,g[A>>2]=B+F*E,g[C>>2]=D+G*E,E=-F,F=-G,(c[q>>2]|0)==2):0){C=q+4|
0;A=b[C>>1]|0;if((A&2)==0?(p=A&65535,(p&2|0)==0):0){z=(p|2)&65535;b[C>>1]=z;g[q+160>>2]=0;H=z}else H=A;if(!((H&2)==0)){G=+g[q+136>>2];g[x>>2]=G*E+ +g[x>>2];g[y>>2]=G*F+ +g[y>>2];g[r>>2]=+g[r>>2]+ +g[q+144>>2]*((s-+g[v>>2])*F-(t-+g[w>>2])*E)}}o=o+1|0}while((o|0)<(f|0))}f=c[a+220>>2]|0;if((f|0)<=0){i=d;return}o=c[a+216>>2]|0;H=a+104|0;a=0;do{if((c[o+(a*24|0)+20>>2]&32|0)!=0){l=c[o+(a*24|0)>>2]|0;k=c[o+(a*24|0)+4>>2]|0;m=c[H>>2]|0;j=m+(k<<3)|0;h=m+(l<<3)|0;E=+g[h>>2];n=m+(k<<3)+4|0;k=m+(l<<3)+4|0;t=
+g[k>>2];F=e*+g[o+(a*24|0)+8>>2];s=F*(+g[j>>2]-E);G=F*(+g[n>>2]-t);g[h>>2]=E+s;g[k>>2]=t+G;g[j>>2]=+g[j>>2]-s;g[n>>2]=+g[n>>2]-G}a=a+1|0}while((a|0)<(f|0));i=d;return}function dl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;d=i;e=a+44|0;if((c[e>>2]|0)>0){f=a+128|0;h=0;do{j=8784;k=c[j+4>>2]|0;l=(c[f>>2]|0)+(h<<3)|0;c[l>>2]=c[j>>2];c[l+4>>2]=k;h=h+1|0}while((h|0)<(c[e>>2]|0))}e=a+216|0;h=c[a+220>>2]|0;f=(h|0)>0;if(f){k=a+128|0;l=c[e>>2]|0;j=0;do{if((c[l+
(j*24|0)+20>>2]&128|0)!=0){m=c[l+(j*24|0)>>2]|0;n=c[l+(j*24|0)+4>>2]|0;o=+g[l+(j*24|0)+8>>2];p=l+(j*24|0)+12|0;q=+g[p>>2];r=o*(1-o);o=r*q;q=r*+g[p+4>>2];p=c[k>>2]|0;s=p+(m<<3)|0;g[s>>2]=+g[s>>2]-o;s=p+(m<<3)+4|0;g[s>>2]=+g[s>>2]-q;s=p+(n<<3)|0;g[s>>2]=o+ +g[s>>2];s=p+(n<<3)+4|0;g[s>>2]=q+ +g[s>>2]}j=j+1|0}while((j|0)<(h|0))}q=+g[a+32>>2]*+g[b+4>>2];o=+g[a+356>>2]*q;r=q*+g[a+360>>2];t=q*.5;if(!f){i=d;return}f=a+116|0;b=a+128|0;j=a+104|0;a=c[e>>2]|0;e=0;do{if((c[a+(e*24|0)+20>>2]&128|0)!=0){k=c[a+(e*
24|0)>>2]|0;l=c[a+(e*24|0)+4>>2]|0;s=a+(e*24|0)+12|0;q=+g[s>>2];u=+g[s+4>>2];s=c[f>>2]|0;n=c[b>>2]|0;v=o*(+g[s+(k<<2)>>2]+ +g[s+(l<<2)>>2]+-2)+r*(q*(+g[n+(l<<3)>>2]-+g[n+(k<<3)>>2])+u*(+g[n+(l<<3)+4>>2]-+g[n+(k<<3)+4>>2]));w=+g[a+(e*24|0)+8>>2]*(v<t?v:t);v=q*w;q=u*w;n=c[j>>2]|0;s=n+(k<<3)|0;g[s>>2]=+g[s>>2]-v;s=n+(k<<3)+4|0;g[s>>2]=+g[s>>2]-q;s=n+(l<<3)|0;g[s>>2]=+g[s>>2]+v;s=n+(l<<3)+4|0;g[s>>2]=+g[s>>2]+q}e=e+1|0}while((e|0)<(h|0));i=d;return}function el(b){b=b|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,
n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;e=i;f=~~(+g[b+388>>2]*128);if((f|0)==0){i=e;return}h=b+220|0;j=c[h>>2]|0;if((j|0)<=0){i=e;return}k=b+216|0;l=b+88|0;m=b+136|0;b=d[8064]|0;n=j;j=0;while(1){o=c[k>>2]|0;p=c[o+(j*24|0)>>2]|0;q=c[o+(j*24|0)+4>>2]|0;o=c[l>>2]|0;if((c[o+(p<<2)>>2]&256&c[o+(q<<2)>>2]|0)==0)r=n;else{o=c[m>>2]|0;s=o+(q<<2)|0;t=o+(p<<2)|0;u=d[t>>0]|0;v=(aa((d[s>>0]|0)-u|0,f)|0)>>b;w=o+(q<<2)+1|0;x=o+(p<<2)+1|0;y=d[x>>0]|0;z=(aa((d[w>>0]|0)-y|0,f)|0)>>b;
A=o+(q<<2)+2|0;B=o+(p<<2)+2|0;C=d[B>>0]|0;D=(aa((d[A>>0]|0)-C|0,f)|0)>>b;E=o+(q<<2)+3|0;q=o+(p<<2)+3|0;p=d[q>>0]|0;o=(aa((d[E>>0]|0)-p|0,f)|0)>>b;a[t>>0]=v+u;a[x>>0]=z+y;a[B>>0]=D+C;a[q>>0]=o+p;a[s>>0]=(d[s>>0]|0)-v;a[w>>0]=(d[w>>0]|0)-z;a[A>>0]=(d[A>>0]|0)-D;a[E>>0]=(d[E>>0]|0)-o;r=c[h>>2]|0}j=j+1|0;if((j|0)>=(r|0))break;else n=r}i=e;return}function fl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;d=i;e=a+120|0;f=c[e>>2]|0;if((f|0)==
0){h=a+48|0;j=c[h>>2]|0;if((j|0)==0){vk(a,256);k=c[h>>2]|0}else k=j;j=Em(c[a+400>>2]|0,k<<2)|0;xn(j|0,0,c[h>>2]<<2|0)|0;l=j}else l=f;c[e>>2]=l;m=+g[a+32>>2]*+g[b+4>>2];n=+g[a+320>>2]*m*m;m=+g[a+376>>2]*n;o=n*.25;n=+g[a+380>>2];b=a+384|0;if((c[b>>2]|0)<=0){i=d;return}l=a+124|0;f=a+44|0;j=a+220|0;h=a+116|0;k=a+88|0;p=a+216|0;a=c[f>>2]|0;q=1;while(1){xn(c[l>>2]|0,0,a<<2|0)|0;r=c[j>>2]|0;if((r|0)>0){s=c[p>>2]|0;t=0;do{if((c[s+(t*24|0)+20>>2]&2048|0)!=0){u=c[s+(t*24|0)>>2]|0;v=c[s+(t*24|0)+4>>2]|0;w=+g[s+
(t*24|0)+8>>2];x=c[e>>2]|0;y=c[l>>2]|0;z=y+(u<<2)|0;g[z>>2]=w*+g[x+(v<<2)>>2]+ +g[z>>2];z=y+(v<<2)|0;g[z>>2]=w*+g[x+(u<<2)>>2]+ +g[z>>2]}t=t+1|0}while((t|0)<(r|0))}r=c[f>>2]|0;if((r|0)>0){t=c[h>>2]|0;s=c[k>>2]|0;z=0;do{w=+g[t+(z<<2)>>2];if((c[s+(z<<2)>>2]&2048|0)==0)g[(c[e>>2]|0)+(z<<2)>>2]=0;else{A=(m*(w+-1)+ +g[(c[l>>2]|0)+(z<<2)>>2])/(n+w);w=A<o?A:o;g[(c[e>>2]|0)+(z<<2)>>2]=w<0?0:w}z=z+1|0}while((z|0)<(r|0))}if((q|0)>=(c[b>>2]|0))break;a=r;q=q+1|0}i=d;return}function gl(a,d){a=a|0;d=d|0;var e=
0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;e=i;f=a+320|0;h=a+32|0;j=+g[h>>2]*+g[d+4>>2];k=+g[f>>2]*j*j;j=+g[a+336>>2]*k;l=k*.25;m=c[a+44>>2]|0;n=(m|0)>0;if(n){o=c[a+116>>2]|0;p=c[a+124>>2]|0;q=0;do{k=+g[o+(q<<2)>>2]+-1;r=j*(k<0?0:k);g[p+(q<<2)>>2]=r<l?r:l;q=q+1|0}while((q|0)<(m|0))}q=c[a+8>>2]|0;if(!((q&192|0)==0|n^1)){p=c[a+88>>2]|0;o=a+124|0;s=0;do{if((c[p+(s<<2)>>2]&192|0)!=0)g[(c[o>>2]|0)+(s<<2)>>2]=0;s=s+1|0}while((s|0)<(m|0))}if(!((q&2048|0)==0|n^1)){n=
c[a+88>>2]|0;q=a+120|0;s=a+124|0;o=0;do{if((c[n+(o<<2)>>2]&2048|0)!=0){p=(c[s>>2]|0)+(o<<2)|0;g[p>>2]=+g[(c[q>>2]|0)+(o<<2)>>2]+ +g[p>>2]}o=o+1|0}while((o|0)<(m|0))}l=+g[d>>2]/(+g[f>>2]*+g[h>>2]);h=c[a+236>>2]|0;if((h|0)>0){f=a+36|0;d=a+28|0;m=c[a+232>>2]|0;o=c[a+96>>2]|0;q=c[a+124>>2]|0;s=c[a+104>>2]|0;n=0;do{p=c[m+(n*28|0)>>2]|0;t=c[m+(n*28|0)+4>>2]|0;r=+g[m+(n*28|0)+12>>2];u=m+(n*28|0)+16|0;k=+g[u>>2];v=+g[u+4>>2];u=o+(p<<3)|0;w=+g[u>>2];x=+g[u+4>>2];y=l*r*+g[m+(n*28|0)+24>>2]*(j*r+ +g[q+(p<<2)>>
2]);r=k*y;k=v*y;y=+g[f>>2]*1.3333333730697632;v=y*+g[d>>2]*y;u=s+(p<<3)|0;g[u>>2]=+g[u>>2]-r*v;u=s+(p<<3)+4|0;g[u>>2]=+g[u>>2]-k*v;if((c[t>>2]|0)==2){u=t+4|0;p=b[u>>1]|0;if((p&2)==0?(z=p&65535,(z&2|0)==0):0){A=(z|2)&65535;b[u>>1]=A;g[t+160>>2]=0;B=A}else B=p;if(!((B&2)==0)){v=+g[t+136>>2];p=t+80|0;g[p>>2]=r*v+ +g[p>>2];p=t+84|0;g[p>>2]=k*v+ +g[p>>2];p=t+88|0;g[p>>2]=+g[p>>2]+ +g[t+144>>2]*(k*(w-+g[t+60>>2])-r*(x-+g[t+64>>2]))}}n=n+1|0}while((n|0)<(h|0))}h=c[a+220>>2]|0;if((h|0)<=0){i=e;return}n=c[a+
216>>2]|0;B=c[a+124>>2]|0;s=c[a+104>>2]|0;a=0;do{d=c[n+(a*24|0)>>2]|0;f=c[n+(a*24|0)+4>>2]|0;q=n+(a*24|0)+12|0;j=+g[q>>2];x=l*+g[n+(a*24|0)+8>>2]*(+g[B+(d<<2)>>2]+ +g[B+(f<<2)>>2]);r=j*x;j=+g[q+4>>2]*x;q=s+(d<<3)|0;g[q>>2]=+g[q>>2]-r;q=s+(d<<3)+4|0;g[q>>2]=+g[q>>2]-j;q=s+(f<<3)|0;g[q>>2]=r+ +g[q>>2];q=s+(f<<3)+4|0;g[q>>2]=j+ +g[q>>2];a=a+1|0}while((a|0)<(h|0));i=e;return}function hl(a,d){a=a|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=
0,E=0,F=0,G=0,H=0,I=0,J=0;e=i;f=+g[a+340>>2];h=1/(+g[a+32>>2]*+g[d+4>>2]);d=c[a+236>>2]|0;if((d|0)>0){j=a+36|0;k=a+28|0;l=c[a+232>>2]|0;m=c[a+96>>2]|0;n=c[a+104>>2]|0;o=0;do{p=c[l+(o*28|0)>>2]|0;q=c[l+(o*28|0)+4>>2]|0;r=l+(o*28|0)+16|0;s=+g[r>>2];t=+g[r+4>>2];r=m+(p<<3)|0;u=+g[r>>2];v=+g[r+4>>2];r=q+88|0;w=+g[r>>2];x=q+60|0;y=q+64|0;z=q+80|0;A=q+84|0;B=n+(p<<3)|0;C=+g[B>>2];D=n+(p<<3)+4|0;E=+g[D>>2];F=s*(+g[z>>2]-w*(v-+g[y>>2])-C)+t*(w*(u-+g[x>>2])+ +g[A>>2]-E);if(F<0?(w=f*+g[l+(o*28|0)+12>>2],G=
h*F,H=G>-.5?-G:.5,G=F*+g[l+(o*28|0)+24>>2]*(w>H?w:H),H=s*G,s=t*G,G=+g[j>>2]*1.3333333730697632,t=G*+g[k>>2]*G,g[B>>2]=C+t*H,g[D>>2]=E+t*s,t=-H,H=-s,(c[q>>2]|0)==2):0){D=q+4|0;B=b[D>>1]|0;if((B&2)==0?(p=B&65535,(p&2|0)==0):0){I=(p|2)&65535;b[D>>1]=I;g[q+160>>2]=0;J=I}else J=B;if(!((J&2)==0)){s=+g[q+136>>2];g[z>>2]=s*t+ +g[z>>2];g[A>>2]=s*H+ +g[A>>2];g[r>>2]=+g[r>>2]+ +g[q+144>>2]*((u-+g[x>>2])*H-(v-+g[y>>2])*t)}}o=o+1|0}while((o|0)<(d|0))}d=c[a+220>>2]|0;if((d|0)<=0){i=e;return}o=c[a+216>>2]|0;J=c[a+
104>>2]|0;a=0;do{k=c[o+(a*24|0)>>2]|0;j=c[o+(a*24|0)+4>>2]|0;l=o+(a*24|0)+12|0;t=+g[l>>2];v=+g[l+4>>2];l=J+(j<<3)|0;n=J+(k<<3)|0;H=+g[n>>2];m=J+(j<<3)+4|0;j=J+(k<<3)+4|0;u=+g[j>>2];s=t*(+g[l>>2]-H)+v*(+g[m>>2]-u);if(s<0){E=f*+g[o+(a*24|0)+8>>2];C=h*s;G=C>-.5?-C:.5;C=s*(E>G?E:G);G=t*C;t=v*C;g[n>>2]=H+G;g[j>>2]=u+t;g[l>>2]=+g[l>>2]-G;g[m>>2]=+g[m>>2]-t}a=a+1|0}while((a|0)<(d|0));i=e;return}function il(a){a=a|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=
0,B=0,C=0,D=0,E=0,F=0;d=i;e=c[a+236>>2]|0;if((e|0)<=0){i=d;return}f=a+96|0;h=a+104|0;j=a+36|0;k=a+28|0;l=c[a+232>>2]|0;m=c[a+88>>2]|0;a=0;do{n=c[l+(a*28|0)>>2]|0;if(((c[m+(n<<2)>>2]&2048|0)!=0?(o=c[l+(a*28|0)+4>>2]|0,p=l+(a*28|0)+16|0,q=+g[p>>2],r=+g[p+4>>2],p=(c[f>>2]|0)+(n<<3)|0,s=+g[p>>2],t=+g[p+4>>2],p=o+88|0,u=+g[p>>2],v=o+60|0,w=o+64|0,x=o+80|0,y=o+84|0,z=c[h>>2]|0,A=z+(n<<3)|0,B=+g[A>>2],C=z+(n<<3)+4|0,D=+g[C>>2],E=q*(+g[x>>2]-u*(t-+g[w>>2])-B)+r*(u*(s-+g[v>>2])+ +g[y>>2]-D),E<0):0)?(u=E*+g[l+
(a*28|0)+24>>2]*.5,E=q*u,q=r*u,u=+g[j>>2]*1.3333333730697632,r=u*+g[k>>2]*u,g[A>>2]=B+E*r,g[C>>2]=D+q*r,r=-E,E=-q,(c[o>>2]|0)==2):0){C=o+4|0;A=b[C>>1]|0;if((A&2)==0?(n=A&65535,(n&2|0)==0):0){z=(n|2)&65535;b[C>>1]=z;g[o+160>>2]=0;F=z}else F=A;if(!((F&2)==0)){q=+g[o+136>>2];g[x>>2]=q*r+ +g[x>>2];g[y>>2]=q*E+ +g[y>>2];g[p>>2]=+g[p>>2]+ +g[o+144>>2]*((s-+g[v>>2])*E-(t-+g[w>>2])*r)}}a=a+1|0}while((a|0)<(e|0));i=d;return}function jl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=
0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0;d=i;e=+g[b+4>>2]*+g[a+344>>2];f=a+268|0;h=c[f>>2]|0;if((h|0)<=0){i=d;return}j=a+264|0;l=a+96|0;m=a+104|0;a=h;h=0;while(1){n=c[j>>2]|0;if((c[n+(h*60|0)+12>>2]&16|0)==0)o=a;else{p=c[n+(h*60|0)>>2]|0;q=c[n+(h*60|0)+4>>2]|0;r=c[n+(h*60|0)+8>>2]|0;s=c[l>>2]|0;t=s+(p<<3)|0;u=+g[t>>2];v=+g[t+4>>2];t=s+(q<<3)|0;w=+g[t>>2];x=+g[t+4>>2];t=s+(r<<3)|0;y=+g[t>>2];s=c[m>>2]|0;z=+g[b>>2];A=s+(p<<3)|0;B=+g[A>>2];C=s+(p<<3)+
4|0;D=+g[C>>2];E=u+z*B;u=v+z*D;p=s+(q<<3)|0;F=s+(q<<3)+4|0;v=w+z*+g[p>>2];w=x+z*+g[F>>2];q=s+(r<<3)|0;G=s+(r<<3)+4|0;x=y+z*+g[q>>2];y=+g[t+4>>2]+z*+g[G>>2];z=(E+v+x)*.3333333432674408;H=(u+w+y)*.3333333432674408;I=E-z;E=u-H;u=v-z;v=w-H;w=x-z;z=y-H;H=+g[n+(h*60|0)+20>>2];y=+g[n+(h*60|0)+24>>2];t=n+(h*60|0)+28|0;x=+g[t>>2];r=n+(h*60|0)+32|0;J=+g[r>>2];s=n+(h*60|0)+36|0;K=+g[s>>2];L=n+(h*60|0)+40|0;M=+g[L>>2];N=H*E-y*I+(x*v-J*u)+(K*z-w*M);O=H*I+y*E+(x*u+J*v)+(w*K+z*M);M=N*N+O*O;K=(c[k>>2]=1597463007-
((g[k>>2]=M,c[k>>2]|0)>>1),+g[k>>2]);J=K*(1.5-K*M*.5*K);K=N*J;N=O*J;J=e*+g[n+(h*60|0)+16>>2];g[A>>2]=B+J*(H*N-y*K-I);g[C>>2]=D+J*(H*K+y*N-E);E=+g[t>>2];y=+g[r>>2];g[p>>2]=+g[p>>2]+J*(E*N-y*K-u);g[F>>2]=+g[F>>2]+J*(E*K+y*N-v);v=+g[s>>2];y=+g[L>>2];g[q>>2]=+g[q>>2]+J*(v*N-y*K-w);g[G>>2]=+g[G>>2]+J*(v*K+y*N-z);o=c[f>>2]|0}h=h+1|0;if((h|0)>=(o|0))break;else a=o}i=d;return}function kl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;d=i;e=+g[b+4>>2]*
+g[a+348>>2];f=c[a+252>>2]|0;if((f|0)<=0){i=d;return}h=a+96|0;j=a+104|0;k=c[a+248>>2]|0;a=0;do{if((c[k+(a*20|0)+8>>2]&8|0)!=0){l=c[k+(a*20|0)>>2]|0;m=c[k+(a*20|0)+4>>2]|0;n=c[h>>2]|0;o=n+(l<<3)|0;p=+g[o>>2];q=+g[o+4>>2];o=n+(m<<3)|0;r=+g[o>>2];n=c[j>>2]|0;s=+g[b>>2];t=n+(l<<3)|0;u=+g[t>>2];v=n+(l<<3)+4|0;w=+g[v>>2];l=n+(m<<3)|0;x=n+(m<<3)+4|0;y=r+s*+g[l>>2]-(p+s*u);p=+g[o+4>>2]+s*+g[x>>2]-(q+s*w);s=+Q(+(y*y+p*p));q=(+g[k+(a*20|0)+16>>2]-s)*e*+g[k+(a*20|0)+12>>2]/s;s=y*q;y=p*q;g[t>>2]=u-s;g[v>>2]=
w-y;g[l>>2]=s+ +g[l>>2];g[x>>2]=y+ +g[x>>2]}a=a+1|0}while((a|0)<(f|0));i=d;return}function ll(a){a=a|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0;d=i;e=+g[a+340>>2];f=a+236|0;if((c[f>>2]|0)>0){h=a+232|0;j=a+144|0;k=a+96|0;l=0;do{m=c[h>>2]|0;n=c[m+(l*28|0)>>2]|0;o=c[(c[j>>2]|0)+(n<<2)>>2]|0;if(((o|0)!=0?(c[o+12>>2]&2|0)!=
0:0)?(p=c[m+(l*28|0)+4>>2]|0,q=m+(l*28|0)+16|0,r=+g[q>>2],s=+g[q+4>>2],t=+g[m+(l*28|0)+12>>2],m=(c[k>>2]|0)+(n<<3)|0,u=+g[m>>2],v=+g[m+4>>2],m=p+88|0,w=+g[m>>2],n=p+60|0,q=p+64|0,x=p+80|0,y=+g[x>>2]-w*(v-+g[q>>2]),z=p+84|0,A=w*(u-+g[n>>2])+ +g[z>>2],nk(o),B=o+56|0,w=+g[B>>2],C=o+48|0,D=o+52|0,E=r*(y-(+g[C>>2]-w*(v-+g[o+44>>2])))+s*(A-(w*(u-+g[o+40>>2])+ +g[D>>2])),E<0):0){nk(o);w=+g[o+32>>2];nk(o);A=+g[o+36>>2];nk(o);F=o+40|0;y=+g[F>>2];if(w>0)G=1/w;else G=0;if(A>0)H=1/A;else H=0;A=s*(u-y)-r*(v-+g[F+
4>>2]);y=+g[p+132>>2];w=+g[p+44>>2];I=+g[p+48>>2];J=y*(w*w+I*I);I=+g[p+140>>2]+J-J;if(y>0)K=1/y;else K=0;if(I>0)L=1/I;else L=0;I=s*(u-+g[n>>2])-r*(v-+g[q>>2]);y=G+A*A*H+K+I*L*I;if(y>0)M=E/y;else M=0;y=e*(t<1?t:1)*M;t=G*y;g[C>>2]=+g[C>>2]+r*t;g[D>>2]=+g[D>>2]+s*t;g[B>>2]=H*A*y+ +g[B>>2];A=-y;y=r*A;r=s*A;if((c[p>>2]|0)==2){B=p+4|0;D=b[B>>1]|0;if((D&2)==0?(C=D&65535,(C&2|0)==0):0){F=(C|2)&65535;b[B>>1]=F;g[p+160>>2]=0;N=F}else N=D;if(!((N&2)==0)){A=+g[p+136>>2];g[x>>2]=y*A+ +g[x>>2];g[z>>2]=r*A+ +g[z>>
2];g[m>>2]=+g[m>>2]+ +g[p+144>>2]*(r*(u-+g[n>>2])-y*(v-+g[q>>2]))}}}l=l+1|0}while((l|0)<(c[f>>2]|0))}f=a+220|0;if((c[f>>2]|0)<=0){i=d;return}l=a+216|0;N=a+144|0;k=a+96|0;j=a+104|0;h=a+88|0;q=a+32|0;n=a+320|0;a=0;do{p=c[l>>2]|0;m=c[p+(a*24|0)>>2]|0;z=c[p+(a*24|0)+4>>2]|0;x=p+(a*24|0)+12|0;H=+g[x>>2];G=+g[x+4>>2];M=+g[p+(a*24|0)+8>>2];p=c[N>>2]|0;x=c[p+(m<<2)>>2]|0;D=c[p+(z<<2)>>2]|0;p=(x|0)==0;if(p)O=0;else O=(c[x+12>>2]&2|0)!=0;F=(D|0)==0;if(F)P=0;else P=(c[D+12>>2]&2|0)!=0;do if((x|0)!=(D|0)&(O|
P)){B=c[k>>2]|0;L=(+g[B+(m<<3)>>2]+ +g[B+(z<<3)>>2])*.5;K=(+g[B+(m<<3)+4>>2]+ +g[B+(z<<3)+4>>2])*.5;if(!F?(c[D+12>>2]&2|0)!=0:0){nk(D);v=+g[D+56>>2];Q=+g[D+48>>2]-v*(K-+g[D+44>>2]);R=v*(L-+g[D+40>>2])+ +g[D+52>>2]}else{B=(c[j>>2]|0)+(z<<3)|0;v=+g[B>>2];Q=v;R=+g[B+4>>2]}if(!p?(c[x+12>>2]&2|0)!=0:0){nk(x);v=+g[x+56>>2];S=+g[x+48>>2]-v*(K-+g[x+44>>2]);T=v*(L-+g[x+40>>2])+ +g[x+52>>2]}else{B=(c[j>>2]|0)+(m<<3)|0;v=+g[B>>2];S=v;T=+g[B+4>>2]}v=G*(R-T)+H*(Q-S);if(v<0){if(O){nk(x);y=+g[x+32>>2];nk(x);u=+g[x+
36>>2];nk(x);B=x+40|0;r=+g[B>>2];if(y>0)U=1/y;else U=0;if(u>0)V=1/u;else V=0;W=V;X=U;Y=G*(L-r)-H*(K-+g[B+4>>2])}else{if((c[(c[h>>2]|0)+(m<<2)>>2]&4|0)==0?(r=+g[q>>2]*.75,u=r*+g[n>>2]*r,u>0):0)Z=1/u;else Z=0;W=0;X=Z;Y=G*(L-L)-H*(K-K)}if(P){nk(D);u=+g[D+32>>2];nk(D);r=+g[D+36>>2];nk(D);B=D+40|0;y=+g[B>>2];if(u>0)_=1/u;else _=0;if(r>0)$=1/r;else $=0;aa=_;ba=$;ca=G*(L-y)-H*(K-+g[B+4>>2])}else{if((c[(c[h>>2]|0)+(z<<2)>>2]&4|0)==0?(y=+g[q>>2]*.75,r=y*+g[n>>2]*y,r>0):0)da=1/r;else da=0;aa=da;ba=0;ca=G*(L-
L)-H*(K-K)}K=X+Y*W*Y+aa+ca*ba*ca;if(K>0)ea=v/K;else ea=0;K=e*M*ea;if(O){v=X*K;B=x+48|0;g[B>>2]=H*v+ +g[B>>2];B=x+52|0;g[B>>2]=G*v+ +g[B>>2];B=x+56|0;g[B>>2]=W*Y*K+ +g[B>>2]}else{B=c[j>>2]|0;v=X*K;C=B+(m<<3)|0;g[C>>2]=H*v+ +g[C>>2];C=B+(m<<3)+4|0;g[C>>2]=G*v+ +g[C>>2]}v=-K;if(P){K=aa*v;C=D+48|0;g[C>>2]=H*K+ +g[C>>2];C=D+52|0;g[C>>2]=G*K+ +g[C>>2];C=D+56|0;g[C>>2]=ba*ca*v+ +g[C>>2];break}else{C=c[j>>2]|0;K=aa*v;B=C+(z<<3)|0;g[B>>2]=H*K+ +g[B>>2];B=C+(z<<3)+4|0;g[B>>2]=G*K+ +g[B>>2];break}}}while(0);
a=a+1|0}while((a|0)<(c[f>>2]|0));i=d;return}function ml(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;d=i;e=c[a+312>>2]|0;if((e|0)==0){i=d;return}f=b+4|0;h=a+104|0;j=a+96|0;a=e;do{if((c[a+12>>2]&2|0)!=0?(nk(a),k=+g[b>>2],l=k*+g[a+56>>2],m=+T(+l),n=+S(+l),l=+g[a+40>>2],o=+g[a+44>>2],p=k*+g[a+48>>2]+l-(n*l-m*o),q=k*+g[a+52>>2]+o-(m*l+n*o),e=a+60|0,o=+g[a+72>>2],l=+g[a+68>>2],k=+(m*o+n*l),r=+(n*o-m*l),l=+g[e>>2],o=+g[a+64>>2],s=+(p+(n*l-m*o)),t=+(q+(m*l+n*o)),
u=e,g[u>>2]=s,g[u+4>>2]=t,u=a+68|0,g[u>>2]=k,g[u+4>>2]=r,r=+g[f>>2],k=p*r,p=q*r,q=m*r,m=(n+-1)*r,u=c[a+4>>2]|0,e=a+8|0,(u|0)<(c[e>>2]|0)):0){v=u;do{u=c[j>>2]|0;r=+g[u+(v<<3)>>2];n=+g[u+(v<<3)+4>>2];t=+(k+(m*r-q*n));s=+(p+(q*r+m*n));u=(c[h>>2]|0)+(v<<3)|0;g[u>>2]=t;g[u+4>>2]=s;v=v+1|0}while((v|0)<(c[e>>2]|0))}a=c[a+24>>2]|0}while((a|0)!=0);i=d;return}function nl(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0;h=i;j=+(e-d|0);k=+g[f>>2]/j;l=+g[f+4>>2]/j;if(!(k!=0|l!=0)){i=h;return}f=b+21|0;if((a[f>>
0]|0)==0){xn(c[b+112>>2]|0,0,c[b+44>>2]<<3|0)|0;a[f>>0]=1}if((d|0)>=(e|0)){i=h;return}f=c[b+112>>2]|0;b=d;do{d=f+(b<<3)|0;g[d>>2]=k+ +g[d>>2];d=f+(b<<3)+4|0;g[d>>2]=l+ +g[d>>2];b=b+1|0}while((b|0)!=(e|0));i=h;return}function ol(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0;f=i;h=+g[a+32>>2]*.75;j=+(d-b|0)*h*+g[a+320>>2]*h;h=+g[e>>2]/j;k=+g[e+4>>2]/j;if((b|0)>=(d|0)){i=f;return}e=c[a+104>>2]|0;a=b;do{b=e+(a<<3)|0;g[b>>2]=h+ +g[b>>2];b=e+(a<<3)+4|0;g[b>>2]=k+ +g[b>>2];a=a+1|0}while((a|0)!=(d|
0));i=f;return}function pl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;e=i;f=c[a+204>>2]|0;if((f|0)==0){i=e;return}h=c[a+200>>2]|0;j=+g[a+36>>2];k=+g[d>>2];l=d+4|0;m=(~~(j*+g[l>>2]+2048)>>>0<<20)+(~~(j*k*256+524288)>>>0)|0;n=h;o=f<<3>>3;a:while(1){p=o;while(1){if((p|0)==0)break a;q=(p|0)/2|0;if((c[n+(q<<3)+4>>2]|0)>>>0<m>>>0)break;else p=q}n=n+(q+1<<3)|0;o=p+-1-q|0}q=d+8|0;o=d+12|0;m=(~~(j*+g[o>>2]+2048)>>>0<<20)+(~~(j*+g[q>>2]*256+524288)>>>0)|0;r=n;s=
h+(f<<3)-n>>3;b:while(1){f=s;while(1){if((f|0)==0)break b;t=(f|0)/2|0;if((c[r+(t<<3)+4>>2]|0)>>>0>m>>>0)f=t;else break}r=r+(t+1<<3)|0;s=f+-1-t|0}if(!(n>>>0<r>>>0)){i=e;return}t=a+96|0;j=k;s=n;while(1){n=c[s>>2]|0;m=c[t>>2]|0;k=+g[m+(n<<3)>>2];if((((j<k?k<+g[q>>2]:0)?(k=+g[m+(n<<3)+4>>2],+g[l>>2]<k):0)?k<+g[o>>2]:0)?!(hb[c[(c[b>>2]|0)+12>>2]&15](b,a,n)|0):0){u=21;break}n=s+8|0;if(!(n>>>0<r>>>0)){u=21;break}j=+g[d>>2];s=n}if((u|0)==21){i=e;return}}function ql(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=
0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0;f=i;i=i+64|0;h=f;j=f+32|0;k=f+24|0;l=f+16|0;if((c[a+204>>2]|0)==0){i=f;return}m=+g[d>>2];n=+g[e>>2];o=d+4|0;p=+g[o>>2];q=+g[e+4>>2];r=+(m<n?m:n);s=+(p<q?p:q);e=h;g[e>>2]=r;g[e+4>>2]=s;s=+(m>n?m:n);r=+(p>q?p:q);e=h+8|0;g[e>>2]=s;g[e+4>>2]=r;r=n-m;m=q-p;p=r*r+m*m;Nk(j,a,h);h=j+16|0;e=c[j+20>>2]|0;t=j+4|0;u=a+96|0;v=a+40|0;w=k+4|0;x=l+4|0;y=c[h>>2]|0;q=1;a:while(1){if(!(y>>>
0<e>>>0)){z=16;break}A=c[j>>2]|0;B=c[t>>2]|0;C=y;while(1){D=c[C+4>>2]&1048575;E=C;C=C+8|0;c[h>>2]=C;if(D>>>0<A>>>0|D>>>0>B>>>0)if(C>>>0<e>>>0){C=C;continue}else{z=16;break a}F=c[E>>2]|0;if(!((F|0)>-1)){z=16;break a}E=c[u>>2]|0;G=+g[d>>2];H=G-+g[E+(F<<3)>>2];I=+g[o>>2];J=I-+g[E+(F<<3)+4>>2];n=r*H+m*J;s=n*n-p*(H*H+J*J-+g[v>>2]);if(s>=0?(K=+Q(+s),s=(-n-K)/p,!(s>q)):0){if(!(s<0)){L=s;break}s=(K-n)/p;if(!(s<0|s>q)){L=s;break}}if(!(C>>>0<e>>>0)){z=16;break a}}s=r*L;n=m*L;K=H+s;M=J+n;g[k>>2]=K;g[w>>2]=M;
N=+Q(+(K*K+M*M));if(!(N<1.1920928955078125E-7)){O=1/N;g[k>>2]=K*O;g[w>>2]=M*O}B=c[(c[b>>2]|0)+12>>2]|0;g[l>>2]=s+G;g[x>>2]=n+I;n=+ab[B&1](b,a,F,l,k,L);q=q<n?q:n;if(q<=0){z=16;break}else y=C}if((z|0)==16){i=f;return}}function rl(b,c,e){b=b|0;c=c|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;f=i;g=((e+-4+(0-c)|0)>>>2)+1|0;h=b;j=c;k=c;while(1){c=d[h>>0]|d[h+1>>0]<<8|d[h+2>>0]<<16|d[h+3>>0]<<24;l=k+1|0;m=a[l>>0]|0;n=k+2|0;o=a[n>>0]|0;p=k+3|0;q=a[p>>0]|0;a[h>>0]=a[k>>
0]|0;a[h+1>>0]=m;a[h+2>>0]=o;a[h+3>>0]=q;a[k>>0]=c;a[l>>0]=c>>>8;a[n>>0]=c>>>16;a[p>>0]=c>>>24;c=h+4|0;p=k+4|0;r=(c|0)==(j|0);if((p|0)==(e|0))break;h=c;j=r?p:j;k=p}k=b+(g<<2)|0;if(r){i=f;return k|0}else{s=k;t=j;u=j}a:while(1){j=s;r=u;while(1){g=d[j>>0]|d[j+1>>0]<<8|d[j+2>>0]<<16|d[j+3>>0]<<24;b=r+1|0;h=a[b>>0]|0;p=r+2|0;c=a[p>>0]|0;n=r+3|0;l=a[n>>0]|0;a[j>>0]=a[r>>0]|0;a[j+1>>0]=h;a[j+2>>0]=c;a[j+3>>0]=l;a[r>>0]=g;a[b>>0]=g>>>8;a[p>>0]=g>>>16;a[n>>0]=g>>>24;j=j+4|0;v=r+4|0;w=(j|0)==(t|0);if((v|0)!=
(e|0))break;if(w)break a;else r=t}s=j;t=w?v:t;u=v}i=f;return k|0}function sl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0;e=i;f=a;a=b;a:while(1){b=a;g=a+-4|0;h=f;b:while(1){j=h;k=b-j|0;l=k>>2;switch(l|0){case 2:m=4;break a;break;case 3:m=6;break a;break;case 5:m=8;break a;break;case 4:m=7;break a;break;case 1:case 0:m=51;break a;break;default:}if((k|
0)<124){m=10;break a}n=(l|0)/2|0;o=h+(n<<2)|0;if((k|0)>3996){k=(l|0)/4|0;p=vl(h,h+(k<<2)|0,o,h+(k+n<<2)|0,g,d)|0}else p=tl(h,o,g,c[d>>2]|0)|0;n=c[h>>2]|0;k=c[d>>2]|0;l=c[k+(n<<2)>>2]|0;q=c[k+(c[o>>2]<<2)>>2]|0;r=+(l|0)<=0;s=+(q|0)<=0;do if(r^s?r:(l|0)>(q|0)){t=g;u=p}else{v=g;while(1){v=v+-4|0;if((h|0)==(v|0))break;w=c[v>>2]|0;x=c[k+(w<<2)>>2]|0;y=+(x|0)<=0;if(y^s?y:(x|0)>(q|0)){m=34;break}}if((m|0)==34){m=0;c[h>>2]=w;c[v>>2]=n;t=v;u=p+1|0;break}x=h+4|0;y=c[g>>2]|0;z=c[k+(y<<2)>>2]|0;if(r^+(z|0)<=
0?r:(l|0)>(z|0))A=x;else{if((x|0)==(g|0)){m=51;break a}else B=x;while(1){C=c[B>>2]|0;x=c[k+(C<<2)>>2]|0;D=B+4|0;if(r^+(x|0)<=0?r:(l|0)>(x|0))break;if((D|0)==(g|0)){m=51;break a}else B=D}c[B>>2]=y;c[g>>2]=C;A=D}if((A|0)==(g|0)){m=51;break a}else{E=A;F=g}while(1){v=c[k+(c[h>>2]<<2)>>2]|0;x=+(v|0)<=0;z=E;while(1){G=c[z>>2]|0;H=c[k+(G<<2)>>2]|0;I=z+4|0;if(x^+(H|0)<=0?x:(v|0)>(H|0)){J=F;break}else z=I}do{J=J+-4|0;K=c[J>>2]|0;H=c[k+(K<<2)>>2]|0}while(x^+(H|0)<=0?x:(v|0)>(H|0));if(!(z>>>0<J>>>0)){h=z;continue b}c[z>>
2]=K;c[J>>2]=G;E=I;F=J}}while(0);l=h+4|0;c:do if(l>>>0<t>>>0){r=l;n=t;q=o;s=u;while(1){y=c[k+(c[q>>2]<<2)>>2]|0;v=+(y|0)<=0;x=r;while(1){L=c[x>>2]|0;H=c[k+(L<<2)>>2]|0;M=+(H|0)<=0;N=x+4|0;if(M^v?M:(H|0)>(y|0))x=N;else{O=n;break}}do{O=O+-4|0;P=c[O>>2]|0;z=c[k+(P<<2)>>2]|0;H=+(z|0)<=0}while(!(H^v?H:(z|0)>(y|0)));if(x>>>0>O>>>0){Q=x;R=q;S=s;break c}c[x>>2]=P;c[O>>2]=L;r=N;n=O;q=(q|0)==(x|0)?O:q;s=s+1|0}}else{Q=l;R=o;S=u}while(0);if((Q|0)!=(R|0)?(o=c[R>>2]|0,l=c[Q>>2]|0,s=c[k+(o<<2)>>2]|0,q=c[k+(l<<2)>>
2]|0,n=+(s|0)<=0,n^+(q|0)<=0?n:(s|0)>(q|0)):0){c[Q>>2]=o;c[R>>2]=l;T=S+1|0}else T=S;if((T|0)==0){U=wl(h,Q,d)|0;l=Q+4|0;if(wl(l,a,d)|0){m=46;break}if(U){h=l;continue}}l=Q;if((l-j|0)>=(b-l|0)){m=50;break}sl(h,Q,d);h=Q+4|0}if((m|0)==46){m=0;if(U){m=51;break}else{f=h;a=Q;continue}}else if((m|0)==50){m=0;sl(Q+4|0,a,d);f=h;a=Q;continue}}if((m|0)==4){Q=c[g>>2]|0;f=c[h>>2]|0;U=c[d>>2]|0;T=c[U+(Q<<2)>>2]|0;S=c[U+(f<<2)>>2]|0;U=+(T|0)<=0;if(!(U^+(S|0)<=0?U:(T|0)>(S|0))){i=e;return}c[h>>2]=Q;c[g>>2]=f;i=e;return}else if((m|
0)==6){tl(h,h+4|0,g,c[d>>2]|0)|0;i=e;return}else if((m|0)==7){ul(h,h+4|0,h+8|0,g,d)|0;i=e;return}else if((m|0)==8){vl(h,h+4|0,h+8|0,h+12|0,g,d)|0;i=e;return}else if((m|0)==10){g=h+8|0;tl(h,h+4|0,g,c[d>>2]|0)|0;f=h+12|0;if((f|0)==(a|0)){i=e;return}Q=c[d>>2]|0;d=f;f=g;while(1){g=c[d>>2]|0;S=c[f>>2]|0;T=Q+(g<<2)|0;U=c[T>>2]|0;R=c[Q+(S<<2)>>2]|0;u=+(U|0)<=0;if(u^+(R|0)<=0?u:(U|0)>(R|0)){R=S;S=d;U=f;while(1){c[S>>2]=R;if((U|0)==(h|0)){V=h;break}u=U+-4|0;R=c[u>>2]|0;O=c[T>>2]|0;N=c[Q+(R<<2)>>2]|0;L=+(O|
0)<=0;if(!(L^+(N|0)<=0?L:(O|0)>(N|0))){V=U;break}else{N=U;U=u;S=N}}c[V>>2]=g}S=d+4|0;if((S|0)==(a|0))break;else{U=d;d=S;f=U}}i=e;return}else if((m|0)==51){i=e;return}}function tl(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;f=i;g=c[b>>2]|0;h=c[a>>2]|0;j=c[e+(g<<2)>>2]|0;k=e+(h<<2)|0;l=c[k>>2]|0;m=+(j|0)<=0;n=c[d>>2]|0;o=c[e+(n<<2)>>2]|0;p=+(o|0)<=0;q=p^m?p:(o|0)>(j|0);if(!(m^+(l|0)<=0?m:(j|0)>(l|0))){if(!q){r=0;i=f;return r|0}c[b>>2]=n;c[d>>2]=g;l=c[b>>2]|0;
j=c[a>>2]|0;m=c[e+(l<<2)>>2]|0;o=c[e+(j<<2)>>2]|0;p=+(m|0)<=0;if(!(p^+(o|0)<=0?p:(m|0)>(o|0))){r=1;i=f;return r|0}c[a>>2]=l;c[b>>2]=j;r=2;i=f;return r|0}if(q){c[a>>2]=n;c[d>>2]=h;r=1;i=f;return r|0}c[a>>2]=g;c[b>>2]=h;g=c[d>>2]|0;a=c[e+(g<<2)>>2]|0;e=c[k>>2]|0;k=+(a|0)<=0;if(!(k^+(e|0)<=0?k:(a|0)>(e|0))){r=1;i=f;return r|0}c[b>>2]=g;c[d>>2]=h;r=2;i=f;return r|0}function ul(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;g=i;h=tl(a,b,d,c[f>>2]|0)|0;j=c[e>>2]|0;k=c[d>>2]|
0;l=c[f>>2]|0;f=c[l+(j<<2)>>2]|0;m=c[l+(k<<2)>>2]|0;n=+(f|0)<=0;if(!(n^+(m|0)<=0?n:(f|0)>(m|0))){o=h;i=g;return o|0}c[d>>2]=j;c[e>>2]=k;k=c[d>>2]|0;e=c[b>>2]|0;j=c[l+(k<<2)>>2]|0;m=c[l+(e<<2)>>2]|0;f=+(j|0)<=0;if(!(f^+(m|0)<=0?f:(j|0)>(m|0))){o=h+1|0;i=g;return o|0}c[b>>2]=k;c[d>>2]=e;e=c[b>>2]|0;d=c[a>>2]|0;k=c[l+(e<<2)>>2]|0;m=c[l+(d<<2)>>2]|0;l=+(k|0)<=0;if(!(l^+(m|0)<=0?l:(k|0)>(m|0))){o=h+2|0;i=g;return o|0}c[a>>2]=e;c[b>>2]=d;o=h+3|0;i=g;return o|0}function vl(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;
e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;h=i;j=ul(a,b,d,e,g)|0;k=c[f>>2]|0;l=c[e>>2]|0;m=c[g>>2]|0;g=c[m+(k<<2)>>2]|0;n=c[m+(l<<2)>>2]|0;o=+(g|0)<=0;if(!(o^+(n|0)<=0?o:(g|0)>(n|0))){p=j;i=h;return p|0}c[e>>2]=k;c[f>>2]=l;l=c[e>>2]|0;f=c[d>>2]|0;k=c[m+(l<<2)>>2]|0;n=c[m+(f<<2)>>2]|0;g=+(k|0)<=0;if(!(g^+(n|0)<=0?g:(k|0)>(n|0))){p=j+1|0;i=h;return p|0}c[d>>2]=l;c[e>>2]=f;f=c[d>>2]|0;e=c[b>>2]|0;l=c[m+(f<<2)>>2]|0;n=c[m+(e<<2)>>2]|0;k=+(l|0)<=0;if(!(k^+(n|0)<=0?k:(l|0)>(n|0))){p=j+2|0;i=
h;return p|0}c[b>>2]=f;c[d>>2]=e;e=c[b>>2]|0;d=c[a>>2]|0;f=c[m+(e<<2)>>2]|0;n=c[m+(d<<2)>>2]|0;m=+(f|0)<=0;if(!(m^+(n|0)<=0?m:(f|0)>(n|0))){p=j+3|0;i=h;return p|0}c[a>>2]=e;c[b>>2]=d;p=j+4|0;i=h;return p|0}function wl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;e=i;switch(b-a>>2|0){case 3:tl(a,a+4|0,b+-4|0,c[d>>2]|0)|0;f=1;i=e;return f|0;case 2:g=b+-4|0;h=c[g>>2]|0;j=c[a>>2]|0;k=c[d>>2]|0;l=c[k+(h<<2)>>2]|0;m=c[k+(j<<2)>>2]|0;k=+(l|0)<=0;if(!(k^
+(m|0)<=0?k:(l|0)>(m|0))){f=1;i=e;return f|0}c[a>>2]=h;c[g>>2]=j;f=1;i=e;return f|0;case 4:ul(a,a+4|0,a+8|0,b+-4|0,d)|0;f=1;i=e;return f|0;case 1:case 0:f=1;i=e;return f|0;case 5:vl(a,a+4|0,a+8|0,a+12|0,b+-4|0,d)|0;f=1;i=e;return f|0;default:j=a+8|0;tl(a,a+4|0,j,c[d>>2]|0)|0;g=a+12|0;if((g|0)==(b|0)){f=1;i=e;return f|0}h=c[d>>2]|0;d=0;m=g;g=j;while(1){j=c[m>>2]|0;l=c[g>>2]|0;k=h+(j<<2)|0;n=c[k>>2]|0;o=c[h+(l<<2)>>2]|0;p=+(n|0)<=0;if(p^+(o|0)<=0?p:(n|0)>(o|0)){o=l;l=m;n=g;while(1){c[l>>2]=o;if((n|
0)==(a|0)){q=a;break}p=n+-4|0;o=c[p>>2]|0;r=c[k>>2]|0;s=c[h+(o<<2)>>2]|0;t=+(r|0)<=0;if(!(t^+(s|0)<=0?t:(r|0)>(s|0))){q=n;break}else{s=n;n=p;l=s}}c[q>>2]=j;l=d+1|0;if((l|0)==8)break;else u=l}else u=d;l=m+4|0;if((l|0)==(b|0)){f=1;v=15;break}else{n=m;d=u;m=l;g=n}}if((v|0)==15){i=e;return f|0}f=(m+4|0)==(b|0);i=e;return f|0}return 0}function xl(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;d=i;i=i+32|0;e=d+16|0;f=d+8|0;h=d;j=a+4|0;k=a+8|0;if((c[b>>2]|0)==(c[j>>2]|0)){l=c[k>>2]|
0;c[a+8>>2]=l+1;if((l|0)>3){l=c[a+12>>2]|0;c[l>>2]=(c[l>>2]|0)+1;m=1;i=d;return m|0}}else{c[k>>2]=0;c[j>>2]=c[b>>2];c[a+8>>2]=1}j=b+16|0;n=+g[j>>2];k=c[a>>2]|0;o=+g[k+32>>2]*(1-+g[b+12>>2]);l=c[b>>2]|0;p=c[k+96>>2]|0;q=+g[j+4>>2]*o+ +g[p+(l<<3)+4>>2];g[e>>2]=+g[p+(l<<3)>>2]+n*o;g[e+4>>2]=q;l=b+8|0;b=c[l>>2]|0;p=c[b+12>>2]|0;if(hb[c[(c[p>>2]|0)+16>>2]&15](p,(c[b+8>>2]|0)+12|0,e)|0){m=0;i=d;return m|0}b=c[(c[l>>2]|0)+12>>2]|0;p=bb[c[(c[b>>2]|0)+12>>2]&7](b)|0;a:do if((p|0)>0){b=0;while(1){j=c[l>>2]|
0;k=c[j+12>>2]|0;mb[c[(c[k>>2]|0)+20>>2]&7](k,(c[j+8>>2]|0)+12|0,e,f,h,b);b=b+1|0;if(+g[f>>2]<.004999999888241291){m=0;break}if((b|0)>=(p|0))break a}i=d;return m|0}while(0);p=c[a+12>>2]|0;c[p>>2]=(c[p>>2]|0)+1;m=1;i=d;return m|0}function yl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;e=i;i=i+32|0;f=e;g=a;a=b;a:while(1){b=a;h=a+-28|0;j=g;b:while(1){k=j;l=b-k|0;switch((l|0)/28|0|0){case 4:m=
14;break a;break;case 3:m=6;break a;break;case 5:m=15;break a;break;case 1:case 0:m=67;break a;break;case 2:m=4;break a;break;default:}if((l|0)<868){m=21;break a}n=(l|0)/56|0;o=j+(n*28|0)|0;do if((l|0)>27972){p=(l|0)/112|0;q=j+(p*28|0)|0;r=j+((p+n|0)*28|0)|0;p=zl(j,q,o,r,d)|0;if(nb[c[d>>2]&31](h,r)|0){c[f+0>>2]=c[r+0>>2];c[f+4>>2]=c[r+4>>2];c[f+8>>2]=c[r+8>>2];c[f+12>>2]=c[r+12>>2];c[f+16>>2]=c[r+16>>2];c[f+20>>2]=c[r+20>>2];c[f+24>>2]=c[r+24>>2];c[r+0>>2]=c[h+0>>2];c[r+4>>2]=c[h+4>>2];c[r+8>>2]=
c[h+8>>2];c[r+12>>2]=c[h+12>>2];c[r+16>>2]=c[h+16>>2];c[r+20>>2]=c[h+20>>2];c[r+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];s=p+1|0;if(nb[c[d>>2]&31](r,o)|0){c[f+0>>2]=c[o+0>>2];c[f+4>>2]=c[o+4>>2];c[f+8>>2]=c[o+8>>2];c[f+12>>2]=c[o+12>>2];c[f+16>>2]=c[o+16>>2];c[f+20>>2]=c[o+20>>2];c[f+24>>2]=c[o+24>>2];c[o+0>>2]=c[r+0>>2];c[o+4>>2]=c[r+4>>2];c[o+8>>2]=c[r+8>>2];c[o+12>>2]=c[r+
12>>2];c[o+16>>2]=c[r+16>>2];c[o+20>>2]=c[r+20>>2];c[o+24>>2]=c[r+24>>2];c[r+0>>2]=c[f+0>>2];c[r+4>>2]=c[f+4>>2];c[r+8>>2]=c[f+8>>2];c[r+12>>2]=c[f+12>>2];c[r+16>>2]=c[f+16>>2];c[r+20>>2]=c[f+20>>2];c[r+24>>2]=c[f+24>>2];r=p+2|0;if(nb[c[d>>2]&31](o,q)|0){c[f+0>>2]=c[q+0>>2];c[f+4>>2]=c[q+4>>2];c[f+8>>2]=c[q+8>>2];c[f+12>>2]=c[q+12>>2];c[f+16>>2]=c[q+16>>2];c[f+20>>2]=c[q+20>>2];c[f+24>>2]=c[q+24>>2];c[q+0>>2]=c[o+0>>2];c[q+4>>2]=c[o+4>>2];c[q+8>>2]=c[o+8>>2];c[q+12>>2]=c[o+12>>2];c[q+16>>2]=c[o+16>>
2];c[q+20>>2]=c[o+20>>2];c[q+24>>2]=c[o+24>>2];c[o+0>>2]=c[f+0>>2];c[o+4>>2]=c[f+4>>2];c[o+8>>2]=c[f+8>>2];c[o+12>>2]=c[f+12>>2];c[o+16>>2]=c[f+16>>2];c[o+20>>2]=c[f+20>>2];c[o+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](q,j)|0){c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[q+0>>2];c[j+4>>2]=c[q+4>>2];c[j+8>>2]=c[q+8>>2];c[j+12>>2]=c[q+12>>2];c[j+16>>2]=c[q+16>>2];c[j+20>>2]=c[q+20>>2];c[j+24>>
2]=c[q+24>>2];c[q+0>>2]=c[f+0>>2];c[q+4>>2]=c[f+4>>2];c[q+8>>2]=c[f+8>>2];c[q+12>>2]=c[f+12>>2];c[q+16>>2]=c[f+16>>2];c[q+20>>2]=c[f+20>>2];c[q+24>>2]=c[f+24>>2];t=p+4|0}else t=p+3|0}else t=r}else t=s}else t=p}else{p=nb[c[d>>2]&31](o,j)|0;s=nb[c[d>>2]&31](h,o)|0;if(!p){if(!s){t=0;break}c[f+0>>2]=c[o+0>>2];c[f+4>>2]=c[o+4>>2];c[f+8>>2]=c[o+8>>2];c[f+12>>2]=c[o+12>>2];c[f+16>>2]=c[o+16>>2];c[f+20>>2]=c[o+20>>2];c[f+24>>2]=c[o+24>>2];c[o+0>>2]=c[h+0>>2];c[o+4>>2]=c[h+4>>2];c[o+8>>2]=c[h+8>>2];c[o+12>>
2]=c[h+12>>2];c[o+16>>2]=c[h+16>>2];c[o+20>>2]=c[h+20>>2];c[o+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](o,j)|0)){t=1;break}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[o+0>>2];c[j+4>>2]=c[o+4>>2];c[j+8>>2]=c[o+8>>2];c[j+12>>2]=c[o+12>>2];c[j+
16>>2]=c[o+16>>2];c[j+20>>2]=c[o+20>>2];c[j+24>>2]=c[o+24>>2];c[o+0>>2]=c[f+0>>2];c[o+4>>2]=c[f+4>>2];c[o+8>>2]=c[f+8>>2];c[o+12>>2]=c[f+12>>2];c[o+16>>2]=c[f+16>>2];c[o+20>>2]=c[f+20>>2];c[o+24>>2]=c[f+24>>2];t=2;break}if(s){c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];c[j+20>>2]=c[h+20>>2];c[j+
24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];t=1;break}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[o+0>>2];c[j+4>>2]=c[o+4>>2];c[j+8>>2]=c[o+8>>2];c[j+12>>2]=c[o+12>>2];c[j+16>>2]=c[o+16>>2];c[j+20>>2]=c[o+20>>2];c[j+24>>2]=c[o+24>>2];c[o+0>>2]=c[f+0>>2];c[o+4>>2]=
c[f+4>>2];c[o+8>>2]=c[f+8>>2];c[o+12>>2]=c[f+12>>2];c[o+16>>2]=c[f+16>>2];c[o+20>>2]=c[f+20>>2];c[o+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](h,o)|0){c[f+0>>2]=c[o+0>>2];c[f+4>>2]=c[o+4>>2];c[f+8>>2]=c[o+8>>2];c[f+12>>2]=c[o+12>>2];c[f+16>>2]=c[o+16>>2];c[f+20>>2]=c[o+20>>2];c[f+24>>2]=c[o+24>>2];c[o+0>>2]=c[h+0>>2];c[o+4>>2]=c[h+4>>2];c[o+8>>2]=c[h+8>>2];c[o+12>>2]=c[h+12>>2];c[o+16>>2]=c[h+16>>2];c[o+20>>2]=c[h+20>>2];c[o+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+
12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];t=2}else t=1}while(0);do if(nb[c[d>>2]&31](j,o)|0){u=h;v=t}else{n=h;while(1){n=n+-28|0;if((j|0)==(n|0))break;if(nb[c[d>>2]&31](n,o)|0){m=50;break}}if((m|0)==50){m=0;c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[n+0>>2];c[j+4>>2]=c[n+4>>2];c[j+8>>2]=c[n+8>>2];c[j+12>>2]=c[n+12>>2];c[j+16>>2]=c[n+16>>2];
c[j+20>>2]=c[n+20>>2];c[j+24>>2]=c[n+24>>2];c[n+0>>2]=c[f+0>>2];c[n+4>>2]=c[f+4>>2];c[n+8>>2]=c[f+8>>2];c[n+12>>2]=c[f+12>>2];c[n+16>>2]=c[f+16>>2];c[n+20>>2]=c[f+20>>2];c[n+24>>2]=c[f+24>>2];u=n;v=t+1|0;break}l=j+28|0;if(nb[c[d>>2]&31](j,h)|0)w=l;else{if((l|0)==(h|0)){m=67;break a}else x=l;while(1){y=x+28|0;if(nb[c[d>>2]&31](j,x)|0)break;if((y|0)==(h|0)){m=67;break a}else x=y}c[f+0>>2]=c[x+0>>2];c[f+4>>2]=c[x+4>>2];c[f+8>>2]=c[x+8>>2];c[f+12>>2]=c[x+12>>2];c[f+16>>2]=c[x+16>>2];c[f+20>>2]=c[x+20>>
2];c[f+24>>2]=c[x+24>>2];c[x+0>>2]=c[h+0>>2];c[x+4>>2]=c[h+4>>2];c[x+8>>2]=c[h+8>>2];c[x+12>>2]=c[h+12>>2];c[x+16>>2]=c[h+16>>2];c[x+20>>2]=c[h+20>>2];c[x+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];w=y}if((w|0)==(h|0)){m=67;break a}else{z=w;A=h}while(1){n=z;while(1){B=n+28|0;if(nb[c[d>>2]&31](j,n)|0){C=A;break}else n=B}do C=C+-28|0;while(nb[c[d>>2]&31](j,C)|0);if(!(n>>>0<C>>>
0)){j=n;continue b}c[f+0>>2]=c[n+0>>2];c[f+4>>2]=c[n+4>>2];c[f+8>>2]=c[n+8>>2];c[f+12>>2]=c[n+12>>2];c[f+16>>2]=c[n+16>>2];c[f+20>>2]=c[n+20>>2];c[f+24>>2]=c[n+24>>2];c[n+0>>2]=c[C+0>>2];c[n+4>>2]=c[C+4>>2];c[n+8>>2]=c[C+8>>2];c[n+12>>2]=c[C+12>>2];c[n+16>>2]=c[C+16>>2];c[n+20>>2]=c[C+20>>2];c[n+24>>2]=c[C+24>>2];c[C+0>>2]=c[f+0>>2];c[C+4>>2]=c[f+4>>2];c[C+8>>2]=c[f+8>>2];c[C+12>>2]=c[f+12>>2];c[C+16>>2]=c[f+16>>2];c[C+20>>2]=c[f+20>>2];c[C+24>>2]=c[f+24>>2];z=B;A=C}}while(0);l=j+28|0;c:do if(l>>>
0<u>>>0){s=l;p=u;r=o;q=v;while(1){D=s;while(1){E=D+28|0;if(nb[c[d>>2]&31](D,r)|0)D=E;else{F=p;break}}do F=F+-28|0;while(!(nb[c[d>>2]&31](F,r)|0));if(D>>>0>F>>>0){G=D;H=r;I=q;break c}c[f+0>>2]=c[D+0>>2];c[f+4>>2]=c[D+4>>2];c[f+8>>2]=c[D+8>>2];c[f+12>>2]=c[D+12>>2];c[f+16>>2]=c[D+16>>2];c[f+20>>2]=c[D+20>>2];c[f+24>>2]=c[D+24>>2];c[D+0>>2]=c[F+0>>2];c[D+4>>2]=c[F+4>>2];c[D+8>>2]=c[F+8>>2];c[D+12>>2]=c[F+12>>2];c[D+16>>2]=c[F+16>>2];c[D+20>>2]=c[F+20>>2];c[D+24>>2]=c[F+24>>2];c[F+0>>2]=c[f+0>>2];c[F+
4>>2]=c[f+4>>2];c[F+8>>2]=c[f+8>>2];c[F+12>>2]=c[f+12>>2];c[F+16>>2]=c[f+16>>2];c[F+20>>2]=c[f+20>>2];c[F+24>>2]=c[f+24>>2];s=E;p=F;r=(r|0)==(D|0)?F:r;q=q+1|0}}else{G=l;H=o;I=v}while(0);if((G|0)!=(H|0)?nb[c[d>>2]&31](H,G)|0:0){c[f+0>>2]=c[G+0>>2];c[f+4>>2]=c[G+4>>2];c[f+8>>2]=c[G+8>>2];c[f+12>>2]=c[G+12>>2];c[f+16>>2]=c[G+16>>2];c[f+20>>2]=c[G+20>>2];c[f+24>>2]=c[G+24>>2];c[G+0>>2]=c[H+0>>2];c[G+4>>2]=c[H+4>>2];c[G+8>>2]=c[H+8>>2];c[G+12>>2]=c[H+12>>2];c[G+16>>2]=c[H+16>>2];c[G+20>>2]=c[H+20>>2];
c[G+24>>2]=c[H+24>>2];c[H+0>>2]=c[f+0>>2];c[H+4>>2]=c[f+4>>2];c[H+8>>2]=c[f+8>>2];c[H+12>>2]=c[f+12>>2];c[H+16>>2]=c[f+16>>2];c[H+20>>2]=c[f+20>>2];c[H+24>>2]=c[f+24>>2];J=I+1|0}else J=I;if((J|0)==0){K=Bl(j,G,d)|0;o=G+28|0;if(Bl(o,a,d)|0){m=62;break}if(K){j=o;continue}}o=G;if((o-k|0)>=(b-o|0)){m=66;break}yl(j,G,d);j=G+28|0}if((m|0)==62){m=0;if(K){m=67;break}else{g=j;a=G;continue}}else if((m|0)==66){m=0;yl(G+28|0,a,d);g=j;a=G;continue}}if((m|0)==4){if(!(nb[c[d>>2]&31](h,j)|0)){i=e;return}c[f+0>>2]=
c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];c[j+20>>2]=c[h+20>>2];c[j+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];i=e;return}else if((m|0)==6){G=j+28|0;g=nb[c[d>>2]&31](G,j)|0;K=nb[c[d>>
2]&31](h,G)|0;if(!g){if(!K){i=e;return}c[f+0>>2]=c[G+0>>2];c[f+4>>2]=c[G+4>>2];c[f+8>>2]=c[G+8>>2];c[f+12>>2]=c[G+12>>2];c[f+16>>2]=c[G+16>>2];c[f+20>>2]=c[G+20>>2];c[f+24>>2]=c[G+24>>2];c[G+0>>2]=c[h+0>>2];c[G+4>>2]=c[h+4>>2];c[G+8>>2]=c[h+8>>2];c[G+12>>2]=c[h+12>>2];c[G+16>>2]=c[h+16>>2];c[G+20>>2]=c[h+20>>2];c[G+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](G,
j)|0)){i=e;return}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[G+0>>2];c[j+4>>2]=c[G+4>>2];c[j+8>>2]=c[G+8>>2];c[j+12>>2]=c[G+12>>2];c[j+16>>2]=c[G+16>>2];c[j+20>>2]=c[G+20>>2];c[j+24>>2]=c[G+24>>2];c[G+0>>2]=c[f+0>>2];c[G+4>>2]=c[f+4>>2];c[G+8>>2]=c[f+8>>2];c[G+12>>2]=c[f+12>>2];c[G+16>>2]=c[f+16>>2];c[G+20>>2]=c[f+20>>2];c[G+24>>2]=c[f+24>>2];i=e;return}if(K){c[f+0>>2]=c[j+0>>2];c[f+
4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];c[j+20>>2]=c[h+20>>2];c[j+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];i=e;return}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=
c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[G+0>>2];c[j+4>>2]=c[G+4>>2];c[j+8>>2]=c[G+8>>2];c[j+12>>2]=c[G+12>>2];c[j+16>>2]=c[G+16>>2];c[j+20>>2]=c[G+20>>2];c[j+24>>2]=c[G+24>>2];c[G+0>>2]=c[f+0>>2];c[G+4>>2]=c[f+4>>2];c[G+8>>2]=c[f+8>>2];c[G+12>>2]=c[f+12>>2];c[G+16>>2]=c[f+16>>2];c[G+20>>2]=c[f+20>>2];c[G+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](h,G)|0)){i=e;return}c[f+0>>2]=c[G+0>>2];c[f+4>>2]=c[G+4>>2];c[f+8>>2]=c[G+8>>2];c[f+12>>2]=c[G+12>>2];c[f+16>>
2]=c[G+16>>2];c[f+20>>2]=c[G+20>>2];c[f+24>>2]=c[G+24>>2];c[G+0>>2]=c[h+0>>2];c[G+4>>2]=c[h+4>>2];c[G+8>>2]=c[h+8>>2];c[G+12>>2]=c[h+12>>2];c[G+16>>2]=c[h+16>>2];c[G+20>>2]=c[h+20>>2];c[G+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];i=e;return}else if((m|0)==14){zl(j,j+28|0,j+56|0,h,d)|0;i=e;return}else if((m|0)==15){G=j+28|0;K=j+56|0;g=j+84|0;zl(j,G,K,g,d)|0;if(!(nb[c[d>>2]&31](h,
g)|0)){i=e;return}c[f+0>>2]=c[g+0>>2];c[f+4>>2]=c[g+4>>2];c[f+8>>2]=c[g+8>>2];c[f+12>>2]=c[g+12>>2];c[f+16>>2]=c[g+16>>2];c[f+20>>2]=c[g+20>>2];c[f+24>>2]=c[g+24>>2];c[g+0>>2]=c[h+0>>2];c[g+4>>2]=c[h+4>>2];c[g+8>>2]=c[h+8>>2];c[g+12>>2]=c[h+12>>2];c[g+16>>2]=c[h+16>>2];c[g+20>>2]=c[h+20>>2];c[g+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](g,K)|0)){i=e;return}c[f+
0>>2]=c[K+0>>2];c[f+4>>2]=c[K+4>>2];c[f+8>>2]=c[K+8>>2];c[f+12>>2]=c[K+12>>2];c[f+16>>2]=c[K+16>>2];c[f+20>>2]=c[K+20>>2];c[f+24>>2]=c[K+24>>2];c[K+0>>2]=c[g+0>>2];c[K+4>>2]=c[g+4>>2];c[K+8>>2]=c[g+8>>2];c[K+12>>2]=c[g+12>>2];c[K+16>>2]=c[g+16>>2];c[K+20>>2]=c[g+20>>2];c[K+24>>2]=c[g+24>>2];c[g+0>>2]=c[f+0>>2];c[g+4>>2]=c[f+4>>2];c[g+8>>2]=c[f+8>>2];c[g+12>>2]=c[f+12>>2];c[g+16>>2]=c[f+16>>2];c[g+20>>2]=c[f+20>>2];c[g+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](K,G)|0)){i=e;return}c[f+0>>2]=c[G+0>>2];c[f+
4>>2]=c[G+4>>2];c[f+8>>2]=c[G+8>>2];c[f+12>>2]=c[G+12>>2];c[f+16>>2]=c[G+16>>2];c[f+20>>2]=c[G+20>>2];c[f+24>>2]=c[G+24>>2];c[G+0>>2]=c[K+0>>2];c[G+4>>2]=c[K+4>>2];c[G+8>>2]=c[K+8>>2];c[G+12>>2]=c[K+12>>2];c[G+16>>2]=c[K+16>>2];c[G+20>>2]=c[K+20>>2];c[G+24>>2]=c[K+24>>2];c[K+0>>2]=c[f+0>>2];c[K+4>>2]=c[f+4>>2];c[K+8>>2]=c[f+8>>2];c[K+12>>2]=c[f+12>>2];c[K+16>>2]=c[f+16>>2];c[K+20>>2]=c[f+20>>2];c[K+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](G,j)|0)){i=e;return}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+
8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[G+0>>2];c[j+4>>2]=c[G+4>>2];c[j+8>>2]=c[G+8>>2];c[j+12>>2]=c[G+12>>2];c[j+16>>2]=c[G+16>>2];c[j+20>>2]=c[G+20>>2];c[j+24>>2]=c[G+24>>2];c[G+0>>2]=c[f+0>>2];c[G+4>>2]=c[f+4>>2];c[G+8>>2]=c[f+8>>2];c[G+12>>2]=c[f+12>>2];c[G+16>>2]=c[f+16>>2];c[G+20>>2]=c[f+20>>2];c[G+24>>2]=c[f+24>>2];i=e;return}else if((m|0)==21){Al(j,a,d);i=e;return}else if((m|0)==67){i=e;return}}function zl(a,b,d,e,
f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0;g=i;i=i+32|0;h=g;j=nb[c[f>>2]&31](b,a)|0;k=nb[c[f>>2]&31](d,b)|0;do if(j){if(k){c[h+0>>2]=c[a+0>>2];c[h+4>>2]=c[a+4>>2];c[h+8>>2]=c[a+8>>2];c[h+12>>2]=c[a+12>>2];c[h+16>>2]=c[a+16>>2];c[h+20>>2]=c[a+20>>2];c[h+24>>2]=c[a+24>>2];c[a+0>>2]=c[d+0>>2];c[a+4>>2]=c[d+4>>2];c[a+8>>2]=c[d+8>>2];c[a+12>>2]=c[d+12>>2];c[a+16>>2]=c[d+16>>2];c[a+20>>2]=c[d+20>>2];c[a+24>>2]=c[d+24>>2];c[d+0>>2]=c[h+0>>2];c[d+4>>2]=c[h+4>>2];c[d+8>>2]=c[h+8>>2];c[d+
12>>2]=c[h+12>>2];c[d+16>>2]=c[h+16>>2];c[d+20>>2]=c[h+20>>2];c[d+24>>2]=c[h+24>>2];l=1;break}c[h+0>>2]=c[a+0>>2];c[h+4>>2]=c[a+4>>2];c[h+8>>2]=c[a+8>>2];c[h+12>>2]=c[a+12>>2];c[h+16>>2]=c[a+16>>2];c[h+20>>2]=c[a+20>>2];c[h+24>>2]=c[a+24>>2];c[a+0>>2]=c[b+0>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[a+16>>2]=c[b+16>>2];c[a+20>>2]=c[b+20>>2];c[a+24>>2]=c[b+24>>2];c[b+0>>2]=c[h+0>>2];c[b+4>>2]=c[h+4>>2];c[b+8>>2]=c[h+8>>2];c[b+12>>2]=c[h+12>>2];c[b+16>>2]=c[h+16>>2];c[b+20>>
2]=c[h+20>>2];c[b+24>>2]=c[h+24>>2];if(nb[c[f>>2]&31](d,b)|0){c[h+0>>2]=c[b+0>>2];c[h+4>>2]=c[b+4>>2];c[h+8>>2]=c[b+8>>2];c[h+12>>2]=c[b+12>>2];c[h+16>>2]=c[b+16>>2];c[h+20>>2]=c[b+20>>2];c[h+24>>2]=c[b+24>>2];c[b+0>>2]=c[d+0>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[d+0>>2]=c[h+0>>2];c[d+4>>2]=c[h+4>>2];c[d+8>>2]=c[h+8>>2];c[d+12>>2]=c[h+12>>2];c[d+16>>2]=c[h+16>>2];c[d+20>>2]=c[h+20>>2];c[d+24>>2]=c[h+24>>
2];l=2}else l=1}else if(k){c[h+0>>2]=c[b+0>>2];c[h+4>>2]=c[b+4>>2];c[h+8>>2]=c[b+8>>2];c[h+12>>2]=c[b+12>>2];c[h+16>>2]=c[b+16>>2];c[h+20>>2]=c[b+20>>2];c[h+24>>2]=c[b+24>>2];c[b+0>>2]=c[d+0>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[d+0>>2]=c[h+0>>2];c[d+4>>2]=c[h+4>>2];c[d+8>>2]=c[h+8>>2];c[d+12>>2]=c[h+12>>2];c[d+16>>2]=c[h+16>>2];c[d+20>>2]=c[h+20>>2];c[d+24>>2]=c[h+24>>2];if(nb[c[f>>2]&31](b,a)|0){c[h+
0>>2]=c[a+0>>2];c[h+4>>2]=c[a+4>>2];c[h+8>>2]=c[a+8>>2];c[h+12>>2]=c[a+12>>2];c[h+16>>2]=c[a+16>>2];c[h+20>>2]=c[a+20>>2];c[h+24>>2]=c[a+24>>2];c[a+0>>2]=c[b+0>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[a+16>>2]=c[b+16>>2];c[a+20>>2]=c[b+20>>2];c[a+24>>2]=c[b+24>>2];c[b+0>>2]=c[h+0>>2];c[b+4>>2]=c[h+4>>2];c[b+8>>2]=c[h+8>>2];c[b+12>>2]=c[h+12>>2];c[b+16>>2]=c[h+16>>2];c[b+20>>2]=c[h+20>>2];c[b+24>>2]=c[h+24>>2];l=2}else l=1}else l=0;while(0);if(!(nb[c[f>>2]&31](e,d)|0)){m=
l;i=g;return m|0}c[h+0>>2]=c[d+0>>2];c[h+4>>2]=c[d+4>>2];c[h+8>>2]=c[d+8>>2];c[h+12>>2]=c[d+12>>2];c[h+16>>2]=c[d+16>>2];c[h+20>>2]=c[d+20>>2];c[h+24>>2]=c[d+24>>2];c[d+0>>2]=c[e+0>>2];c[d+4>>2]=c[e+4>>2];c[d+8>>2]=c[e+8>>2];c[d+12>>2]=c[e+12>>2];c[d+16>>2]=c[e+16>>2];c[d+20>>2]=c[e+20>>2];c[d+24>>2]=c[e+24>>2];c[e+0>>2]=c[h+0>>2];c[e+4>>2]=c[h+4>>2];c[e+8>>2]=c[h+8>>2];c[e+12>>2]=c[h+12>>2];c[e+16>>2]=c[h+16>>2];c[e+20>>2]=c[h+20>>2];c[e+24>>2]=c[h+24>>2];if(!(nb[c[f>>2]&31](d,b)|0)){m=l+1|0;i=g;
return m|0}c[h+0>>2]=c[b+0>>2];c[h+4>>2]=c[b+4>>2];c[h+8>>2]=c[b+8>>2];c[h+12>>2]=c[b+12>>2];c[h+16>>2]=c[b+16>>2];c[h+20>>2]=c[b+20>>2];c[h+24>>2]=c[b+24>>2];c[b+0>>2]=c[d+0>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];c[d+0>>2]=c[h+0>>2];c[d+4>>2]=c[h+4>>2];c[d+8>>2]=c[h+8>>2];c[d+12>>2]=c[h+12>>2];c[d+16>>2]=c[h+16>>2];c[d+20>>2]=c[h+20>>2];c[d+24>>2]=c[h+24>>2];if(!(nb[c[f>>2]&31](b,a)|0)){m=l+2|0;i=g;return m|
0}c[h+0>>2]=c[a+0>>2];c[h+4>>2]=c[a+4>>2];c[h+8>>2]=c[a+8>>2];c[h+12>>2]=c[a+12>>2];c[h+16>>2]=c[a+16>>2];c[h+20>>2]=c[a+20>>2];c[h+24>>2]=c[a+24>>2];c[a+0>>2]=c[b+0>>2];c[a+4>>2]=c[b+4>>2];c[a+8>>2]=c[b+8>>2];c[a+12>>2]=c[b+12>>2];c[a+16>>2]=c[b+16>>2];c[a+20>>2]=c[b+20>>2];c[a+24>>2]=c[b+24>>2];c[b+0>>2]=c[h+0>>2];c[b+4>>2]=c[h+4>>2];c[b+8>>2]=c[h+8>>2];c[b+12>>2]=c[h+12>>2];c[b+16>>2]=c[h+16>>2];c[b+20>>2]=c[h+20>>2];c[b+24>>2]=c[h+24>>2];m=l+3|0;i=g;return m|0}function Al(a,b,d){a=a|0;b=b|0;d=
d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;i=i+64|0;f=e+28|0;g=e;h=a+56|0;j=a+28|0;k=nb[c[d>>2]&31](j,a)|0;l=nb[c[d>>2]&31](h,j)|0;do if(k){if(l){c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+4>>2]=c[h+4>>2];c[a+8>>2]=c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];
c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];break}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[j+0>>2];c[a+4>>2]=c[j+4>>2];c[a+8>>2]=c[j+8>>2];c[a+12>>2]=c[j+12>>2];c[a+16>>2]=c[j+16>>2];c[a+20>>2]=c[j+20>>2];c[a+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>
2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](h,j)|0){c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];c[j+20>>2]=c[h+20>>2];c[j+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>
2]}}else if(l){c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];c[j+20>>2]=c[h+20>>2];c[j+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](j,a)|0){c[f+0>>2]=c[a+0>>
2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[j+0>>2];c[a+4>>2]=c[j+4>>2];c[a+8>>2]=c[j+8>>2];c[a+12>>2]=c[j+12>>2];c[a+16>>2]=c[j+16>>2];c[a+20>>2]=c[j+20>>2];c[a+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2]}}while(0);f=a+84|0;if((f|0)==(b|0)){i=e;return}j=f;f=h;while(1){if(nb[c[d>>
2]&31](j,f)|0){c[g+0>>2]=c[j+0>>2];c[g+4>>2]=c[j+4>>2];c[g+8>>2]=c[j+8>>2];c[g+12>>2]=c[j+12>>2];c[g+16>>2]=c[j+16>>2];c[g+20>>2]=c[j+20>>2];c[g+24>>2]=c[j+24>>2];h=j;l=f;while(1){c[h+0>>2]=c[l+0>>2];c[h+4>>2]=c[l+4>>2];c[h+8>>2]=c[l+8>>2];c[h+12>>2]=c[l+12>>2];c[h+16>>2]=c[l+16>>2];c[h+20>>2]=c[l+20>>2];c[h+24>>2]=c[l+24>>2];if((l|0)==(a|0))break;k=l+-28|0;if(nb[c[d>>2]&31](g,k)|0){m=l;l=k;h=m}else break}c[l+0>>2]=c[g+0>>2];c[l+4>>2]=c[g+4>>2];c[l+8>>2]=c[g+8>>2];c[l+12>>2]=c[g+12>>2];c[l+16>>2]=
c[g+16>>2];c[l+20>>2]=c[g+20>>2];c[l+24>>2]=c[g+24>>2]}h=j+28|0;if((h|0)==(b|0))break;else{m=j;j=h;f=m}}i=e;return}function Bl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;e=i;i=i+64|0;f=e+28|0;g=e;switch((b-a|0)/28|0|0){case 5:h=a+28|0;j=a+56|0;k=a+84|0;l=b+-28|0;zl(a,h,j,k,d)|0;if(!(nb[c[d>>2]&31](l,k)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[k+0>>2];c[f+4>>2]=c[k+4>>2];c[f+8>>2]=c[k+8>>2];c[f+12>>2]=c[k+12>>2];c[f+16>>2]=c[k+16>>2];c[f+20>>2]=c[k+20>>2];c[f+24>>2]=c[k+
24>>2];c[k+0>>2]=c[l+0>>2];c[k+4>>2]=c[l+4>>2];c[k+8>>2]=c[l+8>>2];c[k+12>>2]=c[l+12>>2];c[k+16>>2]=c[l+16>>2];c[k+20>>2]=c[l+20>>2];c[k+24>>2]=c[l+24>>2];c[l+0>>2]=c[f+0>>2];c[l+4>>2]=c[f+4>>2];c[l+8>>2]=c[f+8>>2];c[l+12>>2]=c[f+12>>2];c[l+16>>2]=c[f+16>>2];c[l+20>>2]=c[f+20>>2];c[l+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](k,j)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[j+0>>2];c[f+4>>2]=c[j+4>>2];c[f+8>>2]=c[j+8>>2];c[f+12>>2]=c[j+12>>2];c[f+16>>2]=c[j+16>>2];c[f+20>>2]=c[j+20>>2];c[f+24>>2]=c[j+24>>2];c[j+
0>>2]=c[k+0>>2];c[j+4>>2]=c[k+4>>2];c[j+8>>2]=c[k+8>>2];c[j+12>>2]=c[k+12>>2];c[j+16>>2]=c[k+16>>2];c[j+20>>2]=c[k+20>>2];c[j+24>>2]=c[k+24>>2];c[k+0>>2]=c[f+0>>2];c[k+4>>2]=c[f+4>>2];c[k+8>>2]=c[f+8>>2];c[k+12>>2]=c[f+12>>2];c[k+16>>2]=c[f+16>>2];c[k+20>>2]=c[f+20>>2];c[k+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](j,h)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+20>>2];c[f+24>>2]=c[h+24>>2];c[h+0>>2]=c[j+
0>>2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=c[j+8>>2];c[h+12>>2]=c[j+12>>2];c[h+16>>2]=c[j+16>>2];c[h+20>>2]=c[j+20>>2];c[h+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](h,a)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+
4>>2]=c[h+4>>2];c[a+8>>2]=c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];m=1;i=e;return m|0;case 3:h=a+28|0;j=b+-28|0;k=nb[c[d>>2]&31](h,a)|0;l=nb[c[d>>2]&31](j,h)|0;if(!k){if(!l){m=1;i=e;return m|0}c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];
c[f+20>>2]=c[h+20>>2];c[f+24>>2]=c[h+24>>2];c[h+0>>2]=c[j+0>>2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=c[j+8>>2];c[h+12>>2]=c[j+12>>2];c[h+16>>2]=c[j+16>>2];c[h+20>>2]=c[j+20>>2];c[h+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](h,a)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=
c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+4>>2]=c[h+4>>2];c[a+8>>2]=c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];m=1;i=e;return m|0}if(l){c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];
c[a+0>>2]=c[j+0>>2];c[a+4>>2]=c[j+4>>2];c[a+8>>2]=c[j+8>>2];c[a+12>>2]=c[j+12>>2];c[a+16>>2]=c[j+16>>2];c[a+20>>2]=c[j+20>>2];c[a+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];m=1;i=e;return m|0}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+4>>2]=c[h+4>>2];
c[a+8>>2]=c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(!(nb[c[d>>2]&31](j,h)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+20>>2];c[f+24>>2]=c[h+24>>2];c[h+0>>2]=c[j+0>>2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=
c[j+8>>2];c[h+12>>2]=c[j+12>>2];c[h+16>>2]=c[j+16>>2];c[h+20>>2]=c[j+20>>2];c[h+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];m=1;i=e;return m|0;case 1:case 0:m=1;i=e;return m|0;case 4:zl(a,a+28|0,a+56|0,b+-28|0,d)|0;m=1;i=e;return m|0;case 2:j=b+-28|0;if(!(nb[c[d>>2]&31](j,a)|0)){m=1;i=e;return m|0}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];
c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[j+0>>2];c[a+4>>2]=c[j+4>>2];c[a+8>>2]=c[j+8>>2];c[a+12>>2]=c[j+12>>2];c[a+16>>2]=c[j+16>>2];c[a+20>>2]=c[j+20>>2];c[a+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];m=1;i=e;return m|0;default:j=a+56|0;h=a+28|0;l=nb[c[d>>2]&31](h,a)|0;k=nb[c[d>>2]&31](j,h)|0;do if(l){if(k){c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+
4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[j+0>>2];c[a+4>>2]=c[j+4>>2];c[a+8>>2]=c[j+8>>2];c[a+12>>2]=c[j+12>>2];c[a+16>>2]=c[j+16>>2];c[a+20>>2]=c[j+20>>2];c[a+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];break}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+
16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+4>>2]=c[h+4>>2];c[a+8>>2]=c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](j,h)|0){c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+
20>>2];c[f+24>>2]=c[h+24>>2];c[h+0>>2]=c[j+0>>2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=c[j+8>>2];c[h+12>>2]=c[j+12>>2];c[h+16>>2]=c[j+16>>2];c[h+20>>2]=c[j+20>>2];c[h+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2]}}else if(k){c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2];c[f+20>>2]=c[h+20>>2];c[f+24>>2]=c[h+24>>2];c[h+0>>2]=c[j+0>>
2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=c[j+8>>2];c[h+12>>2]=c[j+12>>2];c[h+16>>2]=c[j+16>>2];c[h+20>>2]=c[j+20>>2];c[h+24>>2]=c[j+24>>2];c[j+0>>2]=c[f+0>>2];c[j+4>>2]=c[f+4>>2];c[j+8>>2]=c[f+8>>2];c[j+12>>2]=c[f+12>>2];c[j+16>>2]=c[f+16>>2];c[j+20>>2]=c[f+20>>2];c[j+24>>2]=c[f+24>>2];if(nb[c[d>>2]&31](h,a)|0){c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];c[f+20>>2]=c[a+20>>2];c[f+24>>2]=c[a+24>>2];c[a+0>>2]=c[h+0>>2];c[a+4>>2]=c[h+4>>2];c[a+8>>2]=
c[h+8>>2];c[a+12>>2]=c[h+12>>2];c[a+16>>2]=c[h+16>>2];c[a+20>>2]=c[h+20>>2];c[a+24>>2]=c[h+24>>2];c[h+0>>2]=c[f+0>>2];c[h+4>>2]=c[f+4>>2];c[h+8>>2]=c[f+8>>2];c[h+12>>2]=c[f+12>>2];c[h+16>>2]=c[f+16>>2];c[h+20>>2]=c[f+20>>2];c[h+24>>2]=c[f+24>>2]}}while(0);f=a+84|0;if((f|0)==(b|0)){m=1;i=e;return m|0}h=0;k=f;f=j;while(1){if(nb[c[d>>2]&31](k,f)|0){c[g+0>>2]=c[k+0>>2];c[g+4>>2]=c[k+4>>2];c[g+8>>2]=c[k+8>>2];c[g+12>>2]=c[k+12>>2];c[g+16>>2]=c[k+16>>2];c[g+20>>2]=c[k+20>>2];c[g+24>>2]=c[k+24>>2];j=k;l=
f;while(1){c[j+0>>2]=c[l+0>>2];c[j+4>>2]=c[l+4>>2];c[j+8>>2]=c[l+8>>2];c[j+12>>2]=c[l+12>>2];c[j+16>>2]=c[l+16>>2];c[j+20>>2]=c[l+20>>2];c[j+24>>2]=c[l+24>>2];if((l|0)==(a|0))break;n=l+-28|0;if(nb[c[d>>2]&31](g,n)|0){o=l;l=n;j=o}else break}c[l+0>>2]=c[g+0>>2];c[l+4>>2]=c[g+4>>2];c[l+8>>2]=c[g+8>>2];c[l+12>>2]=c[g+12>>2];c[l+16>>2]=c[g+16>>2];c[l+20>>2]=c[g+20>>2];c[l+24>>2]=c[g+24>>2];j=h+1|0;if((j|0)==8)break;else p=j}else p=h;j=k+28|0;if((j|0)==(b|0)){m=1;q=35;break}else{o=k;h=p;k=j;f=o}}if((q|
0)==35){i=e;return m|0}m=(k+28|0)==(b|0);i=e;return m|0}return 0}function Cl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0;e=i;i=i+16|0;f=e;g=a;a=b;a:while(1){b=a;h=a+-8|0;j=g;b:while(1){k=j;l=b-k|0;m=l>>3;switch(m|0){case 2:n=4;break a;break;case 3:n=6;break a;break;case 4:n=14;break a;break;case 5:n=26;break a;break;case 1:case 0:n=84;break a;break;default:}if((l|
0)<248){n=28;break a}o=(m|0)/2|0;p=j+(o<<3)|0;do if((l|0)<=7992){q=nb[c[d>>2]&31](p,j)|0;r=nb[c[d>>2]&31](h,p)|0;if(!q){if(!r){s=0;break}q=p;t=c[q>>2]|0;u=c[q+4>>2]|0;q=h;v=c[q+4>>2]|0;w=p;c[w>>2]=c[q>>2];c[w+4>>2]=v;v=h;c[v>>2]=t;c[v+4>>2]=u;if(!(nb[c[d>>2]&31](p,j)|0)){s=1;break}u=j;v=c[u>>2]|0;t=c[u+4>>2]|0;u=p;w=c[u+4>>2]|0;q=j;c[q>>2]=c[u>>2];c[q+4>>2]=w;w=p;c[w>>2]=v;c[w+4>>2]=t;s=2;break}t=j;w=c[t>>2]|0;v=c[t+4>>2]|0;if(r){r=h;t=c[r+4>>2]|0;q=j;c[q>>2]=c[r>>2];c[q+4>>2]=t;t=h;c[t>>2]=w;c[t+
4>>2]=v;s=1;break}t=p;q=c[t+4>>2]|0;r=j;c[r>>2]=c[t>>2];c[r+4>>2]=q;q=p;c[q>>2]=w;c[q+4>>2]=v;if(nb[c[d>>2]&31](h,p)|0){v=p;q=c[v>>2]|0;w=c[v+4>>2]|0;v=h;r=c[v+4>>2]|0;t=p;c[t>>2]=c[v>>2];c[t+4>>2]=r;r=h;c[r>>2]=q;c[r+4>>2]=w;s=2}else s=1}else{w=(m|0)/4|0;s=Dl(j,j+(w<<3)|0,p,j+(w+o<<3)|0,h,d)|0}while(0);do if(nb[c[d>>2]&31](j,p)|0){x=h;y=s}else{o=h;while(1){o=o+-8|0;if((j|0)==(o|0))break;if(nb[c[d>>2]&31](o,p)|0){n=67;break}}if((n|0)==67){n=0;m=j;l=c[m>>2]|0;w=c[m+4>>2]|0;m=o;r=c[m+4>>2]|0;q=j;c[q>>
2]=c[m>>2];c[q+4>>2]=r;r=o;c[r>>2]=l;c[r+4>>2]=w;x=o;y=s+1|0;break}w=j+8|0;if(nb[c[d>>2]&31](j,h)|0)z=w;else{if((w|0)==(h|0)){n=84;break a}else A=w;while(1){B=A+8|0;if(nb[c[d>>2]&31](j,A)|0)break;if((B|0)==(h|0)){n=84;break a}else A=B}o=A;w=c[o>>2]|0;r=c[o+4>>2]|0;o=h;l=c[o+4>>2]|0;q=A;c[q>>2]=c[o>>2];c[q+4>>2]=l;l=h;c[l>>2]=w;c[l+4>>2]=r;z=B}if((z|0)==(h|0)){n=84;break a}else{C=z;D=h}while(1){r=C;while(1){E=r+8|0;if(nb[c[d>>2]&31](j,r)|0){F=D;break}else r=E}do F=F+-8|0;while(nb[c[d>>2]&31](j,F)|
0);if(!(r>>>0<F>>>0)){j=r;continue b}l=r;w=c[l>>2]|0;q=c[l+4>>2]|0;l=F;o=c[l+4>>2]|0;m=r;c[m>>2]=c[l>>2];c[m+4>>2]=o;o=F;c[o>>2]=w;c[o+4>>2]=q;C=E;D=F}}while(0);q=j+8|0;c:do if(q>>>0<x>>>0){o=q;w=x;m=p;l=y;while(1){t=o;while(1){G=t+8|0;if(nb[c[d>>2]&31](t,m)|0)t=G;else{H=w;break}}do H=H+-8|0;while(!(nb[c[d>>2]&31](H,m)|0));if(t>>>0>H>>>0){I=t;J=m;K=l;break c}r=t;v=c[r>>2]|0;u=c[r+4>>2]|0;r=H;L=c[r+4>>2]|0;M=t;c[M>>2]=c[r>>2];c[M+4>>2]=L;L=H;c[L>>2]=v;c[L+4>>2]=u;o=G;w=H;m=(m|0)==(t|0)?H:m;l=l+1|0}}else{I=
q;J=p;K=y}while(0);if((I|0)!=(J|0)?nb[c[d>>2]&31](J,I)|0:0){p=I;q=c[p>>2]|0;l=c[p+4>>2]|0;p=J;m=c[p+4>>2]|0;w=I;c[w>>2]=c[p>>2];c[w+4>>2]=m;m=J;c[m>>2]=q;c[m+4>>2]=l;N=K+1|0}else N=K;if((N|0)==0){O=El(j,I,d)|0;l=I+8|0;if(El(l,a,d)|0){n=79;break}if(O){j=l;continue}}l=I;if((l-k|0)>=(b-l|0)){n=83;break}Cl(j,I,d);j=I+8|0}if((n|0)==79){n=0;if(O){n=84;break}else{g=j;a=I;continue}}else if((n|0)==83){n=0;Cl(I+8|0,a,d);g=j;a=I;continue}}if((n|0)==4){if(!(nb[c[d>>2]&31](h,j)|0)){i=e;return}I=j;g=c[I>>2]|0;
O=c[I+4>>2]|0;I=h;N=c[I+4>>2]|0;K=j;c[K>>2]=c[I>>2];c[K+4>>2]=N;N=h;c[N>>2]=g;c[N+4>>2]=O;i=e;return}else if((n|0)==6){O=j+8|0;N=nb[c[d>>2]&31](O,j)|0;g=nb[c[d>>2]&31](h,O)|0;if(!N){if(!g){i=e;return}N=O;K=c[N>>2]|0;I=c[N+4>>2]|0;N=h;J=c[N+4>>2]|0;y=O;c[y>>2]=c[N>>2];c[y+4>>2]=J;J=h;c[J>>2]=K;c[J+4>>2]=I;if(!(nb[c[d>>2]&31](O,j)|0)){i=e;return}I=j;J=c[I>>2]|0;K=c[I+4>>2]|0;I=O;y=c[I+4>>2]|0;N=j;c[N>>2]=c[I>>2];c[N+4>>2]=y;y=O;c[y>>2]=J;c[y+4>>2]=K;i=e;return}K=j;y=c[K>>2]|0;J=c[K+4>>2]|0;if(g){g=
h;K=c[g+4>>2]|0;N=j;c[N>>2]=c[g>>2];c[N+4>>2]=K;K=h;c[K>>2]=y;c[K+4>>2]=J;i=e;return}K=O;N=c[K+4>>2]|0;g=j;c[g>>2]=c[K>>2];c[g+4>>2]=N;N=O;c[N>>2]=y;c[N+4>>2]=J;if(!(nb[c[d>>2]&31](h,O)|0)){i=e;return}J=O;N=c[J>>2]|0;y=c[J+4>>2]|0;J=h;g=c[J+4>>2]|0;K=O;c[K>>2]=c[J>>2];c[K+4>>2]=g;g=h;c[g>>2]=N;c[g+4>>2]=y;i=e;return}else if((n|0)==14){y=j+8|0;g=j+16|0;N=nb[c[d>>2]&31](y,j)|0;K=nb[c[d>>2]&31](g,y)|0;do if(N){J=j;O=c[J>>2]|0;I=c[J+4>>2]|0;if(K){J=g;H=c[J+4>>2]|0;G=j;c[G>>2]=c[J>>2];c[G+4>>2]=H;H=g;
c[H>>2]=O;c[H+4>>2]=I;break}H=y;G=c[H+4>>2]|0;J=j;c[J>>2]=c[H>>2];c[J+4>>2]=G;G=y;c[G>>2]=O;c[G+4>>2]=I;if(nb[c[d>>2]&31](g,y)|0){I=y;G=c[I>>2]|0;O=c[I+4>>2]|0;I=g;J=c[I+4>>2]|0;H=y;c[H>>2]=c[I>>2];c[H+4>>2]=J;J=g;c[J>>2]=G;c[J+4>>2]=O}}else if(K?(O=y,J=c[O>>2]|0,G=c[O+4>>2]|0,O=g,H=c[O+4>>2]|0,I=y,c[I>>2]=c[O>>2],c[I+4>>2]=H,H=g,c[H>>2]=J,c[H+4>>2]=G,nb[c[d>>2]&31](y,j)|0):0){G=j;H=c[G>>2]|0;J=c[G+4>>2]|0;G=y;I=c[G+4>>2]|0;O=j;c[O>>2]=c[G>>2];c[O+4>>2]=I;I=y;c[I>>2]=H;c[I+4>>2]=J}while(0);if(!(nb[c[d>>
2]&31](h,g)|0)){i=e;return}K=g;N=c[K>>2]|0;J=c[K+4>>2]|0;K=h;I=c[K+4>>2]|0;H=g;c[H>>2]=c[K>>2];c[H+4>>2]=I;I=h;c[I>>2]=N;c[I+4>>2]=J;if(!(nb[c[d>>2]&31](g,y)|0)){i=e;return}J=y;I=c[J>>2]|0;N=c[J+4>>2]|0;J=g;H=c[J+4>>2]|0;K=y;c[K>>2]=c[J>>2];c[K+4>>2]=H;H=g;c[H>>2]=I;c[H+4>>2]=N;if(!(nb[c[d>>2]&31](y,j)|0)){i=e;return}N=j;H=c[N>>2]|0;I=c[N+4>>2]|0;N=y;g=c[N+4>>2]|0;K=j;c[K>>2]=c[N>>2];c[K+4>>2]=g;g=y;c[g>>2]=H;c[g+4>>2]=I;i=e;return}else if((n|0)==26){Dl(j,j+8|0,j+16|0,j+24|0,h,d)|0;i=e;return}else if((n|
0)==28){h=j+16|0;I=j+8|0;g=nb[c[d>>2]&31](I,j)|0;H=nb[c[d>>2]&31](h,I)|0;do if(g){y=j;K=c[y>>2]|0;N=c[y+4>>2]|0;if(H){y=h;J=c[y+4>>2]|0;O=j;c[O>>2]=c[y>>2];c[O+4>>2]=J;J=h;c[J>>2]=K;c[J+4>>2]=N;break}J=I;O=c[J+4>>2]|0;y=j;c[y>>2]=c[J>>2];c[y+4>>2]=O;O=I;c[O>>2]=K;c[O+4>>2]=N;if(nb[c[d>>2]&31](h,I)|0){N=I;O=c[N>>2]|0;K=c[N+4>>2]|0;N=h;y=c[N+4>>2]|0;J=I;c[J>>2]=c[N>>2];c[J+4>>2]=y;y=h;c[y>>2]=O;c[y+4>>2]=K}}else if(H?(K=I,y=c[K>>2]|0,O=c[K+4>>2]|0,K=h,J=c[K+4>>2]|0,N=I,c[N>>2]=c[K>>2],c[N+4>>2]=J,J=
h,c[J>>2]=y,c[J+4>>2]=O,nb[c[d>>2]&31](I,j)|0):0){O=j;J=c[O>>2]|0;y=c[O+4>>2]|0;O=I;N=c[O+4>>2]|0;K=j;c[K>>2]=c[O>>2];c[K+4>>2]=N;N=I;c[N>>2]=J;c[N+4>>2]=y}while(0);I=j+24|0;if((I|0)==(a|0)){i=e;return}else{P=I;Q=h}while(1){if(nb[c[d>>2]&31](P,Q)|0){h=P;I=c[h+4>>2]|0;H=f;c[H>>2]=c[h>>2];c[H+4>>2]=I;I=P;H=Q;while(1){h=H;g=c[h+4>>2]|0;y=I;c[y>>2]=c[h>>2];c[y+4>>2]=g;if((H|0)==(j|0))break;g=H+-8|0;if(nb[c[d>>2]&31](f,g)|0){y=H;H=g;I=y}else break}I=f;y=c[I+4>>2]|0;g=H;c[g>>2]=c[I>>2];c[g+4>>2]=y}y=P+
8|0;if((y|0)==(a|0))break;else{g=P;P=y;Q=g}}i=e;return}else if((n|0)==84){i=e;return}}function Dl(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;h=i;j=nb[c[g>>2]&31](b,a)|0;k=nb[c[g>>2]&31](d,b)|0;do if(j){l=a;m=c[l>>2]|0;n=c[l+4>>2]|0;if(k){l=d;o=c[l+4>>2]|0;p=a;c[p>>2]=c[l>>2];c[p+4>>2]=o;o=d;c[o>>2]=m;c[o+4>>2]=n;q=1;break}o=b;p=c[o+4>>2]|0;l=a;c[l>>2]=c[o>>2];c[l+4>>2]=p;p=b;c[p>>2]=m;c[p+4>>2]=n;if(nb[c[g>>2]&31](d,b)|0){n=b;p=c[n>>2]|0;m=c[n+
4>>2]|0;n=d;l=c[n+4>>2]|0;o=b;c[o>>2]=c[n>>2];c[o+4>>2]=l;l=d;c[l>>2]=p;c[l+4>>2]=m;q=2}else q=1}else if(k){m=b;l=c[m>>2]|0;p=c[m+4>>2]|0;m=d;o=c[m+4>>2]|0;n=b;c[n>>2]=c[m>>2];c[n+4>>2]=o;o=d;c[o>>2]=l;c[o+4>>2]=p;if(nb[c[g>>2]&31](b,a)|0){p=a;o=c[p>>2]|0;l=c[p+4>>2]|0;p=b;n=c[p+4>>2]|0;m=a;c[m>>2]=c[p>>2];c[m+4>>2]=n;n=b;c[n>>2]=o;c[n+4>>2]=l;q=2}else q=1}else q=0;while(0);if(nb[c[g>>2]&31](e,d)|0){k=d;j=c[k>>2]|0;l=c[k+4>>2]|0;k=e;n=c[k+4>>2]|0;o=d;c[o>>2]=c[k>>2];c[o+4>>2]=n;n=e;c[n>>2]=j;c[n+
4>>2]=l;l=q+1|0;if(nb[c[g>>2]&31](d,b)|0){n=b;j=c[n>>2]|0;o=c[n+4>>2]|0;n=d;k=c[n+4>>2]|0;m=b;c[m>>2]=c[n>>2];c[m+4>>2]=k;k=d;c[k>>2]=j;c[k+4>>2]=o;if(nb[c[g>>2]&31](b,a)|0){o=a;k=c[o>>2]|0;j=c[o+4>>2]|0;o=b;m=c[o+4>>2]|0;n=a;c[n>>2]=c[o>>2];c[n+4>>2]=m;m=b;c[m>>2]=k;c[m+4>>2]=j;r=q+3|0}else r=q+2|0}else r=l}else r=q;if(!(nb[c[g>>2]&31](f,e)|0)){s=r;i=h;return s|0}q=e;l=c[q>>2]|0;j=c[q+4>>2]|0;q=f;m=c[q+4>>2]|0;k=e;c[k>>2]=c[q>>2];c[k+4>>2]=m;m=f;c[m>>2]=l;c[m+4>>2]=j;if(!(nb[c[g>>2]&31](e,d)|0)){s=
r+1|0;i=h;return s|0}j=d;m=c[j>>2]|0;l=c[j+4>>2]|0;j=e;f=c[j+4>>2]|0;k=d;c[k>>2]=c[j>>2];c[k+4>>2]=f;f=e;c[f>>2]=m;c[f+4>>2]=l;if(!(nb[c[g>>2]&31](d,b)|0)){s=r+2|0;i=h;return s|0}l=b;f=c[l>>2]|0;m=c[l+4>>2]|0;l=d;e=c[l+4>>2]|0;k=b;c[k>>2]=c[l>>2];c[k+4>>2]=e;e=d;c[e>>2]=f;c[e+4>>2]=m;if(!(nb[c[g>>2]&31](b,a)|0)){s=r+3|0;i=h;return s|0}g=a;m=c[g>>2]|0;e=c[g+4>>2]|0;g=b;f=c[g+4>>2]|0;d=a;c[d>>2]=c[g>>2];c[d+4>>2]=f;f=b;c[f>>2]=m;c[f+4>>2]=e;s=r+4|0;i=h;return s|0}function El(a,b,d){a=a|0;b=b|0;d=d|
0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;e=i;i=i+16|0;f=e;switch(b-a>>3|0){case 2:g=b+-8|0;if(!(nb[c[d>>2]&31](g,a)|0)){h=1;i=e;return h|0}j=a;k=c[j>>2]|0;l=c[j+4>>2]|0;j=g;m=c[j+4>>2]|0;n=a;c[n>>2]=c[j>>2];c[n+4>>2]=m;m=g;c[m>>2]=k;c[m+4>>2]=l;h=1;i=e;return h|0;case 5:Dl(a,a+8|0,a+16|0,a+24|0,b+-8|0,d)|0;h=1;i=e;return h|0;case 1:case 0:h=1;i=e;return h|0;case 4:l=a+8|0;m=a+16|0;k=b+-8|0;g=nb[c[d>>2]&31](l,a)|0;n=nb[c[d>>2]&31](m,l)|0;do if(g){j=a;o=c[j>>2]|
0;p=c[j+4>>2]|0;if(n){j=m;q=c[j+4>>2]|0;r=a;c[r>>2]=c[j>>2];c[r+4>>2]=q;q=m;c[q>>2]=o;c[q+4>>2]=p;break}q=l;r=c[q+4>>2]|0;j=a;c[j>>2]=c[q>>2];c[j+4>>2]=r;r=l;c[r>>2]=o;c[r+4>>2]=p;if(nb[c[d>>2]&31](m,l)|0){p=l;r=c[p>>2]|0;o=c[p+4>>2]|0;p=m;j=c[p+4>>2]|0;q=l;c[q>>2]=c[p>>2];c[q+4>>2]=j;j=m;c[j>>2]=r;c[j+4>>2]=o}}else if(n?(o=l,j=c[o>>2]|0,r=c[o+4>>2]|0,o=m,q=c[o+4>>2]|0,p=l,c[p>>2]=c[o>>2],c[p+4>>2]=q,q=m,c[q>>2]=j,c[q+4>>2]=r,nb[c[d>>2]&31](l,a)|0):0){r=a;q=c[r>>2]|0;j=c[r+4>>2]|0;r=l;p=c[r+4>>2]|
0;o=a;c[o>>2]=c[r>>2];c[o+4>>2]=p;p=l;c[p>>2]=q;c[p+4>>2]=j}while(0);if(!(nb[c[d>>2]&31](k,m)|0)){h=1;i=e;return h|0}n=m;g=c[n>>2]|0;j=c[n+4>>2]|0;n=k;p=c[n+4>>2]|0;q=m;c[q>>2]=c[n>>2];c[q+4>>2]=p;p=k;c[p>>2]=g;c[p+4>>2]=j;if(!(nb[c[d>>2]&31](m,l)|0)){h=1;i=e;return h|0}j=l;p=c[j>>2]|0;g=c[j+4>>2]|0;j=m;k=c[j+4>>2]|0;q=l;c[q>>2]=c[j>>2];c[q+4>>2]=k;k=m;c[k>>2]=p;c[k+4>>2]=g;if(!(nb[c[d>>2]&31](l,a)|0)){h=1;i=e;return h|0}g=a;k=c[g>>2]|0;p=c[g+4>>2]|0;g=l;m=c[g+4>>2]|0;q=a;c[q>>2]=c[g>>2];c[q+4>>2]=
m;m=l;c[m>>2]=k;c[m+4>>2]=p;h=1;i=e;return h|0;case 3:p=a+8|0;m=b+-8|0;k=nb[c[d>>2]&31](p,a)|0;l=nb[c[d>>2]&31](m,p)|0;if(!k){if(!l){h=1;i=e;return h|0}k=p;q=c[k>>2]|0;g=c[k+4>>2]|0;k=m;j=c[k+4>>2]|0;n=p;c[n>>2]=c[k>>2];c[n+4>>2]=j;j=m;c[j>>2]=q;c[j+4>>2]=g;if(!(nb[c[d>>2]&31](p,a)|0)){h=1;i=e;return h|0}g=a;j=c[g>>2]|0;q=c[g+4>>2]|0;g=p;n=c[g+4>>2]|0;k=a;c[k>>2]=c[g>>2];c[k+4>>2]=n;n=p;c[n>>2]=j;c[n+4>>2]=q;h=1;i=e;return h|0}q=a;n=c[q>>2]|0;j=c[q+4>>2]|0;if(l){l=m;q=c[l+4>>2]|0;k=a;c[k>>2]=c[l>>
2];c[k+4>>2]=q;q=m;c[q>>2]=n;c[q+4>>2]=j;h=1;i=e;return h|0}q=p;k=c[q+4>>2]|0;l=a;c[l>>2]=c[q>>2];c[l+4>>2]=k;k=p;c[k>>2]=n;c[k+4>>2]=j;if(!(nb[c[d>>2]&31](m,p)|0)){h=1;i=e;return h|0}j=p;k=c[j>>2]|0;n=c[j+4>>2]|0;j=m;l=c[j+4>>2]|0;q=p;c[q>>2]=c[j>>2];c[q+4>>2]=l;l=m;c[l>>2]=k;c[l+4>>2]=n;h=1;i=e;return h|0;default:n=a+16|0;l=a+8|0;k=nb[c[d>>2]&31](l,a)|0;m=nb[c[d>>2]&31](n,l)|0;do if(k){q=a;j=c[q>>2]|0;p=c[q+4>>2]|0;if(m){q=n;g=c[q+4>>2]|0;o=a;c[o>>2]=c[q>>2];c[o+4>>2]=g;g=n;c[g>>2]=j;c[g+4>>2]=
p;break}g=l;o=c[g+4>>2]|0;q=a;c[q>>2]=c[g>>2];c[q+4>>2]=o;o=l;c[o>>2]=j;c[o+4>>2]=p;if(nb[c[d>>2]&31](n,l)|0){p=l;o=c[p>>2]|0;j=c[p+4>>2]|0;p=n;q=c[p+4>>2]|0;g=l;c[g>>2]=c[p>>2];c[g+4>>2]=q;q=n;c[q>>2]=o;c[q+4>>2]=j}}else if(m?(j=l,q=c[j>>2]|0,o=c[j+4>>2]|0,j=n,g=c[j+4>>2]|0,p=l,c[p>>2]=c[j>>2],c[p+4>>2]=g,g=n,c[g>>2]=q,c[g+4>>2]=o,nb[c[d>>2]&31](l,a)|0):0){o=a;g=c[o>>2]|0;q=c[o+4>>2]|0;o=l;p=c[o+4>>2]|0;j=a;c[j>>2]=c[o>>2];c[j+4>>2]=p;p=l;c[p>>2]=g;c[p+4>>2]=q}while(0);l=a+24|0;if((l|0)==(b|0)){h=
1;i=e;return h|0}else{s=0;t=l;u=n}while(1){if(nb[c[d>>2]&31](t,u)|0){n=t;l=c[n+4>>2]|0;m=f;c[m>>2]=c[n>>2];c[m+4>>2]=l;l=t;m=u;while(1){n=m;k=c[n+4>>2]|0;q=l;c[q>>2]=c[n>>2];c[q+4>>2]=k;if((m|0)==(a|0))break;k=m+-8|0;if(nb[c[d>>2]&31](f,k)|0){q=m;m=k;l=q}else break}l=f;q=c[l+4>>2]|0;k=m;c[k>>2]=c[l>>2];c[k+4>>2]=q;q=s+1|0;if((q|0)==8)break;else v=q}else v=s;q=t+8|0;if((q|0)==(b|0)){h=1;w=41;break}else{k=t;s=v;t=q;u=k}}if((w|0)==41){i=e;return h|0}h=(t+8|0)==(b|0);i=e;return h|0}return 0}function Fl(a,
b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0;e=i;i=i+16|0;f=e;g=a;a=b;a:while(1){b=a;h=a+-8|0;j=g;b:while(1){k=j;l=b-k|0;m=l>>3;switch(m|0){case 2:n=4;break a;break;case 4:n=14;break a;break;case 5:n=26;break a;break;case 3:n=6;break a;break;case 1:case 0:n=84;break a;break;default:}if((l|0)<248){n=28;break a}o=(m|0)/2|0;p=j+(o<<3)|0;do if((l|0)<=7992){q=nb[c[d>>2]&
31](p,j)|0;r=nb[c[d>>2]&31](h,p)|0;if(!q){if(!r){s=0;break}q=p;t=c[q>>2]|0;u=c[q+4>>2]|0;q=h;v=c[q+4>>2]|0;w=p;c[w>>2]=c[q>>2];c[w+4>>2]=v;v=h;c[v>>2]=t;c[v+4>>2]=u;if(!(nb[c[d>>2]&31](p,j)|0)){s=1;break}u=j;v=c[u>>2]|0;t=c[u+4>>2]|0;u=p;w=c[u+4>>2]|0;q=j;c[q>>2]=c[u>>2];c[q+4>>2]=w;w=p;c[w>>2]=v;c[w+4>>2]=t;s=2;break}t=j;w=c[t>>2]|0;v=c[t+4>>2]|0;if(r){r=h;t=c[r+4>>2]|0;q=j;c[q>>2]=c[r>>2];c[q+4>>2]=t;t=h;c[t>>2]=w;c[t+4>>2]=v;s=1;break}t=p;q=c[t+4>>2]|0;r=j;c[r>>2]=c[t>>2];c[r+4>>2]=q;q=p;c[q>>
2]=w;c[q+4>>2]=v;if(nb[c[d>>2]&31](h,p)|0){v=p;q=c[v>>2]|0;w=c[v+4>>2]|0;v=h;r=c[v+4>>2]|0;t=p;c[t>>2]=c[v>>2];c[t+4>>2]=r;r=h;c[r>>2]=q;c[r+4>>2]=w;s=2}else s=1}else{w=(m|0)/4|0;s=Gl(j,j+(w<<3)|0,p,j+(w+o<<3)|0,h,d)|0}while(0);do if(nb[c[d>>2]&31](j,p)|0){x=h;y=s}else{o=h;while(1){o=o+-8|0;if((j|0)==(o|0))break;if(nb[c[d>>2]&31](o,p)|0){n=67;break}}if((n|0)==67){n=0;m=j;l=c[m>>2]|0;w=c[m+4>>2]|0;m=o;r=c[m+4>>2]|0;q=j;c[q>>2]=c[m>>2];c[q+4>>2]=r;r=o;c[r>>2]=l;c[r+4>>2]=w;x=o;y=s+1|0;break}w=j+8|0;
if(nb[c[d>>2]&31](j,h)|0)z=w;else{if((w|0)==(h|0)){n=84;break a}else A=w;while(1){B=A+8|0;if(nb[c[d>>2]&31](j,A)|0)break;if((B|0)==(h|0)){n=84;break a}else A=B}o=A;w=c[o>>2]|0;r=c[o+4>>2]|0;o=h;l=c[o+4>>2]|0;q=A;c[q>>2]=c[o>>2];c[q+4>>2]=l;l=h;c[l>>2]=w;c[l+4>>2]=r;z=B}if((z|0)==(h|0)){n=84;break a}else{C=z;D=h}while(1){r=C;while(1){E=r+8|0;if(nb[c[d>>2]&31](j,r)|0){F=D;break}else r=E}do F=F+-8|0;while(nb[c[d>>2]&31](j,F)|0);if(!(r>>>0<F>>>0)){j=r;continue b}l=r;w=c[l>>2]|0;q=c[l+4>>2]|0;l=F;o=c[l+
4>>2]|0;m=r;c[m>>2]=c[l>>2];c[m+4>>2]=o;o=F;c[o>>2]=w;c[o+4>>2]=q;C=E;D=F}}while(0);q=j+8|0;c:do if(q>>>0<x>>>0){o=q;w=x;m=p;l=y;while(1){t=o;while(1){G=t+8|0;if(nb[c[d>>2]&31](t,m)|0)t=G;else{H=w;break}}do H=H+-8|0;while(!(nb[c[d>>2]&31](H,m)|0));if(t>>>0>H>>>0){I=t;J=m;K=l;break c}r=t;v=c[r>>2]|0;u=c[r+4>>2]|0;r=H;L=c[r+4>>2]|0;M=t;c[M>>2]=c[r>>2];c[M+4>>2]=L;L=H;c[L>>2]=v;c[L+4>>2]=u;o=G;w=H;m=(m|0)==(t|0)?H:m;l=l+1|0}}else{I=q;J=p;K=y}while(0);if((I|0)!=(J|0)?nb[c[d>>2]&31](J,I)|0:0){p=I;q=c[p>>
2]|0;l=c[p+4>>2]|0;p=J;m=c[p+4>>2]|0;w=I;c[w>>2]=c[p>>2];c[w+4>>2]=m;m=J;c[m>>2]=q;c[m+4>>2]=l;N=K+1|0}else N=K;if((N|0)==0){O=Hl(j,I,d)|0;l=I+8|0;if(Hl(l,a,d)|0){n=79;break}if(O){j=l;continue}}l=I;if((l-k|0)>=(b-l|0)){n=83;break}Fl(j,I,d);j=I+8|0}if((n|0)==79){n=0;if(O){n=84;break}else{g=j;a=I;continue}}else if((n|0)==83){n=0;Fl(I+8|0,a,d);g=j;a=I;continue}}if((n|0)==4){if(!(nb[c[d>>2]&31](h,j)|0)){i=e;return}I=j;g=c[I>>2]|0;O=c[I+4>>2]|0;I=h;N=c[I+4>>2]|0;K=j;c[K>>2]=c[I>>2];c[K+4>>2]=N;N=h;c[N>>
2]=g;c[N+4>>2]=O;i=e;return}else if((n|0)==6){O=j+8|0;N=nb[c[d>>2]&31](O,j)|0;g=nb[c[d>>2]&31](h,O)|0;if(!N){if(!g){i=e;return}N=O;K=c[N>>2]|0;I=c[N+4>>2]|0;N=h;J=c[N+4>>2]|0;y=O;c[y>>2]=c[N>>2];c[y+4>>2]=J;J=h;c[J>>2]=K;c[J+4>>2]=I;if(!(nb[c[d>>2]&31](O,j)|0)){i=e;return}I=j;J=c[I>>2]|0;K=c[I+4>>2]|0;I=O;y=c[I+4>>2]|0;N=j;c[N>>2]=c[I>>2];c[N+4>>2]=y;y=O;c[y>>2]=J;c[y+4>>2]=K;i=e;return}K=j;y=c[K>>2]|0;J=c[K+4>>2]|0;if(g){g=h;K=c[g+4>>2]|0;N=j;c[N>>2]=c[g>>2];c[N+4>>2]=K;K=h;c[K>>2]=y;c[K+4>>2]=J;
i=e;return}K=O;N=c[K+4>>2]|0;g=j;c[g>>2]=c[K>>2];c[g+4>>2]=N;N=O;c[N>>2]=y;c[N+4>>2]=J;if(!(nb[c[d>>2]&31](h,O)|0)){i=e;return}J=O;N=c[J>>2]|0;y=c[J+4>>2]|0;J=h;g=c[J+4>>2]|0;K=O;c[K>>2]=c[J>>2];c[K+4>>2]=g;g=h;c[g>>2]=N;c[g+4>>2]=y;i=e;return}else if((n|0)==14){y=j+8|0;g=j+16|0;N=nb[c[d>>2]&31](y,j)|0;K=nb[c[d>>2]&31](g,y)|0;do if(N){J=j;O=c[J>>2]|0;I=c[J+4>>2]|0;if(K){J=g;H=c[J+4>>2]|0;G=j;c[G>>2]=c[J>>2];c[G+4>>2]=H;H=g;c[H>>2]=O;c[H+4>>2]=I;break}H=y;G=c[H+4>>2]|0;J=j;c[J>>2]=c[H>>2];c[J+4>>2]=
G;G=y;c[G>>2]=O;c[G+4>>2]=I;if(nb[c[d>>2]&31](g,y)|0){I=y;G=c[I>>2]|0;O=c[I+4>>2]|0;I=g;J=c[I+4>>2]|0;H=y;c[H>>2]=c[I>>2];c[H+4>>2]=J;J=g;c[J>>2]=G;c[J+4>>2]=O}}else if(K?(O=y,J=c[O>>2]|0,G=c[O+4>>2]|0,O=g,H=c[O+4>>2]|0,I=y,c[I>>2]=c[O>>2],c[I+4>>2]=H,H=g,c[H>>2]=J,c[H+4>>2]=G,nb[c[d>>2]&31](y,j)|0):0){G=j;H=c[G>>2]|0;J=c[G+4>>2]|0;G=y;I=c[G+4>>2]|0;O=j;c[O>>2]=c[G>>2];c[O+4>>2]=I;I=y;c[I>>2]=H;c[I+4>>2]=J}while(0);if(!(nb[c[d>>2]&31](h,g)|0)){i=e;return}K=g;N=c[K>>2]|0;J=c[K+4>>2]|0;K=h;I=c[K+4>>
2]|0;H=g;c[H>>2]=c[K>>2];c[H+4>>2]=I;I=h;c[I>>2]=N;c[I+4>>2]=J;if(!(nb[c[d>>2]&31](g,y)|0)){i=e;return}J=y;I=c[J>>2]|0;N=c[J+4>>2]|0;J=g;H=c[J+4>>2]|0;K=y;c[K>>2]=c[J>>2];c[K+4>>2]=H;H=g;c[H>>2]=I;c[H+4>>2]=N;if(!(nb[c[d>>2]&31](y,j)|0)){i=e;return}N=j;H=c[N>>2]|0;I=c[N+4>>2]|0;N=y;g=c[N+4>>2]|0;K=j;c[K>>2]=c[N>>2];c[K+4>>2]=g;g=y;c[g>>2]=H;c[g+4>>2]=I;i=e;return}else if((n|0)==26){Gl(j,j+8|0,j+16|0,j+24|0,h,d)|0;i=e;return}else if((n|0)==28){h=j+16|0;I=j+8|0;g=nb[c[d>>2]&31](I,j)|0;H=nb[c[d>>2]&
31](h,I)|0;do if(g){y=j;K=c[y>>2]|0;N=c[y+4>>2]|0;if(H){y=h;J=c[y+4>>2]|0;O=j;c[O>>2]=c[y>>2];c[O+4>>2]=J;J=h;c[J>>2]=K;c[J+4>>2]=N;break}J=I;O=c[J+4>>2]|0;y=j;c[y>>2]=c[J>>2];c[y+4>>2]=O;O=I;c[O>>2]=K;c[O+4>>2]=N;if(nb[c[d>>2]&31](h,I)|0){N=I;O=c[N>>2]|0;K=c[N+4>>2]|0;N=h;y=c[N+4>>2]|0;J=I;c[J>>2]=c[N>>2];c[J+4>>2]=y;y=h;c[y>>2]=O;c[y+4>>2]=K}}else if(H?(K=I,y=c[K>>2]|0,O=c[K+4>>2]|0,K=h,J=c[K+4>>2]|0,N=I,c[N>>2]=c[K>>2],c[N+4>>2]=J,J=h,c[J>>2]=y,c[J+4>>2]=O,nb[c[d>>2]&31](I,j)|0):0){O=j;J=c[O>>
2]|0;y=c[O+4>>2]|0;O=I;N=c[O+4>>2]|0;K=j;c[K>>2]=c[O>>2];c[K+4>>2]=N;N=I;c[N>>2]=J;c[N+4>>2]=y}while(0);I=j+24|0;if((I|0)==(a|0)){i=e;return}else{P=I;Q=h}while(1){if(nb[c[d>>2]&31](P,Q)|0){h=P;I=c[h+4>>2]|0;H=f;c[H>>2]=c[h>>2];c[H+4>>2]=I;I=P;H=Q;while(1){h=H;g=c[h+4>>2]|0;y=I;c[y>>2]=c[h>>2];c[y+4>>2]=g;if((H|0)==(j|0))break;g=H+-8|0;if(nb[c[d>>2]&31](f,g)|0){y=H;H=g;I=y}else break}I=f;y=c[I+4>>2]|0;g=H;c[g>>2]=c[I>>2];c[g+4>>2]=y}y=P+8|0;if((y|0)==(a|0))break;else{g=P;P=y;Q=g}}i=e;return}else if((n|
0)==84){i=e;return}}function Gl(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;h=i;j=nb[c[g>>2]&31](b,a)|0;k=nb[c[g>>2]&31](d,b)|0;do if(j){l=a;m=c[l>>2]|0;n=c[l+4>>2]|0;if(k){l=d;o=c[l+4>>2]|0;p=a;c[p>>2]=c[l>>2];c[p+4>>2]=o;o=d;c[o>>2]=m;c[o+4>>2]=n;q=1;break}o=b;p=c[o+4>>2]|0;l=a;c[l>>2]=c[o>>2];c[l+4>>2]=p;p=b;c[p>>2]=m;c[p+4>>2]=n;if(nb[c[g>>2]&31](d,b)|0){n=b;p=c[n>>2]|0;m=c[n+4>>2]|0;n=d;l=c[n+4>>2]|0;o=b;c[o>>2]=c[n>>2];c[o+4>>2]=l;l=d;c[l>>
2]=p;c[l+4>>2]=m;q=2}else q=1}else if(k){m=b;l=c[m>>2]|0;p=c[m+4>>2]|0;m=d;o=c[m+4>>2]|0;n=b;c[n>>2]=c[m>>2];c[n+4>>2]=o;o=d;c[o>>2]=l;c[o+4>>2]=p;if(nb[c[g>>2]&31](b,a)|0){p=a;o=c[p>>2]|0;l=c[p+4>>2]|0;p=b;n=c[p+4>>2]|0;m=a;c[m>>2]=c[p>>2];c[m+4>>2]=n;n=b;c[n>>2]=o;c[n+4>>2]=l;q=2}else q=1}else q=0;while(0);if(nb[c[g>>2]&31](e,d)|0){k=d;j=c[k>>2]|0;l=c[k+4>>2]|0;k=e;n=c[k+4>>2]|0;o=d;c[o>>2]=c[k>>2];c[o+4>>2]=n;n=e;c[n>>2]=j;c[n+4>>2]=l;l=q+1|0;if(nb[c[g>>2]&31](d,b)|0){n=b;j=c[n>>2]|0;o=c[n+4>>
2]|0;n=d;k=c[n+4>>2]|0;m=b;c[m>>2]=c[n>>2];c[m+4>>2]=k;k=d;c[k>>2]=j;c[k+4>>2]=o;if(nb[c[g>>2]&31](b,a)|0){o=a;k=c[o>>2]|0;j=c[o+4>>2]|0;o=b;m=c[o+4>>2]|0;n=a;c[n>>2]=c[o>>2];c[n+4>>2]=m;m=b;c[m>>2]=k;c[m+4>>2]=j;r=q+3|0}else r=q+2|0}else r=l}else r=q;if(!(nb[c[g>>2]&31](f,e)|0)){s=r;i=h;return s|0}q=e;l=c[q>>2]|0;j=c[q+4>>2]|0;q=f;m=c[q+4>>2]|0;k=e;c[k>>2]=c[q>>2];c[k+4>>2]=m;m=f;c[m>>2]=l;c[m+4>>2]=j;if(!(nb[c[g>>2]&31](e,d)|0)){s=r+1|0;i=h;return s|0}j=d;m=c[j>>2]|0;l=c[j+4>>2]|0;j=e;f=c[j+4>>
2]|0;k=d;c[k>>2]=c[j>>2];c[k+4>>2]=f;f=e;c[f>>2]=m;c[f+4>>2]=l;if(!(nb[c[g>>2]&31](d,b)|0)){s=r+2|0;i=h;return s|0}l=b;f=c[l>>2]|0;m=c[l+4>>2]|0;l=d;e=c[l+4>>2]|0;k=b;c[k>>2]=c[l>>2];c[k+4>>2]=e;e=d;c[e>>2]=f;c[e+4>>2]=m;if(!(nb[c[g>>2]&31](b,a)|0)){s=r+3|0;i=h;return s|0}g=a;m=c[g>>2]|0;e=c[g+4>>2]|0;g=b;f=c[g+4>>2]|0;d=a;c[d>>2]=c[g>>2];c[d+4>>2]=f;f=b;c[f>>2]=m;c[f+4>>2]=e;s=r+4|0;i=h;return s|0}function Hl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=
0,u=0,v=0,w=0;e=i;i=i+16|0;f=e;switch(b-a>>3|0){case 3:g=a+8|0;h=b+-8|0;j=nb[c[d>>2]&31](g,a)|0;k=nb[c[d>>2]&31](h,g)|0;if(!j){if(!k){l=1;i=e;return l|0}j=g;m=c[j>>2]|0;n=c[j+4>>2]|0;j=h;o=c[j+4>>2]|0;p=g;c[p>>2]=c[j>>2];c[p+4>>2]=o;o=h;c[o>>2]=m;c[o+4>>2]=n;if(!(nb[c[d>>2]&31](g,a)|0)){l=1;i=e;return l|0}n=a;o=c[n>>2]|0;m=c[n+4>>2]|0;n=g;p=c[n+4>>2]|0;j=a;c[j>>2]=c[n>>2];c[j+4>>2]=p;p=g;c[p>>2]=o;c[p+4>>2]=m;l=1;i=e;return l|0}m=a;p=c[m>>2]|0;o=c[m+4>>2]|0;if(k){k=h;m=c[k+4>>2]|0;j=a;c[j>>2]=c[k>>
2];c[j+4>>2]=m;m=h;c[m>>2]=p;c[m+4>>2]=o;l=1;i=e;return l|0}m=g;j=c[m+4>>2]|0;k=a;c[k>>2]=c[m>>2];c[k+4>>2]=j;j=g;c[j>>2]=p;c[j+4>>2]=o;if(!(nb[c[d>>2]&31](h,g)|0)){l=1;i=e;return l|0}o=g;j=c[o>>2]|0;p=c[o+4>>2]|0;o=h;k=c[o+4>>2]|0;m=g;c[m>>2]=c[o>>2];c[m+4>>2]=k;k=h;c[k>>2]=j;c[k+4>>2]=p;l=1;i=e;return l|0;case 4:p=a+8|0;k=a+16|0;j=b+-8|0;h=nb[c[d>>2]&31](p,a)|0;m=nb[c[d>>2]&31](k,p)|0;do if(h){o=a;g=c[o>>2]|0;n=c[o+4>>2]|0;if(m){o=k;q=c[o+4>>2]|0;r=a;c[r>>2]=c[o>>2];c[r+4>>2]=q;q=k;c[q>>2]=g;c[q+
4>>2]=n;break}q=p;r=c[q+4>>2]|0;o=a;c[o>>2]=c[q>>2];c[o+4>>2]=r;r=p;c[r>>2]=g;c[r+4>>2]=n;if(nb[c[d>>2]&31](k,p)|0){n=p;r=c[n>>2]|0;g=c[n+4>>2]|0;n=k;o=c[n+4>>2]|0;q=p;c[q>>2]=c[n>>2];c[q+4>>2]=o;o=k;c[o>>2]=r;c[o+4>>2]=g}}else if(m?(g=p,o=c[g>>2]|0,r=c[g+4>>2]|0,g=k,q=c[g+4>>2]|0,n=p,c[n>>2]=c[g>>2],c[n+4>>2]=q,q=k,c[q>>2]=o,c[q+4>>2]=r,nb[c[d>>2]&31](p,a)|0):0){r=a;q=c[r>>2]|0;o=c[r+4>>2]|0;r=p;n=c[r+4>>2]|0;g=a;c[g>>2]=c[r>>2];c[g+4>>2]=n;n=p;c[n>>2]=q;c[n+4>>2]=o}while(0);if(!(nb[c[d>>2]&31](j,
k)|0)){l=1;i=e;return l|0}m=k;h=c[m>>2]|0;o=c[m+4>>2]|0;m=j;n=c[m+4>>2]|0;q=k;c[q>>2]=c[m>>2];c[q+4>>2]=n;n=j;c[n>>2]=h;c[n+4>>2]=o;if(!(nb[c[d>>2]&31](k,p)|0)){l=1;i=e;return l|0}o=p;n=c[o>>2]|0;h=c[o+4>>2]|0;o=k;j=c[o+4>>2]|0;q=p;c[q>>2]=c[o>>2];c[q+4>>2]=j;j=k;c[j>>2]=n;c[j+4>>2]=h;if(!(nb[c[d>>2]&31](p,a)|0)){l=1;i=e;return l|0}h=a;j=c[h>>2]|0;n=c[h+4>>2]|0;h=p;k=c[h+4>>2]|0;q=a;c[q>>2]=c[h>>2];c[q+4>>2]=k;k=p;c[k>>2]=j;c[k+4>>2]=n;l=1;i=e;return l|0;case 1:case 0:l=1;i=e;return l|0;case 5:Gl(a,
a+8|0,a+16|0,a+24|0,b+-8|0,d)|0;l=1;i=e;return l|0;case 2:n=b+-8|0;if(!(nb[c[d>>2]&31](n,a)|0)){l=1;i=e;return l|0}k=a;j=c[k>>2]|0;p=c[k+4>>2]|0;k=n;q=c[k+4>>2]|0;h=a;c[h>>2]=c[k>>2];c[h+4>>2]=q;q=n;c[q>>2]=j;c[q+4>>2]=p;l=1;i=e;return l|0;default:p=a+16|0;q=a+8|0;j=nb[c[d>>2]&31](q,a)|0;n=nb[c[d>>2]&31](p,q)|0;do if(j){h=a;k=c[h>>2]|0;o=c[h+4>>2]|0;if(n){h=p;m=c[h+4>>2]|0;g=a;c[g>>2]=c[h>>2];c[g+4>>2]=m;m=p;c[m>>2]=k;c[m+4>>2]=o;break}m=q;g=c[m+4>>2]|0;h=a;c[h>>2]=c[m>>2];c[h+4>>2]=g;g=q;c[g>>2]=
k;c[g+4>>2]=o;if(nb[c[d>>2]&31](p,q)|0){o=q;g=c[o>>2]|0;k=c[o+4>>2]|0;o=p;h=c[o+4>>2]|0;m=q;c[m>>2]=c[o>>2];c[m+4>>2]=h;h=p;c[h>>2]=g;c[h+4>>2]=k}}else if(n?(k=q,h=c[k>>2]|0,g=c[k+4>>2]|0,k=p,m=c[k+4>>2]|0,o=q,c[o>>2]=c[k>>2],c[o+4>>2]=m,m=p,c[m>>2]=h,c[m+4>>2]=g,nb[c[d>>2]&31](q,a)|0):0){g=a;m=c[g>>2]|0;h=c[g+4>>2]|0;g=q;o=c[g+4>>2]|0;k=a;c[k>>2]=c[g>>2];c[k+4>>2]=o;o=q;c[o>>2]=m;c[o+4>>2]=h}while(0);q=a+24|0;if((q|0)==(b|0)){l=1;i=e;return l|0}else{s=0;t=q;u=p}while(1){if(nb[c[d>>2]&31](t,u)|0){p=
t;q=c[p+4>>2]|0;n=f;c[n>>2]=c[p>>2];c[n+4>>2]=q;q=t;n=u;while(1){p=n;j=c[p+4>>2]|0;h=q;c[h>>2]=c[p>>2];c[h+4>>2]=j;if((n|0)==(a|0))break;j=n+-8|0;if(nb[c[d>>2]&31](f,j)|0){h=n;n=j;q=h}else break}q=f;h=c[q+4>>2]|0;j=n;c[j>>2]=c[q>>2];c[j+4>>2]=h;h=s+1|0;if((h|0)==8)break;else v=h}else v=s;h=t+8|0;if((h|0)==(b|0)){l=1;w=41;break}else{j=t;s=v;t=h;u=j}}if((w|0)==41){i=e;return l|0}l=(t+8|0)==(b|0);i=e;return l|0}return 0}function Il(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,
p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0;e=i;f=a;a=b;a:while(1){b=a;g=a+-8|0;h=a+-4|0;j=f;b:while(1){k=j;l=b-k|0;m=l>>3;switch(m|0){case 2:n=4;break a;break;case 4:n=14;break a;break;case 3:n=6;break a;break;case 5:n=15;break a;break;case 1:case 0:n=85;break a;break;default:}if((l|0)<248){n=21;break a}o=(m|0)/2|0;p=j+(o<<3)|0;do if((l|0)>7992){q=(m|0)/4|0;r=j+(q<<3)|0;s=q+o|0;t=j+(s<<3)|0;u=Jl(j,r,p,t,0)|0;v=j+(s<<
3)+4|0;if(!((c[h>>2]|0)>>>0<(c[v>>2]|0)>>>0)){w=j+(o<<3)+4|0;x=u;break}s=t;y=c[s>>2]|0;z=c[s+4>>2]|0;s=g;A=c[s+4>>2]|0;B=t;c[B>>2]=c[s>>2];c[B+4>>2]=A;A=g;c[A>>2]=y;c[A+4>>2]=z;z=j+(o<<3)+4|0;if(!((c[v>>2]|0)>>>0<(c[z>>2]|0)>>>0)){w=z;x=u+1|0;break}v=p;A=c[v>>2]|0;y=c[v+4>>2]|0;v=t;B=c[v+4>>2]|0;s=p;c[s>>2]=c[v>>2];c[s+4>>2]=B;B=t;c[B>>2]=A;c[B+4>>2]=y;y=j+(q<<3)+4|0;if(!((c[z>>2]|0)>>>0<(c[y>>2]|0)>>>0)){w=z;x=u+2|0;break}q=r;B=c[q>>2]|0;A=c[q+4>>2]|0;q=p;t=c[q+4>>2]|0;s=r;c[s>>2]=c[q>>2];c[s+4>>
2]=t;t=p;c[t>>2]=B;c[t+4>>2]=A;if((c[y>>2]|0)>>>0<(c[j+4>>2]|0)>>>0){y=j;A=c[y>>2]|0;t=c[y+4>>2]|0;y=r;B=c[y+4>>2]|0;s=j;c[s>>2]=c[y>>2];c[s+4>>2]=B;B=r;c[B>>2]=A;c[B+4>>2]=t;w=z;x=u+4|0;break}else{w=z;x=u+3|0;break}}else{u=j+(o<<3)+4|0;z=c[u>>2]|0;t=j+4|0;B=(c[h>>2]|0)>>>0<z>>>0;if(!(z>>>0<(c[t>>2]|0)>>>0)){if(!B){w=u;x=0;break}z=p;A=c[z>>2]|0;r=c[z+4>>2]|0;z=g;s=c[z+4>>2]|0;y=p;c[y>>2]=c[z>>2];c[y+4>>2]=s;s=g;c[s>>2]=A;c[s+4>>2]=r;if(!((c[u>>2]|0)>>>0<(c[t>>2]|0)>>>0)){w=u;x=1;break}t=j;r=c[t>>
2]|0;s=c[t+4>>2]|0;t=p;A=c[t+4>>2]|0;y=j;c[y>>2]=c[t>>2];c[y+4>>2]=A;A=p;c[A>>2]=r;c[A+4>>2]=s;w=u;x=2;break}s=j;A=c[s>>2]|0;r=c[s+4>>2]|0;if(B){B=g;s=c[B+4>>2]|0;y=j;c[y>>2]=c[B>>2];c[y+4>>2]=s;s=g;c[s>>2]=A;c[s+4>>2]=r;w=u;x=1;break}s=p;y=c[s+4>>2]|0;B=j;c[B>>2]=c[s>>2];c[B+4>>2]=y;y=p;c[y>>2]=A;c[y+4>>2]=r;if((c[h>>2]|0)>>>0<r>>>0){y=g;B=c[y+4>>2]|0;s=p;c[s>>2]=c[y>>2];c[s+4>>2]=B;B=g;c[B>>2]=A;c[B+4>>2]=r;w=u;x=2}else{w=u;x=1}}while(0);o=j+4|0;m=c[o>>2]|0;l=c[w>>2]|0;do if(m>>>0<l>>>0){C=g;D=
x}else{u=g;while(1){r=u;u=u+-8|0;if((j|0)==(u|0))break;if((c[r+-4>>2]|0)>>>0<l>>>0){n=68;break}}if((n|0)==68){n=0;r=j;B=c[r>>2]|0;A=c[r+4>>2]|0;r=u;s=c[r+4>>2]|0;y=j;c[y>>2]=c[r>>2];c[y+4>>2]=s;s=u;c[s>>2]=B;c[s+4>>2]=A;C=u;D=x+1|0;break}A=j+8|0;if(m>>>0<(c[h>>2]|0)>>>0)E=A;else{if((A|0)==(g|0)){n=85;break a}else F=A;while(1){G=F+8|0;if(m>>>0<(c[F+4>>2]|0)>>>0)break;if((G|0)==(g|0)){n=85;break a}else F=G}u=F;A=c[u>>2]|0;s=c[u+4>>2]|0;u=g;B=c[u+4>>2]|0;y=F;c[y>>2]=c[u>>2];c[y+4>>2]=B;B=g;c[B>>2]=A;
c[B+4>>2]=s;E=G}if((E|0)==(g|0)){n=85;break a}else{H=E;I=g}while(1){s=c[o>>2]|0;B=H;while(1){J=B+8|0;if(s>>>0<(c[B+4>>2]|0)>>>0){K=I;break}else B=J}do{A=K;K=K+-8|0}while(s>>>0<(c[A+-4>>2]|0)>>>0);if(!(B>>>0<K>>>0)){j=B;continue b}s=B;A=c[s>>2]|0;y=c[s+4>>2]|0;s=K;u=c[s+4>>2]|0;r=B;c[r>>2]=c[s>>2];c[r+4>>2]=u;u=K;c[u>>2]=A;c[u+4>>2]=y;H=J;I=K}}while(0);o=j+8|0;c:do if(o>>>0<C>>>0){m=o;l=C;y=p;u=D;while(1){A=c[y+4>>2]|0;r=m;while(1){L=r+8|0;if((c[r+4>>2]|0)>>>0<A>>>0)r=L;else{M=l;break}}do{B=M;M=M+
-8|0}while(!((c[B+-4>>2]|0)>>>0<A>>>0));if(r>>>0>M>>>0){N=r;O=y;P=u;break c}A=r;B=c[A>>2]|0;s=c[A+4>>2]|0;A=M;t=c[A+4>>2]|0;z=r;c[z>>2]=c[A>>2];c[z+4>>2]=t;t=M;c[t>>2]=B;c[t+4>>2]=s;m=L;l=M;y=(y|0)==(r|0)?M:y;u=u+1|0}}else{N=o;O=p;P=D}while(0);if((N|0)!=(O|0)?(c[O+4>>2]|0)>>>0<(c[N+4>>2]|0)>>>0:0){p=N;o=c[p>>2]|0;u=c[p+4>>2]|0;p=O;y=c[p+4>>2]|0;l=N;c[l>>2]=c[p>>2];c[l+4>>2]=y;y=O;c[y>>2]=o;c[y+4>>2]=u;Q=P+1|0}else Q=P;if((Q|0)==0){R=Kl(j,N,0)|0;u=N+8|0;if(Kl(u,a,0)|0){n=80;break}if(R){j=u;continue}}u=
N;if((u-k|0)>=(b-u|0)){n=84;break}Il(j,N,d);j=N+8|0}if((n|0)==80){n=0;if(R){n=85;break}else{f=j;a=N;continue}}else if((n|0)==84){n=0;Il(N+8|0,a,d);f=j;a=N;continue}}if((n|0)==4){if(!((c[h>>2]|0)>>>0<(c[j+4>>2]|0)>>>0)){i=e;return}N=j;f=c[N>>2]|0;d=c[N+4>>2]|0;N=g;R=c[N+4>>2]|0;Q=j;c[Q>>2]=c[N>>2];c[Q+4>>2]=R;R=g;c[R>>2]=f;c[R+4>>2]=d;i=e;return}else if((n|0)==6){d=j+8|0;R=j+12|0;f=c[R>>2]|0;Q=j+4|0;N=(c[h>>2]|0)>>>0<f>>>0;if(!(f>>>0<(c[Q>>2]|0)>>>0)){if(!N){i=e;return}f=d;P=c[f>>2]|0;O=c[f+4>>2]|
0;f=g;D=c[f+4>>2]|0;M=d;c[M>>2]=c[f>>2];c[M+4>>2]=D;D=g;c[D>>2]=P;c[D+4>>2]=O;if(!((c[R>>2]|0)>>>0<(c[Q>>2]|0)>>>0)){i=e;return}Q=j;R=c[Q>>2]|0;O=c[Q+4>>2]|0;Q=d;D=c[Q+4>>2]|0;P=j;c[P>>2]=c[Q>>2];c[P+4>>2]=D;D=d;c[D>>2]=R;c[D+4>>2]=O;i=e;return}O=j;D=c[O>>2]|0;R=c[O+4>>2]|0;if(N){N=g;O=c[N+4>>2]|0;P=j;c[P>>2]=c[N>>2];c[P+4>>2]=O;O=g;c[O>>2]=D;c[O+4>>2]=R;i=e;return}O=d;P=c[O+4>>2]|0;N=j;c[N>>2]=c[O>>2];c[N+4>>2]=P;P=d;c[P>>2]=D;c[P+4>>2]=R;if(!((c[h>>2]|0)>>>0<R>>>0)){i=e;return}P=g;N=c[P+4>>2]|0;
O=d;c[O>>2]=c[P>>2];c[O+4>>2]=N;N=g;c[N>>2]=D;c[N+4>>2]=R;i=e;return}else if((n|0)==14){Jl(j,j+8|0,j+16|0,g,0)|0;i=e;return}else if((n|0)==15){R=j+8|0;N=j+16|0;D=j+24|0;Jl(j,R,N,D,0)|0;O=j+28|0;if(!((c[h>>2]|0)>>>0<(c[O>>2]|0)>>>0)){i=e;return}h=D;P=c[h>>2]|0;d=c[h+4>>2]|0;h=g;Q=c[h+4>>2]|0;M=D;c[M>>2]=c[h>>2];c[M+4>>2]=Q;Q=g;c[Q>>2]=P;c[Q+4>>2]=d;if(!((c[O>>2]|0)>>>0<(c[j+20>>2]|0)>>>0)){i=e;return}O=N;d=c[O>>2]|0;Q=c[O+4>>2]|0;O=D;P=c[O>>2]|0;g=c[O+4>>2]|0;O=N;c[O>>2]=P;c[O+4>>2]=g;O=D;c[O>>2]=
d;c[O+4>>2]=Q;if(!(g>>>0<(c[j+12>>2]|0)>>>0)){i=e;return}Q=R;O=c[Q>>2]|0;d=c[Q+4>>2]|0;Q=R;c[Q>>2]=P;c[Q+4>>2]=g;Q=N;c[Q>>2]=O;c[Q+4>>2]=d;if(!(g>>>0<(c[j+4>>2]|0)>>>0)){i=e;return}d=j;Q=c[d>>2]|0;O=c[d+4>>2]|0;d=j;c[d>>2]=P;c[d+4>>2]=g;g=R;c[g>>2]=Q;c[g+4>>2]=O;i=e;return}else if((n|0)==21){O=j+16|0;g=j+8|0;Q=c[j+12>>2]|0;R=c[j+4>>2]|0;d=c[j+20>>2]|0;P=d>>>0<Q>>>0;do if(Q>>>0<R>>>0){N=j;D=c[N>>2]|0;M=c[N+4>>2]|0;if(P){N=O;h=c[N+4>>2]|0;f=j;c[f>>2]=c[N>>2];c[f+4>>2]=h;h=O;c[h>>2]=D;c[h+4>>2]=M;break}h=
g;f=c[h+4>>2]|0;N=j;c[N>>2]=c[h>>2];c[N+4>>2]=f;f=g;c[f>>2]=D;c[f+4>>2]=M;if(d>>>0<M>>>0){f=O;N=c[f+4>>2]|0;h=g;c[h>>2]=c[f>>2];c[h+4>>2]=N;N=O;c[N>>2]=D;c[N+4>>2]=M}}else if(P?(M=g,N=c[M>>2]|0,D=c[M+4>>2]|0,M=O,h=c[M>>2]|0,f=c[M+4>>2]|0,M=g,c[M>>2]=h,c[M+4>>2]=f,M=O,c[M>>2]=N,c[M+4>>2]=D,f>>>0<R>>>0):0){D=j;M=c[D>>2]|0;N=c[D+4>>2]|0;D=j;c[D>>2]=h;c[D+4>>2]=f;f=g;c[f>>2]=M;c[f+4>>2]=N}while(0);g=j+24|0;if((g|0)==(a|0)){i=e;return}else{S=g;T=O}while(1){if((c[S+4>>2]|0)>>>0<(c[T+4>>2]|0)>>>0){O=S;g=
c[O>>2]|0;R=c[O+4>>2]|0;O=S;P=T;while(1){d=P;Q=c[d+4>>2]|0;N=O;c[N>>2]=c[d>>2];c[N+4>>2]=Q;if((P|0)==(j|0))break;if(R>>>0<(c[P+-4>>2]|0)>>>0){Q=P;P=P+-8|0;O=Q}else break}O=P;c[O>>2]=g;c[O+4>>2]=R}O=S+8|0;if((O|0)==(a|0))break;else{Q=S;S=O;T=Q}}i=e;return}else if((n|0)==85){i=e;return}}function Jl(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;f=i;g=b+4|0;h=c[g>>2]|0;j=a+4|0;k=d+4|0;l=c[k>>2]|0;m=l>>>0<h>>>0;do if(h>>>0<(c[j>>2]|0)>>>0){n=a;
o=c[n>>2]|0;p=c[n+4>>2]|0;if(m){n=d;q=c[n+4>>2]|0;r=a;c[r>>2]=c[n>>2];c[r+4>>2]=q;q=d;c[q>>2]=o;c[q+4>>2]=p;s=1;t=p;break}q=b;r=c[q+4>>2]|0;n=a;c[n>>2]=c[q>>2];c[n+4>>2]=r;r=b;c[r>>2]=o;c[r+4>>2]=p;r=c[k>>2]|0;if(r>>>0<p>>>0){n=d;q=c[n+4>>2]|0;u=b;c[u>>2]=c[n>>2];c[u+4>>2]=q;q=d;c[q>>2]=o;c[q+4>>2]=p;s=2;t=p}else{s=1;t=r}}else if(m){r=b;p=c[r>>2]|0;q=c[r+4>>2]|0;r=d;o=c[r+4>>2]|0;u=b;c[u>>2]=c[r>>2];c[u+4>>2]=o;o=d;c[o>>2]=p;c[o+4>>2]=q;if((c[g>>2]|0)>>>0<(c[j>>2]|0)>>>0){o=a;p=c[o>>2]|0;u=c[o+4>>
2]|0;o=b;r=c[o+4>>2]|0;n=a;c[n>>2]=c[o>>2];c[n+4>>2]=r;r=b;c[r>>2]=p;c[r+4>>2]=u;s=2;t=c[k>>2]|0}else{s=1;t=q}}else{s=0;t=l}while(0);if(!((c[e+4>>2]|0)>>>0<t>>>0)){v=s;i=f;return v|0}t=d;l=c[t>>2]|0;m=c[t+4>>2]|0;t=e;h=c[t+4>>2]|0;q=d;c[q>>2]=c[t>>2];c[q+4>>2]=h;h=e;c[h>>2]=l;c[h+4>>2]=m;if(!((c[k>>2]|0)>>>0<(c[g>>2]|0)>>>0)){v=s+1|0;i=f;return v|0}k=b;m=c[k>>2]|0;h=c[k+4>>2]|0;k=d;l=c[k+4>>2]|0;e=b;c[e>>2]=c[k>>2];c[e+4>>2]=l;l=d;c[l>>2]=m;c[l+4>>2]=h;if(!((c[g>>2]|0)>>>0<(c[j>>2]|0)>>>0)){v=s+2|
0;i=f;return v|0}j=a;g=c[j>>2]|0;h=c[j+4>>2]|0;j=b;l=c[j+4>>2]|0;m=a;c[m>>2]=c[j>>2];c[m+4>>2]=l;l=b;c[l>>2]=g;c[l+4>>2]=h;v=s+3|0;i=f;return v|0}function Kl(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;d=i;switch(b-a>>3|0){case 5:e=a+8|0;f=a+16|0;g=a+24|0;Jl(a,e,f,g,0)|0;h=a+28|0;if(!((c[b+-4>>2]|0)>>>0<(c[h>>2]|0)>>>0)){j=1;i=d;return j|0}k=b+-8|0;l=g;m=c[l>>2]|0;n=c[l+4>>2]|0;l=k;o=c[l+4>>2]|0;p=g;c[p>>2]=c[l>>2];c[p+4>>2]=o;o=k;c[o>>2]=m;c[o+
4>>2]=n;if(!((c[h>>2]|0)>>>0<(c[a+20>>2]|0)>>>0)){j=1;i=d;return j|0}h=f;n=c[h>>2]|0;o=c[h+4>>2]|0;h=g;m=c[h>>2]|0;k=c[h+4>>2]|0;h=f;c[h>>2]=m;c[h+4>>2]=k;h=g;c[h>>2]=n;c[h+4>>2]=o;if(!(k>>>0<(c[a+12>>2]|0)>>>0)){j=1;i=d;return j|0}o=e;h=c[o>>2]|0;n=c[o+4>>2]|0;o=e;c[o>>2]=m;c[o+4>>2]=k;o=f;c[o>>2]=h;c[o+4>>2]=n;if(!(k>>>0<(c[a+4>>2]|0)>>>0)){j=1;i=d;return j|0}n=a;o=c[n>>2]|0;h=c[n+4>>2]|0;n=a;c[n>>2]=m;c[n+4>>2]=k;k=e;c[k>>2]=o;c[k+4>>2]=h;j=1;i=d;return j|0;case 4:Jl(a,a+8|0,a+16|0,b+-8|0,0)|0;
j=1;i=d;return j|0;case 1:case 0:j=1;i=d;return j|0;case 3:h=a+8|0;k=b+-8|0;o=a+12|0;e=c[o>>2]|0;n=a+4|0;m=b+-4|0;f=(c[m>>2]|0)>>>0<e>>>0;if(!(e>>>0<(c[n>>2]|0)>>>0)){if(!f){j=1;i=d;return j|0}e=h;g=c[e>>2]|0;p=c[e+4>>2]|0;e=k;l=c[e+4>>2]|0;q=h;c[q>>2]=c[e>>2];c[q+4>>2]=l;l=k;c[l>>2]=g;c[l+4>>2]=p;if(!((c[o>>2]|0)>>>0<(c[n>>2]|0)>>>0)){j=1;i=d;return j|0}n=a;o=c[n>>2]|0;p=c[n+4>>2]|0;n=h;l=c[n+4>>2]|0;g=a;c[g>>2]=c[n>>2];c[g+4>>2]=l;l=h;c[l>>2]=o;c[l+4>>2]=p;j=1;i=d;return j|0}p=a;l=c[p>>2]|0;o=c[p+
4>>2]|0;if(f){f=k;p=c[f+4>>2]|0;g=a;c[g>>2]=c[f>>2];c[g+4>>2]=p;p=k;c[p>>2]=l;c[p+4>>2]=o;j=1;i=d;return j|0}p=h;g=c[p+4>>2]|0;f=a;c[f>>2]=c[p>>2];c[f+4>>2]=g;g=h;c[g>>2]=l;c[g+4>>2]=o;if(!((c[m>>2]|0)>>>0<o>>>0)){j=1;i=d;return j|0}m=k;g=c[m+4>>2]|0;f=h;c[f>>2]=c[m>>2];c[f+4>>2]=g;g=k;c[g>>2]=l;c[g+4>>2]=o;j=1;i=d;return j|0;case 2:if(!((c[b+-4>>2]|0)>>>0<(c[a+4>>2]|0)>>>0)){j=1;i=d;return j|0}o=b+-8|0;g=a;l=c[g>>2]|0;k=c[g+4>>2]|0;g=o;f=c[g+4>>2]|0;m=a;c[m>>2]=c[g>>2];c[m+4>>2]=f;f=o;c[f>>2]=l;
c[f+4>>2]=k;j=1;i=d;return j|0;default:k=a+16|0;f=a+8|0;l=c[a+12>>2]|0;o=c[a+4>>2]|0;m=c[a+20>>2]|0;g=m>>>0<l>>>0;do if(l>>>0<o>>>0){h=a;p=c[h>>2]|0;n=c[h+4>>2]|0;if(g){h=k;q=c[h+4>>2]|0;e=a;c[e>>2]=c[h>>2];c[e+4>>2]=q;q=k;c[q>>2]=p;c[q+4>>2]=n;break}q=f;e=c[q+4>>2]|0;h=a;c[h>>2]=c[q>>2];c[h+4>>2]=e;e=f;c[e>>2]=p;c[e+4>>2]=n;if(m>>>0<n>>>0){e=k;h=c[e+4>>2]|0;q=f;c[q>>2]=c[e>>2];c[q+4>>2]=h;h=k;c[h>>2]=p;c[h+4>>2]=n}}else if(g?(n=f,h=c[n>>2]|0,p=c[n+4>>2]|0,n=k,q=c[n>>2]|0,e=c[n+4>>2]|0,n=f,c[n>>2]=
q,c[n+4>>2]=e,n=k,c[n>>2]=h,c[n+4>>2]=p,e>>>0<o>>>0):0){p=a;n=c[p>>2]|0;h=c[p+4>>2]|0;p=a;c[p>>2]=q;c[p+4>>2]=e;e=f;c[e>>2]=n;c[e+4>>2]=h}while(0);f=a+24|0;if((f|0)==(b|0)){j=1;i=d;return j|0}else{r=0;s=f;t=k}while(1){if((c[s+4>>2]|0)>>>0<(c[t+4>>2]|0)>>>0){k=s;f=c[k>>2]|0;o=c[k+4>>2]|0;k=s;g=t;while(1){m=g;l=c[m+4>>2]|0;h=k;c[h>>2]=c[m>>2];c[h+4>>2]=l;if((g|0)==(a|0))break;if(o>>>0<(c[g+-4>>2]|0)>>>0){l=g;g=g+-8|0;k=l}else break}k=g;c[k>>2]=f;c[k+4>>2]=o;k=r+1|0;if((k|0)==8)break;else u=k}else u=
r;k=s+8|0;if((k|0)==(b|0)){j=1;v=34;break}else{l=s;r=u;s=k;t=l}}if((v|0)==34){i=d;return j|0}j=(s+8|0)==(b|0);i=d;return j|0}return 0}function Ll(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;h=i;i=i+64|0;j=h;if((e|0)==2){k=b+-60|0;if(!(nb[c[d>>2]&31](k,a)|0)){i=h;return}l=j+0|0;m=a+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));l=a+0|0;m=k+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|
0));l=k+0|0;m=j+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));i=h;return}else if((e|0)==1|(e|0)==0){i=h;return}else{if((e|0)<129){if((a|0)==(b|0)){i=h;return}k=a+60|0;if((k|0)==(b|0)){i=h;return}o=k;do{l=j+0|0;m=o+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));a:do if((o|0)==(a|0))p=a;else{k=o;while(1){q=k;k=k+-60|0;if(!(nb[c[d>>2]&31](j,k)|0)){p=q;break a}l=q+0|0;m=k+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));if((k|0)==(a|0)){p=a;break}}}while(0);
l=p+0|0;m=j+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));o=o+60|0}while((o|0)!=(b|0));i=h;return}o=(e|0)/2|0;j=a+(o*60|0)|0;if((e|0)>(g|0)){Ll(a,j,d,o,f,g);p=e-o|0;Ll(j,b,d,p,f,g);Nl(a,j,b,d,o,p,f,g);i=h;return}Ml(a,j,d,o,f);g=f+(o*60|0)|0;Ml(j,b,d,e-o|0,g);o=f+(e*60|0)|0;b:do if((e+1|0)>>>0<3){r=a;s=g}else{b=a;j=f;p=g;while(1){if((p|0)==(o|0))break;if(nb[c[d>>2]&31](p,j)|0){l=b+0|0;m=p+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));t=p+60|0;u=j}else{l=b+
0|0;m=j+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));t=p;u=j+60|0}k=b+60|0;if((u|0)==(g|0)){r=k;s=t;break b}else{b=k;j=u;p=t}}if((j|0)==(g|0)){i=h;return}else{v=j;w=b}while(1){l=w+0|0;m=v+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));v=v+60|0;if((v|0)==(g|0))break;else w=w+60|0}i=h;return}while(0);if((s|0)==(o|0)){i=h;return}else{x=r;y=s}while(1){l=x+0|0;m=y+0|0;n=l+60|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));y=y+60|0;if((y|0)==(o|0))break;
else x=x+60|0}i=h;return}}function Ml(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;g=i;if((e|0)==1){if((f|0)==0){i=g;return}h=f+0|0;j=a+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0));i=g;return}else if((e|0)==2){l=b+-60|0;m=(f|0)==0;if(nb[c[d>>2]&31](l,a)|0){if(!m){h=f+0|0;j=l+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}h=f+60|0;j=a+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|
0)<(k|0));i=g;return}else{if(!m){h=f+0|0;j=a+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}h=f+60|0;j=l+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0));i=g;return}}else if((e|0)==0){i=g;return}else{if((e|0)<9){if((a|0)==(b|0)){i=g;return}if((f|0)==0)n=0;else{h=f+0|0;j=a+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0));n=f}l=a+60|0;if((l|0)==(b|0)){i=g;return}else{o=l;p=n}do{n=p;p=p+60|0;if(nb[c[d>>2]&31](o,n)|0){h=p+0|0;j=n+0|0;k=h+60|0;do{c[h>>
2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0));a:do if((n|0)==(f|0))q=f;else{l=n;while(1){m=l;l=l+-60|0;if(!(nb[c[d>>2]&31](o,l)|0)){q=m;break a}h=m+0|0;j=l+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0));if((l|0)==(f|0)){q=f;break}}}while(0);h=q+0|0;j=o+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}else{h=p+0|0;j=o+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}o=o+60|0}while((o|0)!=(b|0));i=g;return}o=(e|0)/2|0;p=a+(o*60|0)|0;Ll(a,p,d,o,
f,o);q=e-o|0;Ll(p,b,d,q,f+(o*60|0)|0,q);b:do if((e+1|0)>>>0<3){r=p;s=f}else{q=p;o=a;n=f;while(1){if((q|0)==(b|0))break;l=(n|0)==0;if(nb[c[d>>2]&31](q,o)|0){if(!l){h=n+0|0;j=q+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}t=o;u=q+60|0}else{if(!l){h=n+0|0;j=o+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}t=o+60|0;u=q}l=n+60|0;if((t|0)==(p|0)){r=u;s=l;break b}else{q=u;o=t;n=l}}if((o|0)==(p|0)){i=g;return}else{v=o;w=n}while(1){if((w|0)!=0){h=w+0|0;j=v+0|0;k=h+
60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}v=v+60|0;if((v|0)==(p|0))break;else w=w+60|0}i=g;return}while(0);if((r|0)==(b|0)){i=g;return}else{x=r;y=s}while(1){if((y|0)!=0){h=y+0|0;j=x+0|0;k=h+60|0;do{c[h>>2]=c[j>>2];h=h+4|0;j=j+4|0}while((h|0)<(k|0))}x=x+60|0;if((x|0)==(b|0))break;else y=y+60|0}i=g;return}}function Nl(a,b,d,e,f,g,h,j){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;var k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=
0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0;k=i;i=i+64|0;l=k;if((g|0)==0){i=k;return}m=a;a=b;b=d;d=f;f=g;a:while(1){g=b;n=a;o=d;p=m;q=f;while(1){if((o|0)==0){r=45;break a}else{s=p;t=o}while(1){if(nb[c[e>>2]&31](n,s)|0)break;u=t+-1|0;if((u|0)==0){r=45;break a}else{s=s+60|0;t=u}}if(!((t|0)>(j|0)&(q|0)>(j|0))){r=8;break a}if((t|0)<(q|0)){u=(q|0)/2|0;v=n+(u*60|0)|0;w=s;x=s;y=(n-w|0)/60|0;b:while(1){z=y;while(1){if((z|0)==0)break b;A=(z|0)/2|0;if(nb[c[e>>2]&31](v,x+(A*60|0)|0)|0)z=A;else break}x=
x+((A+1|0)*60|0)|0;y=z+-1-A|0}B=x;C=v;D=(x-w|0)/60|0;E=u}else{if((t|0)==1){r=17;break a}y=(t|0)/2|0;F=s+(y*60|0)|0;G=n;H=n;I=(g-G|0)/60|0;c:while(1){J=I;while(1){if((J|0)==0)break c;K=(J|0)/2|0;if(nb[c[e>>2]&31](H+(K*60|0)|0,F)|0)break;else J=K}H=H+((K+1|0)*60|0)|0;I=J+-1-K|0}B=F;C=H;D=y;E=(H-G|0)/60|0}o=t-D|0;L=q-E|0;d:do if((B|0)!=(n|0))if((n|0)==(C|0))M=B;else{if((B+60|0)==(n|0)){N=l+0|0;O=B+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));J=C-n|0;Bn(B|0,n|0,J|0)|0;I=B+(((J|0)/
60|0)*60|0)|0;N=I+0|0;O=l+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));M=I;break}if((n+60|0)==(C|0)){J=C+-60|0;N=l+0|0;O=J+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));I=J-B|0;u=C+(((I|0)/-60|0)*60|0)|0;Bn(u|0,B|0,I|0)|0;N=B+0|0;O=l+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));M=u;break}J=n;I=(J-B|0)/60|0;w=C;x=(w-J|0)/60|0;if((I|0)==(x|0)){J=B;v=n;while(1){N=l+0|0;O=J+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|
0));N=J+0|0;O=v+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));N=v+0|0;O=l+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));J=J+60|0;if((J|0)==(n|0)){M=n;break d}else v=v+60|0}}else{Q=I;R=x}while(1){v=(Q|0)%(R|0)|0;if((v|0)==0)break;else{J=R;R=v;Q=J}}if((R|0)!=0){J=I+-1|0;v=B+(R*60|0)|0;do{u=v;v=v+-60|0;N=l+0|0;O=v+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));z=v;S=u+(J*60|0)|0;while(1){N=z+0|0;O=S+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;
O=O+4|0}while((N|0)<(P|0));T=(w-S|0)/60|0;if((I|0)<(T|0))U=S+(I*60|0)|0;else U=B+((I-T|0)*60|0)|0;if((U|0)==(v|0))break;else{T=S;S=U;z=T}}N=S+0|0;O=l+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0))}while((v|0)!=(B|0))}M=B+(x*60|0)|0}else M=C;while(0);if((E+D|0)>=(L+o|0))break;Nl(s,B,M,e,D,E,h,j);if((q|0)==(E|0)){r=45;break a}else{n=C;p=M;q=L}}Nl(M,C,b,e,o,L,h,j);if((E|0)==0){r=45;break}else{m=s;a=B;b=M;d=D;f=E}}if((r|0)==8){Ol(s,n,b,e,t,q,h);i=k;return}else if((r|0)==17){N=l+0|
0;O=s+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));N=s+0|0;O=n+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));N=n+0|0;O=l+0|0;P=N+60|0;do{c[N>>2]=c[O>>2];N=N+4|0;O=O+4|0}while((N|0)<(P|0));i=k;return}else if((r|0)==45){i=k;return}}function Ol(a,b,d,e,f,g,h){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0;j=i;k=a;l=b;if((f|0)<=(g|0)){a:do if((a|0)!=(b|0)){g=(((b+-60+(0-
k)|0)>>>0)/60|0)+1|0;f=a;m=h;while(1){if((m|0)!=0){n=m+0|0;o=f+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0))}f=f+60|0;if((f|0)==(b|0))break;else m=m+60|0}m=h+(g*60|0)|0;if((m|0)!=(h|0)){f=a;q=b;r=h;while(1){if((q|0)==(d|0))break;if(nb[c[e>>2]&31](q,r)|0){n=f+0|0;o=q+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0));s=r;t=q+60|0}else{n=f+0|0;o=r+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0));s=r+60|0;t=q}u=f+60|0;if((s|0)==(m|0)){v=u;w=t;break a}else{f=
u;q=t;r=s}}Bn(f|0,r|0,m-r|0)|0;i=j;return}else{v=a;w=b}}else{v=a;w=b}while(0);Bn(v|0,w|0,d-w|0)|0;i=j;return}if((b|0)==(d|0))x=h;else{w=(((d+-60+(0-l)|0)>>>0)/60|0)+1|0;l=b;v=h;while(1){if((v|0)!=0){n=v+0|0;o=l+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0))}l=l+60|0;if((l|0)==(d|0))break;else v=v+60|0}x=h+(w*60|0)|0}w=x;b:do if((b|0)==(a|0)){y=w;z=d}else{v=w;l=b;r=x;m=d;while(1){if((v|0)==(h|0))break;f=r+-60|0;s=l+-60|0;t=m+-60|0;if(nb[c[e>>2]&31](f,s)|0){n=t+0|0;o=s+0|0;p=n+60|
0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0));A=s;B=r}else{n=t+0|0;o=f+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0));A=l;B=f}s=B;if((A|0)==(a|0)){y=s;z=t;break b}else{v=s;l=A;r=B;m=t}}if((l|0)==(a|0)){i=j;return}else{C=m;D=l}do{C=C+-60|0;D=D+-60|0;n=C+0|0;o=D+0|0;p=n+60|0;do{c[n>>2]=c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0))}while((D|0)!=(a|0));i=j;return}while(0);a=y;if((a|0)==(h|0)){i=j;return}else{E=z;F=a}do{E=E+-60|0;F=F+-60|0;n=E+0|0;o=F+0|0;p=n+60|0;do{c[n>>2]=
c[o>>2];n=n+4|0;o=o+4|0}while((n|0)<(p|0))}while((F|0)!=(h|0));i=j;return}function Pl(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;h=i;i=i+32|0;j=h;if((e|0)==2){k=b+-20|0;if(!(nb[c[d>>2]&31](k,a)|0)){i=h;return}c[j+0>>2]=c[a+0>>2];c[j+4>>2]=c[a+4>>2];c[j+8>>2]=c[a+8>>2];c[j+12>>2]=c[a+12>>2];c[j+16>>2]=c[a+16>>2];c[a+0>>2]=c[k+0>>2];c[a+4>>2]=c[k+4>>2];c[a+8>>2]=c[k+8>>2];c[a+12>>2]=c[k+12>>2];c[a+16>>2]=c[k+16>>2];c[k+0>>2]=c[j+0>>2];
c[k+4>>2]=c[j+4>>2];c[k+8>>2]=c[j+8>>2];c[k+12>>2]=c[j+12>>2];c[k+16>>2]=c[j+16>>2];i=h;return}else if((e|0)==1|(e|0)==0){i=h;return}else{if((e|0)<129){if((a|0)==(b|0)){i=h;return}k=a+20|0;if((k|0)==(b|0)){i=h;return}else l=k;do{c[j+0>>2]=c[l+0>>2];c[j+4>>2]=c[l+4>>2];c[j+8>>2]=c[l+8>>2];c[j+12>>2]=c[l+12>>2];c[j+16>>2]=c[l+16>>2];a:do if((l|0)==(a|0))m=a;else{k=l;while(1){n=k;k=k+-20|0;if(!(nb[c[d>>2]&31](j,k)|0)){m=n;break a}c[n+0>>2]=c[k+0>>2];c[n+4>>2]=c[k+4>>2];c[n+8>>2]=c[k+8>>2];c[n+12>>2]=
c[k+12>>2];c[n+16>>2]=c[k+16>>2];if((k|0)==(a|0)){m=a;break}}}while(0);c[m+0>>2]=c[j+0>>2];c[m+4>>2]=c[j+4>>2];c[m+8>>2]=c[j+8>>2];c[m+12>>2]=c[j+12>>2];c[m+16>>2]=c[j+16>>2];l=l+20|0}while((l|0)!=(b|0));i=h;return}l=(e|0)/2|0;j=a+(l*20|0)|0;if((e|0)>(g|0)){Pl(a,j,d,l,f,g);m=e-l|0;Pl(j,b,d,m,f,g);Rl(a,j,b,d,l,m,f,g);i=h;return}Ql(a,j,d,l,f);g=f+(l*20|0)|0;Ql(j,b,d,e-l|0,g);l=f+(e*20|0)|0;b:do if((e+1|0)>>>0<3){o=a;p=g}else{b=a;j=f;m=g;while(1){if((m|0)==(l|0))break;if(nb[c[d>>2]&31](m,j)|0){c[b+0>>
2]=c[m+0>>2];c[b+4>>2]=c[m+4>>2];c[b+8>>2]=c[m+8>>2];c[b+12>>2]=c[m+12>>2];c[b+16>>2]=c[m+16>>2];q=m+20|0;r=j}else{c[b+0>>2]=c[j+0>>2];c[b+4>>2]=c[j+4>>2];c[b+8>>2]=c[j+8>>2];c[b+12>>2]=c[j+12>>2];c[b+16>>2]=c[j+16>>2];q=m;r=j+20|0}k=b+20|0;if((r|0)==(g|0)){o=k;p=q;break b}else{b=k;j=r;m=q}}if((j|0)==(g|0)){i=h;return}else{s=j;t=b}while(1){c[t+0>>2]=c[s+0>>2];c[t+4>>2]=c[s+4>>2];c[t+8>>2]=c[s+8>>2];c[t+12>>2]=c[s+12>>2];c[t+16>>2]=c[s+16>>2];s=s+20|0;if((s|0)==(g|0))break;else t=t+20|0}i=h;return}while(0);
if((p|0)==(l|0)){i=h;return}else{u=o;v=p}while(1){c[u+0>>2]=c[v+0>>2];c[u+4>>2]=c[v+4>>2];c[u+8>>2]=c[v+8>>2];c[u+12>>2]=c[v+12>>2];c[u+16>>2]=c[v+16>>2];v=v+20|0;if((v|0)==(l|0))break;else u=u+20|0}i=h;return}}function Ql(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;g=i;if((e|0)==1){if((f|0)==0){i=g;return}c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];i=g;return}else if((e|0)==
0){i=g;return}else if((e|0)==2){h=b+-20|0;j=(f|0)==0;if(nb[c[d>>2]&31](h,a)|0){if(!j){c[f+0>>2]=c[h+0>>2];c[f+4>>2]=c[h+4>>2];c[f+8>>2]=c[h+8>>2];c[f+12>>2]=c[h+12>>2];c[f+16>>2]=c[h+16>>2]}k=f+20|0;c[k+0>>2]=c[a+0>>2];c[k+4>>2]=c[a+4>>2];c[k+8>>2]=c[a+8>>2];c[k+12>>2]=c[a+12>>2];c[k+16>>2]=c[a+16>>2];i=g;return}else{if(!j){c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2]}j=f+20|0;c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+
12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];i=g;return}}else{if((e|0)<9){if((a|0)==(b|0)){i=g;return}if((f|0)==0)l=0;else{c[f+0>>2]=c[a+0>>2];c[f+4>>2]=c[a+4>>2];c[f+8>>2]=c[a+8>>2];c[f+12>>2]=c[a+12>>2];c[f+16>>2]=c[a+16>>2];l=f}h=a+20|0;if((h|0)==(b|0)){i=g;return}else{m=h;n=l}do{l=n;n=n+20|0;if(nb[c[d>>2]&31](m,l)|0){c[n+0>>2]=c[l+0>>2];c[n+4>>2]=c[l+4>>2];c[n+8>>2]=c[l+8>>2];c[n+12>>2]=c[l+12>>2];c[n+16>>2]=c[l+16>>2];a:do if((l|0)==(f|0))o=f;else{h=l;while(1){j=h;h=h+-20|0;if(!(nb[c[d>>2]&31](m,
h)|0)){o=j;break a}c[j+0>>2]=c[h+0>>2];c[j+4>>2]=c[h+4>>2];c[j+8>>2]=c[h+8>>2];c[j+12>>2]=c[h+12>>2];c[j+16>>2]=c[h+16>>2];if((h|0)==(f|0)){o=f;break}}}while(0);c[o+0>>2]=c[m+0>>2];c[o+4>>2]=c[m+4>>2];c[o+8>>2]=c[m+8>>2];c[o+12>>2]=c[m+12>>2];c[o+16>>2]=c[m+16>>2]}else{c[n+0>>2]=c[m+0>>2];c[n+4>>2]=c[m+4>>2];c[n+8>>2]=c[m+8>>2];c[n+12>>2]=c[m+12>>2];c[n+16>>2]=c[m+16>>2]}m=m+20|0}while((m|0)!=(b|0));i=g;return}m=(e|0)/2|0;n=a+(m*20|0)|0;Pl(a,n,d,m,f,m);o=e-m|0;Pl(n,b,d,o,f+(m*20|0)|0,o);b:do if((e+
1|0)>>>0<3){p=n;q=f}else{o=n;m=a;l=f;while(1){if((o|0)==(b|0))break;h=(l|0)==0;if(nb[c[d>>2]&31](o,m)|0){if(!h){c[l+0>>2]=c[o+0>>2];c[l+4>>2]=c[o+4>>2];c[l+8>>2]=c[o+8>>2];c[l+12>>2]=c[o+12>>2];c[l+16>>2]=c[o+16>>2]}r=m;s=o+20|0}else{if(!h){c[l+0>>2]=c[m+0>>2];c[l+4>>2]=c[m+4>>2];c[l+8>>2]=c[m+8>>2];c[l+12>>2]=c[m+12>>2];c[l+16>>2]=c[m+16>>2]}r=m+20|0;s=o}h=l+20|0;if((r|0)==(n|0)){p=s;q=h;break b}else{o=s;m=r;l=h}}if((m|0)==(n|0)){i=g;return}else{t=m;u=l}while(1){if((u|0)!=0){c[u+0>>2]=c[t+0>>2];
c[u+4>>2]=c[t+4>>2];c[u+8>>2]=c[t+8>>2];c[u+12>>2]=c[t+12>>2];c[u+16>>2]=c[t+16>>2]}t=t+20|0;if((t|0)==(n|0))break;else u=u+20|0}i=g;return}while(0);if((p|0)==(b|0)){i=g;return}else{v=p;w=q}while(1){if((w|0)!=0){c[w+0>>2]=c[v+0>>2];c[w+4>>2]=c[v+4>>2];c[w+8>>2]=c[v+8>>2];c[w+12>>2]=c[v+12>>2];c[w+16>>2]=c[v+16>>2]}v=v+20|0;if((v|0)==(b|0))break;else w=w+20|0}i=g;return}}function Rl(a,b,d,e,f,g,h,j){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;j=j|0;var k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,
w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0;k=i;i=i+48|0;l=k+20|0;m=k;if((g|0)==0){i=k;return}n=a;a=b;b=d;d=f;f=g;a:while(1){g=b;o=a;p=d;q=n;r=f;while(1){if((p|0)==0){s=45;break a}else{t=q;u=p}while(1){if(nb[c[e>>2]&31](o,t)|0)break;v=u+-1|0;if((v|0)==0){s=45;break a}else{t=t+20|0;u=v}}if(!((u|0)>(j|0)&(r|0)>(j|0))){s=8;break a}if((u|0)<(r|0)){v=(r|0)/2|0;w=o+(v*20|0)|0;x=t;y=t;z=(o-x|0)/20|0;b:while(1){A=z;while(1){if((A|0)==0)break b;B=(A|0)/2|0;if(nb[c[e>>
2]&31](w,y+(B*20|0)|0)|0)A=B;else break}y=y+((B+1|0)*20|0)|0;z=A+-1-B|0}C=y;D=w;E=(y-x|0)/20|0;F=v}else{if((u|0)==1){s=17;break a}z=(u|0)/2|0;G=t+(z*20|0)|0;H=o;I=o;J=(g-H|0)/20|0;c:while(1){K=J;while(1){if((K|0)==0)break c;L=(K|0)/2|0;if(nb[c[e>>2]&31](I+(L*20|0)|0,G)|0)break;else K=L}I=I+((L+1|0)*20|0)|0;J=K+-1-L|0}C=G;D=I;E=z;F=(I-H|0)/20|0}p=u-E|0;M=r-F|0;d:do if((C|0)!=(o|0))if((o|0)==(D|0))N=C;else{if((C+20|0)==(o|0)){c[l+0>>2]=c[C+0>>2];c[l+4>>2]=c[C+4>>2];c[l+8>>2]=c[C+8>>2];c[l+12>>2]=c[C+
12>>2];c[l+16>>2]=c[C+16>>2];J=D-o|0;Bn(C|0,o|0,J|0)|0;v=C+(((J|0)/20|0)*20|0)|0;c[v+0>>2]=c[l+0>>2];c[v+4>>2]=c[l+4>>2];c[v+8>>2]=c[l+8>>2];c[v+12>>2]=c[l+12>>2];c[v+16>>2]=c[l+16>>2];N=v;break}if((o+20|0)==(D|0)){v=D+-20|0;c[l+0>>2]=c[v+0>>2];c[l+4>>2]=c[v+4>>2];c[l+8>>2]=c[v+8>>2];c[l+12>>2]=c[v+12>>2];c[l+16>>2]=c[v+16>>2];J=v-C|0;v=D+(((J|0)/-20|0)*20|0)|0;Bn(v|0,C|0,J|0)|0;c[C+0>>2]=c[l+0>>2];c[C+4>>2]=c[l+4>>2];c[C+8>>2]=c[l+8>>2];c[C+12>>2]=c[l+12>>2];c[C+16>>2]=c[l+16>>2];N=v;break}v=o;J=
(v-C|0)/20|0;x=D;y=(x-v|0)/20|0;if((J|0)==(y|0)){v=C;w=o;while(1){c[l+0>>2]=c[v+0>>2];c[l+4>>2]=c[v+4>>2];c[l+8>>2]=c[v+8>>2];c[l+12>>2]=c[v+12>>2];c[l+16>>2]=c[v+16>>2];c[v+0>>2]=c[w+0>>2];c[v+4>>2]=c[w+4>>2];c[v+8>>2]=c[w+8>>2];c[v+12>>2]=c[w+12>>2];c[v+16>>2]=c[w+16>>2];c[w+0>>2]=c[l+0>>2];c[w+4>>2]=c[l+4>>2];c[w+8>>2]=c[l+8>>2];c[w+12>>2]=c[l+12>>2];c[w+16>>2]=c[l+16>>2];v=v+20|0;if((v|0)==(o|0)){N=o;break d}else w=w+20|0}}else{O=J;P=y}while(1){w=(O|0)%(P|0)|0;if((w|0)==0)break;else{v=P;P=w;O=
v}}if((P|0)!=0){v=J+-1|0;w=C+(P*20|0)|0;do{K=w;w=w+-20|0;c[m+0>>2]=c[w+0>>2];c[m+4>>2]=c[w+4>>2];c[m+8>>2]=c[w+8>>2];c[m+12>>2]=c[w+12>>2];c[m+16>>2]=c[w+16>>2];A=w;Q=K+(v*20|0)|0;while(1){c[A+0>>2]=c[Q+0>>2];c[A+4>>2]=c[Q+4>>2];c[A+8>>2]=c[Q+8>>2];c[A+12>>2]=c[Q+12>>2];c[A+16>>2]=c[Q+16>>2];K=(x-Q|0)/20|0;if((J|0)<(K|0))R=Q+(J*20|0)|0;else R=C+((J-K|0)*20|0)|0;if((R|0)==(w|0))break;else{K=Q;Q=R;A=K}}c[Q+0>>2]=c[m+0>>2];c[Q+4>>2]=c[m+4>>2];c[Q+8>>2]=c[m+8>>2];c[Q+12>>2]=c[m+12>>2];c[Q+16>>2]=c[m+
16>>2]}while((w|0)!=(C|0))}N=C+(y*20|0)|0}else N=D;while(0);if((F+E|0)>=(M+p|0))break;Rl(t,C,N,e,E,F,h,j);if((r|0)==(F|0)){s=45;break a}else{o=D;q=N;r=M}}Rl(N,D,b,e,p,M,h,j);if((F|0)==0){s=45;break}else{n=t;a=C;b=N;d=E;f=F}}if((s|0)==8){Sl(t,o,b,e,u,r,h);i=k;return}else if((s|0)==17){c[l+0>>2]=c[t+0>>2];c[l+4>>2]=c[t+4>>2];c[l+8>>2]=c[t+8>>2];c[l+12>>2]=c[t+12>>2];c[l+16>>2]=c[t+16>>2];c[t+0>>2]=c[o+0>>2];c[t+4>>2]=c[o+4>>2];c[t+8>>2]=c[o+8>>2];c[t+12>>2]=c[o+12>>2];c[t+16>>2]=c[o+16>>2];c[o+0>>2]=
c[l+0>>2];c[o+4>>2]=c[l+4>>2];c[o+8>>2]=c[l+8>>2];c[o+12>>2]=c[l+12>>2];c[o+16>>2]=c[l+16>>2];i=k;return}else if((s|0)==45){i=k;return}}function Sl(a,b,d,e,f,g,h){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;j=i;k=a;l=b;if((f|0)<=(g|0)){a:do if((a|0)!=(b|0)){g=(((b+-20+(0-k)|0)>>>0)/20|0)+1|0;f=a;m=h;while(1){if((m|0)!=0){c[m+0>>2]=c[f+0>>2];c[m+4>>2]=c[f+4>>2];c[m+8>>2]=c[f+8>>2];c[m+12>>2]=c[f+12>>2];c[m+16>>2]=c[f+
16>>2]}f=f+20|0;if((f|0)==(b|0))break;else m=m+20|0}m=h+(g*20|0)|0;if((m|0)!=(h|0)){f=a;n=b;o=h;while(1){if((n|0)==(d|0))break;if(nb[c[e>>2]&31](n,o)|0){c[f+0>>2]=c[n+0>>2];c[f+4>>2]=c[n+4>>2];c[f+8>>2]=c[n+8>>2];c[f+12>>2]=c[n+12>>2];c[f+16>>2]=c[n+16>>2];p=o;q=n+20|0}else{c[f+0>>2]=c[o+0>>2];c[f+4>>2]=c[o+4>>2];c[f+8>>2]=c[o+8>>2];c[f+12>>2]=c[o+12>>2];c[f+16>>2]=c[o+16>>2];p=o+20|0;q=n}r=f+20|0;if((p|0)==(m|0)){s=r;t=q;break a}else{f=r;n=q;o=p}}Bn(f|0,o|0,m-o|0)|0;i=j;return}else{s=a;t=b}}else{s=
a;t=b}while(0);Bn(s|0,t|0,d-t|0)|0;i=j;return}if((b|0)==(d|0))u=h;else{t=(((d+-20+(0-l)|0)>>>0)/20|0)+1|0;l=b;s=h;while(1){if((s|0)!=0){c[s+0>>2]=c[l+0>>2];c[s+4>>2]=c[l+4>>2];c[s+8>>2]=c[l+8>>2];c[s+12>>2]=c[l+12>>2];c[s+16>>2]=c[l+16>>2]}l=l+20|0;if((l|0)==(d|0))break;else s=s+20|0}u=h+(t*20|0)|0}t=u;b:do if((b|0)==(a|0)){v=t;w=d}else{s=t;l=b;p=u;q=d;while(1){if((s|0)==(h|0))break;k=p+-20|0;n=l+-20|0;g=q+-20|0;if(nb[c[e>>2]&31](k,n)|0){c[g+0>>2]=c[n+0>>2];c[g+4>>2]=c[n+4>>2];c[g+8>>2]=c[n+8>>2];
c[g+12>>2]=c[n+12>>2];c[g+16>>2]=c[n+16>>2];x=n;y=p}else{c[g+0>>2]=c[k+0>>2];c[g+4>>2]=c[k+4>>2];c[g+8>>2]=c[k+8>>2];c[g+12>>2]=c[k+12>>2];c[g+16>>2]=c[k+16>>2];x=l;y=k}k=y;if((x|0)==(a|0)){v=k;w=g;break b}else{s=k;l=x;p=y;q=g}}if((l|0)==(a|0)){i=j;return}else{z=q;A=l}do{z=z+-20|0;A=A+-20|0;c[z+0>>2]=c[A+0>>2];c[z+4>>2]=c[A+4>>2];c[z+8>>2]=c[A+8>>2];c[z+12>>2]=c[A+12>>2];c[z+16>>2]=c[A+16>>2]}while((A|0)!=(a|0));i=j;return}while(0);a=v;if((a|0)==(h|0)){i=j;return}else{B=w;C=a}do{B=B+-20|0;C=C+-20|
0;c[B+0>>2]=c[C+0>>2];c[B+4>>2]=c[C+4>>2];c[B+8>>2]=c[C+8>>2];c[B+12>>2]=c[C+12>>2];c[B+16>>2]=c[C+16>>2]}while((C|0)!=(h|0));i=j;return}function Tl(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0;b=i;d=a+4|0;e=c[d>>2]|0;if((e|0)!=(a|0)){f=e;do{e=Sm(f)|0;g=c[e>>2]|0;if((g|0)!=0){h=0;j=e+32|0;while(1){k=j+4|0;c[(c[j>>2]|0)+4>>2]=c[k>>2];c[c[k>>2]>>2]=c[j>>2];c[k>>2]=j;c[j>>2]=j;h=h+1|0;if((h|0)==(g|0))break;else j=j+12|0}}Um(a,e);f=c[d>>2]|0}while((f|0)!=(a|0))}f=a+12|0;j=a+20|0;g=a+24|0;c[(c[j>>2]|0)+
4>>2]=c[g>>2];c[c[g>>2]>>2]=c[j>>2];c[g>>2]=j;c[j>>2]=j;j=a+16|0;c[(c[f>>2]|0)+4>>2]=c[j>>2];c[c[j>>2]>>2]=c[f>>2];c[j>>2]=f;c[f>>2]=f;Vm(a);c[(c[a>>2]|0)+4>>2]=c[d>>2];c[c[d>>2]>>2]=c[a>>2];c[d>>2]=a;c[a>>2]=a;i=b;return}function Ul(a){a=a|0;return}function Vl(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Wl(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;e=i;i=i+48|0;f=e+24|0;g=e;if((a[d+38>>0]|0)!=0){i=e;return 1}h=c[d+12>>2]|0;j=bb[c[(c[h>>2]|0)+12>>2]&
7](h)|0;if((j|0)<=0){i=e;return 1}h=d+24|0;k=b+4|0;l=g+16|0;m=g+20|0;n=g+4|0;o=0;do{p=(c[h>>2]|0)+(o*28|0)|0;c[f+0>>2]=c[p+0>>2];c[f+4>>2]=c[p+4>>2];c[f+8>>2]=c[p+8>>2];c[f+12>>2]=c[p+12>>2];Nk(g,c[k>>2]|0,f);p=c[l>>2]|0;q=c[m>>2]|0;a:do if(p>>>0<q>>>0){r=c[g>>2]|0;s=c[n>>2]|0;t=p;while(1){u=c[t+4>>2]&1048575;v=t;t=t+8|0;c[l>>2]=t;if(u>>>0<r>>>0|u>>>0>s>>>0)if(t>>>0<q>>>0){t=t;continue}else break;u=c[v>>2]|0;if(!((u|0)>-1))break a;pb[c[(c[b>>2]|0)+20>>2]&31](b,d,o,u);if(!(t>>>0<q>>>0))break}}while(0);
o=o+1|0}while((o|0)!=(j|0));i=e;return 1}function Xl(a,b){a=a|0;b=b|0;return 0}function Yl(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;h=i;i=i+48|0;j=h+24|0;l=h;m=c[d+8>>2]|0;n=b+4|0;o=c[n>>2]|0;p=(c[o+96>>2]|0)+(f<<3)|0;q=c[p>>2]|0;r=c[p+4>>2]|0;s=(c[k>>2]=q,+g[k>>2]);t=(c[k>>2]=r,+g[k>>2]);p=(c[o+104>>2]|0)+(f<<3)|0;u=+g[p>>2];v=+g[p+4>>2];if((c[o+24>>2]|0)==0){w=s-+g[m+28>>2];x=t-+g[m+32>>2];
y=+g[m+40>>2];z=+g[m+36>>2];A=w*y+x*z;B=y*x-w*z;o=c[d+12>>2]|0;if((c[o+4>>2]|0)==0){w=+g[m+44>>2];x=A-w;C=+g[m+48>>2];D=B-C;E=x*y-D*z;F=y*D+x*z;z=+g[m+24>>2];x=+g[m+20>>2];G=z;H=w+(z*E+x*F);I=x;J=C+(z*F-E*x)}else{G=+g[m+24>>2];H=A;I=+g[m+20>>2];J=B}B=+(+g[m+12>>2]+(H*G-J*I));A=+(J*G+H*I+ +g[m+16>>2]);p=l;g[p>>2]=B;g[p+4>>2]=A;K=o}else{o=l;c[o>>2]=q;c[o+4>>2]=r;K=c[d+12>>2]|0}d=l+8|0;A=+g[b+8>>2];B=+(s+u*A);I=+(t+v*A);r=d;g[r>>2]=B;g[r+4>>2]=I;g[l+16>>2]=1;if(!(ob[c[(c[K>>2]|0)+24>>2]&15](K,j,l,m+
12|0,e)|0)){i=h;return}e=j;I=+g[e>>2];B=+g[j+8>>2];A=1-B;j=b+12|0;H=+g[j>>2];G=H*(I*.004999999888241291+(+g[l>>2]*A+B*+g[d>>2])-s);s=H*(+g[e+4>>2]*.004999999888241291+(A*+g[l+4>>2]+B*+g[l+12>>2])-t);t=+G;B=+s;l=(c[(c[n>>2]|0)+104>>2]|0)+(f<<3)|0;g[l>>2]=t;g[l+4>>2]=B;l=c[n>>2]|0;B=+g[l+32>>2]*.75;t=+g[j>>2]*B*+g[l+320>>2]*B;B=(u-G)*t;G=(v-s)*t;if(!(B!=0|G!=0)){i=h;return}if((c[(c[l+88>>2]|0)+(f<<2)>>2]&4|0)!=0){i=h;return}j=l+21|0;n=l+112|0;if((a[j>>0]|0)==0){xn(c[n>>2]|0,0,c[l+44>>2]<<3|0)|0;a[j>>
0]=1}j=c[n>>2]|0;n=j+(f<<3)|0;g[n>>2]=B+ +g[n>>2];n=j+(f<<3)+4|0;g[n>>2]=G+ +g[n>>2];i=h;return}function Zl(a){a=a|0;return}function _l(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function $l(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;f=i;i=i+32|0;h=f;j=f+16|0;k=f+8|0;l=a+4|0;m=(c[(c[l>>2]|0)+96>>2]|0)+(e<<3)|0;n=c[m+4>>2]|0;o=h;c[o>>2]=c[m>>2];c[o+4>>2]=n;n=c[b+12>>2]|0;o=b+8|0;mb[c[(c[n>>2]|0)+20>>2]&7](n,(c[o>>2]|0)+12|
0,h,j,k,d);d=c[l>>2]|0;if(!(+g[j>>2]<+g[d+32>>2])){i=f;return}n=c[a+8>>2]|0;if(((n|0)!=0?(c[(c[d+88>>2]|0)+(e<<2)>>2]&65536|0)!=0:0)?!(lb[c[(c[n>>2]|0)+12>>2]&7](n,b,d,e)|0):0){i=f;return}d=c[o>>2]|0;o=d+60|0;p=+g[o>>2];q=+g[d+132>>2];r=+g[d+44>>2];s=+g[d+48>>2];t=q*(r*r+s*s);s=+g[d+140>>2]+t-t;if(q>0)u=1/q;else u=0;if(s>0)v=1/s;else v=0;n=c[l>>2]|0;if((c[(c[n+88>>2]|0)+(e<<2)>>2]&4|0)==0){s=+g[n+36>>2]*1.3333333730697632;w=s*+g[n+28>>2]*s}else w=0;a=k+4|0;s=(+g[h>>2]-p)*+g[a>>2]-(+g[h+4>>2]-+g[o+
4>>2])*+g[k>>2];p=u+w+s*v*s;o=n+232|0;h=n+236|0;m=c[h>>2]|0;x=n+240|0;y=c[x>>2]|0;if((m|0)>=(y|0)?(z=(y|0)==0?256:y<<1,(y|0)<(z|0)):0){y=n+244|0;n=Em(c[y>>2]|0,z*28|0)|0;A=c[o>>2]|0;if((A|0)!=0){An(n|0,A|0,(c[h>>2]|0)*28|0)|0;Fm(c[y>>2]|0,c[o>>2]|0,(c[x>>2]|0)*28|0)}c[x>>2]=z;c[o>>2]=n;B=c[h>>2]|0}else B=m;c[h>>2]=B+1;h=c[o>>2]|0;c[h+(B*28|0)>>2]=e;c[h+(B*28|0)+4>>2]=d;c[h+(B*28|0)+8>>2]=b;g[h+(B*28|0)+12>>2]=1-+g[j>>2]*+g[(c[l>>2]|0)+36>>2];s=+-+g[k>>2];v=+-+g[a>>2];a=h+(B*28|0)+16|0;g[a>>2]=s;g[a+
4>>2]=v;if(p>0)C=1/p;else C=0;g[h+(B*28|0)+24>>2]=C;Tk(c[l>>2]|0,e);i=f;return}function am(a){a=a|0;return}function bm(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function sj(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;b=i;d=c[a+102960>>2]|0;if((d|0)!=0){e=d;do{d=e;e=c[e+112>>2]|0;f=c[d+116>>2]|0;while(1){if((f|0)==0)break;d=c[f+4>>2]|0;c[f+28>>2]=0;nj(f,a);f=d}}while((e|0)!=0)}e=a+102968|0;f=c[e>>2]|0;if((f|0)==0){g=a+102880|0;Ne(g);h=a+76|0;Xm(h);Dm(a);i=b;return}d=a+102876|0;j=f;while(1){if((c[d>>
2]&2|0)==0){f=j+404|0;k=c[f>>2]|0;l=j+408|0;if((k|0)!=0)c[k+408>>2]=c[l>>2];k=c[l>>2]|0;if((k|0)!=0)c[k+404>>2]=c[f>>2];if((c[e>>2]|0)==(j|0))c[e>>2]=c[l>>2];sk(j);Fm(a,j,416);m=c[e>>2]|0}else m=j;if((m|0)==0)break;else j=m}g=a+102880|0;Ne(g);h=a+76|0;Xm(h);Dm(a);i=b;return}function tj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;if((c[a+102876>>2]&2|0)!=0){i=d;return}e=b+404|0;f=c[e>>2]|0;g=b+408|0;if((f|0)!=0)c[f+408>>2]=c[g>>2];f=c[g>>2]|0;if((f|0)!=0)c[f+404>>2]=c[e>>2];e=a+102968|0;if((c[e>>2]|0)==
(b|0))c[e>>2]=c[g>>2];sk(b);Fm(a,b,416);i=d;return}function uj(a,b){a=a|0;b=b|0;c[a+102952>>2]=b;return}function vj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;if((c[a+102876>>2]&2|0)!=0){e=0;i=d;return e|0}f=Em(a,168)|0;if((f|0)==0)g=0;else{Hj(f,b,a);g=f}c[g+108>>2]=0;f=a+102960|0;c[g+112>>2]=c[f>>2];b=c[f>>2]|0;if((b|0)!=0)c[b+108>>2]=g;c[f>>2]=g;f=a+102972|0;c[f>>2]=(c[f>>2]|0)+1;e=g;i=d;return e|0}function wj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;d=i;if((c[a+102876>>2]&2|0)!=0){i=
d;return}e=b+124|0;f=c[e>>2]|0;if((f|0)!=0){g=a+102992|0;h=f;do{f=h;h=c[h+12>>2]|0;j=c[g>>2]|0;if((j|0)==0)k=f+4|0;else{l=f+4|0;gb[c[(c[j>>2]|0)+8>>2]&63](j,c[l>>2]|0);k=l}xj(a,c[k>>2]|0);c[e>>2]=h}while((h|0)!=0)}c[e>>2]=0;e=b+128|0;h=c[e>>2]|0;if((h|0)!=0){k=a+102880|0;g=h;do{h=g;g=c[g+12>>2]|0;Tj(k,c[h+4>>2]|0)}while((g|0)!=0)}c[e>>2]=0;e=b+116|0;g=c[e>>2]|0;if((g|0)==0)m=b+120|0;else{k=a+102992|0;h=a+102880|0;l=b+120|0;j=g;do{g=j;j=c[j+4>>2]|0;f=c[k>>2]|0;if((f|0)!=0)gb[c[(c[f>>2]|0)+12>>2]&63](f,
g);pj(g,h);nj(g,a);Fm(a,g,44);c[e>>2]=j;c[l>>2]=(c[l>>2]|0)+-1}while((j|0)!=0);m=l}c[e>>2]=0;c[m>>2]=0;m=b+108|0;e=c[m>>2]|0;l=b+112|0;if((e|0)!=0)c[e+112>>2]=c[l>>2];e=c[l>>2]|0;if((e|0)!=0)c[e+108>>2]=c[m>>2];m=a+102960|0;if((c[m>>2]|0)==(b|0))c[m>>2]=c[l>>2];l=a+102972|0;c[l>>2]=(c[l>>2]|0)+-1;Ij(b);Fm(a,b,168);i=d;return}function xj(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;h=i;if((c[d+102876>>2]&2|0)!=0){i=h;return}j=a[f+61>>0]|0;k=f+8|0;l=c[k>>2]|0;m=f+12|0;if((l|0)!=0)c[l+12>>2]=
c[m>>2];l=c[m>>2]|0;if((l|0)!=0)c[l+8>>2]=c[k>>2];k=d+102964|0;if((c[k>>2]|0)==(f|0))c[k>>2]=c[m>>2];m=c[f+48>>2]|0;k=c[f+52>>2]|0;l=m+4|0;n=e[l>>1]|0;if((n&2|0)==0){b[l>>1]=n|2;g[m+160>>2]=0}n=k+4|0;l=e[n>>1]|0;if((l&2|0)==0){b[n>>1]=l|2;g[k+160>>2]=0}l=f+24|0;n=c[l>>2]|0;o=f+28|0;if((n|0)!=0)c[n+12>>2]=c[o>>2];n=c[o>>2]|0;if((n|0)!=0)c[n+8>>2]=c[l>>2];n=m+124|0;if((f+16|0)==(c[n>>2]|0))c[n>>2]=c[o>>2];c[l>>2]=0;c[o>>2]=0;o=f+40|0;l=c[o>>2]|0;n=f+44|0;if((l|0)!=0)c[l+12>>2]=c[n>>2];l=c[n>>2]|0;if((l|
0)!=0)c[l+8>>2]=c[o>>2];l=k+124|0;if((f+32|0)==(c[l>>2]|0))c[l>>2]=c[n>>2];c[o>>2]=0;c[n>>2]=0;uh(f,d);f=d+102976|0;c[f>>2]=(c[f>>2]|0)+-1;if(!(j<<24>>24==0)){i=h;return}j=c[k+128>>2]|0;if((j|0)==0){i=h;return}else p=j;do{if((c[p>>2]|0)==(m|0)){j=(c[p+4>>2]|0)+4|0;c[j>>2]=c[j>>2]|8}p=c[p+12>>2]|0}while((p|0)!=0);i=h;return}function yj(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;e=i;if((c[b+102876>>2]&2|0)!=0){f=0;i=e;return f|0}g=th(d,b)|0;c[g+8>>2]=0;h=b+102964|0;c[g+12>>2]=
c[h>>2];j=c[h>>2]|0;if((j|0)!=0)c[j+8>>2]=g;c[h>>2]=g;h=b+102976|0;c[h>>2]=(c[h>>2]|0)+1;h=g+16|0;c[g+20>>2]=g;b=g+52|0;c[h>>2]=c[b>>2];c[g+24>>2]=0;j=g+48|0;k=c[j>>2]|0;l=k+124|0;c[g+28>>2]=c[l>>2];m=c[l>>2]|0;if((m|0)==0)n=k;else{c[m+8>>2]=h;n=c[j>>2]|0}c[n+124>>2]=h;h=g+32|0;c[g+36>>2]=g;c[h>>2]=c[j>>2];c[g+40>>2]=0;j=c[b>>2]|0;n=j+124|0;c[g+44>>2]=c[n>>2];m=c[n>>2]|0;if((m|0)==0)o=j;else{c[m+8>>2]=h;o=c[b>>2]|0}c[o+124>>2]=h;h=c[d+8>>2]|0;if((a[d+16>>0]|0)!=0){f=g;i=e;return f|0}o=c[(c[d+12>>
2]|0)+128>>2]|0;if((o|0)==0){f=g;i=e;return f|0}else p=o;do{if((c[p>>2]|0)==(h|0)){o=(c[p+4>>2]|0)+4|0;c[o>>2]=c[o>>2]|8}p=c[p+12>>2]|0}while((p|0)!=0);f=g;i=e;return f|0}function zj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;if((c[a+102876>>2]&2|0)!=0){e=0;i=d;return e|0}f=Em(a,416)|0;if((f|0)==0)g=0;else{rk(f,b,a);g=f}c[g+404>>2]=0;f=a+102968|0;c[g+408>>2]=c[f>>2];a=c[f>>2]|0;if((a|0)!=0)c[a+404>>2]=g;c[f>>2]=g;e=g;i=d;return e|0}function Aj(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=
0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0;h=i;i=i+96|0;j=h+40|0;k=h+8|0;l=h;m=d+102960|0;n=c[m>>2]|0;if((n|0)!=0){o=n;do{n=o+28|0;p=o+12|0;c[n+0>>2]=c[p+0>>2];c[n+4>>2]=c[p+4>>2];c[n+8>>2]=c[p+8>>2];c[n+12>>2]=c[p+12>>2];o=c[o+112>>2]|0}while((o|0)!=0)}o=d+103020|0;g[o>>2]=0;p=d+103024|0;g[p>>2]=0;n=d+103028|0;g[n>>2]=0;q=d+102972|0;r=d+102880|0;s=d+76|0;mf(j,c[q>>2]|0,c[d+102944>>2]|0,c[d+102976>>2]|0,s,c[d+
102952>>2]|0);t=c[m>>2]|0;if((t|0)!=0){u=t;do{t=u+4|0;b[t>>1]=b[t>>1]&65534;u=c[u+112>>2]|0}while((u|0)!=0)}u=c[d+102940>>2]|0;if((u|0)!=0){t=u;do{u=t+4|0;c[u>>2]=c[u>>2]&-2;t=c[t+12>>2]|0}while((t|0)!=0)}t=c[d+102964>>2]|0;if((t|0)!=0){u=t;do{a[u+60>>0]=0;u=c[u+12>>2]|0}while((u|0)!=0)}u=Ym(s,c[q>>2]<<2)|0;q=c[m>>2]|0;if((q|0)!=0){t=j+28|0;v=j+36|0;w=j+32|0;x=j+8|0;y=j+16|0;z=j+12|0;A=d+102980|0;B=d+102988|0;C=k+12|0;D=k+16|0;E=k+20|0;F=q;do{q=F+4|0;G=b[q>>1]|0;if((G&35)==34?(c[F>>2]|0)!=0:0){c[t>>
2]=0;c[v>>2]=0;c[w>>2]=0;c[u>>2]=F;b[q>>1]=G&65535|1;G=0;q=1;while(1){H=q+-1|0;I=c[u+(H<<2)>>2]|0;c[I+8>>2]=G;J=c[t>>2]|0;c[(c[x>>2]|0)+(J<<2)>>2]=I;c[t>>2]=J+1;J=I+4|0;K=e[J>>1]|0;if((K&2|0)==0){b[J>>1]=K|2;g[I+160>>2]=0}if((c[I>>2]|0)!=0){K=c[I+128>>2]|0;if((K|0)==0)L=H;else{J=K;K=H;while(1){M=c[J+4>>2]|0;N=M+4|0;do if((c[N>>2]&7|0)==6?(a[(c[M+48>>2]|0)+38>>0]|0)==0:0){if((a[(c[M+52>>2]|0)+38>>0]|0)!=0){O=K;break}P=c[v>>2]|0;c[v>>2]=P+1;c[(c[z>>2]|0)+(P<<2)>>2]=M;c[N>>2]=c[N>>2]|1;P=c[J>>2]|0;Q=
P+4|0;R=b[Q>>1]|0;if(!((R&1)==0)){O=K;break}c[u+(K<<2)>>2]=P;b[Q>>1]=R&65535|1;O=K+1|0}else O=K;while(0);J=c[J+12>>2]|0;if((J|0)==0){L=O;break}else K=O}}K=c[I+124>>2]|0;if((K|0)==0)S=L;else{J=K;K=L;while(1){N=J+4|0;M=c[N>>2]|0;do if((a[M+60>>0]|0)==0?(R=c[J>>2]|0,Q=R+4|0,P=b[Q>>1]|0,!((P&32)==0)):0){T=c[w>>2]|0;c[w>>2]=T+1;c[(c[y>>2]|0)+(T<<2)>>2]=M;a[(c[N>>2]|0)+60>>0]=1;if(!((P&1)==0)){U=K;break}c[u+(K<<2)>>2]=R;b[Q>>1]=P&65535|1;U=K+1|0}else U=K;while(0);J=c[J+12>>2]|0;if((J|0)==0){S=U;break}else K=
U}}}else S=H;if((S|0)<=0)break;G=c[t>>2]|0;q=S}of(j,k,f,A,(a[B>>0]|0)!=0);g[o>>2]=+g[C>>2]+ +g[o>>2];g[p>>2]=+g[D>>2]+ +g[p>>2];g[n>>2]=+g[E>>2]+ +g[n>>2];q=c[t>>2]|0;if((q|0)>0){G=c[x>>2]|0;K=0;do{J=c[G+(K<<2)>>2]|0;if((c[J>>2]|0)==0){I=J+4|0;b[I>>1]=b[I>>1]&65534}K=K+1|0}while((K|0)<(q|0))}}F=c[F+112>>2]|0}while((F|0)!=0)}_m(s,u);Km(l);u=c[m>>2]|0;if((u|0)==0){Vj(r);V=+Mm(l);W=d+103032|0;g[W>>2]=V;nf(j);i=h;return}else X=u;do{if(!((b[X+4>>1]&1)==0)?(c[X>>2]|0)!=0:0)Lj(X);X=c[X+112>>2]|0}while((X|
0)!=0);Vj(r);V=+Mm(l);W=d+103032|0;g[W>>2]=V;nf(j);i=h;return}function Bj(d,f){d=d|0;f=f|0;var h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,
Va=0,Wa=0,Xa=0,Ya=0,Za=0;h=i;i=i+336|0;j=h+284|0;l=h+152|0;m=h+144|0;n=h+108|0;o=h+72|0;p=h+64|0;q=h+28|0;r=h;s=d+102880|0;t=d+102952|0;mf(j,64,32,0,d+76|0,c[t>>2]|0);u=d+103007|0;if((a[u>>0]|0)!=0){v=c[d+102960>>2]|0;if((v|0)!=0){w=v;do{v=w+4|0;b[v>>1]=b[v>>1]&65534;g[w+76>>2]=0;w=c[w+112>>2]|0}while((w|0)!=0)}w=d+102940|0;v=c[w>>2]|0;if((v|0)==0)x=w;else{y=v;do{v=y+4|0;c[v>>2]=c[v>>2]&-34;c[y+128>>2]=0;g[y+132>>2]=1;y=c[y+12>>2]|0}while((y|0)!=0);x=w}}else x=d+102940|0;w=j+28|0;y=j+36|0;v=j+32|
0;z=j+8|0;A=j+12|0;B=p+4|0;C=j+40|0;D=j+44|0;E=r+4|0;F=r+8|0;G=r+16|0;H=f+12|0;I=r+12|0;J=f+20|0;K=r+20|0;L=r+24|0;M=d+103006|0;d=l+16|0;N=l+20|0;O=l+24|0;P=l+44|0;Q=l+48|0;R=l+52|0;U=l+28|0;V=l+56|0;W=l+92|0;X=l+128|0;Y=m+4|0;while(1){Z=c[x>>2]|0;if((Z|0)==0){_=28;break}else{$=Z;aa=1;ba=0}while(1){Z=$+4|0;ca=c[Z>>2]|0;do if((ca&4|0)!=0?(c[$+128>>2]|0)<=8:0){if((ca&32|0)==0){da=c[$+48>>2]|0;ea=c[$+52>>2]|0;if((a[da+38>>0]|0)!=0){fa=aa;ga=ba;break}if((a[ea+38>>0]|0)!=0){fa=aa;ga=ba;break}ha=c[da+8>>
2]|0;ia=c[ea+8>>2]|0;ja=c[ha>>2]|0;ka=c[ia>>2]|0;la=b[ha+4>>1]|0;ma=b[ia+4>>1]|0;if(!((la&2)!=0&(ja|0)!=0|(ma&2)!=0&(ka|0)!=0)){fa=aa;ga=ba;break}if(!((la&8)!=0|(ja|0)!=2|((ma&8)!=0|(ka|0)!=2))){fa=aa;ga=ba;break}ka=ha+44|0;ma=ha+76|0;na=+g[ma>>2];ja=ia+44|0;la=ia+76|0;oa=+g[la>>2];if(!(na<oa))if(oa<na){pa=(na-oa)/(1-oa);qa=ia+52|0;ra=+g[qa>>2];sa=ia+56|0;ta=+g[sa>>2];ua=pa*(+g[ia+64>>2]-ta);g[qa>>2]=ra+pa*(+g[ia+60>>2]-ra);g[sa>>2]=ta+ua;sa=ia+68|0;ua=+g[sa>>2];g[sa>>2]=ua+pa*(+g[ia+72>>2]-ua);g[la>>
2]=na;va=na}else va=na;else{ua=(oa-na)/(1-na);la=ha+52|0;na=+g[la>>2];ia=ha+56|0;pa=+g[ia>>2];ta=ua*(+g[ha+64>>2]-pa);g[la>>2]=na+ua*(+g[ha+60>>2]-na);g[ia>>2]=pa+ta;ia=ha+68|0;ta=+g[ia>>2];g[ia>>2]=ta+ua*(+g[ha+72>>2]-ta);g[ma>>2]=oa;va=oa}ma=c[$+56>>2]|0;ha=c[$+60>>2]|0;c[d>>2]=0;c[N>>2]=0;g[O>>2]=0;c[P>>2]=0;c[Q>>2]=0;g[R>>2]=0;be(l,c[da+12>>2]|0,ma);be(U,c[ea+12>>2]|0,ha);wa=V+0|0;xa=ka+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));wa=W+0|0;xa=ja+0|0;ya=wa+36|0;
do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));g[X>>2]=1;Zd(m,l);if((c[m>>2]|0)==3){oa=va+(1-va)*+g[Y>>2];za=oa<1?oa:1}else za=1;g[$+132>>2]=za;c[Z>>2]=c[Z>>2]|32;Aa=za}else Aa=+g[$+132>>2];if(Aa<aa){fa=Aa;ga=$}else{fa=aa;ga=ba}}else{fa=aa;ga=ba}while(0);$=c[$+12>>2]|0;if(($|0)==0)break;else{aa=fa;ba=ga}}if((ga|0)==0|fa>.9999988079071045){_=28;break}Z=c[(c[ga+48>>2]|0)+8>>2]|0;ca=c[(c[ga+52>>2]|0)+8>>2]|0;ja=Z+44|0;wa=n+0|0;xa=ja+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+
4|0}while((wa|0)<(ya|0));ka=ca+44|0;wa=o+0|0;xa=ka+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));ha=Z+76|0;oa=+g[ha>>2];ta=(fa-oa)/(1-oa);ea=Z+60|0;ma=Z+52|0;oa=+g[ma>>2];da=Z+64|0;ia=Z+56|0;ua=+g[ia>>2];pa=ta*(+g[da>>2]-ua);g[ma>>2]=oa+ta*(+g[ea>>2]-oa);g[ia>>2]=ua+pa;ia=Z+72|0;ma=Z+68|0;pa=+g[ma>>2];ua=pa+ta*(+g[ia>>2]-pa);g[ma>>2]=ua;g[ha>>2]=fa;ha=Z+52|0;ma=c[ha>>2]|0;la=c[ha+4>>2]|0;ha=Z+60|0;c[ha>>2]=ma;c[ha+4>>2]=la;g[ia>>2]=ua;pa=+T(+ua);ha=Z+20|0;g[ha>>2]=pa;
ta=+S(+ua);sa=Z+24|0;g[sa>>2]=ta;qa=Z+12|0;Ba=Z+44|0;ua=+g[Ba>>2];Ca=Z+48|0;oa=+g[Ca>>2];na=(c[k>>2]=ma,+g[k>>2])-(ta*ua-pa*oa);ra=(c[k>>2]=la,+g[k>>2])-(pa*ua+ta*oa);oa=+na;na=+ra;la=qa;g[la>>2]=oa;g[la+4>>2]=na;la=ca+76|0;na=+g[la>>2];oa=(fa-na)/(1-na);ma=ca+60|0;Da=ca+52|0;na=+g[Da>>2];Ea=ca+64|0;Fa=ca+56|0;ra=+g[Fa>>2];ta=oa*(+g[Ea>>2]-ra);g[Da>>2]=na+oa*(+g[ma>>2]-na);g[Fa>>2]=ra+ta;Fa=ca+72|0;Da=ca+68|0;ta=+g[Da>>2];ra=ta+oa*(+g[Fa>>2]-ta);g[Da>>2]=ra;g[la>>2]=fa;la=ca+52|0;Da=c[la>>2]|0;Ga=
c[la+4>>2]|0;la=ca+60|0;c[la>>2]=Da;c[la+4>>2]=Ga;g[Fa>>2]=ra;ta=+T(+ra);la=ca+20|0;g[la>>2]=ta;oa=+S(+ra);Ha=ca+24|0;g[Ha>>2]=oa;Ia=ca+12|0;Ja=ca+44|0;ra=+g[Ja>>2];Ka=ca+48|0;na=+g[Ka>>2];ua=(c[k>>2]=Da,+g[k>>2])-(oa*ra-ta*na);pa=(c[k>>2]=Ga,+g[k>>2])-(ta*ra+oa*na);na=+ua;ua=+pa;Ga=Ia;g[Ga>>2]=na;g[Ga+4>>2]=ua;xi(ga,c[t>>2]|0);Ga=ga+4|0;Da=c[Ga>>2]|0;c[Ga>>2]=Da&-33;La=ga+128|0;c[La>>2]=(c[La>>2]|0)+1;if((Da&6|0)!=6){c[Ga>>2]=Da&-37;wa=ja+0|0;xa=n+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=
xa+4|0}while((wa|0)<(ya|0));wa=ka+0|0;xa=o+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));ua=+g[ia>>2];na=+T(+ua);g[ha>>2]=na;pa=+S(+ua);g[sa>>2]=pa;ua=+g[Ba>>2];oa=+g[Ca>>2];ra=+(+g[ea>>2]-(pa*ua-na*oa));ta=+(+g[da>>2]-(na*ua+pa*oa));ka=qa;g[ka>>2]=ra;g[ka+4>>2]=ta;ta=+g[Fa>>2];ra=+T(+ta);g[la>>2]=ra;oa=+S(+ta);g[Ha>>2]=oa;ta=+g[Ja>>2];pa=+g[Ka>>2];ua=+(+g[ma>>2]-(oa*ta-ra*pa));na=+(+g[Ea>>2]-(ra*ta+oa*pa));ka=Ia;g[ka>>2]=ua;g[ka+4>>2]=na;continue}ka=Z+4|0;ja=b[ka>>
1]|0;Da=ja&65535;if((Da&2|0)==0){La=(Da|2)&65535;b[ka>>1]=La;g[Z+160>>2]=0;Ma=La}else Ma=ja;ja=ca+4|0;La=e[ja>>1]|0;if((La&2|0)==0){b[ja>>1]=La|2;g[ca+160>>2]=0;Na=b[ka>>1]|0}else Na=Ma;c[w>>2]=0;c[y>>2]=0;c[v>>2]=0;La=Z+8|0;c[La>>2]=0;Da=c[w>>2]|0;c[(c[z>>2]|0)+(Da<<2)>>2]=Z;Oa=Da+1|0;c[w>>2]=Oa;Da=ca+8|0;c[Da>>2]=Oa;Oa=c[w>>2]|0;c[(c[z>>2]|0)+(Oa<<2)>>2]=ca;c[w>>2]=Oa+1;Oa=c[y>>2]|0;c[y>>2]=Oa+1;c[(c[A>>2]|0)+(Oa<<2)>>2]=ga;b[ka>>1]=Na&65535|1;b[ja>>1]=e[ja>>1]|1;c[Ga>>2]=c[Ga>>2]|1;c[p>>2]=Z;c[B>>
2]=ca;ja=Z;ka=1;while(1){a:do if((c[ja>>2]|0)==2?(Oa=c[ja+128>>2]|0,(Oa|0)!=0):0){Pa=ja+4|0;Qa=Oa;do{if((c[w>>2]|0)==(c[C>>2]|0))break a;if((c[y>>2]|0)==(c[D>>2]|0))break a;Oa=c[Qa+4>>2]|0;Ra=Oa+4|0;do if((c[Ra>>2]&1|0)==0){Sa=c[Qa>>2]|0;if(((c[Sa>>2]|0)==2?(b[Pa>>1]&8)==0:0)?(b[Sa+4>>1]&8)==0:0)break;if((a[(c[Oa+48>>2]|0)+38>>0]|0)==0?(a[(c[Oa+52>>2]|0)+38>>0]|0)==0:0){Ta=Sa+44|0;wa=q+0|0;xa=Ta+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));Ua=Sa+4|0;if((b[Ua>>1]&1)==
0){Va=Sa+76|0;na=+g[Va>>2];ua=(fa-na)/(1-na);Wa=Sa+52|0;na=+g[Wa>>2];Xa=Sa+56|0;pa=+g[Xa>>2];oa=ua*(+g[Sa+64>>2]-pa);g[Wa>>2]=na+ua*(+g[Sa+60>>2]-na);g[Xa>>2]=pa+oa;Xa=Sa+72|0;Wa=Sa+68|0;oa=+g[Wa>>2];pa=oa+ua*(+g[Xa>>2]-oa);g[Wa>>2]=pa;g[Va>>2]=fa;Va=Sa+52|0;Wa=c[Va>>2]|0;Ya=c[Va+4>>2]|0;Va=Sa+60|0;c[Va>>2]=Wa;c[Va+4>>2]=Ya;g[Xa>>2]=pa;oa=+T(+pa);g[Sa+20>>2]=oa;ua=+S(+pa);g[Sa+24>>2]=ua;pa=+g[Sa+44>>2];na=+g[Sa+48>>2];ta=(c[k>>2]=Wa,+g[k>>2])-(ua*pa-oa*na);ra=(c[k>>2]=Ya,+g[k>>2])-(oa*pa+ua*na);na=
+ta;ta=+ra;Ya=Sa+12|0;g[Ya>>2]=na;g[Ya+4>>2]=ta}xi(Oa,c[t>>2]|0);Ya=c[Ra>>2]|0;if((Ya&4|0)==0){wa=Ta+0|0;xa=q+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));ta=+g[Sa+72>>2];na=+T(+ta);g[Sa+20>>2]=na;ra=+S(+ta);g[Sa+24>>2]=ra;ta=+g[Sa+44>>2];ua=+g[Sa+48>>2];pa=+(+g[Sa+60>>2]-(ra*ta-na*ua));oa=+(+g[Sa+64>>2]-(na*ta+ra*ua));Wa=Sa+12|0;g[Wa>>2]=pa;g[Wa+4>>2]=oa;break}if((Ya&2|0)==0){wa=Ta+0|0;xa=q+0|0;ya=wa+36|0;do{c[wa>>2]=c[xa>>2];wa=wa+4|0;xa=xa+4|0}while((wa|0)<(ya|0));
oa=+g[Sa+72>>2];pa=+T(+oa);g[Sa+20>>2]=pa;ua=+S(+oa);g[Sa+24>>2]=ua;oa=+g[Sa+44>>2];ra=+g[Sa+48>>2];ta=+(+g[Sa+60>>2]-(ua*oa-pa*ra));na=+(+g[Sa+64>>2]-(pa*oa+ua*ra));Ta=Sa+12|0;g[Ta>>2]=ta;g[Ta+4>>2]=na;break}c[Ra>>2]=Ya|1;Ta=c[y>>2]|0;c[y>>2]=Ta+1;c[(c[A>>2]|0)+(Ta<<2)>>2]=Oa;Ta=e[Ua>>1]|0;if((Ta&1|0)!=0)break;b[Ua>>1]=Ta|1;do if((c[Sa>>2]|0)!=0){if((Ta&2|0)!=0)break;b[Ua>>1]=Ta|3;g[Sa+160>>2]=0}while(0);c[Sa+8>>2]=c[w>>2];Ta=c[w>>2]|0;c[(c[z>>2]|0)+(Ta<<2)>>2]=Sa;c[w>>2]=Ta+1}}while(0);Qa=c[Qa+
12>>2]|0}while((Qa|0)!=0)}while(0);if((ka|0)>=2)break;ja=c[p+(ka<<2)>>2]|0;ka=ka+1|0}na=(1-fa)*+g[f>>2];g[r>>2]=na;g[E>>2]=1/na;g[F>>2]=1;c[G>>2]=20;c[I>>2]=c[H>>2];c[K>>2]=c[J>>2];a[L>>0]=0;pf(j,r,c[La>>2]|0,c[Da>>2]|0);ka=c[w>>2]|0;if((ka|0)>0){ja=ka;ka=0;while(1){Z=c[(c[z>>2]|0)+(ka<<2)>>2]|0;ca=Z+4|0;b[ca>>1]=b[ca>>1]&65534;if((c[Z>>2]|0)==2){Lj(Z);ca=c[Z+128>>2]|0;if((ca|0)!=0){Z=ca;do{ca=(c[Z+4>>2]|0)+4|0;c[ca>>2]=c[ca>>2]&-34;Z=c[Z+12>>2]|0}while((Z|0)!=0)}Za=c[w>>2]|0}else Za=ja;ka=ka+1|0;
if((ka|0)>=(Za|0))break;else ja=Za}}Vj(s);if((a[M>>0]|0)!=0){_=68;break}}if((_|0)==28){a[u>>0]=1;nf(j);i=h;return}else if((_|0)==68){a[u>>0]=0;nf(j);i=h;return}}function Cj(b,d,e,f,h){b=b|0;d=+d;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;j=i;i=i+64|0;k=j+24|0;l=j+32|0;m=j+16|0;n=j+8|0;o=j;Km(k);p=b+102876|0;q=c[p>>2]|0;if((q&1|0)==0)r=q;else{Vj(b+102880|0);q=c[p>>2]&-2;c[p>>2]=q;r=q}c[p>>2]=r|2;g[l>>2]=d;c[l+12>>2]=e;c[l+16>>2]=f;c[l+20>>2]=h;if(d>0)g[l+4>>2]=
1/d;else g[l+4>>2]=0;h=b+103E3|0;g[l+8>>2]=+g[h>>2]*d;a[l+24>>0]=a[b+103004>>0]|0;Km(m);Uj(b+102880|0);g[b+103012>>2]=+Mm(m);if((a[b+103007>>0]|0)!=0?+g[l>>2]>0:0){Km(n);m=c[b+102968>>2]|0;if((m|0)!=0){f=m;do{bl(f,l);f=c[f+408>>2]|0}while((f|0)!=0)}Aj(b,l);g[b+103016>>2]=+Mm(n)}if((a[b+103005>>0]|0)!=0){d=+g[l>>2];if(d>0){Km(o);Bj(b,l);g[b+103036>>2]=+Mm(o);s=14}else t=d}else s=14;if((s|0)==14)t=+g[l>>2];if(t>0)g[h>>2]=+g[l+4>>2];l=c[p>>2]|0;if((l&4|0)==0){u=l&-3;c[p>>2]=u;v=+Mm(k);w=b+103008|0;g[w>>
2]=v;i=j;return}h=c[b+102960>>2]|0;if((h|0)==0){u=l&-3;c[p>>2]=u;v=+Mm(k);w=b+103008|0;g[w>>2]=v;i=j;return}else x=h;do{g[x+92>>2]=0;g[x+96>>2]=0;g[x+100>>2]=0;x=c[x+112>>2]|0}while((x|0)!=0);u=l&-3;c[p>>2]=u;v=+Mm(k);w=b+103008|0;g[w>>2]=v;i=j;return}function Dj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0;e=i;i=i+16|0;f=e;g=a+102880|0;c[f>>2]=g;c[f+4>>2]=b;Gj(g,f,d);f=c[a+102968>>2]|0;if((f|0)==0){i=e;return}a=f;do{if(nb[c[(c[b>>2]|0)+16>>2]&31](b,a)|0)pl(a,b,d);a=c[a+408>>2]|0}while((a|0)!=0);i=e;
return}function Ej(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0;f=i;i=i+32|0;h=f+24|0;j=f;k=a+102880|0;c[h>>2]=k;c[h+4>>2]=b;g[j+16>>2]=1;l=d;m=c[l+4>>2]|0;n=j;c[n>>2]=c[l>>2];c[n+4>>2]=m;m=e;n=c[m+4>>2]|0;l=j+8|0;c[l>>2]=c[m>>2];c[l+4>>2]=n;Fj(k,h,j);j=c[a+102968>>2]|0;if((j|0)==0){i=f;return}a=j;do{if(nb[c[(c[b>>2]|0)+16>>2]&31](b,a)|0)ql(a,b,d,e);a=c[a+408>>2]|0}while((a|0)!=0);i=f;return}function Fj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=
0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0;e=i;i=i+1088|0;f=e+1064|0;h=e+1056|0;j=e+20|0;k=e;l=d;m=+g[l>>2];n=+g[l+4>>2];l=d+8|0;o=l;p=+g[o>>2];q=p-m;p=+g[o+4>>2]-n;r=+Q(+(q*q+p*p));if(r<1.1920928955078125E-7){s=p;t=q}else{u=1/r;s=p*u;t=q*u}u=-s;r=s<-0?u:s;if(t>0)v=t;else v=-t;s=+g[d+16>>2];w=m+q*s;x=n+p*s;o=j+4|0;c[j>>2]=o;y=j+1028|
0;c[y>>2]=0;z=j+1032|0;c[z>>2]=256;A=c[j>>2]|0;c[A+(c[y>>2]<<2)>>2]=c[a>>2];B=c[y>>2]|0;C=B+1|0;c[y>>2]=C;a:do if((B|0)>-1){D=a+4|0;E=k+8|0;F=k+16|0;G=f+8|0;H=k+4|0;I=k+8|0;J=k+12|0;K=h+4|0;L=b+4|0;M=C;N=n<x?n:x;O=m<w?m:w;P=n>x?n:x;R=m>w?m:w;S=A;T=s;while(1){U=M;V=S;while(1){W=U+-1|0;c[y>>2]=W;X=c[V+(W<<2)>>2]|0;if((X|0)==-1){Y=W;Z=V}else{_=c[D>>2]|0;$=+g[_+(X*36|0)+8>>2];aa=+g[_+(X*36|0)+12>>2];ba=+g[_+(X*36|0)>>2];ca=+g[_+(X*36|0)+4>>2];if(O-$>0|N-aa>0|ba-R>0|ca-P>0){da=N;ea=O;fa=P;ga=R;ha=T;break}ia=
(m-($+ba)*.5)*u+t*(n-(aa+ca)*.5);if(ia>0)ja=ia;else ja=-ia;if(ja-(r*($-ba)*.5+v*(aa-ca)*.5)>0){da=N;ea=O;fa=P;ga=R;ha=T;break}ka=_+(X*36|0)+24|0;if((c[ka>>2]|0)==-1){la=17;break}if((W|0)==(c[z>>2]|0)?(c[z>>2]=W<<1,ma=Pm(W<<3)|0,c[j>>2]=ma,An(ma|0,V|0,c[y>>2]<<2|0)|0,(V|0)!=(o|0)):0)Qm(V);ma=c[j>>2]|0;c[ma+(c[y>>2]<<2)>>2]=c[ka>>2];ka=(c[y>>2]|0)+1|0;c[y>>2]=ka;W=_+(X*36|0)+28|0;if((ka|0)==(c[z>>2]|0)?(c[z>>2]=ka<<1,_=Pm(ka<<3)|0,c[j>>2]=_,An(_|0,ma|0,c[y>>2]<<2|0)|0,(ma|0)!=(o|0)):0)Qm(ma);ma=c[j>>
2]|0;c[ma+(c[y>>2]<<2)>>2]=c[W>>2];W=(c[y>>2]|0)+1|0;c[y>>2]=W;Y=W;Z=ma}if((Y|0)>0){U=Y;V=Z}else break a}if((la|0)==17){la=0;c[k+0>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;V=d;U=c[V+4>>2]|0;ma=k;c[ma>>2]=c[V>>2];c[ma+4>>2]=U;U=l;ma=c[U+4>>2]|0;V=E;c[V>>2]=c[U>>2];c[V+4>>2]=ma;g[F>>2]=T;ma=c[(c[(c[b>>2]|0)+4>>2]|0)+(X*36|0)+16>>2]|0;V=c[ma+16>>2]|0;U=c[V+12>>2]|0;if(ob[c[(c[U>>2]|0)+24>>2]&15](U,f,k,(c[V+8>>2]|0)+12|0,c[ma+20>>2]|0)|0){ca=+g[G>>2];aa=1-ca;ba=aa*+g[H>>2]+ca*+g[J>>2];g[h>>2]=+g[k>>
2]*aa+ca*+g[I>>2];g[K>>2]=ba;ma=c[L>>2]|0;na=+fb[c[(c[ma>>2]|0)+8>>2]&1](ma,V,h,f,ca)}else na=+g[F>>2];if(na==0)break a;if(na>0){ca=m+q*na;ba=n+p*na;da=n<ba?n:ba;ea=m<ca?m:ca;fa=n>ba?n:ba;ga=m>ca?m:ca;ha=na}else{da=N;ea=O;fa=P;ga=R;ha=T}}V=c[y>>2]|0;if((V|0)<=0)break a;M=V;N=da;O=ea;P=fa;R=ga;S=c[j>>2]|0;T=ha}}while(0);y=c[j>>2]|0;if((y|0)==(o|0)){i=e;return}Qm(y);c[j>>2]=0;i=e;return}function Gj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,
y=0,z=0,A=0,B=0;e=i;i=i+1040|0;f=e;h=f+4|0;c[f>>2]=h;j=f+1028|0;c[j>>2]=0;k=f+1032|0;c[k>>2]=256;l=c[f>>2]|0;c[l+(c[j>>2]<<2)>>2]=c[a>>2];m=c[j>>2]|0;n=m+1|0;c[j>>2]=n;a:do if((m|0)>-1){o=a+4|0;p=d+4|0;q=d+8|0;r=d+12|0;s=b+4|0;t=n;u=l;while(1){v=t+-1|0;c[j>>2]=v;w=c[u+(v<<2)>>2]|0;do if(!((w|0)==-1)?(x=c[o>>2]|0,!((+g[d>>2]-+g[x+(w*36|0)+8>>2]>0?1:+g[p>>2]-+g[x+(w*36|0)+12>>2]>0)|+g[x+(w*36|0)>>2]-+g[q>>2]>0|+g[x+(w*36|0)+4>>2]-+g[r>>2]>0)):0){y=x+(w*36|0)+24|0;if((c[y>>2]|0)==-1){z=c[s>>2]|0;if(!(nb[c[(c[z>>
2]|0)+8>>2]&31](z,c[(c[(c[(c[b>>2]|0)+4>>2]|0)+(w*36|0)+16>>2]|0)+16>>2]|0)|0))break a;A=c[j>>2]|0;break}if((v|0)==(c[k>>2]|0)?(c[k>>2]=v<<1,z=Pm(v<<3)|0,c[f>>2]=z,An(z|0,u|0,c[j>>2]<<2|0)|0,(u|0)!=(h|0)):0)Qm(u);z=c[f>>2]|0;c[z+(c[j>>2]<<2)>>2]=c[y>>2];y=(c[j>>2]|0)+1|0;c[j>>2]=y;B=x+(w*36|0)+28|0;if((y|0)==(c[k>>2]|0)?(c[k>>2]=y<<1,x=Pm(y<<3)|0,c[f>>2]=x,An(x|0,z|0,c[j>>2]<<2|0)|0,(z|0)!=(h|0)):0)Qm(z);c[(c[f>>2]|0)+(c[j>>2]<<2)>>2]=c[B>>2];B=(c[j>>2]|0)+1|0;c[j>>2]=B;A=B}else A=v;while(0);if((A|
0)<=0)break a;t=A;u=c[f>>2]|0}}while(0);A=c[f>>2]|0;if((A|0)==(h|0)){i=e;return}Qm(A);c[f>>2]=0;i=e;return}function Hj(d,e,f){d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;h=i;j=d+12|0;k=d+28|0;l=d+80|0;m=d+4|0;n=(a[e+39>>0]|0)==0?0:8;b[m>>1]=n;if((a[e+38>>0]|0)==0)o=n;else{p=(n&65535|16)&65535;b[m>>1]=p;o=p}if((a[e+36>>0]|0)==0)q=o;else{p=(o&65535|4)&65535;b[m>>1]=p;q=p}if((a[e+37>>0]|0)==0)r=q;else{p=(q&65535|2)&65535;b[m>>1]=p;r=p}if((a[e+40>>0]|
0)!=0)b[m>>1]=r&65535|32;c[d+104>>2]=f;f=e+4|0;r=c[f>>2]|0;m=c[f+4>>2]|0;f=j;c[f>>2]=r;c[f+4>>2]=m;f=e+12|0;s=+g[f>>2];g[d+20>>2]=+T(+s);g[d+24>>2]=+S(+s);c[k+0>>2]=c[j+0>>2];c[k+4>>2]=c[j+4>>2];c[k+8>>2]=c[j+8>>2];c[k+12>>2]=c[j+12>>2];g[d+44>>2]=0;g[d+48>>2]=0;j=d+52|0;c[j>>2]=r;c[j+4>>2]=m;j=d+60|0;c[j>>2]=r;c[j+4>>2]=m;g[d+68>>2]=+g[f>>2];g[d+72>>2]=+g[f>>2];g[d+76>>2]=0;c[d+124>>2]=0;c[d+128>>2]=0;c[d+108>>2]=0;c[d+112>>2]=0;f=e+16|0;m=c[f+4>>2]|0;j=l;c[j>>2]=c[f>>2];c[j+4>>2]=m;g[d+88>>2]=+g[e+
24>>2];g[d+148>>2]=+g[e+28>>2];g[d+152>>2]=+g[e+32>>2];g[d+156>>2]=+g[e+48>>2];g[d+92>>2]=0;g[d+96>>2]=0;g[d+100>>2]=0;g[d+160>>2]=0;m=c[e>>2]|0;c[d>>2]=m;j=d+132|0;if((m|0)==2){g[j>>2]=1;g[d+136>>2]=1;t=d+140|0;g[t>>2]=0;u=d+144|0;g[u>>2]=0;v=e+44|0;w=c[v>>2]|0;x=d+164|0;c[x>>2]=w;y=d+116|0;c[y>>2]=0;z=d+120|0;c[z>>2]=0;i=h;return}else{g[j>>2]=0;g[d+136>>2]=0;t=d+140|0;g[t>>2]=0;u=d+144|0;g[u>>2]=0;v=e+44|0;w=c[v>>2]|0;x=d+164|0;c[x>>2]=w;y=d+116|0;c[y>>2]=0;z=d+120|0;c[z>>2]=0;i=h;return}}function Ij(a){a=
a|0;return}function Jj(a,d){a=a|0;d=d|0;var f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;f=i;i=i+16|0;h=f;j=a+104|0;if((c[(c[j>>2]|0)+102876>>2]&2|0)!=0){i=f;return}if((c[a>>2]|0)==(d|0)){i=f;return}c[a>>2]=d;Kj(a);if((c[a>>2]|0)==0?(g[a+80>>2]=0,g[a+84>>2]=0,g[a+88>>2]=0,l=+g[a+72>>2],g[a+68>>2]=l,d=a+60|0,m=c[d>>2]|0,n=c[d+4>>2]|0,d=a+52|0,c[d>>2]=m,c[d+4>>2]=n,o=+T(+l),g[h+8>>2]=o,p=+S(+l),g[h+12>>2]=p,l=+g[a+44>>2],q=+g[a+48>>2],r=(c[k>>2]=m,+g[k>>2])-(p*l-o*q),s=(c[k>>2]=n,+g[k>>2])-(o*
l+p*q),q=+r,r=+s,n=h,g[n>>2]=q,g[n+4>>2]=r,n=(c[j>>2]|0)+102880|0,m=c[a+116>>2]|0,(m|0)!=0):0){d=a+12|0;t=m;do{qj(t,n,h,d);t=c[t+4>>2]|0}while((t|0)!=0)}t=a+4|0;d=e[t>>1]|0;if((d&2|0)==0){b[t>>1]=d|2;g[a+160>>2]=0}g[a+92>>2]=0;g[a+96>>2]=0;g[a+100>>2]=0;d=a+128|0;t=c[d>>2]|0;if((t|0)!=0){h=t;do{t=h;h=c[h+12>>2]|0;Tj((c[j>>2]|0)+102880|0,c[t+4>>2]|0)}while((h|0)!=0)}c[d>>2]=0;d=(c[j>>2]|0)+102880|0;j=c[a+116>>2]|0;if((j|0)==0){i=f;return}else u=j;do{j=c[u+28>>2]|0;if((j|0)>0){a=u+24|0;h=0;do{Re(d,
c[(c[a>>2]|0)+(h*28|0)+24>>2]|0);h=h+1|0}while((h|0)!=(j|0))}u=c[u+4>>2]|0}while((u|0)!=0);i=f;return}function Kj(a){a=a|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0;d=i;i=i+16|0;e=d;f=a+132|0;h=a+136|0;j=a+140|0;k=a+144|0;l=a+44|0;g[l>>2]=0;g[a+48>>2]=0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;if((c[a>>2]|0)>>>0<2){m=a+12|0;n=c[m>>2]|0;o=c[m+4>>2]|0;m=a+52|0;c[m>>2]=n;c[m+4>>2]=o;m=a+60|0;
c[m>>2]=n;c[m+4>>2]=o;g[a+68>>2]=+g[a+72>>2];i=d;return}o=8784;p=+g[o>>2];q=+g[o+4>>2];o=c[a+116>>2]|0;if((o|0)!=0){m=e+4|0;n=e+8|0;r=e+12|0;s=0;t=0;u=p;v=q;w=o;while(1){x=+g[w>>2];if(x==0){y=s;z=t;A=u;B=v}else{o=c[w+12>>2]|0;kb[c[(c[o>>2]|0)+32>>2]&31](o,e,x);x=+g[e>>2];C=x+ +g[f>>2];g[f>>2]=C;D=u+x*+g[m>>2];E=v+x*+g[n>>2];x=+g[r>>2]+ +g[j>>2];g[j>>2]=x;y=x;z=C;A=D;B=E}w=c[w+4>>2]|0;if((w|0)==0)break;else{s=y;t=z;u=A;v=B}}if(z>0){v=1/z;g[h>>2]=v;F=y;G=A*v;H=B*v;I=z}else{J=B;K=A;L=y;M=10}}else{J=
q;K=p;L=0;M=10}if((M|0)==10){g[f>>2]=1;g[h>>2]=1;F=L;G=K;H=J;I=1}if(F>0?(b[a+4>>1]&16)==0:0){J=F-(H*H+G*G)*I;g[j>>2]=J;N=1/J}else{g[j>>2]=0;N=0}g[k>>2]=N;k=a+60|0;j=k;N=+g[j>>2];J=+g[j+4>>2];I=+G;F=+H;j=l;g[j>>2]=I;g[j+4>>2]=F;F=+g[a+24>>2];I=+g[a+20>>2];K=+g[a+12>>2]+(F*G-I*H);L=G*I+F*H+ +g[a+16>>2];H=+K;F=+L;j=k;g[j>>2]=H;g[j+4>>2]=F;j=a+52|0;g[j>>2]=H;g[j+4>>2]=F;F=+g[a+88>>2];j=a+80|0;g[j>>2]=+g[j>>2]-F*(L-J);j=a+84|0;g[j>>2]=F*(K-N)+ +g[j>>2];i=d;return}function Lj(a){a=a|0;var b=0,d=0,e=0,f=
0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;b=i;i=i+16|0;d=b;e=+g[a+68>>2];f=+T(+e);g[d+8>>2]=f;h=+S(+e);g[d+12>>2]=h;e=+g[a+44>>2];j=+g[a+48>>2];k=+(+g[a+52>>2]-(h*e-f*j));l=+(+g[a+56>>2]-(e*f+h*j));m=d;g[m>>2]=k;g[m+4>>2]=l;m=(c[a+104>>2]|0)+102880|0;n=c[a+116>>2]|0;if((n|0)==0){i=b;return}o=a+12|0;a=n;do{qj(a,m,d,o);a=c[a+4>>2]|0}while((a|0)!=0);i=b;return}function Mj(a,d){a=a|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0;e=i;f=a+104|0;h=c[f>>2]|0;if((c[h+102876>>2]&2|0)!=0){j=0;i=e;return j|0}k=Em(h,44)|0;if((k|0)==
0)l=0;else{lj(k);l=k}mj(l,h,a,d);if(!((b[a+4>>1]&32)==0))oj(l,(c[f>>2]|0)+102880|0,a+12|0);d=a+116|0;c[l+4>>2]=c[d>>2];c[d>>2]=l;d=a+120|0;c[d>>2]=(c[d>>2]|0)+1;c[l+8>>2]=a;if(+g[l>>2]>0)Kj(a);a=(c[f>>2]|0)+102876|0;c[a>>2]=c[a>>2]|1;j=l;i=e;return j|0}function Nj(a,d){a=a|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0;e=i;f=a+104|0;if((c[(c[f>>2]|0)+102876>>2]&2|0)!=0){i=e;return}g=a+116|0;h=c[g>>2]|0;a:do if((h|0)!=0){j=h;k=g;while(1){l=j+4|0;if((j|0)==(d|0))break;j=c[l>>2]|0;if((j|0)==0)break a;else k=
l}c[k>>2]=c[d+4>>2]}while(0);g=c[a+128>>2]|0;if((g|0)!=0){h=g;do{g=c[h+4>>2]|0;h=c[h+12>>2]|0;if((c[g+48>>2]|0)==(d|0)?1:(c[g+52>>2]|0)==(d|0))Tj((c[f>>2]|0)+102880|0,g)}while((h|0)!=0)}h=c[f>>2]|0;if(!((b[a+4>>1]&32)==0))pj(d,h+102880|0);nj(d,h);c[d+8>>2]=0;c[d+4>>2]=0;Fm(h,d,44);d=a+120|0;c[d>>2]=(c[d>>2]|0)+-1;Kj(a);i=e;return}function Oj(a,d){a=a|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;e=i;if((c[(c[a+104>>2]|0)+102876>>2]&2|0)!=0){i=e;return}if((c[a>>2]|0)!=2){i=e;return}f=
a+136|0;g[f>>2]=0;h=a+140|0;g[h>>2]=0;j=a+144|0;g[j>>2]=0;l=+g[d>>2];m=!(l<=0)?l:1;g[a+132>>2]=m;g[f>>2]=1/m;l=+g[d+12>>2];if(l>0?(b[a+4>>1]&16)==0:0){n=+g[d+4>>2];o=+g[d+8>>2];p=l-m*(n*n+o*o);g[h>>2]=p;g[j>>2]=1/p}j=a+60|0;h=j;p=+g[h>>2];o=+g[h+4>>2];h=d+4|0;d=c[h>>2]|0;f=c[h+4>>2]|0;h=a+44|0;c[h>>2]=d;c[h+4>>2]=f;n=+g[a+24>>2];m=(c[k>>2]=d,+g[k>>2]);l=+g[a+20>>2];q=(c[k>>2]=f,+g[k>>2]);r=+g[a+12>>2]+(n*m-l*q);s=m*l+n*q+ +g[a+16>>2];q=+r;n=+s;f=j;g[f>>2]=q;g[f+4>>2]=n;f=a+52|0;g[f>>2]=q;g[f+4>>2]=
n;n=+g[a+88>>2];f=a+80|0;g[f>>2]=+g[f>>2]-n*(s-o);f=a+84|0;g[f>>2]=n*(r-p)+ +g[f>>2];i=e;return}function Pj(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0;e=i;if((c[b>>2]|0)!=2?(c[d>>2]|0)!=2:0)f=0;else g=3;a:do if((g|0)==3){h=c[b+124>>2]|0;if((h|0)==0)f=1;else{j=h;while(1){if((c[j>>2]|0)==(d|0)?(a[(c[j+4>>2]|0)+61>>0]|0)==0:0){f=0;break a}j=c[j+12>>2]|0;if((j|0)==0){f=1;break}}}}while(0);i=e;return f|0}function Qj(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;e=i;f=c[a+104>>
2]|0;if((c[f+102876>>2]&2|0)!=0){i=e;return}h=a+12|0;j=+T(+d);g[a+20>>2]=j;l=+S(+d);g[a+24>>2]=l;m=b;b=c[m>>2]|0;n=c[m+4>>2]|0;m=h;c[m>>2]=b;c[m+4>>2]=n;m=a+28|0;c[m+0>>2]=c[h+0>>2];c[m+4>>2]=c[h+4>>2];c[m+8>>2]=c[h+8>>2];c[m+12>>2]=c[h+12>>2];o=+g[a+44>>2];p=+g[a+48>>2];q=(c[k>>2]=b,+g[k>>2])+(l*o-j*p);r=o*j+l*p+(c[k>>2]=n,+g[k>>2]);p=+q;q=+r;n=a+60|0;g[n>>2]=p;g[n+4>>2]=q;g[a+72>>2]=d;n=a+52|0;g[n>>2]=p;g[n+4>>2]=q;g[a+68>>2]=d;n=f+102880|0;f=c[a+116>>2]|0;if((f|0)==0){i=e;return}else s=f;do{qj(s,
n,h,h);s=c[s+4>>2]|0}while((s|0)!=0);i=e;return}function Rj(a){a=a|0;return}function Sj(a){a=a|0;var b=0;b=i;Me(a);c[a+60>>2]=0;c[a+64>>2]=0;c[a+68>>2]=6800;c[a+72>>2]=6808;c[a+76>>2]=0;i=b;return}function Tj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;d=i;e=c[(c[b+48>>2]|0)+8>>2]|0;f=c[(c[b+52>>2]|0)+8>>2]|0;g=c[a+72>>2]|0;if((g|0)!=0?(c[b+4>>2]&2|0)!=0:0)gb[c[(c[g>>2]|0)+12>>2]&63](g,b);g=b+8|0;h=c[g>>2]|0;j=b+12|0;if((h|0)!=0)c[h+12>>2]=c[j>>2];h=c[j>>2]|0;if((h|0)!=0)c[h+
8>>2]=c[g>>2];g=a+60|0;if((c[g>>2]|0)==(b|0))c[g>>2]=c[j>>2];j=b+24|0;g=c[j>>2]|0;h=b+28|0;if((g|0)!=0)c[g+12>>2]=c[h>>2];g=c[h>>2]|0;if((g|0)!=0)c[g+8>>2]=c[j>>2];j=e+128|0;if((b+16|0)==(c[j>>2]|0))c[j>>2]=c[h>>2];h=b+40|0;j=c[h>>2]|0;e=b+44|0;if((j|0)!=0)c[j+12>>2]=c[e>>2];j=c[e>>2]|0;if((j|0)!=0)c[j+8>>2]=c[h>>2];h=f+128|0;if((b+32|0)!=(c[h>>2]|0)){k=a+76|0;l=c[k>>2]|0;vi(b,l);m=a+64|0;n=c[m>>2]|0;o=n+-1|0;c[m>>2]=o;i=d;return}c[h>>2]=c[e>>2];k=a+76|0;l=c[k>>2]|0;vi(b,l);m=a+64|0;n=c[m>>2]|0;o=
n+-1|0;c[m>>2]=o;i=d;return}function Uj(a){a=a|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0;d=i;e=c[a+60>>2]|0;if((e|0)==0){i=d;return}f=a+4|0;h=a+72|0;j=a+68|0;k=e;while(1){e=c[k+48>>2]|0;l=c[k+52>>2]|0;m=c[k+56>>2]|0;n=c[k+60>>2]|0;o=c[e+8>>2]|0;p=c[l+8>>2]|0;q=k+4|0;do if((c[q>>2]&8|0)==0)r=11;else{if(!(Pj(p,o)|0)){s=c[k+12>>2]|0;Tj(a,k);t=s;break}s=c[j>>2]|0;if((s|0)!=0?!(hb[c[(c[s>>2]|0)+8>>2]&15](s,e,l)|0):0){s=c[k+12>>2]|0;Tj(a,k);t=s;break}c[q>>2]=c[q>>2]&
-9;r=11}while(0);do if((r|0)==11){r=0;if((b[o+4>>1]&2)==0)u=0;else u=(c[o>>2]|0)!=0;if((b[p+4>>1]&2)==0)v=0;else v=(c[p>>2]|0)!=0;if(!(u|v)){t=c[k+12>>2]|0;break}q=c[(c[e+24>>2]|0)+(m*28|0)+24>>2]|0;s=c[(c[l+24>>2]|0)+(n*28|0)+24>>2]|0;w=c[f>>2]|0;if((+g[w+(s*36|0)>>2]-+g[w+(q*36|0)+8>>2]>0?1:+g[w+(s*36|0)+4>>2]-+g[w+(q*36|0)+12>>2]>0)|+g[w+(q*36|0)>>2]-+g[w+(s*36|0)+8>>2]>0|+g[w+(q*36|0)+4>>2]-+g[w+(s*36|0)+12>>2]>0){s=c[k+12>>2]|0;Tj(a,k);t=s;break}else{xi(k,c[h>>2]|0);t=c[k+12>>2]|0;break}}while(0);
if((t|0)==0)break;else k=t}i=d;return}function Vj(a){a=a|0;var b=0;b=i;Wj(a,a);i=b;return}function Wj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;d=i;i=i+16|0;e=d;f=a+52|0;c[f>>2]=0;g=a+40|0;h=c[g>>2]|0;if((h|0)>0){j=a+32|0;k=a+56|0;l=a+4|0;m=h;h=0;while(1){n=c[(c[j>>2]|0)+(h<<2)>>2]|0;c[k>>2]=n;if((n|0)==-1)o=m;else{Yj(a,a,(c[l>>2]|0)+(n*36|0)|0);o=c[g>>2]|0}h=h+1|0;if((h|0)>=(o|0))break;else m=o}p=c[f>>2]|0}else p=0;c[g>>2]=0;g=a+44|0;o=c[g>>2]|0;c[e>>2]=26;_j(o,o+(p<<3)|
0,e);if((c[f>>2]|0)<=0){i=d;return}e=a+4|0;a=0;a:while(1){p=c[g>>2]|0;o=p+(a<<3)|0;m=c[e>>2]|0;h=p+(a<<3)+4|0;Xj(b,c[m+((c[o>>2]|0)*36|0)+16>>2]|0,c[m+((c[h>>2]|0)*36|0)+16>>2]|0);m=c[f>>2]|0;p=a;while(1){l=p+1|0;if((l|0)>=(m|0))break a;k=c[g>>2]|0;if((c[k+(l<<3)>>2]|0)!=(c[o>>2]|0)){a=l;continue a}if((c[k+(l<<3)+4>>2]|0)==(c[h>>2]|0))p=l;else{a=l;continue a}}}i=d;return}function Xj(d,f,h){d=d|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;j=i;k=c[f+16>>2]|0;l=c[h+16>>2]|0;
m=c[f+20>>2]|0;f=c[h+20>>2]|0;h=c[k+8>>2]|0;n=c[l+8>>2]|0;if((h|0)==(n|0)){i=j;return}o=c[n+128>>2]|0;a:do if((o|0)!=0){p=o;while(1){if((c[p>>2]|0)==(h|0)){q=c[p+4>>2]|0;r=c[q+48>>2]|0;s=c[q+52>>2]|0;t=c[q+56>>2]|0;u=c[q+60>>2]|0;if((r|0)==(k|0)&(s|0)==(l|0)&(t|0)==(m|0)&(u|0)==(f|0)){v=24;break}if((r|0)==(l|0)&(s|0)==(k|0)&(t|0)==(f|0)&(u|0)==(m|0)){v=24;break}}p=c[p+12>>2]|0;if((p|0)==0)break a}if((v|0)==24){i=j;return}}while(0);if(!(Pj(n,h)|0)){i=j;return}h=c[d+68>>2]|0;if((h|0)!=0?!(hb[c[(c[h>>
2]|0)+8>>2]&15](h,k,l)|0):0){i=j;return}h=ui(k,m,l,f,c[d+76>>2]|0)|0;if((h|0)==0){i=j;return}f=c[h+48>>2]|0;l=c[h+52>>2]|0;m=c[f+8>>2]|0;k=c[l+8>>2]|0;c[h+8>>2]=0;n=d+60|0;c[h+12>>2]=c[n>>2];v=c[n>>2]|0;if((v|0)!=0)c[v+8>>2]=h;c[n>>2]=h;n=h+16|0;c[h+20>>2]=h;c[n>>2]=k;c[h+24>>2]=0;v=m+128|0;c[h+28>>2]=c[v>>2];o=c[v>>2]|0;if((o|0)!=0)c[o+8>>2]=n;c[v>>2]=n;n=h+32|0;c[h+36>>2]=h;c[n>>2]=m;c[h+40>>2]=0;v=k+128|0;c[h+44>>2]=c[v>>2];h=c[v>>2]|0;if((h|0)!=0)c[h+8>>2]=n;c[v>>2]=n;if((a[f+38>>0]|0)==0?(a[l+
38>>0]|0)==0:0){l=m+4|0;f=e[l>>1]|0;if((f&2|0)==0){b[l>>1]=f|2;g[m+160>>2]=0}m=k+4|0;f=e[m>>1]|0;if((f&2|0)==0){b[m>>1]=f|2;g[k+160>>2]=0}}k=d+64|0;c[k>>2]=(c[k>>2]|0)+1;i=j;return}function Yj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;e=i;i=i+1040|0;f=e;h=f+4|0;c[f>>2]=h;j=f+1028|0;c[j>>2]=0;k=f+1032|0;c[k>>2]=256;l=c[f>>2]|0;c[l+(c[j>>2]<<2)>>2]=c[a>>2];m=c[j>>2]|0;n=m+1|0;c[j>>2]=n;a:do if((m|0)>-1){o=a+4|0;p=d+4|0;q=d+8|0;r=
d+12|0;s=n;t=l;while(1){u=s+-1|0;c[j>>2]=u;v=c[t+(u<<2)>>2]|0;do if(!((v|0)==-1)?(w=c[o>>2]|0,!((+g[d>>2]-+g[w+(v*36|0)+8>>2]>0?1:+g[p>>2]-+g[w+(v*36|0)+12>>2]>0)|+g[w+(v*36|0)>>2]-+g[q>>2]>0|+g[w+(v*36|0)+4>>2]-+g[r>>2]>0)):0){x=w+(v*36|0)+24|0;if((c[x>>2]|0)==-1){if(!(Se(b,v)|0))break a;y=c[j>>2]|0;break}if((u|0)==(c[k>>2]|0)?(c[k>>2]=u<<1,z=Pm(u<<3)|0,c[f>>2]=z,An(z|0,t|0,c[j>>2]<<2|0)|0,(t|0)!=(h|0)):0)Qm(t);z=c[f>>2]|0;c[z+(c[j>>2]<<2)>>2]=c[x>>2];x=(c[j>>2]|0)+1|0;c[j>>2]=x;A=w+(v*36|0)+28|
0;if((x|0)==(c[k>>2]|0)?(c[k>>2]=x<<1,w=Pm(x<<3)|0,c[f>>2]=w,An(w|0,z|0,c[j>>2]<<2|0)|0,(z|0)!=(h|0)):0)Qm(z);c[(c[f>>2]|0)+(c[j>>2]<<2)>>2]=c[A>>2];A=(c[j>>2]|0)+1|0;c[j>>2]=A;y=A}else y=u;while(0);if((y|0)<=0)break a;s=y;t=c[f>>2]|0}}while(0);y=c[f>>2]|0;if((y|0)==(h|0)){i=e;return}Qm(y);c[f>>2]=0;i=e;return}function Zj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=c[a>>2]|0;f=c[b>>2]|0;if((e|0)>=(f|0))if((e|0)==(f|0))g=(c[a+4>>2]|0)<(c[b+4>>2]|0);else g=0;else g=1;i=d;return g|0}function _j(a,b,d){a=
a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0;e=i;f=a;a=b;a:while(1){b=a;g=a+-8|0;h=f;b:while(1){j=h;k=b-j|0;l=k>>3;switch(l|0){case 5:m=15;break a;break;case 2:m=4;break a;break;case 4:m=14;break a;break;case 1:case 0:m=67;break a;break;case 3:m=6;break a;break;default:}if((k|0)<248){m=21;break a}n=(l|0)/2|0;o=h+(n<<3)|0;do if((k|0)>7992){p=(l|0)/4|0;q=h+(p<<3)|0;r=h+(p+n<<3)|0;p=
$j(h,q,o,r,d)|0;if(nb[c[d>>2]&31](g,r)|0){s=r;t=c[s>>2]|0;u=c[s+4>>2]|0;s=g;v=c[s+4>>2]|0;w=r;c[w>>2]=c[s>>2];c[w+4>>2]=v;v=g;c[v>>2]=t;c[v+4>>2]=u;u=p+1|0;if(nb[c[d>>2]&31](r,o)|0){v=o;t=c[v>>2]|0;w=c[v+4>>2]|0;v=r;s=c[v+4>>2]|0;x=o;c[x>>2]=c[v>>2];c[x+4>>2]=s;s=r;c[s>>2]=t;c[s+4>>2]=w;w=p+2|0;if(nb[c[d>>2]&31](o,q)|0){s=q;t=c[s>>2]|0;r=c[s+4>>2]|0;s=o;x=c[s+4>>2]|0;v=q;c[v>>2]=c[s>>2];c[v+4>>2]=x;x=o;c[x>>2]=t;c[x+4>>2]=r;if(nb[c[d>>2]&31](q,h)|0){r=h;x=c[r>>2]|0;t=c[r+4>>2]|0;r=q;v=c[r+4>>2]|0;
s=h;c[s>>2]=c[r>>2];c[s+4>>2]=v;v=q;c[v>>2]=x;c[v+4>>2]=t;y=p+4|0}else y=p+3|0}else y=w}else y=u}else y=p}else{p=nb[c[d>>2]&31](o,h)|0;u=nb[c[d>>2]&31](g,o)|0;if(!p){if(!u){y=0;break}p=o;w=c[p>>2]|0;t=c[p+4>>2]|0;p=g;v=c[p+4>>2]|0;x=o;c[x>>2]=c[p>>2];c[x+4>>2]=v;v=g;c[v>>2]=w;c[v+4>>2]=t;if(!(nb[c[d>>2]&31](o,h)|0)){y=1;break}t=h;v=c[t>>2]|0;w=c[t+4>>2]|0;t=o;x=c[t+4>>2]|0;p=h;c[p>>2]=c[t>>2];c[p+4>>2]=x;x=o;c[x>>2]=v;c[x+4>>2]=w;y=2;break}w=h;x=c[w>>2]|0;v=c[w+4>>2]|0;if(u){u=g;w=c[u+4>>2]|0;p=h;
c[p>>2]=c[u>>2];c[p+4>>2]=w;w=g;c[w>>2]=x;c[w+4>>2]=v;y=1;break}w=o;p=c[w+4>>2]|0;u=h;c[u>>2]=c[w>>2];c[u+4>>2]=p;p=o;c[p>>2]=x;c[p+4>>2]=v;if(nb[c[d>>2]&31](g,o)|0){v=o;p=c[v>>2]|0;x=c[v+4>>2]|0;v=g;u=c[v+4>>2]|0;w=o;c[w>>2]=c[v>>2];c[w+4>>2]=u;u=g;c[u>>2]=p;c[u+4>>2]=x;y=2}else y=1}while(0);do if(nb[c[d>>2]&31](h,o)|0){z=g;A=y}else{n=g;while(1){n=n+-8|0;if((h|0)==(n|0))break;if(nb[c[d>>2]&31](n,o)|0){m=50;break}}if((m|0)==50){m=0;l=h;k=c[l>>2]|0;x=c[l+4>>2]|0;l=n;u=c[l+4>>2]|0;p=h;c[p>>2]=c[l>>
2];c[p+4>>2]=u;u=n;c[u>>2]=k;c[u+4>>2]=x;z=n;A=y+1|0;break}x=h+8|0;if(nb[c[d>>2]&31](h,g)|0)B=x;else{if((x|0)==(g|0)){m=67;break a}else C=x;while(1){D=C+8|0;if(nb[c[d>>2]&31](h,C)|0)break;if((D|0)==(g|0)){m=67;break a}else C=D}n=C;x=c[n>>2]|0;u=c[n+4>>2]|0;n=g;k=c[n+4>>2]|0;p=C;c[p>>2]=c[n>>2];c[p+4>>2]=k;k=g;c[k>>2]=x;c[k+4>>2]=u;B=D}if((B|0)==(g|0)){m=67;break a}else{E=B;F=g}while(1){u=E;while(1){G=u+8|0;if(nb[c[d>>2]&31](h,u)|0){H=F;break}else u=G}do H=H+-8|0;while(nb[c[d>>2]&31](h,H)|0);if(!(u>>>
0<H>>>0)){h=u;continue b}k=u;x=c[k>>2]|0;p=c[k+4>>2]|0;k=H;n=c[k+4>>2]|0;l=u;c[l>>2]=c[k>>2];c[l+4>>2]=n;n=H;c[n>>2]=x;c[n+4>>2]=p;E=G;F=H}}while(0);p=h+8|0;c:do if(p>>>0<z>>>0){n=p;x=z;l=o;k=A;while(1){w=n;while(1){I=w+8|0;if(nb[c[d>>2]&31](w,l)|0)w=I;else{J=x;break}}do J=J+-8|0;while(!(nb[c[d>>2]&31](J,l)|0));if(w>>>0>J>>>0){K=w;L=l;M=k;break c}u=w;v=c[u>>2]|0;t=c[u+4>>2]|0;u=J;q=c[u+4>>2]|0;s=w;c[s>>2]=c[u>>2];c[s+4>>2]=q;q=J;c[q>>2]=v;c[q+4>>2]=t;n=I;x=J;l=(l|0)==(w|0)?J:l;k=k+1|0}}else{K=p;L=
o;M=A}while(0);if((K|0)!=(L|0)?nb[c[d>>2]&31](L,K)|0:0){o=K;p=c[o>>2]|0;k=c[o+4>>2]|0;o=L;l=c[o+4>>2]|0;x=K;c[x>>2]=c[o>>2];c[x+4>>2]=l;l=L;c[l>>2]=p;c[l+4>>2]=k;N=M+1|0}else N=M;if((N|0)==0){O=bk(h,K,d)|0;k=K+8|0;if(bk(k,a,d)|0){m=62;break}if(O){h=k;continue}}k=K;if((k-j|0)>=(b-k|0)){m=66;break}_j(h,K,d);h=K+8|0}if((m|0)==62){m=0;if(O){m=67;break}else{f=h;a=K;continue}}else if((m|0)==66){m=0;_j(K+8|0,a,d);f=h;a=K;continue}}if((m|0)==4){if(!(nb[c[d>>2]&31](g,h)|0)){i=e;return}K=h;f=c[K>>2]|0;O=c[K+
4>>2]|0;K=g;N=c[K+4>>2]|0;M=h;c[M>>2]=c[K>>2];c[M+4>>2]=N;N=g;c[N>>2]=f;c[N+4>>2]=O;i=e;return}else if((m|0)==6){O=h+8|0;N=nb[c[d>>2]&31](O,h)|0;f=nb[c[d>>2]&31](g,O)|0;if(!N){if(!f){i=e;return}N=O;M=c[N>>2]|0;K=c[N+4>>2]|0;N=g;L=c[N+4>>2]|0;A=O;c[A>>2]=c[N>>2];c[A+4>>2]=L;L=g;c[L>>2]=M;c[L+4>>2]=K;if(!(nb[c[d>>2]&31](O,h)|0)){i=e;return}K=h;L=c[K>>2]|0;M=c[K+4>>2]|0;K=O;A=c[K+4>>2]|0;N=h;c[N>>2]=c[K>>2];c[N+4>>2]=A;A=O;c[A>>2]=L;c[A+4>>2]=M;i=e;return}M=h;A=c[M>>2]|0;L=c[M+4>>2]|0;if(f){f=g;M=c[f+
4>>2]|0;N=h;c[N>>2]=c[f>>2];c[N+4>>2]=M;M=g;c[M>>2]=A;c[M+4>>2]=L;i=e;return}M=O;N=c[M+4>>2]|0;f=h;c[f>>2]=c[M>>2];c[f+4>>2]=N;N=O;c[N>>2]=A;c[N+4>>2]=L;if(!(nb[c[d>>2]&31](g,O)|0)){i=e;return}L=O;N=c[L>>2]|0;A=c[L+4>>2]|0;L=g;f=c[L+4>>2]|0;M=O;c[M>>2]=c[L>>2];c[M+4>>2]=f;f=g;c[f>>2]=N;c[f+4>>2]=A;i=e;return}else if((m|0)==14){$j(h,h+8|0,h+16|0,g,d)|0;i=e;return}else if((m|0)==15){A=h+8|0;f=h+16|0;N=h+24|0;$j(h,A,f,N,d)|0;if(!(nb[c[d>>2]&31](g,N)|0)){i=e;return}M=N;L=c[M>>2]|0;O=c[M+4>>2]|0;M=g;K=
c[M+4>>2]|0;J=N;c[J>>2]=c[M>>2];c[J+4>>2]=K;K=g;c[K>>2]=L;c[K+4>>2]=O;if(!(nb[c[d>>2]&31](N,f)|0)){i=e;return}O=f;K=c[O>>2]|0;L=c[O+4>>2]|0;O=N;g=c[O+4>>2]|0;J=f;c[J>>2]=c[O>>2];c[J+4>>2]=g;g=N;c[g>>2]=K;c[g+4>>2]=L;if(!(nb[c[d>>2]&31](f,A)|0)){i=e;return}L=A;g=c[L>>2]|0;K=c[L+4>>2]|0;L=f;N=c[L+4>>2]|0;J=A;c[J>>2]=c[L>>2];c[J+4>>2]=N;N=f;c[N>>2]=g;c[N+4>>2]=K;if(!(nb[c[d>>2]&31](A,h)|0)){i=e;return}K=h;N=c[K>>2]|0;g=c[K+4>>2]|0;K=A;f=c[K+4>>2]|0;J=h;c[J>>2]=c[K>>2];c[J+4>>2]=f;f=A;c[f>>2]=N;c[f+4>>
2]=g;i=e;return}else if((m|0)==21){ak(h,a,d);i=e;return}else if((m|0)==67){i=e;return}}function $j(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;g=i;h=nb[c[f>>2]&31](b,a)|0;j=nb[c[f>>2]&31](d,b)|0;do if(h){k=a;l=c[k>>2]|0;m=c[k+4>>2]|0;if(j){k=d;n=c[k+4>>2]|0;o=a;c[o>>2]=c[k>>2];c[o+4>>2]=n;n=d;c[n>>2]=l;c[n+4>>2]=m;p=1;break}n=b;o=c[n+4>>2]|0;k=a;c[k>>2]=c[n>>2];c[k+4>>2]=o;o=b;c[o>>2]=l;c[o+4>>2]=m;if(nb[c[f>>2]&31](d,b)|0){m=b;o=c[m>>2]|0;l=c[m+4>>2]|0;m=
d;k=c[m+4>>2]|0;n=b;c[n>>2]=c[m>>2];c[n+4>>2]=k;k=d;c[k>>2]=o;c[k+4>>2]=l;p=2}else p=1}else if(j){l=b;k=c[l>>2]|0;o=c[l+4>>2]|0;l=d;n=c[l+4>>2]|0;m=b;c[m>>2]=c[l>>2];c[m+4>>2]=n;n=d;c[n>>2]=k;c[n+4>>2]=o;if(nb[c[f>>2]&31](b,a)|0){o=a;n=c[o>>2]|0;k=c[o+4>>2]|0;o=b;m=c[o+4>>2]|0;l=a;c[l>>2]=c[o>>2];c[l+4>>2]=m;m=b;c[m>>2]=n;c[m+4>>2]=k;p=2}else p=1}else p=0;while(0);if(!(nb[c[f>>2]&31](e,d)|0)){q=p;i=g;return q|0}j=d;h=c[j>>2]|0;k=c[j+4>>2]|0;j=e;m=c[j+4>>2]|0;n=d;c[n>>2]=c[j>>2];c[n+4>>2]=m;m=e;c[m>>
2]=h;c[m+4>>2]=k;if(!(nb[c[f>>2]&31](d,b)|0)){q=p+1|0;i=g;return q|0}k=b;m=c[k>>2]|0;h=c[k+4>>2]|0;k=d;e=c[k+4>>2]|0;n=b;c[n>>2]=c[k>>2];c[n+4>>2]=e;e=d;c[e>>2]=m;c[e+4>>2]=h;if(!(nb[c[f>>2]&31](b,a)|0)){q=p+2|0;i=g;return q|0}f=a;h=c[f>>2]|0;e=c[f+4>>2]|0;f=b;m=c[f+4>>2]|0;d=a;c[d>>2]=c[f>>2];c[d+4>>2]=m;m=b;c[m>>2]=h;c[m+4>>2]=e;q=p+3|0;i=g;return q|0}function ak(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;e=i;i=i+16|0;f=e;g=a+16|0;h=a+8|0;j=nb[c[d>>2]&31](h,
a)|0;k=nb[c[d>>2]&31](g,h)|0;do if(j){l=a;m=c[l>>2]|0;n=c[l+4>>2]|0;if(k){l=g;o=c[l+4>>2]|0;p=a;c[p>>2]=c[l>>2];c[p+4>>2]=o;o=g;c[o>>2]=m;c[o+4>>2]=n;break}o=h;p=c[o+4>>2]|0;l=a;c[l>>2]=c[o>>2];c[l+4>>2]=p;p=h;c[p>>2]=m;c[p+4>>2]=n;if(nb[c[d>>2]&31](g,h)|0){n=h;p=c[n>>2]|0;m=c[n+4>>2]|0;n=g;l=c[n+4>>2]|0;o=h;c[o>>2]=c[n>>2];c[o+4>>2]=l;l=g;c[l>>2]=p;c[l+4>>2]=m}}else if(k?(m=h,l=c[m>>2]|0,p=c[m+4>>2]|0,m=g,o=c[m+4>>2]|0,n=h,c[n>>2]=c[m>>2],c[n+4>>2]=o,o=g,c[o>>2]=l,c[o+4>>2]=p,nb[c[d>>2]&31](h,a)|
0):0){p=a;o=c[p>>2]|0;l=c[p+4>>2]|0;p=h;n=c[p+4>>2]|0;m=a;c[m>>2]=c[p>>2];c[m+4>>2]=n;n=h;c[n>>2]=o;c[n+4>>2]=l}while(0);h=a+24|0;if((h|0)==(b|0)){i=e;return}else{q=h;r=g}while(1){if(nb[c[d>>2]&31](q,r)|0){g=q;h=c[g+4>>2]|0;k=f;c[k>>2]=c[g>>2];c[k+4>>2]=h;h=q;k=r;while(1){g=k;j=c[g+4>>2]|0;l=h;c[l>>2]=c[g>>2];c[l+4>>2]=j;if((k|0)==(a|0))break;j=k+-8|0;if(nb[c[d>>2]&31](f,j)|0){l=k;k=j;h=l}else break}h=f;l=c[h+4>>2]|0;j=k;c[j>>2]=c[h>>2];c[j+4>>2]=l}l=q+8|0;if((l|0)==(b|0))break;else{j=q;q=l;r=j}}i=
e;return}function bk(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;e=i;i=i+16|0;f=e;switch(b-a>>3|0){case 2:g=b+-8|0;if(!(nb[c[d>>2]&31](g,a)|0)){h=1;i=e;return h|0}j=a;k=c[j>>2]|0;l=c[j+4>>2]|0;j=g;m=c[j+4>>2]|0;n=a;c[n>>2]=c[j>>2];c[n+4>>2]=m;m=g;c[m>>2]=k;c[m+4>>2]=l;h=1;i=e;return h|0;case 4:$j(a,a+8|0,a+16|0,b+-8|0,d)|0;h=1;i=e;return h|0;case 5:l=a+8|0;m=a+16|0;k=a+24|0;g=b+-8|0;$j(a,l,m,k,d)|0;if(!(nb[c[d>>2]&31](g,k)|0)){h=1;i=e;return h|
0}n=k;j=c[n>>2]|0;o=c[n+4>>2]|0;n=g;p=c[n+4>>2]|0;q=k;c[q>>2]=c[n>>2];c[q+4>>2]=p;p=g;c[p>>2]=j;c[p+4>>2]=o;if(!(nb[c[d>>2]&31](k,m)|0)){h=1;i=e;return h|0}o=m;p=c[o>>2]|0;j=c[o+4>>2]|0;o=k;g=c[o+4>>2]|0;q=m;c[q>>2]=c[o>>2];c[q+4>>2]=g;g=k;c[g>>2]=p;c[g+4>>2]=j;if(!(nb[c[d>>2]&31](m,l)|0)){h=1;i=e;return h|0}j=l;g=c[j>>2]|0;p=c[j+4>>2]|0;j=m;k=c[j+4>>2]|0;q=l;c[q>>2]=c[j>>2];c[q+4>>2]=k;k=m;c[k>>2]=g;c[k+4>>2]=p;if(!(nb[c[d>>2]&31](l,a)|0)){h=1;i=e;return h|0}p=a;k=c[p>>2]|0;g=c[p+4>>2]|0;p=l;m=c[p+
4>>2]|0;q=a;c[q>>2]=c[p>>2];c[q+4>>2]=m;m=l;c[m>>2]=k;c[m+4>>2]=g;h=1;i=e;return h|0;case 3:g=a+8|0;m=b+-8|0;k=nb[c[d>>2]&31](g,a)|0;l=nb[c[d>>2]&31](m,g)|0;if(!k){if(!l){h=1;i=e;return h|0}k=g;q=c[k>>2]|0;p=c[k+4>>2]|0;k=m;j=c[k+4>>2]|0;o=g;c[o>>2]=c[k>>2];c[o+4>>2]=j;j=m;c[j>>2]=q;c[j+4>>2]=p;if(!(nb[c[d>>2]&31](g,a)|0)){h=1;i=e;return h|0}p=a;j=c[p>>2]|0;q=c[p+4>>2]|0;p=g;o=c[p+4>>2]|0;k=a;c[k>>2]=c[p>>2];c[k+4>>2]=o;o=g;c[o>>2]=j;c[o+4>>2]=q;h=1;i=e;return h|0}q=a;o=c[q>>2]|0;j=c[q+4>>2]|0;if(l){l=
m;q=c[l+4>>2]|0;k=a;c[k>>2]=c[l>>2];c[k+4>>2]=q;q=m;c[q>>2]=o;c[q+4>>2]=j;h=1;i=e;return h|0}q=g;k=c[q+4>>2]|0;l=a;c[l>>2]=c[q>>2];c[l+4>>2]=k;k=g;c[k>>2]=o;c[k+4>>2]=j;if(!(nb[c[d>>2]&31](m,g)|0)){h=1;i=e;return h|0}j=g;k=c[j>>2]|0;o=c[j+4>>2]|0;j=m;l=c[j+4>>2]|0;q=g;c[q>>2]=c[j>>2];c[q+4>>2]=l;l=m;c[l>>2]=k;c[l+4>>2]=o;h=1;i=e;return h|0;case 1:case 0:h=1;i=e;return h|0;default:o=a+16|0;l=a+8|0;k=nb[c[d>>2]&31](l,a)|0;m=nb[c[d>>2]&31](o,l)|0;do if(k){q=a;j=c[q>>2]|0;g=c[q+4>>2]|0;if(m){q=o;p=c[q+
4>>2]|0;n=a;c[n>>2]=c[q>>2];c[n+4>>2]=p;p=o;c[p>>2]=j;c[p+4>>2]=g;break}p=l;n=c[p+4>>2]|0;q=a;c[q>>2]=c[p>>2];c[q+4>>2]=n;n=l;c[n>>2]=j;c[n+4>>2]=g;if(nb[c[d>>2]&31](o,l)|0){g=l;n=c[g>>2]|0;j=c[g+4>>2]|0;g=o;q=c[g+4>>2]|0;p=l;c[p>>2]=c[g>>2];c[p+4>>2]=q;q=o;c[q>>2]=n;c[q+4>>2]=j}}else if(m?(j=l,q=c[j>>2]|0,n=c[j+4>>2]|0,j=o,p=c[j+4>>2]|0,g=l,c[g>>2]=c[j>>2],c[g+4>>2]=p,p=o,c[p>>2]=q,c[p+4>>2]=n,nb[c[d>>2]&31](l,a)|0):0){n=a;p=c[n>>2]|0;q=c[n+4>>2]|0;n=l;g=c[n+4>>2]|0;j=a;c[j>>2]=c[n>>2];c[j+4>>2]=
g;g=l;c[g>>2]=p;c[g+4>>2]=q}while(0);l=a+24|0;if((l|0)==(b|0)){h=1;i=e;return h|0}else{r=0;s=l;t=o}while(1){if(nb[c[d>>2]&31](s,t)|0){o=s;l=c[o+4>>2]|0;m=f;c[m>>2]=c[o>>2];c[m+4>>2]=l;l=s;m=t;while(1){o=m;k=c[o+4>>2]|0;q=l;c[q>>2]=c[o>>2];c[q+4>>2]=k;if((m|0)==(a|0))break;k=m+-8|0;if(nb[c[d>>2]&31](f,k)|0){q=m;m=k;l=q}else break}l=f;q=c[l+4>>2]|0;k=m;c[k>>2]=c[l>>2];c[k+4>>2]=q;q=r+1|0;if((q|0)==8)break;else u=q}else u=r;q=s+8|0;if((q|0)==(b|0)){h=1;v=34;break}else{k=s;r=u;s=q;t=k}}if((v|0)==34){i=
e;return h|0}h=(s+8|0)==(b|0);i=e;return h|0}return 0}function ck(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function dk(a,b){a=a|0;b=b|0;return}function ek(a,b){a=a|0;b=b|0;return}function fk(a,b,c){a=a|0;b=b|0;c=c|0;return}function gk(a,b,c){a=a|0;b=b|0;c=c|0;return}function hk(a,b,d){a=a|0;b=b|0;d=d|0;var e=0;e=i;c[a>>2]=b;c[a+4>>2]=Ym(b,d<<4)|0;c[a+8>>2]=d;d=a+12|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;i=e;return}function ik(a){a=a|0;var b=0,d=0;b=i;d=c[a+24>>2]|0;if((d|0)!=0)_m(c[a>>2]|
0,d);_m(c[a>>2]|0,c[a+4>>2]|0);i=b;return}function jk(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,i=0;g=b+12|0;h=c[g>>2]|0;c[g>>2]=h+1;g=c[b+4>>2]|0;b=d;d=c[b+4>>2]|0;i=g+(h<<4)|0;c[i>>2]=c[b>>2];c[i+4>>2]=d;c[g+(h<<4)+8>>2]=e;a[g+(h<<4)+12>>0]=f&1;return}function kk(b,d,e){b=b|0;d=+d;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,ba=0,ca=0,da=0,ea=
0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0,zb=0,Ab=0,Bb=0,Cb=0,Db=0,Eb=0,Fb=0,Gb=0,Hb=0,Ib=0,Jb=0,Kb=0,Lb=0,Mb=0,Nb=0,Ob=0,Pb=0,Qb=0,Rb=0,Sb=0,Tb=0,Ub=0,Vb=0,Wb=0,Xb=0,Yb=0,
Zb=0,_b=0,$b=0,ac=0,bc=0,cc=0,dc=0,ec=0,fc=0,gc=0,hc=0,ic=0,jc=0;f=i;h=1/d;j=b+12|0;k=c[j>>2]|0;if((k|0)>0){l=c[b+4>>2]|0;d=3.4028234663852886E38;m=3.4028234663852886E38;n=-3.4028234663852886E38;o=-3.4028234663852886E38;p=0;while(1){if((a[l+(p<<4)+12>>0]|0)==0){q=m;r=d;s=o;t=n}else{u=+g[l+(p<<4)>>2];v=+g[l+(p<<4)+4>>2];q=m<v?m:v;r=d<u?d:u;s=o>v?o:v;t=n>u?n:u}p=p+1|0;if((p|0)>=(k|0)){w=q;x=r;y=s;z=t;break}else{d=r;m=q;n=t;o=s}}}else{w=3.4028234663852886E38;x=3.4028234663852886E38;y=-3.4028234663852886E38;
z=-3.4028234663852886E38}s=x-e;x=w-e;k=~~(h*(z+e-s))+1|0;p=b+16|0;c[p>>2]=k;l=~~(h*(y+e-x))+1|0;A=b+20|0;c[A>>2]=l;B=Ym(c[b>>2]|0,aa(l<<2,k)|0)|0;k=b+24|0;c[k>>2]=B;l=c[p>>2]|0;C=c[A>>2]|0;D=aa(C,l)|0;a:do if((D|0)>0){E=B;F=0;while(1){c[E+(F<<2)>>2]=0;G=F+1|0;if((G|0)>=(D|0))break a;E=c[k>>2]|0;F=G}}while(0);D=c[b>>2]|0;B=aa(l<<2,C)|0;C=Ym(D,B<<4)|0;if((c[j>>2]|0)>0){l=b+4|0;b=0;F=B;E=C;G=0;while(1){H=c[l>>2]|0;I=H+(G<<4)|0;J=H+(G<<4)+4|0;e=h*(+g[I>>2]-s);y=+e;z=+(h*(+g[J>>2]-x));H=I;g[H>>2]=y;g[H+
4>>2]=z;H=~~e;K=~~+g[J>>2];if(((K|H|0)>-1?(J=c[p>>2]|0,(H|0)<(J|0)):0)?(K|0)<(c[A>>2]|0):0){L=(aa(J,K)|0)+H|0;if((b|0)<(F|0)){M=F;N=E}else{if((b|0)>0){J=0;do J=J+1|0;while((J|0)!=(b|0))}J=(F|0)>0?F<<1:1;M=J;N=Zm(D,E,J<<4)|0}c[N+(b<<4)>>2]=H;c[N+(b<<4)+4>>2]=K;c[N+(b<<4)+8>>2]=L;c[N+(b<<4)+12>>2]=I;O=M;P=b+1|0;Q=N}else{O=F;P=b;Q=E}G=G+1|0;if((G|0)>=(c[j>>2]|0)){R=O;S=P;T=0;U=Q;break}else{b=P;F=O;E=Q}}}else{R=B;S=0;T=0;U=C}b:while(1){C=T;do{if((C|0)==(S|0))break b;V=c[U+(C<<4)>>2]|0;W=c[U+(C<<4)+4>>
2]|0;X=c[U+(C<<4)+8>>2]|0;Y=c[U+(C<<4)+12>>2]|0;C=C+1|0;Z=(c[k>>2]|0)+(X<<2)|0}while((c[Z>>2]|0)!=0);c[Z>>2]=Y;if((V|0)>0){I=V+-1|0;L=X+-1|0;if((S|0)>=(R|0)){if((C|0)<(S|0)){K=C;do{H=U+(K-C<<4)|0;B=U+(K<<4)|0;c[H+0>>2]=c[B+0>>2];c[H+4>>2]=c[B+4>>2];c[H+8>>2]=c[B+8>>2];c[H+12>>2]=c[B+12>>2];K=K+1|0}while((K|0)!=(S|0))}K=S-C|0;if((K|0)<(R|0)){_=U;$=K;ba=R;ca=0}else{B=(R|0)>0?R<<1:1;_=Zm(D,U,B<<4)|0;$=K;ba=B;ca=0}}else{_=U;$=S;ba=R;ca=C}c[_+($<<4)>>2]=I;c[_+($<<4)+4>>2]=W;c[_+($<<4)+8>>2]=L;c[_+($<<
4)+12>>2]=Y;da=$+1|0;ea=ba;fa=ca;ga=_}else{da=S;ea=R;fa=C;ga=U}if((W|0)>0){B=W+-1|0;K=X-(c[p>>2]|0)|0;if((da|0)>=(ea|0)){if((fa|0)<(da|0)){H=fa;do{Q=ga+(H-fa<<4)|0;E=ga+(H<<4)|0;c[Q+0>>2]=c[E+0>>2];c[Q+4>>2]=c[E+4>>2];c[Q+8>>2]=c[E+8>>2];c[Q+12>>2]=c[E+12>>2];H=H+1|0}while((H|0)!=(da|0))}H=da-fa|0;if((H|0)<(ea|0)){ha=ga;ia=H;ja=ea;ka=0}else{C=(ea|0)>0?ea<<1:1;ha=Zm(D,ga,C<<4)|0;ia=H;ja=C;ka=0}}else{ha=ga;ia=da;ja=ea;ka=fa}c[ha+(ia<<4)>>2]=V;c[ha+(ia<<4)+4>>2]=B;c[ha+(ia<<4)+8>>2]=K;c[ha+(ia<<4)+12>>
2]=Y;la=ia+1|0;ma=ja;na=ka;oa=ha}else{la=da;ma=ea;na=fa;oa=ga}if((V|0)<((c[p>>2]|0)+-1|0)){C=V+1|0;H=X+1|0;if((la|0)>=(ma|0)){if((na|0)<(la|0)){L=na;do{I=oa+(L-na<<4)|0;E=oa+(L<<4)|0;c[I+0>>2]=c[E+0>>2];c[I+4>>2]=c[E+4>>2];c[I+8>>2]=c[E+8>>2];c[I+12>>2]=c[E+12>>2];L=L+1|0}while((L|0)!=(la|0))}L=la-na|0;if((L|0)<(ma|0)){pa=oa;qa=L;ra=ma;sa=0}else{K=(ma|0)>0?ma<<1:1;pa=Zm(D,oa,K<<4)|0;qa=L;ra=K;sa=0}}else{pa=oa;qa=la;ra=ma;sa=na}c[pa+(qa<<4)>>2]=C;c[pa+(qa<<4)+4>>2]=W;c[pa+(qa<<4)+8>>2]=H;c[pa+(qa<<
4)+12>>2]=Y;ta=qa+1|0;ua=ra;va=sa;wa=pa}else{ta=la;ua=ma;va=na;wa=oa}if((W|0)>=((c[A>>2]|0)+-1|0)){R=ua;S=ta;T=va;U=wa;continue}K=W+1|0;L=(c[p>>2]|0)+X|0;if((ta|0)>=(ua|0)){if((va|0)<(ta|0)){B=va;do{E=wa+(B-va<<4)|0;I=wa+(B<<4)|0;c[E+0>>2]=c[I+0>>2];c[E+4>>2]=c[I+4>>2];c[E+8>>2]=c[I+8>>2];c[E+12>>2]=c[I+12>>2];B=B+1|0}while((B|0)!=(ta|0))}B=ta-va|0;if((B|0)<(ua|0)){xa=wa;ya=B;za=ua;Aa=0}else{H=(ua|0)>0?ua<<1:1;xa=Zm(D,wa,H<<4)|0;ya=B;za=H;Aa=0}}else{xa=wa;ya=ta;za=ua;Aa=va}c[xa+(ya<<4)>>2]=V;c[xa+
(ya<<4)+4>>2]=K;c[xa+(ya<<4)+8>>2]=L;c[xa+(ya<<4)+12>>2]=Y;R=za;S=ya+1|0;T=Aa;U=xa}xa=c[A>>2]|0;if((xa|0)>0){Aa=c[p>>2]|0;T=xa;ya=U;za=S;Y=S;V=R;va=0;while(1){if((Aa+-1|0)>0){ua=Aa;ta=Y;wa=V;X=za;W=ya;oa=0;while(1){na=(aa(ua,va)|0)+oa|0;ma=c[k>>2]|0;la=c[ma+(na<<2)>>2]|0;pa=na+1|0;sa=c[ma+(pa<<2)>>2]|0;if((la|0)==(sa|0)){Ba=oa+1|0;Ca=ua;Da=wa;Ea=ta;Fa=X;Ga=W}else{if((ta|0)>=(wa|0)){if((X|0)<(ta|0)){ma=X;do{ra=W+(ma-X<<4)|0;qa=W+(ma<<4)|0;c[ra+0>>2]=c[qa+0>>2];c[ra+4>>2]=c[qa+4>>2];c[ra+8>>2]=c[qa+
8>>2];c[ra+12>>2]=c[qa+12>>2];ma=ma+1|0}while((ma|0)!=(ta|0))}ma=ta-X|0;if((ma|0)<(wa|0)){Ha=W;Ia=ma;Ja=wa;Ka=0}else{qa=(wa|0)>0?wa<<1:1;Ha=Zm(D,W,qa<<4)|0;Ia=ma;Ja=qa;Ka=0}}else{Ha=W;Ia=ta;Ja=wa;Ka=X}c[Ha+(Ia<<4)>>2]=oa;c[Ha+(Ia<<4)+4>>2]=va;c[Ha+(Ia<<4)+8>>2]=na;c[Ha+(Ia<<4)+12>>2]=sa;qa=Ia+1|0;ma=oa+1|0;if((qa|0)>=(Ja|0)){if((Ka|0)<(qa|0)){ra=Ka;do{ga=Ha+(ra-Ka<<4)|0;fa=Ha+(ra<<4)|0;c[ga+0>>2]=c[fa+0>>2];c[ga+4>>2]=c[fa+4>>2];c[ga+8>>2]=c[fa+8>>2];c[ga+12>>2]=c[fa+12>>2];ra=ra+1|0}while((ra|0)!=
(qa|0))}ra=qa-Ka|0;if((ra|0)<(Ja|0)){La=Ha;Ma=ra;Na=Ja;Oa=0}else{sa=(Ja|0)>0?Ja<<1:1;La=Zm(D,Ha,sa<<4)|0;Ma=ra;Na=sa;Oa=0}}else{La=Ha;Ma=qa;Na=Ja;Oa=Ka}c[La+(Ma<<4)>>2]=ma;c[La+(Ma<<4)+4>>2]=va;c[La+(Ma<<4)+8>>2]=pa;c[La+(Ma<<4)+12>>2]=la;Ba=ma;Ca=c[p>>2]|0;Da=Na;Ea=Ma+1|0;Fa=Oa;Ga=La}if((Ba|0)<(Ca+-1|0)){ua=Ca;ta=Ea;wa=Da;X=Fa;W=Ga;oa=Ba}else break}Pa=Da;Qa=Ea;Ra=Fa;Sa=Ga;Ta=c[A>>2]|0;Ua=Ca}else{Pa=V;Qa=Y;Ra=za;Sa=ya;Ta=T;Ua=Aa}va=va+1|0;if((va|0)>=(Ta|0)){Va=Pa;Wa=Qa;Xa=Ra;Ya=Sa;Za=Ta;break}else{Aa=
Ua;T=Ta;ya=Sa;za=Ra;Y=Qa;V=Pa}}}else{Va=R;Wa=S;Xa=S;Ya=U;Za=xa}if((Za+-1|0)>0){xa=c[p>>2]|0;U=Za;Za=Ya;S=Xa;R=Wa;Pa=Va;V=0;while(1){Qa=V;V=V+1|0;if((xa|0)>0){Y=xa;Ra=R;za=Pa;Sa=S;ya=Za;Ta=0;while(1){T=(aa(Y,Qa)|0)+Ta|0;Ua=c[k>>2]|0;Aa=c[Ua+(T<<2)>>2]|0;va=c[Ua+(T+Y<<2)>>2]|0;if((Aa|0)==(va|0)){_a=Y;$a=za;ab=Ra;bb=Sa;cb=ya}else{if((Ra|0)>=(za|0)){if((Sa|0)<(Ra|0)){Ua=Sa;do{Ca=ya+(Ua-Sa<<4)|0;Ga=ya+(Ua<<4)|0;c[Ca+0>>2]=c[Ga+0>>2];c[Ca+4>>2]=c[Ga+4>>2];c[Ca+8>>2]=c[Ga+8>>2];c[Ca+12>>2]=c[Ga+12>>2];Ua=
Ua+1|0}while((Ua|0)!=(Ra|0))}Ua=Ra-Sa|0;if((Ua|0)<(za|0)){db=ya;eb=Ua;fb=za;gb=0}else{ma=(za|0)>0?za<<1:1;db=Zm(D,ya,ma<<4)|0;eb=Ua;fb=ma;gb=0}}else{db=ya;eb=Ra;fb=za;gb=Sa}c[db+(eb<<4)>>2]=Ta;c[db+(eb<<4)+4>>2]=Qa;c[db+(eb<<4)+8>>2]=T;c[db+(eb<<4)+12>>2]=va;ma=eb+1|0;Ua=(c[p>>2]|0)+T|0;if((ma|0)>=(fb|0)){if((gb|0)<(ma|0)){la=gb;do{pa=db+(la-gb<<4)|0;qa=db+(la<<4)|0;c[pa+0>>2]=c[qa+0>>2];c[pa+4>>2]=c[qa+4>>2];c[pa+8>>2]=c[qa+8>>2];c[pa+12>>2]=c[qa+12>>2];la=la+1|0}while((la|0)!=(ma|0))}la=ma-gb|0;
if((la|0)<(fb|0)){hb=db;ib=la;jb=fb;kb=0}else{T=(fb|0)>0?fb<<1:1;hb=Zm(D,db,T<<4)|0;ib=la;jb=T;kb=0}}else{hb=db;ib=ma;jb=fb;kb=gb}c[hb+(ib<<4)>>2]=Ta;c[hb+(ib<<4)+4>>2]=V;c[hb+(ib<<4)+8>>2]=Ua;c[hb+(ib<<4)+12>>2]=Aa;_a=c[p>>2]|0;$a=jb;ab=ib+1|0;bb=kb;cb=hb}Ta=Ta+1|0;if((Ta|0)>=(_a|0))break;else{Y=_a;Ra=ab;za=$a;Sa=bb;ya=cb}}lb=$a;mb=ab;nb=bb;ob=cb;pb=c[A>>2]|0;qb=_a}else{lb=Pa;mb=R;nb=S;ob=Za;pb=U;qb=xa}if((V|0)>=(pb+-1|0)){rb=lb;sb=mb;tb=nb;ub=ob;break}else{xa=qb;U=pb;Za=ob;S=nb;R=mb;Pa=lb}}}else{rb=
Va;sb=Wa;tb=Xa;ub=Ya}if((tb|0)==(sb|0)){vb=ub;_m(D,vb);i=f;return}else{wb=rb;xb=sb;yb=tb;zb=ub}c:while(1){ub=c[k>>2]|0;tb=yb;while(1){Ab=c[zb+(tb<<4)>>2]|0;Bb=c[zb+(tb<<4)+4>>2]|0;Cb=c[zb+(tb<<4)+8>>2]|0;Db=c[zb+(tb<<4)+12>>2]|0;tb=tb+1|0;Eb=ub+(Cb<<2)|0;sb=c[Eb>>2]|0;if((sb|0)!=(Db|0)?(x=+(Ab|0),h=+g[sb>>2]-x,s=+(Bb|0),e=+g[sb+4>>2]-s,z=+g[Db>>2]-x,x=+g[Db+4>>2]-s,h*h+e*e>z*z+x*x):0)break;if((tb|0)==(xb|0)){vb=zb;Fb=122;break c}}c[Eb>>2]=Db;if((Ab|0)>0){ub=Ab+-1|0;sb=Cb+-1|0;if((xb|0)>=(wb|0)){if((tb|
0)<(xb|0)){rb=tb;do{Ya=zb+(rb-tb<<4)|0;Xa=zb+(rb<<4)|0;c[Ya+0>>2]=c[Xa+0>>2];c[Ya+4>>2]=c[Xa+4>>2];c[Ya+8>>2]=c[Xa+8>>2];c[Ya+12>>2]=c[Xa+12>>2];rb=rb+1|0}while((rb|0)!=(xb|0))}rb=xb-tb|0;if((rb|0)<(wb|0)){Gb=zb;Hb=rb;Ib=wb;Jb=0}else{Xa=(wb|0)>0?wb<<1:1;Gb=Zm(D,zb,Xa<<4)|0;Hb=rb;Ib=Xa;Jb=0}}else{Gb=zb;Hb=xb;Ib=wb;Jb=tb}c[Gb+(Hb<<4)>>2]=ub;c[Gb+(Hb<<4)+4>>2]=Bb;c[Gb+(Hb<<4)+8>>2]=sb;c[Gb+(Hb<<4)+12>>2]=Db;Kb=Hb+1|0;Lb=Ib;Mb=Jb;Nb=Gb}else{Kb=xb;Lb=wb;Mb=tb;Nb=zb}if((Bb|0)>0){Xa=Bb+-1|0;rb=Cb-(c[p>>
2]|0)|0;if((Kb|0)>=(Lb|0)){if((Mb|0)<(Kb|0)){Ya=Mb;do{Wa=Nb+(Ya-Mb<<4)|0;Va=Nb+(Ya<<4)|0;c[Wa+0>>2]=c[Va+0>>2];c[Wa+4>>2]=c[Va+4>>2];c[Wa+8>>2]=c[Va+8>>2];c[Wa+12>>2]=c[Va+12>>2];Ya=Ya+1|0}while((Ya|0)!=(Kb|0))}Ya=Kb-Mb|0;if((Ya|0)<(Lb|0)){Ob=Nb;Pb=Ya;Qb=Lb;Rb=0}else{tb=(Lb|0)>0?Lb<<1:1;Ob=Zm(D,Nb,tb<<4)|0;Pb=Ya;Qb=tb;Rb=0}}else{Ob=Nb;Pb=Kb;Qb=Lb;Rb=Mb}c[Ob+(Pb<<4)>>2]=Ab;c[Ob+(Pb<<4)+4>>2]=Xa;c[Ob+(Pb<<4)+8>>2]=rb;c[Ob+(Pb<<4)+12>>2]=Db;Sb=Pb+1|0;Tb=Qb;Ub=Rb;Vb=Ob}else{Sb=Kb;Tb=Lb;Ub=Mb;Vb=Nb}if((Ab|
0)<((c[p>>2]|0)+-1|0)){tb=Ab+1|0;Ya=Cb+1|0;if((Sb|0)>=(Tb|0)){if((Ub|0)<(Sb|0)){sb=Ub;do{ub=Vb+(sb-Ub<<4)|0;Va=Vb+(sb<<4)|0;c[ub+0>>2]=c[Va+0>>2];c[ub+4>>2]=c[Va+4>>2];c[ub+8>>2]=c[Va+8>>2];c[ub+12>>2]=c[Va+12>>2];sb=sb+1|0}while((sb|0)!=(Sb|0))}sb=Sb-Ub|0;if((sb|0)<(Tb|0)){Wb=Vb;Xb=sb;Yb=Tb;Zb=0}else{rb=(Tb|0)>0?Tb<<1:1;Wb=Zm(D,Vb,rb<<4)|0;Xb=sb;Yb=rb;Zb=0}}else{Wb=Vb;Xb=Sb;Yb=Tb;Zb=Ub}c[Wb+(Xb<<4)>>2]=tb;c[Wb+(Xb<<4)+4>>2]=Bb;c[Wb+(Xb<<4)+8>>2]=Ya;c[Wb+(Xb<<4)+12>>2]=Db;_b=Xb+1|0;$b=Yb;ac=Zb;bc=
Wb}else{_b=Sb;$b=Tb;ac=Ub;bc=Vb}if((Bb|0)<((c[A>>2]|0)+-1|0)){rb=Bb+1|0;sb=(c[p>>2]|0)+Cb|0;if((_b|0)>=($b|0)){if((ac|0)<(_b|0)){Xa=ac;do{Va=bc+(Xa-ac<<4)|0;ub=bc+(Xa<<4)|0;c[Va+0>>2]=c[ub+0>>2];c[Va+4>>2]=c[ub+4>>2];c[Va+8>>2]=c[ub+8>>2];c[Va+12>>2]=c[ub+12>>2];Xa=Xa+1|0}while((Xa|0)!=(_b|0))}Xa=_b-ac|0;if((Xa|0)<($b|0)){cc=bc;dc=Xa;ec=$b;fc=0}else{Ya=($b|0)>0?$b<<1:1;cc=Zm(D,bc,Ya<<4)|0;dc=Xa;ec=Ya;fc=0}}else{cc=bc;dc=_b;ec=$b;fc=ac}c[cc+(dc<<4)>>2]=Ab;c[cc+(dc<<4)+4>>2]=rb;c[cc+(dc<<4)+8>>2]=sb;
c[cc+(dc<<4)+12>>2]=Db;gc=ec;hc=dc+1|0;ic=fc;jc=cc}else{gc=$b;hc=_b;ic=ac;jc=bc}if((ic|0)==(hc|0)){vb=jc;Fb=122;break}else{wb=gc;xb=hc;yb=ic;zb=jc}}if((Fb|0)==122){_m(D,vb);i=f;return}}function lk(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;e=i;f=b+20|0;g=c[f>>2]|0;if((g+-1|0)<=0){i=e;return}h=b+16|0;j=b+24|0;b=c[h>>2]|0;k=g;g=0;while(1){if((b+-1|0)>0){l=b;m=0;do{n=(aa(l,g)|0)+m|0;o=c[j>>2]|0;p=c[o+(n<<2)>>2]|0;q=n+1|0;r=c[o+(q<<2)>>2]|0;s=c[o+(n+l<<2)>>2]|
0;n=c[o+(q+l<<2)>>2]|0;do if((r|0)!=(s|0)){do if(!((p|0)==(r|0)|(p|0)==(s|0))){if(((a[p+12>>0]|0)==0?(a[r+12>>0]|0)==0:0)?(a[s+12>>0]|0)==0:0)break;pb[c[(c[d>>2]|0)+8>>2]&31](d,c[p+8>>2]|0,c[r+8>>2]|0,c[s+8>>2]|0)}while(0);if(!((n|0)==(r|0)|(n|0)==(s|0))){if(((a[r+12>>0]|0)==0?(a[n+12>>0]|0)==0:0)?(a[s+12>>0]|0)==0:0)break;pb[c[(c[d>>2]|0)+8>>2]&31](d,c[r+8>>2]|0,c[n+8>>2]|0,c[s+8>>2]|0)}}while(0);m=m+1|0;l=c[h>>2]|0}while((m|0)<(l+-1|0));t=c[f>>2]|0;u=l}else{t=k;u=b}g=g+1|0;if((g|0)>=(t+-1|0))break;
else{b=u;k=t}}i=e;return}function mk(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0;b=i;d=a+40|0;e=a+48|0;f=a+16|0;c[a+0>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;c[a+12>>2]=0;g[f>>2]=1;c[a+20>>2]=0;c[a+24>>2]=0;c[a+28>>2]=-1;g[a+32>>2]=0;g[a+36>>2]=0;f=8784;h=c[f+4>>2]|0;j=d;c[j>>2]=c[f>>2];c[j+4>>2]=h;h=8784;j=c[h+4>>2]|0;f=e;c[f>>2]=c[h>>2];c[f+4>>2]=j;j=a+56|0;f=a+72|0;c[j+0>>2]=0;c[j+4>>2]=0;c[j+8>>2]=0;c[j+12>>2]=0;g[f>>2]=1;c[a+76>>2]=0;i=b;return}function nk(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,
o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0;b=i;d=a+28|0;e=c[a>>2]|0;f=c[e+4>>2]|0;if((c[d>>2]|0)==(f|0)){i=b;return}h=+g[e+32>>2]*.75;j=h*+g[e+320>>2]*h;k=a+32|0;g[k>>2]=0;l=a+40|0;m=a+44|0;n=a+48|0;o=a+52|0;p=a+4|0;c[l+0>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;q=c[p>>2]|0;p=c[a+8>>2]|0;r=(q|0)<(p|0);if(r){s=c[e+96>>2]|0;t=c[e+104>>2]|0;h=0;u=0;v=0;w=0;x=0;y=q;do{h=j+h;g[k>>2]=h;z=j*+g[s+(y<<3)+4>>2];u=j*+g[s+(y<<3)>>2]+u;g[l>>2]=u;v=z+v;g[m>>2]=v;z=j*+g[t+(y<<
3)+4>>2];w=j*+g[t+(y<<3)>>2]+w;g[n>>2]=w;x=z+x;g[o>>2]=x;y=y+1|0}while((y|0)<(p|0));if(h>0){z=1/h;A=z*u;g[l>>2]=A;B=z*v;g[m>>2]=B;z=1/h;h=z*w;g[n>>2]=h;C=z*x;g[o>>2]=C;D=A;E=B;F=h;G=C}else{D=u;E=v;F=w;G=x}o=a+36|0;g[o>>2]=0;n=a+56|0;g[n>>2]=0;if(r){r=c[e+96>>2]|0;m=c[e+104>>2]|0;x=0;w=0;e=q;do{v=+g[r+(e<<3)>>2]-D;u=+g[r+(e<<3)+4>>2]-E;C=+g[m+(e<<3)>>2]-F;h=+g[m+(e<<3)+4>>2]-G;x=j*(v*v+u*u)+x;g[o>>2]=x;w=w+j*(v*h-u*C);g[n>>2]=w;e=e+1|0}while((e|0)<(p|0));if(x>0)g[n>>2]=1/x*w}}else{g[a+36>>2]=0;g[a+
56>>2]=0}c[d>>2]=f;i=b;return}function ok(a,b){a=a|0;b=b|0;var d=0;d=i;nl(c[a>>2]|0,c[a+4>>2]|0,c[a+8>>2]|0,b);i=d;return}function pk(a,b){a=a|0;b=b|0;var d=0;d=i;ol(c[a>>2]|0,c[a+4>>2]|0,c[a+8>>2]|0,b);i=d;return}function qk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=c[a>>2]|0;if((c[(c[e+400>>2]|0)+102876>>2]&2|0)!=0){i=d;return}f=c[a+4>>2]|0;g=a+8|0;if((f|0)<(c[g>>2]|0)){h=e;j=f}else{i=d;return}while(1){Bk(h,j,b);f=j+1|0;if((f|0)>=(c[g>>2]|0))break;h=c[a>>2]|0;j=f}i=d;return}function rk(b,
d,e){b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;f=i;h=b+52|0;c[b+56>>2]=h;c[h>>2]=h;c[b+60>>2]=256;h=b+64|0;c[b+68>>2]=h;c[h>>2]=h;h=b+72|0;c[b+76>>2]=h;c[h>>2]=h;h=b+80|0;c[b+136>>2]=0;c[b+140>>2]=0;c[b+148>>2]=0;c[b+152>>2]=0;j=b+160|0;k=b+196|0;c[h+0>>2]=0;c[h+4>>2]=0;c[h+8>>2]=0;c[h+12>>2]=0;c[h+16>>2]=0;c[h+20>>2]=0;c[h+24>>2]=0;c[h+28>>2]=0;h=j+0|0;j=h+36|0;do{c[h>>2]=0;h=h+4|0}while((h|0)<(j|0));c[k>>2]=e;c[b+200>>2]=0;c[b+204>>2]=0;c[b+208>>2]=0;c[b+212>>2]=e;c[b+216>>
2]=0;c[b+220>>2]=0;c[b+224>>2]=0;c[b+228>>2]=e;c[b+232>>2]=0;c[b+236>>2]=0;c[b+240>>2]=0;c[b+244>>2]=e;c[b+248>>2]=0;c[b+252>>2]=0;c[b+256>>2]=0;c[b+260>>2]=e;c[b+264>>2]=0;c[b+268>>2]=0;c[b+272>>2]=0;c[b+276>>2]=e;k=b+280|0;l=b+316|0;a[l>>0]=0;m=b+320|0;c[k+0>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;g[m>>2]=1;n=b+324|0;g[n>>2]=1;g[b+328>>2]=1;o=b+332|0;c[o>>2]=0;g[b+336>>2]=.05000000074505806;g[b+340>>2]=1;g[b+344>>2]=.25;g[b+348>>2]=.25;g[b+352>>2]=.25;g[b+356>>2]=.20000000298023224;g[b+360>>
2]=.20000000298023224;g[b+364>>2]=1;g[b+368>>2]=.5;g[b+372>>2]=.5;g[b+376>>2]=.20000000298023224;g[b+380>>2]=.20000000298023224;c[b+384>>2]=8;g[b+388>>2]=.5;p=b+392|0;a[p>>0]=1;g[b+396>>2]=.01666666753590107;a[b>>0]=0;c[b+4>>2]=0;c[b+8>>2]=0;a[b+12>>0]=0;c[b+16>>2]=0;a[b+20>>0]=0;a[b+21>>0]=0;c[b+24>>2]=0;a[l>>0]=a[d>>0]|0;q=+g[d+4>>2];g[m>>2]=q;g[b+28>>2]=1/q;g[n>>2]=+g[d+8>>2];q=+g[d+12>>2]*2;g[b+32>>2]=q;g[b+40>>2]=q*q;g[b+36>>2]=1/q;c[o>>2]=c[d+16>>2];c[b+44>>2]=0;o=b+48|0;c[o>>2]=0;n=b+112|0;
c[b+144>>2]=0;c[b+308>>2]=0;c[b+312>>2]=0;c[n+0>>2]=0;c[n+4>>2]=0;c[n+8>>2]=0;c[n+12>>2]=0;c[n+16>>2]=0;c[n+20>>2]=0;h=l+0|0;l=d+0|0;j=h+84|0;do{c[h>>2]=c[l>>2];h=h+4|0;l=l+4|0}while((h|0)<(j|0));l=b+400|0;c[l>>2]=e;c[b+156>>2]=0;e=b+296|0;c[e>>2]=0;c[e+4>>2]=0;a[b+304>>0]=0;e=a[p>>0]|0;if(e<<24>>24==0){a[p>>0]=e;i=f;return}h=c[k>>2]|0;if((h|0)==0){vk(b,256);b=Em(c[l>>2]|0,c[o>>2]<<2)|0;xn(b|0,0,c[o>>2]<<2|0)|0;r=b}else r=h;c[k>>2]=r;a[p>>0]=e;i=f;return}function sk(a){a=a|0;var b=0,d=0,e=0,f=0,g=
0;b=i;d=a+312|0;while(1){e=c[d>>2]|0;if((e|0)==0)break;tk(a,e)}if((c[a+84>>2]|0)==0?(d=a+80|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+92>>2]|0)==0?(d=a+88|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+164>>2]|0)==0?(d=a+160|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+172>>2]|0)==0?(d=a+168|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+180>>2]|0)==0?(d=a+176|0,e=
c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+100>>2]|0)==0?(d=a+96|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<3);c[d>>2]=0}if((c[a+108>>2]|0)==0?(d=a+104|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<3);c[d>>2]=0}if((c[a+140>>2]|0)==0?(d=a+136|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+152>>2]|0)==0?(d=a+148|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+284>>2]|0)==0?(d=a+
280|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}if((c[a+292>>2]|0)==0?(d=a+288|0,e=c[d>>2]|0,(e|0)!=0):0){Fm(c[a+400>>2]|0,e,c[a+48>>2]<<2);c[d>>2]=0}d=a+112|0;e=a+48|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<3);c[d>>2]=0}d=a+116|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<2);c[d>>2]=0}d=a+120|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<2);c[d>>2]=0}d=a+124|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<2);c[d>>2]=0}d=a+128|0;f=
c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<3);c[d>>2]=0}d=a+132|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<2);c[d>>2]=0}d=a+144|0;f=c[d>>2]|0;if((f|0)!=0){Fm(c[a+400>>2]|0,f,c[e>>2]<<2);c[d>>2]=0}d=a+264|0;e=c[d>>2]|0;if((e|0)!=0){f=a+272|0;Fm(c[a+276>>2]|0,e,(c[f>>2]|0)*60|0);c[d>>2]=0;c[f>>2]=0;c[a+268>>2]=0}f=a+248|0;d=c[f>>2]|0;if((d|0)!=0){e=a+256|0;Fm(c[a+260>>2]|0,d,(c[e>>2]|0)*20|0);c[f>>2]=0;c[e>>2]=0;c[a+252>>2]=0}e=a+232|0;f=c[e>>2]|0;if((f|0)!=0){d=a+240|0;Fm(c[a+244>>
2]|0,f,(c[d>>2]|0)*28|0);c[e>>2]=0;c[d>>2]=0;c[a+236>>2]=0}d=a+216|0;e=c[d>>2]|0;if((e|0)!=0){f=a+224|0;Fm(c[a+228>>2]|0,e,(c[f>>2]|0)*24|0);c[d>>2]=0;c[f>>2]=0;c[a+220>>2]=0}f=a+200|0;d=c[f>>2]|0;if((d|0)!=0){e=a+208|0;Fm(c[a+212>>2]|0,d,c[e>>2]<<3);c[f>>2]=0;c[e>>2]=0;c[a+204>>2]=0}e=a+184|0;f=c[e>>2]|0;if((f|0)==0){g=a+52|0;Tl(g);i=b;return}d=a+192|0;Fm(c[a+196>>2]|0,f,c[d>>2]<<2);c[e>>2]=0;c[d>>2]=0;c[a+188>>2]=0;g=a+52|0;Tl(g);i=b;return}function tk(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=
0,l=0,m=0,n=0,o=0;e=i;f=b+400|0;g=c[(c[f>>2]|0)+102992>>2]|0;if((g|0)!=0)gb[c[(c[g>>2]|0)+16>>2]&63](g,d);g=d+12|0;h=c[g>>2]|0;j=h<<4;k=j&16;if((((j|-17)^16)&h|0)!=0)a[b+20>>0]=1;h=b+16|0;j=c[h>>2]|0;if((k&~j|0)!=0)c[h>>2]=j|k;c[g>>2]=k;k=c[d+4>>2]|0;g=c[d+8>>2]|0;if((k|0)<(g|0)){j=b+144|0;h=k;do{c[(c[j>>2]|0)+(h<<2)>>2]=0;h=h+1|0}while((h|0)<(g|0))}g=d+20|0;h=c[g>>2]|0;j=d+24|0;if((h|0)!=0)c[h+24>>2]=c[j>>2];h=c[j>>2]|0;if((h|0)!=0)c[h+20>>2]=c[g>>2];g=b+312|0;if((c[g>>2]|0)!=(d|0)){l=b+308|0;m=
c[l>>2]|0;n=m+-1|0;c[l>>2]=n;o=c[f>>2]|0;Fm(o,d,80);i=e;return}c[g>>2]=c[j>>2];l=b+308|0;m=c[l>>2]|0;n=m+-1|0;c[l>>2]=n;o=c[f>>2]|0;Fm(o,d,80);i=e;return}function uk(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0;b=i;d=a+136|0;e=c[d>>2]|0;if((e|0)!=0){f=e;c[d>>2]=f;i=b;return f|0}e=a+48|0;g=c[e>>2]|0;if((g|0)==0){vk(a,256);h=c[e>>2]|0}else h=g;g=Em(c[a+400>>2]|0,h<<2)|0;xn(g|0,0,c[e>>2]<<2|0)|0;f=g;c[d>>2]=f;i=b;return f|0}function vk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,
r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0;d=i;e=c[a+332>>2]|0;if((e|0)==0)f=b;else f=(e|0)<(b|0)?e:b;b=a+92|0;e=c[b>>2]|0;if((e|0)==0)g=f;else g=(f|0)>(e|0)?e:f;f=a+100|0;e=c[f>>2]|0;if((e|0)==0)h=g;else h=(g|0)>(e|0)?e:g;g=a+108|0;e=c[g>>2]|0;if((e|0)==0)j=h;else j=(h|0)>(e|0)?e:h;h=a+140|0;e=c[h>>2]|0;if((e|0)==0)k=j;else k=(j|0)>(e|0)?e:j;j=a+152|0;e=c[j>>2]|0;if((e|0)==0)l=k;else l=(k|0)>(e|0)?e:k;k=a+48|0;e=c[k>>2]|0;if((e|0)>=(l|0)){i=d;return}m=a+80|0;n=c[m>>2]|0;o=(n|
0)==0;if((c[a+84>>2]|0)==0&(o^1)){p=a+400|0;q=Em(c[p>>2]|0,l<<2)|0;if(o)r=q;else{o=e<<2;An(q|0,n|0,o|0)|0;Fm(c[p>>2]|0,n,o);r=q}}else r=n;c[m>>2]=r;r=c[k>>2]|0;c[a+60>>2]=l-r;m=a+88|0;n=c[m>>2]|0;if((c[b>>2]|0)==0){b=a+400|0;q=Em(c[b>>2]|0,l<<2)|0;if((n|0)==0)s=q;else{o=r<<2;An(q|0,n|0,o|0)|0;Fm(c[b>>2]|0,n,o);s=q}}else s=n;c[m>>2]=s;s=(c[a+156>>2]|0)>0;m=c[k>>2]|0;n=a+160|0;q=c[n>>2]|0;o=(q|0)==0;if((c[a+164>>2]|0)==0&(o&s^1)){b=a+400|0;r=Em(c[b>>2]|0,l<<2)|0;if(o)t=r;else{o=m<<2;An(r|0,q|0,o|0)|
0;Fm(c[b>>2]|0,q,o);t=r}}else t=q;c[n>>2]=t;t=c[k>>2]|0;n=a+168|0;q=c[n>>2]|0;r=(q|0)==0;if((c[a+172>>2]|0)==0&(r&s^1)){o=a+400|0;b=Em(c[o>>2]|0,l<<2)|0;if(r)u=b;else{r=t<<2;An(b|0,q|0,r|0)|0;Fm(c[o>>2]|0,q,r);u=b}}else u=q;c[n>>2]=u;u=c[k>>2]|0;n=a+176|0;q=c[n>>2]|0;b=(q|0)==0;if((c[a+180>>2]|0)==0&(b&s^1)){s=a+400|0;r=Em(c[s>>2]|0,l<<2)|0;if(b)v=r;else{b=u<<2;An(r|0,q|0,b|0)|0;Fm(c[s>>2]|0,q,b);v=r}}else v=q;c[n>>2]=v;v=c[k>>2]|0;n=a+96|0;q=c[n>>2]|0;if((c[f>>2]|0)==0){f=a+400|0;r=Em(c[f>>2]|0,
l<<3)|0;if((q|0)==0)w=r;else{b=v<<3;An(r|0,q|0,b|0)|0;Fm(c[f>>2]|0,q,b);w=r}}else w=q;c[n>>2]=w;w=c[k>>2]|0;n=a+104|0;q=c[n>>2]|0;if((c[g>>2]|0)==0){g=a+400|0;r=l<<3;b=Em(c[g>>2]|0,r)|0;if((q|0)==0){x=b;y=r;z=g}else{f=w<<3;An(b|0,q|0,f|0)|0;Fm(c[g>>2]|0,q,f);x=b;y=r;z=g}}else{x=q;y=l<<3;z=a+400|0}c[n>>2]=x;x=a+112|0;n=c[x>>2]|0;q=c[k>>2]|0;g=Em(c[z>>2]|0,y)|0;if((n|0)!=0){r=q<<3;An(g|0,n|0,r|0)|0;Fm(c[z>>2]|0,n,r)}c[x>>2]=g;g=a+116|0;x=c[g>>2]|0;r=c[k>>2]|0;n=l<<2;q=Em(c[z>>2]|0,n)|0;if((x|0)!=0){b=
r<<2;An(q|0,x|0,b|0)|0;Fm(c[z>>2]|0,x,b)}c[g>>2]=q;q=a+120|0;g=c[q>>2]|0;if((g|0)==0)A=0;else{b=c[k>>2]|0;x=Em(c[z>>2]|0,n)|0;r=b<<2;An(x|0,g|0,r|0)|0;Fm(c[z>>2]|0,g,r);A=x}c[q>>2]=A;A=a+124|0;q=c[A>>2]|0;x=c[k>>2]|0;r=Em(c[z>>2]|0,n)|0;if((q|0)!=0){g=x<<2;An(r|0,q|0,g|0)|0;Fm(c[z>>2]|0,q,g)}c[A>>2]=r;r=a+128|0;A=c[r>>2]|0;if((A|0)==0)B=0;else{g=c[k>>2]|0;q=Em(c[z>>2]|0,y)|0;y=g<<3;An(q|0,A|0,y|0)|0;Fm(c[z>>2]|0,A,y);B=q}c[r>>2]=B;B=a+132|0;r=c[B>>2]|0;if((r|0)==0)C=0;else{q=c[k>>2]|0;y=Em(c[z>>2]|
0,n)|0;A=q<<2;An(y|0,r|0,A|0)|0;Fm(c[z>>2]|0,r,A);C=y}c[B>>2]=C;C=c[k>>2]|0;B=a+136|0;y=c[B>>2]|0;A=(y|0)==0;do if((c[h>>2]|0)==0&(A^1)){r=Em(c[z>>2]|0,n)|0;if(A){D=r;break}q=C<<2;An(r|0,y|0,q|0)|0;Fm(c[z>>2]|0,y,q);D=r}else D=y;while(0);c[B>>2]=D;D=a+144|0;B=c[D>>2]|0;y=c[k>>2]|0;C=Em(c[z>>2]|0,n)|0;if((B|0)!=0){A=y<<2;An(C|0,B|0,A|0)|0;Fm(c[z>>2]|0,B,A)}c[D>>2]=C;C=c[k>>2]|0;D=a+148|0;A=c[D>>2]|0;B=(A|0)==0;do if((c[j>>2]|0)==0&(B^1)){y=Em(c[z>>2]|0,n)|0;if(B){E=y;break}h=C<<2;An(y|0,A|0,h|0)|0;
Fm(c[z>>2]|0,A,h);E=y}else E=A;while(0);c[D>>2]=E;E=c[k>>2]|0;D=a+280|0;A=c[D>>2]|0;C=(A|0)==0;do if((c[a+284>>2]|0)==0&(C^1)){B=Em(c[z>>2]|0,n)|0;if(C){F=B;break}j=E<<2;An(B|0,A|0,j|0)|0;Fm(c[z>>2]|0,A,j);F=B}else F=A;while(0);c[D>>2]=F;F=c[k>>2]|0;D=a+288|0;A=c[D>>2]|0;E=(A|0)==0;do if((c[a+292>>2]|0)==0&(E^1)){C=Em(c[z>>2]|0,n)|0;if(E){G=C;break}B=F<<2;An(C|0,A|0,B|0)|0;Fm(c[z>>2]|0,A,B);G=C}else G=A;while(0);c[D>>2]=G;c[k>>2]=l;i=d;return}function wk(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=
0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;e=i;f=b+400|0;if((c[(c[f>>2]|0)+102876>>2]&2|0)!=0){h=0;i=e;return h|0}j=b+44|0;k=c[j>>2]|0;l=b+48|0;m=c[l>>2]|0;if((k|0)<(m|0)){n=k;o=m}else{vk(b,(k|0)==0?256:k<<1);n=c[j>>2]|0;o=c[l>>2]|0}do if((n|0)>=(o|0))if((a[b+392>>0]|0)==0){h=-1;i=e;return h|0}else{k=c[b+288>>2]|0;m=c[k+(n+-1<<2)>>2]|0;p=+(c[(c[b+280>>2]|0)+(m<<2)>>2]|0)>0?m:c[k>>2]|0;k=b+88|0;Ak(b,p,c[(c[k>>2]|0)+(p<<2)>>2]|2);xk(b);q=k;r=c[j>>2]|0;break}else{q=b+88|0;r=n}while(0);
n=r+1|0;c[j>>2]=n;c[(c[q>>2]|0)+(r<<2)>>2]=0;q=c[b+160>>2]|0;if((q|0)!=0)c[q+(r<<2)>>2]=0;q=c[b+168>>2]|0;if((q|0)!=0)c[q+(r<<2)>>2]=0;q=c[b+176>>2]|0;if((q|0)!=0)c[q+(r<<2)>>2]=0;q=d+4|0;j=c[q+4>>2]|0;o=(c[b+96>>2]|0)+(r<<3)|0;c[o>>2]=c[q>>2];c[o+4>>2]=j;j=d+12|0;o=c[j+4>>2]|0;q=(c[b+104>>2]|0)+(r<<3)|0;c[q>>2]=c[j>>2];c[q+4>>2]=o;g[(c[b+116>>2]|0)+(r<<2)>>2]=0;o=8784;q=c[o+4>>2]|0;j=(c[b+112>>2]|0)+(r<<3)|0;c[j>>2]=c[o>>2];c[j+4>>2]=q;q=c[b+120>>2]|0;if((q|0)!=0)g[q+(r<<2)>>2]=0;q=c[b+132>>2]|0;
if((q|0)!=0)g[q+(r<<2)>>2]=0;q=b+136|0;j=c[q>>2]|0;o=d+20|0;do if((j|0)==0){if((((a[o>>0]|0)==0?(a[d+21>>0]|0)==0:0)?(a[d+22>>0]|0)==0:0)?(a[d+23>>0]|0)==0:0)break;k=c[l>>2]|0;if((k|0)==0){vk(b,256);s=c[l>>2]|0}else s=k;k=Em(c[f>>2]|0,s<<2)|0;xn(k|0,0,c[l>>2]<<2|0)|0;t=k;u=26}else{t=j;u=26}while(0);if((u|0)==26){c[q>>2]=t;q=a[d+21>>0]|0;j=a[d+22>>0]|0;s=a[d+23>>0]|0;a[t+(r<<2)>>0]=a[o>>0]|0;a[t+(r<<2)+1>>0]=q;a[t+(r<<2)+2>>0]=j;a[t+(r<<2)+3>>0]=s}s=b+148|0;t=c[s>>2]|0;j=d+28|0;if((t|0)==0){if((c[j>>
2]|0)!=0){q=c[l>>2]|0;if((q|0)==0){vk(b,256);v=c[l>>2]|0}else v=q;q=Em(c[f>>2]|0,v<<2)|0;xn(q|0,0,c[l>>2]<<2|0)|0;w=q;u=32}}else{w=t;u=32}if((u|0)==32){c[s>>2]=w;c[w+(r<<2)>>2]=c[j>>2]}j=c[b+80>>2]|0;if((j|0)!=0)c[j+(r<<2)>>2]=0;j=b+200|0;w=b+204|0;s=c[w>>2]|0;u=b+208|0;t=c[u>>2]|0;if((s|0)>=(t|0)?(q=(t|0)==0?256:t<<1,(t|0)<(q|0)):0){t=b+212|0;l=Em(c[t>>2]|0,q<<3)|0;v=c[j>>2]|0;if((v|0)!=0){An(l|0,v|0,c[w>>2]<<3|0)|0;Fm(c[t>>2]|0,c[j>>2]|0,c[u>>2]<<3)}c[u>>2]=q;c[j>>2]=l;x=c[w>>2]|0}else x=s;c[w>>
2]=x+1;w=c[j>>2]|0;y=+g[d+24>>2];j=y>0;if((c[b+280>>2]|0)!=0|j){if(j)z=y;else{j=c[b+300>>2]|0;z=+g[b+396>>2]*+(((j|0)<0?0-j|0:0)-j|0)}yk(b,r,z);c[(c[b+288>>2]|0)+(r<<2)>>2]=r}c[w+(x<<3)>>2]=r;x=c[d+32>>2]|0;c[(c[b+144>>2]|0)+(r<<2)>>2]=x;do if((x|0)!=0){w=x+4|0;j=c[w>>2]|0;s=x+8|0;l=c[s>>2]|0;if((j|0)<(l|0)){zk(b,j,l,r);c[s>>2]=n;break}else{c[w>>2]=r;c[s>>2]=n;break}}while(0);Ak(b,r,c[d>>2]|0);h=r;i=e;return h|0}function xk(b){b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,
u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0;d=i;e=b+400|0;f=b+44|0;h=Ym((c[e>>2]|0)+76|0,c[f>>2]<<2)|0;if((c[f>>2]|0)>0){j=b+88|0;k=b+80|0;l=b+160|0;m=b+168|0;n=b+176|0;o=b+96|0;p=b+104|0;q=b+144|0;r=b+21|0;s=b+120|0;t=b+132|0;u=b+136|0;v=b+148|0;w=b+280|0;x=b+112|0;y=b+64|0;z=0;A=0;B=0;while(1){C=
c[j>>2]|0;D=c[C+(A<<2)>>2]|0;if((D&2|0)==0){c[h+(A<<2)>>2]=B;if((A|0)!=(B|0)){E=c[k>>2]|0;if((E|0)==0)F=C;else{C=c[E+(A<<2)>>2]|0;if((C|0)!=0)c[C+8>>2]=B;c[E+(B<<2)>>2]=C;F=c[j>>2]|0}c[F+(B<<2)>>2]=c[F+(A<<2)>>2];C=c[l>>2]|0;if((C|0)!=0)c[C+(B<<2)>>2]=c[C+(A<<2)>>2];C=c[m>>2]|0;if((C|0)!=0)c[C+(B<<2)>>2]=c[C+(A<<2)>>2];C=c[n>>2]|0;if((C|0)!=0)c[C+(B<<2)>>2]=c[C+(A<<2)>>2];C=c[o>>2]|0;E=C+(A<<3)|0;G=c[E+4>>2]|0;H=C+(B<<3)|0;c[H>>2]=c[E>>2];c[H+4>>2]=G;G=c[p>>2]|0;H=G+(A<<3)|0;E=c[H+4>>2]|0;C=G+(B<<
3)|0;c[C>>2]=c[H>>2];c[C+4>>2]=E;E=c[q>>2]|0;c[E+(B<<2)>>2]=c[E+(A<<2)>>2];if((a[r>>0]|0)!=0){E=c[x>>2]|0;C=E+(A<<3)|0;H=c[C+4>>2]|0;G=E+(B<<3)|0;c[G>>2]=c[C>>2];c[G+4>>2]=H}H=c[s>>2]|0;if((H|0)!=0)g[H+(B<<2)>>2]=+g[H+(A<<2)>>2];H=c[t>>2]|0;if((H|0)!=0)g[H+(B<<2)>>2]=+g[H+(A<<2)>>2];H=c[u>>2]|0;if((H|0)!=0){G=a[H+(A<<2)+1>>0]|0;C=a[H+(A<<2)+2>>0]|0;E=a[H+(A<<2)+3>>0]|0;a[H+(B<<2)>>0]=a[H+(A<<2)>>0]|0;a[H+(B<<2)+1>>0]=G;a[H+(B<<2)+2>>0]=C;a[H+(B<<2)+3>>0]=E}E=c[v>>2]|0;if((E|0)!=0)c[E+(B<<2)>>2]=c[E+
(A<<2)>>2];E=c[w>>2]|0;if((E|0)!=0)c[E+(B<<2)>>2]=c[E+(A<<2)>>2]}I=D|z;J=B+1|0}else{E=c[(c[e>>2]|0)+102992>>2]|0;if(!((D&512|0)==0|(E|0)==0))ib[c[(c[E>>2]|0)+20>>2]&7](E,b,A);E=c[k>>2]|0;if((E|0)!=0?(D=E+(A<<2)|0,E=c[D>>2]|0,(E|0)!=0):0){c[E+8>>2]=-1;c[D>>2]=0;Bm(y,E)}c[h+(A<<2)>>2]=-1;I=z;J=B}A=A+1|0;if((A|0)>=(c[f>>2]|0)){K=I;L=J;break}else{z=I;B=J}}}else{K=0;L=0}J=b+204|0;B=c[J>>2]|0;I=b+200|0;z=c[I>>2]|0;if((B|0)>0){A=0;do{y=z+(A<<3)|0;c[y>>2]=c[h+(c[y>>2]<<2)>>2];A=A+1|0;y=c[J>>2]|0}while((A|
0)<(y|0));M=y}else M=B;B=z+(M<<3)|0;a:do if((M|0)==0){N=z;O=40}else{A=z;while(1){if((c[A>>2]|0)<0){N=A;O=40;break a}A=A+8|0;if((A|0)==(B|0)){P=B;Q=z;break}}}while(0);if((O|0)==40)if((N|0)==(B|0)){P=B;Q=z}else{z=N;M=N;b:while(1){N=M;do{N=N+8|0;if((N|0)==(B|0))break b}while((c[N>>2]|0)<0);A=N;y=c[A+4>>2]|0;k=z;c[k>>2]=c[A>>2];c[k+4>>2]=y;z=z+8|0;M=N}P=z;Q=c[I>>2]|0}c[J>>2]=P-Q>>3;Q=b+220|0;P=c[Q>>2]|0;J=b+216|0;I=c[J>>2]|0;if((P|0)>0){z=0;do{M=I+(z*24|0)|0;B=I+(z*24|0)+4|0;y=c[h+(c[B>>2]<<2)>>2]|0;
c[M>>2]=c[h+(c[M>>2]<<2)>>2];c[B>>2]=y;z=z+1|0;y=c[Q>>2]|0}while((z|0)<(y|0));R=y}else R=P;P=I+(R*24|0)|0;c:do if((R|0)==0){S=I;O=52}else{z=I;while(1){if((c[z>>2]|0)<0){S=z;O=52;break c}if((c[z+4>>2]|0)<0){S=z;O=52;break c}z=z+24|0;if((z|0)==(P|0)){T=P;U=I;break}}}while(0);if((O|0)==52)if((S|0)==(P|0)){T=P;U=I}else{I=S+24|0;d:do if((I|0)==(P|0))V=S;else{R=S;z=I;N=S;while(1){y=z;B=N;while(1){if((c[y>>2]|0)>=0?(c[B+28>>2]|0)>=0:0)break;M=y+24|0;if((M|0)==(P|0)){V=R;break d}else{k=y;y=M;B=k}}c[R+0>>
2]=c[y+0>>2];c[R+4>>2]=c[y+4>>2];c[R+8>>2]=c[y+8>>2];c[R+12>>2]=c[y+12>>2];c[R+16>>2]=c[y+16>>2];c[R+20>>2]=c[y+20>>2];B=R+24|0;z=y+24|0;if((z|0)==(P|0)){V=B;break}else{R=B;N=y}}}while(0);T=V;U=c[J>>2]|0}c[Q>>2]=(T-U|0)/24|0;U=b+236|0;T=c[U>>2]|0;Q=b+232|0;J=c[Q>>2]|0;if((T|0)>0){V=0;do{P=J+(V*28|0)|0;c[P>>2]=c[h+(c[P>>2]<<2)>>2];V=V+1|0;P=c[U>>2]|0}while((V|0)<(P|0));W=P}else W=T;T=J+(W*28|0)|0;e:do if((W|0)==0){X=J;O=65}else{V=J;while(1){if((c[V>>2]|0)<0){X=V;O=65;break e}V=V+28|0;if((V|0)==(T|
0)){Y=T;Z=J;break}}}while(0);if((O|0)==65)if((X|0)==(T|0)){Y=T;Z=J}else{J=X;W=X;f:while(1){X=W;do{X=X+28|0;if((X|0)==(T|0))break f}while((c[X>>2]|0)<0);c[J+0>>2]=c[X+0>>2];c[J+4>>2]=c[X+4>>2];c[J+8>>2]=c[X+8>>2];c[J+12>>2]=c[X+12>>2];c[J+16>>2]=c[X+16>>2];c[J+20>>2]=c[X+20>>2];c[J+24>>2]=c[X+24>>2];J=J+28|0;W=X}Y=J;Z=c[Q>>2]|0}c[U>>2]=(Y-Z|0)/28|0;Z=b+252|0;Y=c[Z>>2]|0;U=b+248|0;Q=c[U>>2]|0;if((Y|0)>0){J=0;do{W=Q+(J*20|0)|0;c[W>>2]=c[h+(c[W>>2]<<2)>>2];W=Q+(J*20|0)+4|0;c[W>>2]=c[h+(c[W>>2]<<2)>>2];
J=J+1|0;W=c[Z>>2]|0}while((J|0)<(W|0));_=W}else _=Y;Y=Q+(_*20|0)|0;g:do if((_|0)==0){$=Q;O=77}else{J=Q;while(1){if((c[J>>2]|0)<0){$=J;O=77;break g}if((c[J+4>>2]|0)<0){$=J;O=77;break g}J=J+20|0;if((J|0)==(Y|0)){aa=Y;ba=Q;break}}}while(0);if((O|0)==77)if(($|0)==(Y|0)){aa=Y;ba=Q}else{Q=$+20|0;h:do if((Q|0)==(Y|0))ca=$;else{_=$;J=Q;X=$;while(1){W=J;T=X;while(1){if((c[W>>2]|0)>=0?(c[T+24>>2]|0)>=0:0)break;V=W+20|0;if((V|0)==(Y|0)){ca=_;break h}else{P=W;W=V;T=P}}c[_+0>>2]=c[W+0>>2];c[_+4>>2]=c[W+4>>2];
c[_+8>>2]=c[W+8>>2];c[_+12>>2]=c[W+12>>2];c[_+16>>2]=c[W+16>>2];T=_+20|0;J=W+20|0;if((J|0)==(Y|0)){ca=T;break}else{_=T;X=W}}}while(0);aa=ca;ba=c[U>>2]|0}c[Z>>2]=(aa-ba|0)/20|0;ba=b+268|0;aa=c[ba>>2]|0;Z=b+264|0;U=c[Z>>2]|0;if((aa|0)>0){ca=0;do{Y=U+(ca*60|0)|0;c[Y>>2]=c[h+(c[Y>>2]<<2)>>2];Y=U+(ca*60|0)+4|0;c[Y>>2]=c[h+(c[Y>>2]<<2)>>2];Y=U+(ca*60|0)+8|0;c[Y>>2]=c[h+(c[Y>>2]<<2)>>2];ca=ca+1|0;Y=c[ba>>2]|0}while((ca|0)<(Y|0));da=Y}else da=aa;aa=U+(da*60|0)|0;i:do if((da|0)==0){ea=U;O=92}else{ca=U;while(1){if((c[ca>>
2]|0)<0){ea=ca;O=92;break i}if((c[ca+4>>2]|0)<0){ea=ca;O=92;break i}if((c[ca+8>>2]|0)<0){ea=ca;O=92;break i}ca=ca+60|0;if((ca|0)==(aa|0)){fa=aa;ga=U;break}}}while(0);if((O|0)==92)if((ea|0)==(aa|0)){fa=aa;ga=U}else{U=ea+60|0;j:do if((U|0)==(aa|0))ha=ea;else{O=ea;da=U;ca=ea;while(1){Y=da;$=ca;while(1){if(((c[Y>>2]|0)>=0?(c[$+64>>2]|0)>=0:0)?(c[$+68>>2]|0)>=0:0)break;Q=Y+60|0;if((Q|0)==(aa|0)){ha=O;break j}else{X=Y;Y=Q;$=X}}$=O+0|0;W=Y+0|0;X=$+60|0;do{c[$>>2]=c[W>>2];$=$+4|0;W=W+4|0}while(($|0)<(X|0));
W=O+60|0;da=Y+60|0;if((da|0)==(aa|0)){ha=W;break}else{O=W;ca=Y}}}while(0);fa=ha;ga=c[Z>>2]|0}c[ba>>2]=(fa-ga|0)/60|0;ga=c[b+288>>2]|0;if((ga|0)!=0?(fa=c[f>>2]|0,(fa|0)>0):0){ba=fa;fa=0;Z=0;while(1){ha=c[h+(c[ga+(fa<<2)>>2]<<2)>>2]|0;if((ha|0)==-1){ia=ba;ja=Z}else{c[ga+(Z<<2)>>2]=ha;ia=c[f>>2]|0;ja=Z+1|0}fa=fa+1|0;if((fa|0)>=(ia|0))break;else{ba=ia;Z=ja}}}ja=b+312|0;Z=c[ja>>2]|0;if((Z|0)!=0){ia=b+16|0;ba=b+132|0;fa=b+48|0;ga=b+20|0;ha=Z;do{Z=ha+4|0;aa=c[Z>>2]|0;ea=ha+8|0;U=c[ea>>2]|0;if((aa|0)<(U|
0)){ca=L;O=aa;aa=0;da=0;while(1){W=c[h+(O<<2)>>2]|0;if((W|0)>-1){$=W+1|0;ka=(ca|0)<(W|0)?ca:W;la=(aa|0)>($|0)?aa:$;ma=da}else{ka=ca;la=aa;ma=1}O=O+1|0;if((O|0)>=(U|0)){na=ka;oa=la;pa=ma;break}else{ca=ka;aa=la;da=ma}}}else{na=L;oa=0;pa=0}if((na|0)<(oa|0)){c[Z>>2]=na;c[ea>>2]=oa;if(pa?(da=ha+12|0,aa=c[da>>2]|0,(aa&1|0)!=0):0){ca=aa|16;aa=c[ia>>2]|0;if((ca&~aa|0)!=0){U=c[ba>>2]|0;if((U|0)==0){O=c[fa>>2]|0;if((O|0)==0){vk(b,256);qa=c[fa>>2]|0}else qa=O;O=Em(c[e>>2]|0,qa<<2)|0;xn(O|0,0,c[fa>>2]<<2|0)|
0;ra=O;sa=c[ia>>2]|0}else{ra=U;sa=aa}c[ba>>2]=ra;c[ia>>2]=sa|ca}c[da>>2]=ca}}else{c[Z>>2]=0;c[ea>>2]=0;ca=ha+12|0;da=c[ca>>2]|0;if((da&4|0)==0){aa=da|8;if(((da&-9^-9)&da|0)!=0)a[ga>>0]=1;U=c[ia>>2]|0;if((aa&~U|0)!=0){if((da&1|0)==0)ta=U;else{da=c[ba>>2]|0;if((da|0)==0){O=c[fa>>2]|0;if((O|0)==0){vk(b,256);ua=c[fa>>2]|0}else ua=O;O=Em(c[e>>2]|0,ua<<2)|0;xn(O|0,0,c[fa>>2]<<2|0)|0;va=O;wa=c[ia>>2]|0}else{va=da;wa=U}c[ba>>2]=va;ta=wa}c[ia>>2]=ta|aa}c[ca>>2]=aa}}ha=c[ha+24>>2]|0}while((ha|0)!=0)}c[f>>2]=
L;_m((c[e>>2]|0)+76|0,h);c[b+8>>2]=K;a[b+12>>0]=0;K=c[ja>>2]|0;if((K|0)==0){i=d;return}else xa=K;do{K=xa;xa=c[xa+24>>2]|0;if((c[K+12>>2]&8|0)!=0)tk(b,K)}while((xa|0)!=0);i=d;return}function yk(b,d,e){b=b|0;d=d|0;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;f=i;h=b+288|0;j=c[h>>2]|0;k=(j|0)==0;l=b+280|0;m=c[l>>2]|0;if((m|0)==0){n=b+48|0;o=c[n>>2]|0;if((o|0)==0){vk(b,256);p=c[n>>2]|0}else p=o;o=Em(c[b+400>>2]|0,p<<2)|0;xn(o|0,0,c[n>>2]<<2|0)|0;q=o;r=c[h>>2]|0}else{q=m;r=j}c[l>>2]=
q;if((r|0)==0){q=b+48|0;j=c[q>>2]|0;if((j|0)==0){vk(b,256);s=c[q>>2]|0}else s=j;j=Em(c[b+400>>2]|0,s<<2)|0;xn(j|0,0,c[q>>2]<<2|0)|0;t=j}else t=r;c[h>>2]=t;if(k?(k=c[b+44>>2]|0,(k|0)>0):0){h=0;do{c[t+(h<<2)>>2]=h;h=h+1|0}while((h|0)!=(k|0))}k=~~(e/+g[b+396>>2]);if((k|0)>0)u=(c[b+300>>2]|0)+k|0;else u=k;k=(c[l>>2]|0)+(d<<2)|0;if((u|0)==(c[k>>2]|0)){i=f;return}c[k>>2]=u;a[b+304>>0]=1;i=f;return}function zk(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=
0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0;h=i;if((d|0)==(e|0)|(e|0)==(f|0)){i=h;return}j=c[b+88>>2]|0;k=j+(d<<2)|0;l=j+(e<<2)|0;m=j+(f<<2)|0;a:do if((d+1|0)!=(e|0)){if((e+1|0)==(f|0)){n=j+(f+-1<<2)|0;o=c[n>>2]|0;p=n-k|0;Bn(j+(f-(p>>2)<<2)|0,k|0,p|0)|0;c[k>>2]=o;break}o=l;p=o-k>>2;n=m;q=n-o>>2;if((p|0)==(q|
0)){o=k;r=l;while(1){s=c[o>>2]|0;c[o>>2]=c[r>>2];c[r>>2]=s;o=o+4|0;if((o|0)==(l|0))break a;else r=r+4|0}}else{t=p;u=q}while(1){r=(t|0)%(u|0)|0;if((r|0)==0)break;else{o=u;u=r;t=o}}if((u|0)!=0){q=p+-1|0;o=p+d|0;r=j+(u+d<<2)|0;do{s=r;r=r+-4|0;v=c[r>>2]|0;w=r;x=s+(q<<2)|0;while(1){c[w>>2]=c[x>>2];s=n-x>>2;if((p|0)<(s|0))y=x+(p<<2)|0;else y=j+(o-s<<2)|0;if((y|0)==(r|0))break;else{s=x;x=y;w=s}}c[x>>2]=v}while((r|0)!=(k|0))}}else{r=c[k>>2]|0;o=m-l|0;Bn(k|0,l|0,o|0)|0;c[j+((o>>2)+d<<2)>>2]=r}while(0);j=c[b+
160>>2]|0;b:do if((j|0)!=0){l=j+(d<<2)|0;k=j+(e<<2)|0;m=j+(f<<2)|0;if((d+1|0)==(e|0)){y=c[l>>2]|0;u=m-k|0;Bn(l|0,k|0,u|0)|0;c[j+((u>>2)+d<<2)>>2]=y;break}if((e+1|0)==(f|0)){y=j+(f+-1<<2)|0;u=c[y>>2]|0;t=y-l|0;Bn(j+(f-(t>>2)<<2)|0,l|0,t|0)|0;c[l>>2]=u;break}u=k;t=u-l>>2;y=m;m=y-u>>2;if((t|0)==(m|0)){u=l;r=k;while(1){o=c[u>>2]|0;c[u>>2]=c[r>>2];c[r>>2]=o;u=u+4|0;if((u|0)==(k|0))break b;else r=r+4|0}}else{z=t;A=m}while(1){r=(z|0)%(A|0)|0;if((r|0)==0)break;else{k=A;A=r;z=k}}if((A|0)!=0){m=t+-1|0;k=t+
d|0;r=j+(A+d<<2)|0;do{u=r;r=r+-4|0;o=c[r>>2]|0;p=r;n=u+(m<<2)|0;while(1){c[p>>2]=c[n>>2];u=y-n>>2;if((t|0)<(u|0))B=n+(t<<2)|0;else B=j+(k-u<<2)|0;if((B|0)==(r|0))break;else{u=n;n=B;p=u}}c[n>>2]=o}while((r|0)!=(l|0))}}while(0);B=c[b+168>>2]|0;c:do if((B|0)!=0){j=B+(d<<2)|0;A=B+(e<<2)|0;z=B+(f<<2)|0;if((d+1|0)==(e|0)){l=c[j>>2]|0;r=z-A|0;Bn(j|0,A|0,r|0)|0;c[B+((r>>2)+d<<2)>>2]=l;break}if((e+1|0)==(f|0)){l=B+(f+-1<<2)|0;r=c[l>>2]|0;k=l-j|0;Bn(B+(f-(k>>2)<<2)|0,j|0,k|0)|0;c[j>>2]=r;break}r=A;k=r-j>>2;
l=z;z=l-r>>2;if((k|0)==(z|0)){r=j;t=A;while(1){y=c[r>>2]|0;c[r>>2]=c[t>>2];c[t>>2]=y;r=r+4|0;if((r|0)==(A|0))break c;else t=t+4|0}}else{C=k;D=z}while(1){t=(C|0)%(D|0)|0;if((t|0)==0)break;else{A=D;D=t;C=A}}if((D|0)!=0){z=k+-1|0;A=k+d|0;t=B+(D+d<<2)|0;do{r=t;t=t+-4|0;y=c[t>>2]|0;m=t;p=r+(z<<2)|0;while(1){c[m>>2]=c[p>>2];r=l-p>>2;if((k|0)<(r|0))E=p+(k<<2)|0;else E=B+(A-r<<2)|0;if((E|0)==(t|0))break;else{r=p;p=E;m=r}}c[p>>2]=y}while((t|0)!=(j|0))}}while(0);E=c[b+176>>2]|0;d:do if((E|0)!=0){B=E+(d<<2)|
0;D=E+(e<<2)|0;C=E+(f<<2)|0;if((d+1|0)==(e|0)){j=c[B>>2]|0;t=C-D|0;Bn(B|0,D|0,t|0)|0;c[E+((t>>2)+d<<2)>>2]=j;break}if((e+1|0)==(f|0)){j=E+(f+-1<<2)|0;t=c[j>>2]|0;A=j-B|0;Bn(E+(f-(A>>2)<<2)|0,B|0,A|0)|0;c[B>>2]=t;break}t=D;A=t-B>>2;j=C;C=j-t>>2;if((A|0)==(C|0)){t=B;k=D;while(1){l=c[t>>2]|0;c[t>>2]=c[k>>2];c[k>>2]=l;t=t+4|0;if((t|0)==(D|0))break d;else k=k+4|0}}else{F=A;G=C}while(1){k=(F|0)%(G|0)|0;if((k|0)==0)break;else{D=G;G=k;F=D}}if((G|0)!=0){C=A+-1|0;D=A+d|0;k=E+(G+d<<2)|0;do{t=k;k=k+-4|0;l=c[k>>
2]|0;z=k;m=t+(C<<2)|0;while(1){c[z>>2]=c[m>>2];t=j-m>>2;if((A|0)<(t|0))H=m+(A<<2)|0;else H=E+(D-t<<2)|0;if((H|0)==(k|0))break;else{t=m;m=H;z=t}}c[m>>2]=l}while((k|0)!=(B|0))}}while(0);H=c[b+96>>2]|0;E=H+(d<<3)|0;G=H+(e<<3)|0;F=H+(f<<3)|0;e:do if((d+1|0)!=(e|0)){if((e+1|0)==(f|0)){B=H+(f+-1<<3)|0;k=B;D=c[k>>2]|0;A=c[k+4>>2]|0;k=B-E|0;Bn(H+(f-(k>>3)<<3)|0,E|0,k|0)|0;k=E;c[k>>2]=D;c[k+4>>2]=A;break}A=G;k=A-E>>3;D=F;B=D-A>>3;if((k|0)==(B|0)){A=E;j=G;while(1){C=A;z=c[C>>2]|0;y=c[C+4>>2]|0;C=j;p=c[C+4>>
2]|0;t=A;c[t>>2]=c[C>>2];c[t+4>>2]=p;p=j;c[p>>2]=z;c[p+4>>2]=y;A=A+8|0;if((A|0)==(G|0))break e;else j=j+8|0}}else{I=k;J=B}while(1){j=(I|0)%(J|0)|0;if((j|0)==0)break;else{A=J;J=j;I=A}}if((J|0)!=0){B=k+-1|0;A=k+d|0;j=H+(J+d<<3)|0;do{y=j;j=j+-8|0;p=j;z=c[p>>2]|0;t=c[p+4>>2]|0;p=j;C=y+(B<<3)|0;while(1){y=C;o=c[y+4>>2]|0;n=p;c[n>>2]=c[y>>2];c[n+4>>2]=o;o=D-C>>3;if((k|0)<(o|0))K=C+(k<<3)|0;else K=H+(A-o<<3)|0;if((K|0)==(j|0))break;else{o=C;C=K;p=o}}p=C;c[p>>2]=z;c[p+4>>2]=t}while((j|0)!=(E|0))}}else{j=
E;A=c[j>>2]|0;k=c[j+4>>2]|0;j=F-G|0;Bn(E|0,G|0,j|0)|0;D=H+((j>>3)+d<<3)|0;c[D>>2]=A;c[D+4>>2]=k}while(0);H=c[b+104>>2]|0;G=H+(d<<3)|0;E=H+(e<<3)|0;F=H+(f<<3)|0;f:do if((d+1|0)!=(e|0)){if((e+1|0)==(f|0)){K=H+(f+-1<<3)|0;J=K;I=c[J>>2]|0;k=c[J+4>>2]|0;J=K-G|0;Bn(H+(f-(J>>3)<<3)|0,G|0,J|0)|0;J=G;c[J>>2]=I;c[J+4>>2]=k;break}k=E;J=k-G>>3;I=F;K=I-k>>3;if((J|0)==(K|0)){k=G;D=E;while(1){A=k;j=c[A>>2]|0;B=c[A+4>>2]|0;A=D;p=c[A+4>>2]|0;l=k;c[l>>2]=c[A>>2];c[l+4>>2]=p;p=D;c[p>>2]=j;c[p+4>>2]=B;k=k+8|0;if((k|
0)==(E|0))break f;else D=D+8|0}}else{L=J;M=K}while(1){D=(L|0)%(M|0)|0;if((D|0)==0)break;else{k=M;M=D;L=k}}if((M|0)!=0){K=J+-1|0;k=J+d|0;D=H+(M+d<<3)|0;do{B=D;D=D+-8|0;p=D;j=c[p>>2]|0;l=c[p+4>>2]|0;p=D;A=B+(K<<3)|0;while(1){B=A;m=c[B+4>>2]|0;o=p;c[o>>2]=c[B>>2];c[o+4>>2]=m;m=I-A>>3;if((J|0)<(m|0))N=A+(J<<3)|0;else N=H+(k-m<<3)|0;if((N|0)==(D|0))break;else{m=A;A=N;p=m}}p=A;c[p>>2]=j;c[p+4>>2]=l}while((D|0)!=(G|0))}}else{D=G;k=c[D>>2]|0;J=c[D+4>>2]|0;D=F-E|0;Bn(G|0,E|0,D|0)|0;I=H+((D>>3)+d<<3)|0;c[I>>
2]=k;c[I+4>>2]=J}while(0);H=c[b+144>>2]|0;E=H+(d<<2)|0;G=H+(e<<2)|0;F=H+(f<<2)|0;g:do if((d+1|0)!=(e|0)){if((e+1|0)==(f|0)){N=H+(f+-1<<2)|0;M=c[N>>2]|0;L=N-E|0;Bn(H+(f-(L>>2)<<2)|0,E|0,L|0)|0;c[E>>2]=M;break}M=G;L=M-E>>2;N=F;J=N-M>>2;if((L|0)==(J|0)){M=E;I=G;while(1){k=c[M>>2]|0;c[M>>2]=c[I>>2];c[I>>2]=k;M=M+4|0;if((M|0)==(G|0))break g;else I=I+4|0}}else{O=L;P=J}while(1){I=(O|0)%(P|0)|0;if((I|0)==0)break;else{M=P;P=I;O=M}}if((P|0)!=0){J=L+-1|0;M=L+d|0;I=H+(P+d<<2)|0;do{k=I;I=I+-4|0;D=c[I>>2]|0;K=
I;p=k+(J<<2)|0;while(1){c[K>>2]=c[p>>2];k=N-p>>2;if((L|0)<(k|0))Q=p+(L<<2)|0;else Q=H+(M-k<<2)|0;if((Q|0)==(I|0))break;else{k=p;p=Q;K=k}}c[p>>2]=D}while((I|0)!=(E|0))}}else{I=c[E>>2]|0;M=F-G|0;Bn(E|0,G|0,M|0)|0;c[H+((M>>2)+d<<2)>>2]=I}while(0);h:do if((a[b+21>>0]|0)!=0){H=c[b+112>>2]|0;G=H+(d<<3)|0;E=H+(e<<3)|0;F=H+(f<<3)|0;if((d+1|0)==(e|0)){Q=G;P=c[Q>>2]|0;O=c[Q+4>>2]|0;Q=F-E|0;Bn(G|0,E|0,Q|0)|0;I=H+((Q>>3)+d<<3)|0;c[I>>2]=P;c[I+4>>2]=O;break}if((e+1|0)==(f|0)){O=H+(f+-1<<3)|0;I=O;P=c[I>>2]|0;Q=
c[I+4>>2]|0;I=O-G|0;Bn(H+(f-(I>>3)<<3)|0,G|0,I|0)|0;I=G;c[I>>2]=P;c[I+4>>2]=Q;break}Q=E;I=Q-G>>3;P=F;F=P-Q>>3;if((I|0)==(F|0)){Q=G;O=E;while(1){M=Q;L=c[M>>2]|0;N=c[M+4>>2]|0;M=O;J=c[M+4>>2]|0;K=Q;c[K>>2]=c[M>>2];c[K+4>>2]=J;J=O;c[J>>2]=L;c[J+4>>2]=N;Q=Q+8|0;if((Q|0)==(E|0))break h;else O=O+8|0}}else{R=I;S=F}while(1){O=(R|0)%(S|0)|0;if((O|0)==0)break;else{E=S;S=O;R=E}}if((S|0)!=0){F=I+-1|0;E=I+d|0;O=H+(S+d<<3)|0;do{Q=O;O=O+-8|0;N=O;J=c[N>>2]|0;L=c[N+4>>2]|0;N=O;K=Q+(F<<3)|0;while(1){Q=K;M=c[Q+4>>2]|
0;l=N;c[l>>2]=c[Q>>2];c[l+4>>2]=M;M=P-K>>3;if((I|0)<(M|0))T=K+(I<<3)|0;else T=H+(E-M<<3)|0;if((T|0)==(O|0))break;else{M=K;K=T;N=M}}N=K;c[N>>2]=J;c[N+4>>2]=L}while((O|0)!=(G|0))}}while(0);T=c[b+120>>2]|0;i:do if((T|0)!=0){S=T+(d<<2)|0;R=T+(e<<2)|0;G=T+(f<<2)|0;if((d+1|0)==(e|0)){U=+g[S>>2];O=G-R|0;Bn(S|0,R|0,O|0)|0;g[T+((O>>2)+d<<2)>>2]=U;break}if((e+1|0)==(f|0)){O=T+(f+-1<<2)|0;U=+g[O>>2];E=O-S|0;Bn(T+(f-(E>>2)<<2)|0,S|0,E|0)|0;g[S>>2]=U;break}E=R;O=E-S>>2;H=G;G=H-E>>2;if((O|0)==(G|0)){E=S;I=R;while(1){U=
+g[E>>2];g[E>>2]=+g[I>>2];g[I>>2]=U;E=E+4|0;if((E|0)==(R|0))break i;else I=I+4|0}}else{V=O;W=G}while(1){I=(V|0)%(W|0)|0;if((I|0)==0)break;else{R=W;W=I;V=R}}if((W|0)!=0){G=O+-1|0;R=O+d|0;I=T+(W+d<<2)|0;do{E=I;I=I+-4|0;U=+g[I>>2];P=I;F=E+(G<<2)|0;while(1){g[P>>2]=+g[F>>2];E=H-F>>2;if((O|0)<(E|0))X=F+(O<<2)|0;else X=T+(R-E<<2)|0;if((X|0)==(I|0))break;else{E=F;F=X;P=E}}g[F>>2]=U}while((I|0)!=(S|0))}}while(0);X=c[b+132>>2]|0;j:do if((X|0)!=0){T=X+(d<<2)|0;W=X+(e<<2)|0;V=X+(f<<2)|0;if((d+1|0)==(e|0)){Y=
+g[T>>2];S=V-W|0;Bn(T|0,W|0,S|0)|0;g[X+((S>>2)+d<<2)>>2]=Y;break}if((e+1|0)==(f|0)){S=X+(f+-1<<2)|0;Y=+g[S>>2];I=S-T|0;Bn(X+(f-(I>>2)<<2)|0,T|0,I|0)|0;g[T>>2]=Y;break}I=W;S=I-T>>2;R=V;V=R-I>>2;if((S|0)==(V|0)){I=T;O=W;while(1){Y=+g[I>>2];g[I>>2]=+g[O>>2];g[O>>2]=Y;I=I+4|0;if((I|0)==(W|0))break j;else O=O+4|0}}else{Z=S;_=V}while(1){O=(Z|0)%(_|0)|0;if((O|0)==0)break;else{W=_;_=O;Z=W}}if((_|0)!=0){V=S+-1|0;W=S+d|0;O=X+(_+d<<2)|0;do{I=O;O=O+-4|0;Y=+g[O>>2];H=O;G=I+(V<<2)|0;while(1){g[H>>2]=+g[G>>2];I=
R-G>>2;if((S|0)<(I|0))$=G+(S<<2)|0;else $=X+(W-I<<2)|0;if(($|0)==(O|0))break;else{I=G;G=$;H=I}}g[G>>2]=Y}while((O|0)!=(T|0))}}while(0);$=c[b+136>>2]|0;if(($|0)!=0)rl($+(d<<2)|0,$+(e<<2)|0,$+(f<<2)|0)|0;$=c[b+148>>2]|0;k:do if(($|0)!=0){X=$+(d<<2)|0;_=$+(e<<2)|0;Z=$+(f<<2)|0;if((d+1|0)==(e|0)){T=c[X>>2]|0;O=Z-_|0;Bn(X|0,_|0,O|0)|0;c[$+((O>>2)+d<<2)>>2]=T;break}if((e+1|0)==(f|0)){T=$+(f+-1<<2)|0;O=c[T>>2]|0;W=T-X|0;Bn($+(f-(W>>2)<<2)|0,X|0,W|0)|0;c[X>>2]=O;break}O=_;W=O-X>>2;T=Z;Z=T-O>>2;if((W|0)==
(Z|0)){O=X;S=_;while(1){R=c[O>>2]|0;c[O>>2]=c[S>>2];c[S>>2]=R;O=O+4|0;if((O|0)==(_|0))break k;else S=S+4|0}}else{aa=W;ba=Z}while(1){S=(aa|0)%(ba|0)|0;if((S|0)==0)break;else{_=ba;ba=S;aa=_}}if((ba|0)!=0){Z=W+-1|0;_=W+d|0;S=$+(ba+d<<2)|0;do{O=S;S=S+-4|0;R=c[S>>2]|0;V=S;H=O+(Z<<2)|0;while(1){c[V>>2]=c[H>>2];O=T-H>>2;if((W|0)<(O|0))ca=H+(W<<2)|0;else ca=$+(_-O<<2)|0;if((ca|0)==(S|0))break;else{O=H;H=ca;V=O}}c[H>>2]=R}while((S|0)!=(X|0))}}while(0);ca=b+80|0;$=c[ca>>2]|0;if(($|0)!=0){ba=$+(d<<2)|0;aa=$+
(e<<2)|0;X=$+(f<<2)|0;l:do if((d+1|0)!=(e|0)){if((e+1|0)==(f|0)){S=$+(f+-1<<2)|0;_=c[S>>2]|0;W=S-ba|0;Bn($+(f-(W>>2)<<2)|0,ba|0,W|0)|0;c[ba>>2]=_;break}_=aa;W=_-ba>>2;S=X;T=S-_>>2;if((W|0)==(T|0)){_=ba;Z=aa;while(1){V=c[_>>2]|0;c[_>>2]=c[Z>>2];c[Z>>2]=V;_=_+4|0;if((_|0)==(aa|0))break l;else Z=Z+4|0}}else{da=W;ea=T}while(1){Z=(da|0)%(ea|0)|0;if((Z|0)==0)break;else{_=ea;ea=Z;da=_}}if((ea|0)!=0){T=W+-1|0;_=W+d|0;Z=$+(ea+d<<2)|0;do{V=Z;Z=Z+-4|0;G=c[Z>>2]|0;O=Z;F=V+(T<<2)|0;while(1){c[O>>2]=c[F>>2];V=
S-F>>2;if((W|0)<(V|0))fa=F+(W<<2)|0;else fa=$+(_-V<<2)|0;if((fa|0)==(Z|0))break;else{V=F;F=fa;O=V}}c[F>>2]=G}while((Z|0)!=(ba|0))}}else{Z=c[ba>>2]|0;_=X-aa|0;Bn(ba|0,aa|0,_|0)|0;c[$+((_>>2)+d<<2)>>2]=Z}while(0);if((d|0)<(f|0)){$=c[ca>>2]|0;ca=f-e|0;aa=d-e|0;ba=d;do{X=c[$+(ba<<2)>>2]|0;if((X|0)!=0){fa=X+8|0;X=c[fa>>2]|0;do if((X|0)>=(d|0))if((X|0)<(e|0)){ga=ca+X|0;break}else{ga=X+((X|0)<(f|0)?aa:0)|0;break}else ga=X;while(0);c[fa>>2]=ga}ba=ba+1|0}while((ba|0)!=(f|0))}}ba=c[b+280>>2]|0;if((ba|0)!=0){ga=
ba+(d<<2)|0;aa=ba+(e<<2)|0;ca=ba+(f<<2)|0;m:do if((d+1|0)==(e|0)){$=c[ga>>2]|0;X=ca-aa|0;Bn(ga|0,aa|0,X|0)|0;c[ba+((X>>2)+d<<2)>>2]=$}else{if((e+1|0)==(f|0)){$=ba+(f+-1<<2)|0;X=c[$>>2]|0;ea=$-ga|0;Bn(ba+(f-(ea>>2)<<2)|0,ga|0,ea|0)|0;c[ga>>2]=X;break}X=aa;ea=X-ga>>2;$=ca;da=$-X>>2;if((ea|0)==(da|0)){X=ga;Z=aa;while(1){_=c[X>>2]|0;c[X>>2]=c[Z>>2];c[Z>>2]=_;X=X+4|0;if((X|0)==(aa|0))break m;else Z=Z+4|0}}else{ha=ea;ia=da}while(1){Z=(ha|0)%(ia|0)|0;if((Z|0)==0)break;else{X=ia;ia=Z;ha=X}}if((ia|0)==0)break;
da=ea+-1|0;X=ea+d|0;Z=ba+(ia+d<<2)|0;do{fa=Z;Z=Z+-4|0;_=c[Z>>2]|0;W=Z;S=fa+(da<<2)|0;while(1){c[W>>2]=c[S>>2];fa=$-S>>2;if((ea|0)<(fa|0))ja=S+(ea<<2)|0;else ja=ba+(X-fa<<2)|0;if((ja|0)==(Z|0))break;else{fa=S;S=ja;W=fa}}c[S>>2]=_}while((Z|0)!=(ga|0))}while(0);ga=c[b+44>>2]|0;ja=c[b+288>>2]|0;if((ga|0)>0){ba=f-e|0;ia=d-e|0;ha=0;do{aa=ja+(ha<<2)|0;ca=c[aa>>2]|0;do if((ca|0)>=(d|0))if((ca|0)<(e|0)){ka=ba+ca|0;break}else{ka=ca+((ca|0)<(f|0)?ia:0)|0;break}else ka=ca;while(0);c[aa>>2]=ka;ha=ha+1|0}while((ha|
0)!=(ga|0))}}ga=b+204|0;if((c[ga>>2]|0)>0){ha=c[b+200>>2]|0;ka=f-e|0;ia=d-e|0;ba=0;do{ja=ha+(ba<<3)|0;ca=c[ja>>2]|0;do if((ca|0)>=(d|0))if((ca|0)<(e|0)){la=ka+ca|0;break}else{la=ca+((ca|0)<(f|0)?ia:0)|0;break}else la=ca;while(0);c[ja>>2]=la;ba=ba+1|0}while((ba|0)<(c[ga>>2]|0))}ga=b+220|0;if((c[ga>>2]|0)>0){ba=c[b+216>>2]|0;la=f-e|0;ia=d-e|0;ka=0;do{ha=ba+(ka*24|0)|0;ca=c[ha>>2]|0;do if((ca|0)>=(d|0))if((ca|0)<(e|0)){ma=la+ca|0;break}else{ma=ca+((ca|0)<(f|0)?ia:0)|0;break}else ma=ca;while(0);ca=ba+
(ka*24|0)+4|0;ja=c[ca>>2]|0;do if((ja|0)>=(d|0))if((ja|0)<(e|0)){na=la+ja|0;break}else{na=ja+((ja|0)<(f|0)?ia:0)|0;break}else na=ja;while(0);c[ha>>2]=ma;c[ca>>2]=na;ka=ka+1|0}while((ka|0)<(c[ga>>2]|0))}ga=b+236|0;if((c[ga>>2]|0)>0){ka=c[b+232>>2]|0;na=f-e|0;ma=d-e|0;ia=0;do{la=ka+(ia*28|0)|0;ba=c[la>>2]|0;do if((ba|0)>=(d|0))if((ba|0)<(e|0)){oa=na+ba|0;break}else{oa=ba+((ba|0)<(f|0)?ma:0)|0;break}else oa=ba;while(0);c[la>>2]=oa;ia=ia+1|0}while((ia|0)<(c[ga>>2]|0))}ga=b+252|0;if((c[ga>>2]|0)>0){ia=
c[b+248>>2]|0;oa=f-e|0;ma=d-e|0;na=0;do{ka=ia+(na*20|0)|0;ba=c[ka>>2]|0;do if((ba|0)>=(d|0))if((ba|0)<(e|0)){pa=oa+ba|0;break}else{pa=ba+((ba|0)<(f|0)?ma:0)|0;break}else pa=ba;while(0);c[ka>>2]=pa;ba=ia+(na*20|0)+4|0;la=c[ba>>2]|0;do if((la|0)>=(d|0))if((la|0)<(e|0)){qa=oa+la|0;break}else{qa=la+((la|0)<(f|0)?ma:0)|0;break}else qa=la;while(0);c[ba>>2]=qa;na=na+1|0}while((na|0)<(c[ga>>2]|0))}ga=b+268|0;if((c[ga>>2]|0)>0){na=c[b+264>>2]|0;qa=f-e|0;ma=d-e|0;oa=0;do{ia=na+(oa*60|0)|0;pa=c[ia>>2]|0;do if((pa|
0)>=(d|0))if((pa|0)<(e|0)){ra=qa+pa|0;break}else{ra=pa+((pa|0)<(f|0)?ma:0)|0;break}else ra=pa;while(0);c[ia>>2]=ra;pa=na+(oa*60|0)+4|0;ba=c[pa>>2]|0;do if((ba|0)>=(d|0))if((ba|0)<(e|0)){sa=qa+ba|0;break}else{sa=ba+((ba|0)<(f|0)?ma:0)|0;break}else sa=ba;while(0);c[pa>>2]=sa;ba=na+(oa*60|0)+8|0;ia=c[ba>>2]|0;do if((ia|0)>=(d|0))if((ia|0)<(e|0)){ta=qa+ia|0;break}else{ta=ia+((ia|0)<(f|0)?ma:0)|0;break}else ta=ia;while(0);c[ba>>2]=ta;oa=oa+1|0}while((oa|0)<(c[ga>>2]|0))}ga=c[b+312>>2]|0;if((ga|0)==0){i=
h;return}b=d-e|0;oa=f-e|0;ta=ga;do{ga=ta+4|0;ma=c[ga>>2]|0;do if((ma|0)>=(d|0))if((ma|0)<(e|0)){ua=oa+ma|0;break}else{ua=ma+((ma|0)<(f|0)?b:0)|0;break}else ua=ma;while(0);c[ga>>2]=ua;ma=ta+8|0;ba=c[ma>>2]|0;qa=ba+-1|0;do if((ba|0)>(d|0))if((ba|0)>(e|0)){va=qa+((ba|0)>(f|0)?0:b)|0;break}else{va=oa+qa|0;break}else va=qa;while(0);c[ma>>2]=va+1;ta=c[ta+24>>2]|0}while((ta|0)!=0);i=h;return}function Ak(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;f=i;g=(c[b+88>>2]|0)+(d<<2)|0;if((c[g>>
2]&~e|0)!=0)a[b+12>>0]=1;d=b+8|0;if((~c[d>>2]&e|0)==0){c[g>>2]=e;i=f;return}if((e&128|0)!=0){h=b+128|0;j=c[h>>2]|0;if((j|0)==0){k=b+48|0;l=c[k>>2]|0;if((l|0)==0){vk(b,256);m=c[k>>2]|0}else m=l;l=Em(c[b+400>>2]|0,m<<3)|0;xn(l|0,0,c[k>>2]<<3|0)|0;n=l}else n=j;c[h>>2]=n}if((e&256|0)!=0){n=b+136|0;h=c[n>>2]|0;if((h|0)==0){j=b+48|0;l=c[j>>2]|0;if((l|0)==0){vk(b,256);o=c[j>>2]|0}else o=l;l=Em(c[b+400>>2]|0,o<<2)|0;xn(l|0,0,c[j>>2]<<2|0)|0;p=l}else p=h;c[n>>2]=p}c[d>>2]=c[d>>2]|e;c[g>>2]=e;i=f;return}function Bk(a,
b,d){a=a|0;b=b|0;d=d|0;var e=0;e=i;Ak(a,b,c[(c[a+88>>2]|0)+(b<<2)>>2]|(d?514:2));i=e;return}function Ck(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0,k=0,l=0,m=0;g=i;i=i+64|0;h=g+16|0;j=g;k=b+400|0;if((c[(c[k>>2]|0)+102876>>2]&2|0)!=0){l=0;i=g;return l|0}c[h>>2]=7912;m=h+12|0;c[h+4>>2]=b;c[h+8>>2]=d;c[m+0>>2]=c[e+0>>2];c[m+4>>2]=c[e+4>>2];c[m+8>>2]=c[e+8>>2];c[m+12>>2]=c[e+12>>2];a[h+28>>0]=f&1;f=h+32|0;c[f>>2]=0;pb[c[(c[d>>2]|0)+28>>2]&31](d,j,e,0);Dj(c[k>>2]|0,h,j);l=c[f>>2]|0;i=g;return l|0}
function Dk(d,e,f,h){d=d|0;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0;j=i;i=i+96|0;k=j+48|0;l=j;m=+g[f+52>>2];if(m==0)n=+g[d+32>>2]*.75;else n=m;o=bb[c[(c[e>>2]|0)+12>>2]&7](e)|0;if((o|0)<=0){i=j;return}p=l+4|0;q=l+8|0;r=l+28|0;s=e+4|0;t=l+12|0;u=e+12|0;v=l+20|0;w=l+12|0;x=l+
24|0;y=l+16|0;z=k+4|0;A=k+12|0;B=k+20|0;C=k+21|0;D=k+22|0;E=k+23|0;F=k+24|0;G=k+28|0;H=k+32|0;I=h+12|0;J=h+8|0;K=h+4|0;L=f+28|0;M=f+8|0;N=f+12|0;O=f+20|0;P=f+24|0;R=f+32|0;S=f+33|0;T=f+34|0;U=f+35|0;V=f+64|0;W=f+68|0;X=0;m=0;while(1){c[l>>2]=488;c[p>>2]=1;g[q>>2]=.009999999776482582;c[r+0>>2]=0;c[r+4>>2]=0;c[r+8>>2]=0;c[r+12>>2]=0;b[r+16>>1]=0;if((c[s>>2]|0)==1){Y=s;Z=c[Y+4>>2]|0;_=p;c[_>>2]=c[Y>>2];c[_+4>>2]=Z;c[t+0>>2]=c[u+0>>2];c[t+4>>2]=c[u+4>>2];c[t+8>>2]=c[u+8>>2];c[t+12>>2]=c[u+12>>2];c[t+
16>>2]=c[u+16>>2];c[t+20>>2]=c[u+20>>2];c[t+24>>2]=c[u+24>>2];c[t+28>>2]=c[u+28>>2];b[t+32>>1]=b[u+32>>1]|0}else Ge(e,l,X);$=+g[w>>2];aa=+g[v>>2]-$;ba=+g[y>>2];ca=+g[x>>2]-ba;da=+Q(+(aa*aa+ca*ca));a:do if(m<da){ea=$;fa=ba;ga=m;while(1){ha=ga/da;ia=ea+aa*ha;ja=ca*ha+fa;c[H>>2]=0;c[k>>2]=c[f>>2];ha=+g[I>>2];ka=+g[J>>2];la=+g[h>>2]+(ia*ha-ja*ka);ma=ja*ha+ia*ka+ +g[K>>2];ka=+la;ia=+ma;Z=z;g[Z>>2]=ka;g[Z+4>>2]=ia;ia=+g[L>>2];ka=+(+g[O>>2]-ia*(ma-+g[N>>2]));ma=+(ia*(la-+g[M>>2])+ +g[P>>2]);Z=A;g[Z>>2]=
ka;g[Z+4>>2]=ma;Z=a[S>>0]|0;_=a[T>>0]|0;Y=a[U>>0]|0;a[B>>0]=a[R>>0]|0;a[C>>0]=Z;a[D>>0]=_;a[E>>0]=Y;g[F>>2]=+g[V>>2];c[G>>2]=c[W>>2];wk(d,k)|0;ma=n+ga;if(!(ma<da)){na=ma;break a}ea=+g[w>>2];fa=+g[y>>2];ga=ma}}else na=m;while(0);Y=X+1|0;if((Y|0)==(o|0))break;X=Y;m=na-da}i=j;return}function Ek(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,
_=0,$=0,aa=0,ba=0,ca=0;h=i;i=i+80|0;j=h+40|0;k=h+24|0;l=h+8|0;m=h;n=+g[e+52>>2];if(n==0)o=+g[b+32>>2]*.75;else o=n;g[k>>2]=0;g[k+4>>2]=0;g[k+8>>2]=0;g[k+12>>2]=1;pb[c[(c[d>>2]|0)+28>>2]&31](d,l,k,0);n=o*+O(+(+g[l+4>>2]/o));p=l+12|0;q=+g[p>>2];if(!(n<q)){i=h;return}r=l+8|0;s=m+4|0;t=j+4|0;u=j+12|0;v=j+20|0;w=j+21|0;x=j+22|0;y=j+23|0;z=j+24|0;A=j+28|0;B=j+32|0;C=f+12|0;D=f+8|0;E=f+4|0;F=e+28|0;G=e+8|0;H=e+12|0;I=e+20|0;J=e+24|0;K=e+32|0;L=e+33|0;M=e+34|0;N=e+35|0;P=e+64|0;Q=e+68|0;R=q;q=+g[r>>2];S=
n;while(1){n=o*+O(+(+g[l>>2]/o));if(n<q){T=n;do{g[m>>2]=T;g[s>>2]=S;if(hb[c[(c[d>>2]|0)+16>>2]&15](d,k,m)|0){c[B>>2]=0;c[j>>2]=c[e>>2];n=+g[C>>2];U=+g[m>>2];V=+g[D>>2];W=+g[s>>2];X=+g[f>>2]+(n*U-V*W);Y=U*V+n*W+ +g[E>>2];W=+X;n=+Y;Z=t;g[Z>>2]=W;g[Z+4>>2]=n;n=+g[F>>2];W=+(+g[I>>2]-n*(Y-+g[H>>2]));Y=+(n*(X-+g[G>>2])+ +g[J>>2]);Z=u;g[Z>>2]=W;g[Z+4>>2]=Y;Z=a[L>>0]|0;_=a[M>>0]|0;$=a[N>>0]|0;a[v>>0]=a[K>>0]|0;a[w>>0]=Z;a[x>>0]=_;a[y>>0]=$;g[z>>2]=+g[P>>2];c[A>>2]=c[Q>>2];wk(b,j)|0}T=o+T;aa=+g[r>>2]}while(T<
aa);ba=+g[p>>2];ca=aa}else{ba=R;ca=q}S=o+S;if(!(S<ba))break;else{R=ba;q=ca}}i=h;return}function Fk(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0;e=i;i=i+64|0;f=e+20|0;h=e;j=e+16|0;k=b+400|0;if((c[(c[k>>2]|0)+102876>>2]&2|0)!=0){l=0;i=e;return l|0}m=+g[d+16>>2];n=d+8|0;o=c[n+4>>2]|0;p=h;c[p>>2]=c[n>>2];c[p+4>>2]=o;o=h+8|0;g[o>>2]=+T(+m);
p=h+12|0;g[p>>2]=+S(+m);n=b+44|0;q=c[n>>2]|0;r=c[d+40>>2]|0;do if((r|0)!=0){s=c[r+4>>2]|0;if((s|0)==3|(s|0)==1){Dk(b,r,d,h);break}else if((s|0)==0|(s|0)==2){Ek(b,r,d,h);break}else break}while(0);r=c[d+44>>2]|0;if((r|0)!=0){s=c[d+48>>2]|0;c[f>>2]=7720;c[f+12>>2]=r;c[f+16>>2]=s;Ek(b,f,d,h)}s=d+56|0;if((c[s>>2]|0)>0){r=d+60|0;t=f+4|0;u=f+12|0;v=f+20|0;w=f+21|0;x=f+22|0;y=f+23|0;z=f+24|0;A=f+28|0;B=f+32|0;m=+g[p>>2];C=+g[o>>2];D=+g[h>>2];E=+g[h+4>>2];o=d+28|0;p=d+8|0;F=d+12|0;G=d+20|0;H=d+24|0;I=d+32|
0;J=d+33|0;K=d+34|0;L=d+35|0;M=d+64|0;N=d+68|0;O=0;do{P=(c[r>>2]|0)+(O<<3)|0;Q=+g[P>>2];R=+g[P+4>>2];c[B>>2]=0;c[f>>2]=c[d>>2];U=D+(Q*m-R*C);V=m*R+Q*C+E;Q=+U;R=+V;P=t;g[P>>2]=Q;g[P+4>>2]=R;R=+g[o>>2];Q=+(+g[G>>2]-R*(V-+g[F>>2]));V=+(R*(U-+g[p>>2])+ +g[H>>2]);P=u;g[P>>2]=Q;g[P+4>>2]=V;P=a[J>>0]|0;W=a[K>>0]|0;X=a[L>>0]|0;a[v>>0]=a[I>>0]|0;a[w>>0]=P;a[x>>0]=W;a[y>>0]=X;g[z>>2]=+g[M>>2];c[A>>2]=c[N>>2];wk(b,f)|0;O=O+1|0}while((O|0)<(c[s>>2]|0))}s=c[n>>2]|0;n=Em(c[k>>2]|0,80)|0;if((n|0)==0)Y=0;else{mk(n);
Y=n}c[Y>>2]=b;c[Y+4>>2]=q;c[Y+8>>2]=s;g[Y+16>>2]=+g[d+36>>2];c[Y+76>>2]=c[d+68>>2];n=Y+60|0;c[n+0>>2]=c[h+0>>2];c[n+4>>2]=c[h+4>>2];c[n+8>>2]=c[h+8>>2];c[n+12>>2]=c[h+12>>2];c[Y+20>>2]=0;h=b+312|0;c[Y+24>>2]=c[h>>2];n=c[h>>2]|0;if((n|0)!=0)c[n+20>>2]=Y;c[h>>2]=Y;h=b+308|0;c[h>>2]=(c[h>>2]|0)+1;if((q|0)<(s|0)){h=b+144|0;n=q;do{c[(c[h>>2]|0)+(n<<2)>>2]=Y;n=n+1|0}while((n|0)!=(s|0))}n=c[d+4>>2]|0;h=Y+12|0;O=c[h>>2]|0;f=(O^n)<<4&16|n;if((O&~f|0)!=0)a[b+20>>0]=1;O=b+16|0;N=c[O>>2]|0;if((f&~N|0)!=0){if((n&
1|0)==0)Z=N;else{n=b+132|0;A=c[n>>2]|0;if((A|0)==0){M=b+48|0;z=c[M>>2]|0;if((z|0)==0){vk(b,256);_=c[M>>2]|0}else _=z;z=Em(c[k>>2]|0,_<<2)|0;xn(z|0,0,c[M>>2]<<2|0)|0;$=z;aa=c[O>>2]|0}else{$=A;aa=N}c[n>>2]=$;Z=aa}c[O>>2]=Z|f}c[h>>2]=f;c[j>>2]=7544;Gk(b,1);Hk(b,q,s,j);j=d+72|0;d=c[j>>2]|0;if((d|0)==0){l=Y;i=e;return l|0}Ik(b,d,Y);l=c[j>>2]|0;i=e;return l|0}function Gk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;d=i;i=i+32|0;e=d;f=d+8|0;h=a+204|0;j=c[h>>2]|0;k=
c[a+200>>2]|0;l=k+(j<<3)|0;if((j|0)>0){m=c[a+96>>2]|0;n=+g[a+36>>2];o=k;do{p=c[o>>2]|0;c[o+4>>2]=(~~(n*+g[m+(p<<3)+4>>2]+2048)>>>0<<20)+(~~(n*+g[m+(p<<3)>>2]*256+524288)>>>0);o=o+8|0}while(o>>>0<l>>>0);q=c[h>>2]|0}else q=j;Il(k,k+(q<<3)|0,e);e=c[a+400>>2]|0;c[f>>2]=0;c[f+4>>2]=0;q=f+8|0;c[q>>2]=0;k=f+12|0;c[k>>2]=e+76;if((c[a+8>>2]&32768|0)!=0?(c[e+102952>>2]|0)!=0:0)Rk(f,c[a+216>>2]|0,c[a+220>>2]|0,c[a+88>>2]|0);e=a+216|0;Ok(a,e);Qk(a,e);Sk(a,f);if(b){b=c[e>>2]|0;j=a+220|0;a=c[j>>2]|0;h=b+(a*24|
0)|0;a:do if((a|0)==0){r=b;s=12}else{l=b;while(1){if((c[l+20>>2]&2|0)!=0){r=l;s=12;break a}l=l+24|0;if((l|0)==(h|0)){t=h;u=b;break}}}while(0);if((s|0)==12)if((r|0)==(h|0)){t=h;u=b}else{b=r;s=r;b:while(1){r=s;do{a=r;r=r+24|0;if((r|0)==(h|0))break b}while((c[a+44>>2]&2|0)!=0);c[b+0>>2]=c[r+0>>2];c[b+4>>2]=c[r+4>>2];c[b+8>>2]=c[r+8>>2];c[b+12>>2]=c[r+12>>2];c[b+16>>2]=c[r+16>>2];c[b+20>>2]=c[r+20>>2];b=b+24|0;s=r}t=b;u=c[e>>2]|0}c[j>>2]=(t-u|0)/24|0}u=c[f>>2]|0;if((u|0)==0){i=d;return}_m(c[k>>2]|0,u);
c[f>>2]=0;c[q>>2]=0;i=d;return}function Hk(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0;f=i;i=i+48|0;h=f+40|0;j=f+12|0;k=f;l=(b|0)<(d|0);if(!l){i=f;return}m=c[a+88>>2]|0;n=b;o=0;do{o=c[m+(n<<2)>>2]|o;n=n+1|0}while((n|0)!=(d|0));if((o&1032|0)!=0){n=a+220|0;if((c[n>>2]|0)>0){m=a+216|0;p=a+88|0;q=a+144|0;r=a+252|0;s=a+256|0;t=a+248|0;
u=a+96|0;v=a+260|0;w=0;do{x=c[m>>2]|0;y=c[x+(w*24|0)>>2]|0;z=c[x+(w*24|0)+4>>2]|0;A=c[p>>2]|0;B=c[A+(y<<2)>>2]|0;C=c[A+(z<<2)>>2]|0;A=c[q>>2]|0;D=c[A+(y<<2)>>2]|0;E=c[A+(z<<2)>>2]|0;do if((z|0)<(d|0)&(((y|0)>=(d|0)|(y|0)<(b|0)|(z|0)<(b|0))^1)?(A=C|B,!((A&2|0)!=0|(A&1032|0)==0)):0){if(!(nb[c[(c[e>>2]|0)+8>>2]&31](e,y)|0)?!(nb[c[(c[e>>2]|0)+8>>2]&31](e,z)|0):0)break;if((B&28|0)==0){if((D|0)==0)break;if((c[D+12>>2]&2|0)==0)break}if((C&28|0)==0){if((E|0)==0)break;if((c[E+12>>2]&2|0)==0)break}if(hb[c[(c[e>>
2]|0)+12>>2]&15](e,y,z)|0){A=c[r>>2]|0;F=c[s>>2]|0;if((A|0)>=(F|0)?(G=(F|0)==0?256:F<<1,(F|0)<(G|0)):0){F=Em(c[v>>2]|0,G*20|0)|0;H=c[t>>2]|0;if((H|0)!=0){An(F|0,H|0,(c[r>>2]|0)*20|0)|0;Fm(c[v>>2]|0,c[t>>2]|0,(c[s>>2]|0)*20|0)}c[s>>2]=G;c[t>>2]=F;I=c[r>>2]|0}else I=A;c[r>>2]=I+1;A=c[t>>2]|0;c[A+(I*20|0)>>2]=y;c[A+(I*20|0)+4>>2]=z;c[A+(I*20|0)+8>>2]=c[x+(w*24|0)+20>>2];if((D|0)==0)J=1;else J=+g[D+16>>2];if((E|0)==0)K=1;else K=+g[E+16>>2];g[A+(I*20|0)+12>>2]=J<K?J:K;F=c[u>>2]|0;L=+g[F+(y<<3)>>2]-+g[F+
(z<<3)>>2];M=+g[F+(y<<3)+4>>2]-+g[F+(z<<3)+4>>2];g[A+(I*20|0)+16>>2]=+Q(+(L*L+M*M))}}while(0);w=w+1|0}while((w|0)<(c[n>>2]|0));N=r}else N=a+252|0;r=a+248|0;n=c[r>>2]|0;w=c[N>>2]|0;I=n+(w*20|0)|0;c[h>>2]=27;u=w*20|0;w=(u|0)/20|0;a:do if((u|0)>2560){t=w;while(1){s=rn(t*20|0,9632)|0;if((s|0)!=0){O=s;P=t;break a}if((t|0)>1)t=(t|0)/2|0;else{O=s;P=0;break}}}else{O=0;P=0}while(0);Pl(n,I,h,w,O,P);if((O|0)!=0)sn(O);O=c[r>>2]|0;P=c[N>>2]|0;w=O+(P*20|0)|0;b:do if((P|0)==0){R=O;S=40}else if((P|0)==1){T=w;U=O}else{I=
O;n=O+20|0;u=c[O>>2]|0;while(1){t=u;u=c[n>>2]|0;if((t|0)==(u|0)?(c[I+4>>2]|0)==(c[I+24>>2]|0):0){R=I;S=40;break b}t=n+20|0;if((t|0)==(w|0)){T=w;U=O;break}else{s=n;n=t;I=s}}}while(0);if((S|0)==40)if((R|0)==(w|0)){T=w;U=O}else{O=R;P=R+20|0;c:while(1){R=O+4|0;I=P;do{n=I;I=I+20|0;if((I|0)==(w|0))break c;if((c[O>>2]|0)!=(c[I>>2]|0))break}while((c[R>>2]|0)==(c[n+24>>2]|0));R=O+20|0;c[R+0>>2]=c[I+0>>2];c[R+4>>2]=c[I+4>>2];c[R+8>>2]=c[I+8>>2];c[R+12>>2]=c[I+12>>2];c[R+16>>2]=c[I+16>>2];O=R;P=I}T=O+20|0;U=
c[r>>2]|0}c[N>>2]=(T-U|0)/20|0}if((o&16|0)==0){i=f;return}hk(j,(c[a+400>>2]|0)+76|0,d-b|0);if(l){l=a+88|0;o=a+144|0;U=a+96|0;T=b;do{b=c[(c[l>>2]|0)+(T<<2)>>2]|0;do if((b&2|0)==0){N=c[(c[o>>2]|0)+(T<<2)>>2]|0;if((b&28|0)==0){if((N|0)==0)break;if((c[N+12>>2]&2|0)==0)break}N=c[U>>2]|0;jk(j,N+(T<<3)|0,T,nb[c[(c[e>>2]|0)+8>>2]&31](e,T)|0)}while(0);T=T+1|0}while((T|0)<(d|0))}K=+g[a+32>>2]*.75;kk(j,K*.5,K*2);c[k>>2]=7176;c[k+4>>2]=a;c[k+8>>2]=e;lk(j,k);k=a+264|0;e=c[k>>2]|0;d=a+268|0;a=c[d>>2]|0;T=e+(a*
60|0)|0;c[h>>2]=28;U=a*60|0;a=(U|0)/60|0;d:do if((U|0)>7680){o=a;while(1){l=rn(o*60|0,9632)|0;if((l|0)!=0){V=l;W=o;break d}if((o|0)>1)o=(o|0)/2|0;else{V=l;W=0;break}}}else{V=0;W=0}while(0);Ll(e,T,h,a,V,W);if((V|0)!=0)sn(V);V=c[k>>2]|0;W=c[d>>2]|0;a=V+(W*60|0)|0;e:do if((W|0)==0){X=V;S=69}else if((W|0)==1){Y=a;Z=V}else{h=V;T=V+60|0;e=c[V>>2]|0;while(1){U=e;e=c[T>>2]|0;if(((U|0)==(e|0)?(c[h+4>>2]|0)==(c[h+64>>2]|0):0)?(c[h+8>>2]|0)==(c[h+68>>2]|0):0){X=h;S=69;break e}U=T+60|0;if((U|0)==(a|0)){Y=a;Z=
V;break}else{o=T;T=U;h=o}}}while(0);if((S|0)==69)if((X|0)==(a|0)){Y=a;Z=V}else{V=X;S=X+60|0;f:while(1){X=V+4|0;W=V+8|0;h=S;do{T=h;h=h+60|0;if((h|0)==(a|0))break f;if((c[V>>2]|0)!=(c[h>>2]|0))break;if((c[X>>2]|0)!=(c[T+64>>2]|0))break}while((c[W>>2]|0)==(c[T+68>>2]|0));W=V+60|0;X=W+0|0;T=h+0|0;e=X+60|0;do{c[X>>2]=c[T>>2];X=X+4|0;T=T+4|0}while((X|0)<(e|0));V=W;S=h}Y=V+60|0;Z=c[k>>2]|0}c[d>>2]=(Y-Z|0)/60|0;ik(j);i=f;return}function Ik(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,
p=0,q=0,r=0,s=0,t=0,u=0,v=0;f=i;i=i+16|0;g=f;h=b+400|0;if((c[(c[h>>2]|0)+102876>>2]&2|0)!=0){i=f;return}j=e+4|0;k=e+8|0;zk(b,c[j>>2]|0,c[k>>2]|0,c[b+44>>2]|0);l=d+4|0;m=d+8|0;zk(b,c[l>>2]|0,c[m>>2]|0,c[j>>2]|0);n=c[j>>2]|0;c[g>>2]=7576;c[g+4>>2]=n;Gk(b,1);Hk(b,c[l>>2]|0,c[k>>2]|0,g);g=c[j>>2]|0;l=c[k>>2]|0;if((g|0)<(l|0)){n=b+144|0;o=g;do{c[(c[n>>2]|0)+(o<<2)>>2]=d;o=o+1|0}while((o|0)<(l|0))}l=d+12|0;d=c[l>>2]|0;o=c[e+12>>2]|d;n=(o^d)<<4&16|o;if((d&~n|0)!=0)a[b+20>>0]=1;d=b+16|0;g=c[d>>2]|0;if((n&
~g|0)!=0){if((o&1|0)==0)p=g;else{o=b+132|0;q=c[o>>2]|0;if((q|0)==0){r=b+48|0;s=c[r>>2]|0;if((s|0)==0){vk(b,256);t=c[r>>2]|0}else t=s;s=Em(c[h>>2]|0,t<<2)|0;xn(s|0,0,c[r>>2]<<2|0)|0;u=s;v=c[d>>2]|0}else{u=q;v=g}c[o>>2]=u;p=v}c[d>>2]=p|n}c[l>>2]=n;c[m>>2]=c[k>>2];c[j>>2]=c[k>>2];tk(b,e);i=f;return}function Jk(a){a=a|0;return}function Kk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=c[a>>2]|0;f=c[b>>2]|0;if((e|0)==(f|0)){g=(c[a+4>>2]|0)<(c[b+4>>2]|0);i=d;return g|0}else{g=(e-f|0)<0;i=d;return g|0}return 0}
function Lk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=c[a>>2]|0;f=c[b>>2]|0;if((e|0)!=(f|0)){g=(e-f|0)<0;i=d;return g|0}f=c[a+4>>2]|0;e=c[b+4>>2]|0;if((f|0)==(e|0)){g=(c[a+8>>2]|0)<(c[b+8>>2]|0);i=d;return g|0}else{g=(f-e|0)<0;i=d;return g|0}return 0}function Mk(b){b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0;d=i;e=b+400|0;f=b+220|0;h=Ym((c[e>>2]|0)+76|0,(c[f>>2]|0)*24|0)|0;j=c[f>>2]|
0;if((j|0)>0){k=b+216|0;l=b+144|0;m=j;j=0;n=0;while(1){o=c[k>>2]|0;p=o+(n*24|0)|0;q=c[l>>2]|0;r=c[q+(c[p>>2]<<2)>>2]|0;if(((r|0)!=0?(r|0)==(c[q+(c[o+(n*24|0)+4>>2]<<2)>>2]|0):0)?(c[r+12>>2]&16|0)!=0:0){r=j+1|0;o=h+(j*24|0)|0;c[o+0>>2]=c[p+0>>2];c[o+4>>2]=c[p+4>>2];c[o+8>>2]=c[p+8>>2];c[o+12>>2]=c[p+12>>2];c[o+16>>2]=c[p+16>>2];c[o+20>>2]=c[p+20>>2];s=c[f>>2]|0;t=r}else{s=m;t=j}n=n+1|0;if((n|0)>=(s|0)){u=t;break}else{m=s;j=t}}}else u=0;t=Ym((c[e>>2]|0)+76|0,c[b+308>>2]<<2)|0;j=c[b+312>>2]|0;if((j|
0)==0)v=0;else{s=b+16|0;m=b+124|0;n=b+132|0;f=b+48|0;l=b+20|0;k=j;j=0;while(1){r=k+12|0;p=c[r>>2]|0;if((p&16|0)!=0){o=j+1|0;c[t+(j<<2)>>2]=k;q=p&-17;if((((p|16)^-17)&p|0)!=0)a[l>>0]=1;w=c[s>>2]|0;if((q&~w|0)!=0){if((p&1|0)==0)x=w;else{p=c[n>>2]|0;if((p|0)==0){y=c[f>>2]|0;if((y|0)==0){vk(b,256);z=c[f>>2]|0}else z=y;y=Em(c[e>>2]|0,z<<2)|0;xn(y|0,0,c[f>>2]<<2|0)|0;A=y;B=c[s>>2]|0}else{A=p;B=w}c[n>>2]=A;x=B}c[s>>2]=x|q}c[r>>2]=q;q=c[k+4>>2]|0;r=c[k+8>>2]|0;if((q|0)<(r|0)){w=q+1|0;xn((c[m>>2]|0)+(q<<2)|
0,0,((r|0)>(w|0)?r:w)-q<<2|0)|0;C=o}else C=o}else C=j;k=c[k+24>>2]|0;if((k|0)==0){v=C;break}else j=C}}C=(u|0)>0;if(C){j=c[b+124>>2]|0;k=0;do{m=c[h+(k*24|0)+4>>2]|0;D=+g[h+(k*24|0)+8>>2];x=j+(c[h+(k*24|0)>>2]<<2)|0;g[x>>2]=D+ +g[x>>2];x=j+(m<<2)|0;g[x>>2]=D+ +g[x>>2];k=k+1|0}while((k|0)!=(u|0))}k=(v|0)>0;if(k){j=b+124|0;x=b+132|0;m=0;do{s=c[t+(m<<2)>>2]|0;B=c[s+4>>2]|0;A=c[s+8>>2]|0;if((B|0)<(A|0)){s=c[j>>2]|0;n=c[x>>2]|0;f=B;do{g[n+(f<<2)>>2]=+g[s+(f<<2)>>2]<.800000011920929?0:3.4028234663852886E38;
f=f+1|0}while((f|0)<(A|0))}m=m+1|0}while((m|0)!=(v|0))}m=~~+Q(+ +(c[b+44>>2]|0));if((m|0)>0?(x=b+132|0,C):0){C=0;do{j=c[x>>2]|0;A=0;f=0;while(1){D=1-+g[h+(A*24|0)+8>>2];s=j+(c[h+(A*24|0)>>2]<<2)|0;n=j+(c[h+(A*24|0)+4>>2]<<2)|0;E=+g[n>>2];F=D+E;G=+g[s>>2];H=D+G;if(G>F){g[s>>2]=F;I=+g[n>>2];J=1}else{I=E;J=f}if(I>H){g[n>>2]=H;K=1}else K=J;A=A+1|0;if((A|0)==(u|0))break;else f=K}C=C+1|0}while(K&(C|0)<(m|0))}if(!k){L=c[e>>2]|0;M=L+76|0;_m(M,t);N=c[e>>2]|0;O=N+76|0;_m(O,h);i=d;return}k=b+132|0;m=b+32|0;
b=0;do{C=c[t+(b<<2)>>2]|0;K=c[C+4>>2]|0;u=c[C+8>>2]|0;if((K|0)<(u|0)){C=c[k>>2]|0;J=K;do{K=C+(J<<2)|0;I=+g[K>>2];if(I<3.4028234663852886E38)P=I*+g[m>>2];else P=0;g[K>>2]=P;J=J+1|0}while((J|0)<(u|0))}b=b+1|0}while((b|0)!=(v|0));L=c[e>>2]|0;M=L+76|0;_m(M,t);N=c[e>>2]|0;O=N+76|0;_m(O,h);i=d;return}function Nk(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;e=i;f=+g[b+36>>2];h=(~~(f*+g[d+4>>2]+-1+2048)>>>0<<20)+(~~((f*+g[d>>2]+-1)*256+524288)>>>0)|0;j=~~(f*+g[d+12>>2]+1+2048)>>>0;k=~~((f*
+g[d+8>>2]+1)*256+524288)>>>0;d=c[b+200>>2]|0;l=c[b+204>>2]|0;b=d+(l<<3)|0;m=d;d=l<<3>>3;a:while(1){l=d;while(1){if((l|0)==0)break a;n=(l|0)/2|0;if((c[m+(n<<3)+4>>2]|0)>>>0<h>>>0)break;else l=n}m=m+(n+1<<3)|0;d=l+-1-n|0}n=(j<<20)+k|0;k=m;j=b-m>>3;b:while(1){b=j;while(1){if((b|0)==0)break b;o=(b|0)/2|0;if((c[k+(o<<3)+4>>2]|0)>>>0>n>>>0)b=o;else break}k=k+(o+1<<3)|0;j=b+-1-o|0}c[a>>2]=h&1048575;c[a+4>>2]=n&1048575;c[a+8>>2]=h&-1048576;c[a+12>>2]=n&-1048576;c[a+16>>2]=m;c[a+20>>2]=k;i=e;return}function Ok(a,
b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;d=i;e=c[a+200>>2]|0;f=c[a+204>>2]|0;g=e+(f<<3)|0;c[b+4>>2]=0;if((f|0)>0){h=e;j=e}else{i=d;return}while(1){e=h+4|0;f=(c[e>>2]|0)+256|0;k=h;h=h+8|0;l=h>>>0<g>>>0;a:do if(l){m=h;do{if(f>>>0<(c[m+4>>2]|0)>>>0)break a;Pk(a,c[k>>2]|0,c[m>>2]|0,b);m=m+8|0}while(m>>>0<g>>>0)}while(0);f=c[e>>2]|0;m=f+1048320|0;b:do if(j>>>0<g>>>0){n=j;while(1){o=n+8|0;if(!(m>>>0>(c[n+4>>2]|0)>>>0)){p=n;break b}if(o>>>0<g>>>0)n=o;else{p=o;break}}}else p=j;while(0);
m=f+1048832|0;c:do if(p>>>0<g>>>0){e=p;do{if(m>>>0<(c[e+4>>2]|0)>>>0)break c;Pk(a,c[k>>2]|0,c[e>>2]|0,b);e=e+8|0}while(e>>>0<g>>>0)}while(0);if(!l)break;else j=p}i=d;return}function Pk(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;f=i;h=c[a+96>>2]|0;j=+g[h+(d<<3)>>2]-+g[h+(b<<3)>>2];l=+g[h+(d<<3)+4>>2]-+g[h+(b<<3)+4>>2];m=j*j+l*l;if(!(m<+g[a+40>>2])){i=f;return}n=(c[k>>2]=1597463007-((g[k>>2]=m,c[k>>2]|0)>>1),+g[k>>2]);o=n*(1.5-n*m*.5*n);h=e+4|0;p=c[h>>
2]|0;q=e+8|0;r=c[q>>2]|0;if((p|0)>=(r|0)?(s=(r|0)==0?256:r<<1,(r|0)<(s|0)):0){r=e+12|0;t=Em(c[r>>2]|0,s*24|0)|0;u=c[e>>2]|0;if((u|0)!=0){An(t|0,u|0,(c[h>>2]|0)*24|0)|0;Fm(c[r>>2]|0,c[e>>2]|0,(c[q>>2]|0)*24|0)}c[q>>2]=s;c[e>>2]=t;v=c[h>>2]|0}else v=p;c[h>>2]=v+1;h=c[e>>2]|0;c[h+(v*24|0)>>2]=b;c[h+(v*24|0)+4>>2]=d;e=c[a+88>>2]|0;c[h+(v*24|0)+20>>2]=c[e+(d<<2)>>2]|c[e+(b<<2)>>2];g[h+(v*24|0)+8>>2]=1-m*o*+g[a+36>>2];m=+(j*o);j=+(l*o);a=h+(v*24|0)+12|0;g[a>>2]=m;g[a+4>>2]=j;i=f;return}function Qk(a,b){a=
a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;d=i;if((c[a+8>>2]&131072|0)==0){i=d;return}e=c[(c[a+400>>2]|0)+102948>>2]|0;if((e|0)==0){i=d;return}f=c[b>>2]|0;g=b+4|0;h=c[g>>2]|0;j=f+(h*24|0)|0;a:do if((h|0)==0){k=f;l=8}else{m=f;while(1){if((c[m+20>>2]&131072|0)!=0?!(lb[c[(c[e>>2]|0)+16>>2]&7](e,a,c[m>>2]|0,c[m+4>>2]|0)|0):0){k=m;l=8;break a}m=m+24|0;if((m|0)==(j|0)){n=j;break}}}while(0);b:do if((l|0)==8)if((k|0)==(j|0))n=j;else{f=k;h=k;while(1){m=h;do{o=m;m=m+24|0;if((m|0)==(j|0)){n=f;
break b}if((c[o+44>>2]&131072|0)==0)break}while(!(lb[c[(c[e>>2]|0)+16>>2]&7](e,a,c[m>>2]|0,c[o+28>>2]|0)|0));c[f+0>>2]=c[m+0>>2];c[f+4>>2]=c[m+4>>2];c[f+8>>2]=c[m+8>>2];c[f+12>>2]=c[m+12>>2];c[f+16>>2]=c[m+16>>2];c[f+20>>2]=c[m+20>>2];f=f+24|0;h=m}}while(0);c[g>>2]=(n-(c[b>>2]|0)|0)/24|0;i=d;return}function Rk(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;f=i;i=i+16|0;g=f;h=c[a>>2]|0;if((h|0)!=0){_m(c[a+12>>2]|0,h);c[a>>2]=0;c[a+8>>2]=0}if((d|0)==0)j=c[a+8>>2]|0;else{h=
Ym(c[a+12>>2]|0,d*9|0)|0;c[a>>2]=h;k=h+(d<<3)|0;c[a+4>>2]=k;xn(k|0,1,d|0)|0;c[a+8>>2]=d;j=d}if((j|0)==0){i=f;return}j=c[a>>2]|0;if((d|0)>0){k=0;h=0;while(1){l=c[b+(k*24|0)>>2]|0;if((!((l|0)==-1)?(m=b+(k*24|0)+4|0,n=c[m>>2]|0,!((n|0)==-1)):0)?((c[e+(n<<2)>>2]|c[e+(l<<2)>>2])&32768|0)!=0:0){c[j+(k<<3)>>2]=l;c[j+(k<<3)+4>>2]=c[m>>2];o=h+1|0}else o=h;k=k+1|0;if((k|0)==(d|0)){p=o;break}else h=o}}else p=0;c[a+8>>2]=p;c[g>>2]=29;Cl(j,j+(p<<3)|0,g);i=f;return}function Sk(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,
h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0;e=i;if((c[b+8>>2]&32768|0)==0){i=e;return}f=c[(c[b+400>>2]|0)+102952>>2]|0;if((f|0)==0){i=e;return}g=c[b+220>>2]|0;h=c[b+216>>2]|0;j=h+(g*24|0)|0;k=d+8|0;if((g|0)>0){g=d+4|0;l=h;while(1){h=c[l>>2]|0;m=c[l+4>>2]|0;n=c[k>>2]|0;do if((n|0)==0)o=24;else{p=c[d>>2]|0;q=p;r=p+(n<<3)-q>>3;s=(r|0)==0;a:do if(s)t=p;else{u=p;v=r;while(1){w=v;while(1){x=(w|0)/2|0;if((c[u+(x<<3)>>2]|0)<(h|0)?(c[u+(x<<3)+4>>2]|0)<(m|
0):0)break;if((w+1|0)>>>0<3){t=u;break a}else w=x}y=u+(x+1<<3)|0;z=w+-1|0;if((z|0)==(x|0)){t=y;break}else{u=y;v=z-x|0}}}while(0);if((t|0)!=0?(v=(t-q|0)>>>3,u=c[g>>2]|0,(a[u+v>>0]|0)!=0):0){A=u;B=v}else{b:do if(s)C=p;else{v=p;u=r;while(1){z=u;while(1){D=(z|0)/2|0;if((c[v+(D<<3)>>2]|0)<(m|0)?(c[v+(D<<3)+4>>2]|0)<(h|0):0)break;if((z+1|0)>>>0<3){C=v;break b}else z=D}w=v+(D+1<<3)|0;y=z+-1|0;if((y|0)==(D|0)){C=w;break}else{v=w;u=y-D|0}}}while(0);if((C|0)==0){o=24;break}r=(C-q|0)>>>3;p=c[g>>2]|0;if((a[p+
r>>0]|0)==0){o=24;break}else{A=p;B=r}}a[A+B>>0]=0}while(0);if((o|0)==24){o=0;ib[c[(c[f>>2]|0)+24>>2]&7](f,b,l)}l=l+24|0;if(!(l>>>0<j>>>0)){E=d;F=g;break}}}else{E=d;F=d+4|0}d=c[k>>2]|0;k=c[E>>2]|0;E=c[F>>2]|0;if((d|0)<=0){i=e;return}F=0;do{if((a[E+F>>0]|0)!=0)pb[c[(c[f>>2]|0)+28>>2]&31](f,b,c[k+(F<<3)>>2]|0,c[k+(F<<3)+4>>2]|0);F=F+1|0}while((F|0)!=(d|0));i=e;return}function Tk(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;d=i;e=a+156|0;if((c[e>>2]|0)<1){i=d;return}f=(c[a+176>>2]|
0)+(b<<2)|0;g=(c[a+160>>2]|0)+(b<<2)|0;h=(c[a+168>>2]|0)+(b<<2)|0;j=(c[h>>2]|0)+1|0;c[h>>2]=j;if((j|0)==2?(j=c[f>>2]|0,c[f>>2]=j+1,(j|0)>=(c[e>>2]|0)):0){e=a+184|0;j=a+188|0;f=c[j>>2]|0;h=a+192|0;k=c[h>>2]|0;if((f|0)>=(k|0)?(l=(k|0)==0?256:k<<1,(k|0)<(l|0)):0){k=a+196|0;m=Em(c[k>>2]|0,l<<2)|0;n=c[e>>2]|0;if((n|0)!=0){An(m|0,n|0,c[j>>2]<<2|0)|0;Fm(c[k>>2]|0,c[e>>2]|0,c[h>>2]<<2)}c[h>>2]=l;c[e>>2]=m;o=c[j>>2]|0}else o=f;c[j>>2]=o+1;c[(c[e>>2]|0)+(o<<2)>>2]=b}c[g>>2]=c[a+4>>2];i=d;return}function Uk(a,
b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;f=i;i=i+16|0;g=f;h=c[a>>2]|0;if((h|0)!=0){_m(c[a+12>>2]|0,h);c[a>>2]=0;c[a+8>>2]=0}if((d|0)==0)j=c[a+8>>2]|0;else{h=Ym(c[a+12>>2]|0,d*9|0)|0;c[a>>2]=h;k=h+(d<<3)|0;c[a+4>>2]=k;xn(k|0,1,d|0)|0;c[a+8>>2]=d;j=d}if((j|0)==0){i=f;return}j=c[a>>2]|0;if((d|0)>0){k=0;h=0;while(1){l=c[b+(k*28|0)>>2]|0;if(!((l|0)==-1)?(c[e+(l<<2)>>2]&16384|0)!=0:0){c[j+(k<<3)>>2]=c[b+(k*28|0)+8>>2];c[j+(k<<3)+4>>2]=l;m=h+1|0}else m=h;k=k+1|0;if((k|0)==(d|0)){n=
m;break}else h=m}}else n=0;c[a+8>>2]=n;c[g>>2]=30;Fl(j,j+(n<<3)|0,g);i=f;return}function Vk(a,b){a=a|0;b=b|0;var d=0,e=0;d=i;if(!((c[a>>2]|0)>>>0<(c[b>>2]|0)>>>0)){e=0;i=d;return e|0}e=(c[a+4>>2]|0)<(c[b+4>>2]|0);i=d;return e|0}function Wk(a,b){a=a|0;b=b|0;var d=0,e=0;d=i;if((c[a>>2]|0)>=(c[b>>2]|0)){e=0;i=d;return e|0}e=(c[a+4>>2]|0)<(c[b+4>>2]|0);i=d;return e|0}function Xk(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;e=i;if((c[b+
8>>2]&16384|0)==0){i=e;return}f=c[(c[b+400>>2]|0)+102952>>2]|0;if((f|0)==0){i=e;return}g=b+232|0;h=b+236|0;if((c[h>>2]|0)==0){j=d;k=d+8|0;l=d+4|0}else{m=d+8|0;n=d+4|0;o=c[g>>2]|0;while(1){p=c[o+8>>2]|0;q=c[o>>2]|0;r=c[m>>2]|0;if((r|0)!=0){s=c[d>>2]|0;t=s;u=s+(r<<3)-t>>3;a:do if((u|0)==0)v=s;else{r=s;w=u;while(1){x=w;while(1){y=(x|0)/2|0;if((c[r+(y<<3)>>2]|0)>>>0<p>>>0?(c[r+(y<<3)+4>>2]|0)<(q|0):0)break;if((x+1|0)>>>0<3){v=r;break a}else x=y}z=r+(y+1<<3)|0;A=x+-1|0;if((A|0)==(y|0)){v=z;break}else{r=
z;w=A-y|0}}}while(0);if((v|0)!=0?(q=(c[n>>2]|0)+((v-t|0)>>>3)|0,(a[q>>0]|0)!=0):0)a[q>>0]=0;else B=16}else B=16;if((B|0)==16){B=0;ib[c[(c[f>>2]|0)+16>>2]&7](f,b,o)}o=o+28|0;if((o|0)==((c[g>>2]|0)+((c[h>>2]|0)*28|0)|0)){j=d;k=m;l=n;break}}}n=c[j>>2]|0;j=c[l>>2]|0;l=c[k>>2]|0;if((l|0)<=0){i=e;return}k=0;do{if((a[j+k>>0]|0)!=0)pb[c[(c[f>>2]|0)+20>>2]&31](f,c[n+(k<<3)>>2]|0,b,c[n+(k<<3)+4>>2]|0);k=k+1|0}while((k|0)!=(l|0));i=e;return}function Yk(b){b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=
0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;d=i;i=i+48|0;e=d+32|0;f=d+16|0;h=d;j=b+400|0;k=c[j>>2]|0;c[e>>2]=0;c[e+4>>2]=0;l=e+8|0;c[l>>2]=0;m=e+12|0;c[m>>2]=k+76;n=b+8|0;if((c[n>>2]&16384|0)!=0?(c[k+102952>>2]|0)!=0:0)Uk(e,c[b+232>>2]|0,c[b+236>>2]|0,c[b+88>>2]|0);if((c[b+156>>2]|0)>0?(k=c[b+44>>2]|0,(k|0)>0):0){o=c[b+168>>2]|0;p=b+4|0;q=c[b+160>>2]|0;r=b+176|0;s=0;do{c[o+(s<<2)>>2]=0;if((c[p>>2]|0)>((c[q+(s<<2)>>2]|0)+1|0))c[(c[r>>2]|0)+(s<<2)>>2]=0;s=s+1|0}while((s|
0)!=(k|0))}c[b+236>>2]=0;c[b+188>>2]=0;if((c[n>>2]&65536|0)==0)t=0;else t=c[(c[j>>2]|0)+102948>>2]|0;c[f+4>>2]=b;c[f>>2]=7056;c[f+8>>2]=t;t=c[b+44>>2]|0;g[h>>2]=3.4028234663852886E38;n=h+4|0;g[n>>2]=3.4028234663852886E38;k=h+8|0;g[k>>2]=-3.4028234663852886E38;s=h+12|0;g[s>>2]=-3.4028234663852886E38;if((t|0)>0){r=c[b+96>>2]|0;u=3.4028234663852886E38;v=3.4028234663852886E38;w=-3.4028234663852886E38;x=-3.4028234663852886E38;q=0;while(1){p=r+(q<<3)|0;y=+g[p>>2];z=+g[p+4>>2];A=u<y?u:y;B=v<z?v:z;C=+A;D=
+B;p=h;g[p>>2]=C;g[p+4>>2]=D;D=w>y?w:y;y=x>z?x:z;z=+D;C=+y;p=k;g[p>>2]=z;g[p+4>>2]=C;q=q+1|0;if((q|0)==(t|0)){E=y;F=A;G=B;H=D;break}else{u=A;v=B;w=D;x=y}}}else{E=-3.4028234663852886E38;F=3.4028234663852886E38;G=3.4028234663852886E38;H=-3.4028234663852886E38}x=+g[b+32>>2];g[h>>2]=F-x;g[n>>2]=G-x;g[k>>2]=H+x;g[s>>2]=E+x;Dj(c[j>>2]|0,f,h);if((a[b+316>>0]|0)!=0)Zk(b);Xk(b,e);b=c[e>>2]|0;if((b|0)==0){i=d;return}_m(c[m>>2]|0,b);c[e>>2]=0;c[l>>2]=0;i=d;return}function Zk(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,
h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;b=i;i=i+32|0;d=b+20|0;e=b;f=b+16|0;g=a+232|0;h=c[g>>2]|0;j=a+236|0;k=h+((c[j>>2]|0)*28|0)|0;c[d>>2]=31;yl(h,k,d);c[f>>2]=0;d=c[g>>2]|0;g=c[j>>2]|0;k=d+(g*28|0)|0;c[e>>2]=a;c[e+4>>2]=-1;c[e+8>>2]=0;c[e+12>>2]=f;a:do if((g|0)==0)l=d;else{a=d;do{if(xl(e,a)|0){l=a;break a}a=a+28|0}while((a|0)!=(k|0));m=c[j>>2]|0;n=c[f>>2]|0;o=m-n|0;c[j>>2]=o;i=b;return}while(0);if((l|0)==(k|0)){m=c[j>>2]|0;n=c[f>>2]|0;o=m-n|0;c[j>>2]=o;i=b;return}else{p=l;q=l}b:while(1){l=q;do{l=l+
28|0;if((l|0)==(k|0))break b}while(xl(e,l)|0);c[p+0>>2]=c[l+0>>2];c[p+4>>2]=c[l+4>>2];c[p+8>>2]=c[l+8>>2];c[p+12>>2]=c[l+12>>2];c[p+16>>2]=c[l+16>>2];c[p+20>>2]=c[l+20>>2];c[p+24>>2]=c[l+24>>2];p=p+28|0;q=l}m=c[j>>2]|0;n=c[f>>2]|0;o=m-n|0;c[j>>2]=o;i=b;return}function _k(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;e=c[a>>2]|0;f=c[b>>2]|0;if((e|0)==(f|0)){h=+g[a+12>>2]>+g[b+12>>2];i=d;return h|0}else{h=(e|0)<(f|0);i=d;return h|0}return 0}function Jf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;vh(a,b);c[a>>
2]=1056;e=b+20|0;f=c[e+4>>2]|0;h=a+68|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;g[a+76>>2]=+g[b+28>>2];g[a+80>>2]=0;g[a+84>>2]=0;g[a+88>>2]=0;g[a+92>>2]=+g[b+32>>2];g[a+96>>2]=+g[b+36>>2];g[a+100>>2]=+g[b+40>>2];i=d;return}function Kf(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=
0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+104|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+108|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+128|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+136|0;c[o>>2]=r;c[o+4>>2]=s;o=b+156|0;g[o>>2]=+g[f+136>>2];t=b+160|0;g[t>>2]=+g[l+136>>2];u=b+164|0;g[u>>2]=+g[f+144>>2];f=b+168|0;g[f>>2]=+g[l+144>>2];l=c[d+28>>2]|0;v=l+(h*12|0)|0;w=+g[v>>2];x=+g[v+4>>2];y=+g[l+(h*
12|0)+8>>2];v=d+32|0;z=c[v>>2]|0;A=z+(h*12|0)|0;B=+g[A>>2];C=+g[A+4>>2];D=+g[z+(h*12|0)+8>>2];h=l+(m*12|0)|0;E=+g[h>>2];F=+g[h+4>>2];G=+g[l+(m*12|0)+8>>2];l=z+(m*12|0)|0;H=+g[l>>2];I=+g[l+4>>2];J=+g[z+(m*12|0)+8>>2];K=+T(+y);L=+S(+y);M=+T(+G);N=+S(+G);O=-(c[k>>2]=p,+g[k>>2]);P=-(c[k>>2]=q,+g[k>>2]);Q=L*O-K*P;R=K*O+L*P;P=+Q;O=+R;q=b+112|0;g[q>>2]=P;g[q+4>>2]=O;O=-(c[k>>2]=r,+g[k>>2]);P=-(c[k>>2]=s,+g[k>>2]);U=N*O-M*P;V=M*O+N*P;P=+U;N=+V;s=b+120|0;g[s>>2]=P;g[s+4>>2]=N;N=+g[o>>2];P=+g[t>>2];O=+g[u>>
2];M=+g[f>>2];W=N+P;X=W+R*O*R+V*M*V;Y=O*Q;Z=M*U;_=-(R*Y)-V*Z;$=W+Q*Y+U*Z;Z=X*$-_*_;if(Z!=0)aa=1/Z;else aa=Z;Z=-(_*aa);g[b+172>>2]=$*aa;g[b+176>>2]=Z;g[b+180>>2]=Z;g[b+184>>2]=X*aa;aa=O+M;if(aa>0)ba=1/aa;else ba=aa;g[b+188>>2]=ba;ba=+g[b+68>>2];aa=+g[b+72>>2];X=+(E+U-w-Q-(L*ba-K*aa));w=+(F+V-x-R-(K*ba+L*aa));f=b+144|0;g[f>>2]=X;g[f+4>>2]=w;g[b+152>>2]=G-y-+g[b+76>>2];f=b+80|0;if((a[d+24>>0]|0)==0){g[f>>2]=0;g[b+84>>2]=0;g[b+88>>2]=0;ca=B;da=C;ea=H;fa=I;ga=D;ha=J;ia=c[j>>2]|0;ja=c[v>>2]|0;ka=ja+(ia*
12|0)|0;la=+ca;ma=+da;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[j>>2]|0;sa=c[v>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=ga;ua=c[n>>2]|0;va=sa+(ua*12|0)|0;wa=+ea;xa=+fa;ya=va;za=ya;g[za>>2]=wa;Aa=ya+4|0;Ba=Aa;g[Ba>>2]=xa;Ca=c[n>>2]|0;Da=c[v>>2]|0;Ea=Da+(Ca*12|0)+8|0;g[Ea>>2]=ha;i=e;return}else{u=d+8|0;y=+g[u>>2];G=y*+g[f>>2];g[f>>2]=G;f=b+84|0;w=y*+g[f>>2];g[f>>2]=w;f=b+88|0;y=+g[u>>2]*+g[f>>2];g[f>>2]=y;ca=B-N*G;da=C-N*w;ea=H+P*G;fa=I+P*w;ga=D-O*(y+(w*Q-G*R));ha=J+M*(y+(w*U-G*V));ia=c[j>>
2]|0;ja=c[v>>2]|0;ka=ja+(ia*12|0)|0;la=+ca;ma=+da;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[j>>2]|0;sa=c[v>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=ga;ua=c[n>>2]|0;va=sa+(ua*12|0)|0;wa=+ea;xa=+fa;ya=va;za=ya;g[za>>2]=wa;Aa=ya+4|0;Ba=Aa;g[Ba>>2]=xa;Ca=c[n>>2]|0;Da=c[v>>2]|0;Ea=Da+(Ca*12|0)+8|0;g[Ea>>2]=ha;i=e;return}}function Lf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0;d=i;e=a+104|
0;f=c[e>>2]|0;h=b+32|0;j=c[h>>2]|0;k=j+(f*12|0)|0;l=+g[k>>2];m=+g[k+4>>2];n=+g[j+(f*12|0)+8>>2];f=a+108|0;k=c[f>>2]|0;o=j+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[j+(k*12|0)+8>>2];s=+g[a+156>>2];t=+g[a+160>>2];u=+g[a+164>>2];v=+g[a+168>>2];w=+g[b>>2];x=+g[b+4>>2]*+g[a+100>>2];b=a+88|0;y=+g[b>>2];z=w*+g[a+96>>2];A=y-+g[a+188>>2]*(r-n+x*+g[a+152>>2]);B=-z;C=A<z?A:z;z=C<B?B:C;g[b>>2]=z;C=z-y;y=n-u*C;n=r+v*C;C=+g[a+124>>2];r=+g[a+120>>2];z=+g[a+116>>2];B=+g[a+112>>2];A=+g[a+144>>2]*x+(z*y+(p-C*n-l));D=
x*+g[a+148>>2]+(q+r*n-m-B*y);x=+g[a+176>>2]*A+ +g[a+184>>2]*D;b=a+80|0;k=b;E=+g[k>>2];F=+g[k+4>>2];G=E-(+g[a+172>>2]*A+ +g[a+180>>2]*D);g[b>>2]=G;k=a+84|0;D=+g[k>>2]-x;g[k>>2]=D;x=w*+g[a+92>>2];w=G*G+D*D;if(w>x*x){A=+Q(+w);if(A<1.1920928955078125E-7){H=G;I=D}else{w=1/A;A=G*w;g[b>>2]=A;J=D*w;g[k>>2]=J;H=A;I=J}J=x*H;g[b>>2]=J;H=x*I;g[k>>2]=H;K=J;L=H}else{K=G;L=D}D=K-E;E=L-F;F=+(l-s*D);l=+(m-s*E);k=(c[h>>2]|0)+((c[e>>2]|0)*12|0)|0;g[k>>2]=F;g[k+4>>2]=l;k=c[h>>2]|0;g[k+((c[e>>2]|0)*12|0)+8>>2]=y-u*(B*
E-D*z);z=+(p+t*D);p=+(q+t*E);e=k+((c[f>>2]|0)*12|0)|0;g[e>>2]=z;g[e+4>>2]=p;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=n+v*(E*r-D*C);i=d;return}function Mf(a,b){a=a|0;b=b|0;return 1}function Nf(a,b){a=a|0;b=b|0;var d=0,e=0;d=(c[b+48>>2]|0)+12|0;b=c[d+4>>2]|0;e=a;c[e>>2]=c[d>>2];c[e+4>>2]=b;return}function Of(a,b){a=a|0;b=b|0;var d=0,e=0;d=(c[b+52>>2]|0)+12|0;b=c[d+4>>2]|0;e=a;c[e>>2]=c[d>>2];c[e+4>>2]=b;return}function Pf(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+84>>2]*c;g[a>>2]=+g[b+80>>2]*c;g[a+4>>2]=
d;return}function Qf(a,b){a=a|0;b=+b;return+(+g[a+88>>2]*b)}function Rf(a,d){a=a|0;d=d|0;var f=0,h=0,j=0,k=0,l=0;f=i;h=a+68|0;if(!(+g[d>>2]!=+g[h>>2])?!(+g[d+4>>2]!=+g[a+72>>2]):0){i=f;return}j=c[a+48>>2]|0;k=j+4|0;l=e[k>>1]|0;if((l&2|0)==0){b[k>>1]=l|2;g[j+160>>2]=0}j=c[a+52>>2]|0;a=j+4|0;l=e[a>>1]|0;if((l&2|0)==0){b[a>>1]=l|2;g[j+160>>2]=0}j=d;d=c[j+4>>2]|0;l=h;c[l>>2]=c[j>>2];c[l+4>>2]=d;i=f;return}function Sf(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0,l=0;f=i;h=a+76|0;if(!(+g[h>>2]!=d)){i=f;return}j=
c[a+48>>2]|0;k=j+4|0;l=e[k>>1]|0;if((l&2|0)==0){b[k>>1]=l|2;g[j+160>>2]=0}j=c[a+52>>2]|0;a=j+4|0;l=e[a>>1]|0;if((l&2|0)==0){b[a>>1]=l|2;g[j+160>>2]=0}g[h>>2]=d;i=f;return}function Tf(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(1104,e);c[e>>2]=f;Rm(1128,e);c[e>>2]=j;Rm(1160,e);c[e>>2]=d[a+61>>0]|0;Rm(1192,e);l=+g[a+72>>2];h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(1232,
e);h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1280,e);h[k>>3]=+g[a+92>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1312,e);h[k>>3]=+g[a+96>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1344,e);h[k>>3]=+g[a+100>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1376,e);c[e>>2]=c[a+56>>2];Rm(1416,e);i=b;return}function Uf(a,b){a=a|0;b=b|0;return}function Vf(a){a=a|0;return}function Wf(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Xf(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=
0,n=0,o=0,p=0;h=i;c[a+8>>2]=b;c[a+12>>2]=d;j=+g[e>>2]-+g[b+12>>2];k=e+4|0;l=+g[k>>2]-+g[b+16>>2];m=+g[b+24>>2];n=+g[b+20>>2];o=+(j*m+l*n);p=+(m*l-j*n);b=a+20|0;g[b>>2]=o;g[b+4>>2]=p;p=+g[f>>2]-+g[d+12>>2];b=f+4|0;o=+g[b>>2]-+g[d+16>>2];n=+g[d+24>>2];j=+g[d+20>>2];l=+(p*n+o*j);m=+(n*o-p*j);d=a+28|0;g[d>>2]=l;g[d+4>>2]=m;m=+g[f>>2]-+g[e>>2];l=+g[b>>2]-+g[k>>2];g[a+36>>2]=+Q(+(m*m+l*l));i=h;return}function Yf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;vh(a,b);c[a>>2]=1504;e=b+20|0;f=c[e+4>>2]|0;h=a+80|
0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+28|0;h=c[f+4>>2]|0;e=a+88|0;c[e>>2]=c[f>>2];c[e+4>>2]=h;g[a+104>>2]=+g[b+36>>2];g[a+68>>2]=+g[b+40>>2];g[a+72>>2]=+g[b+44>>2];g[a+100>>2]=0;g[a+96>>2]=0;g[a+76>>2]=0;i=d;return}function Zf(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=
0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+108|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+112|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+140|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+148|0;c[o>>2]=r;c[o+4>>2]=s;s=b+156|0;g[s>>2]=+g[f+136>>2];o=b+160|0;g[o>>2]=+g[l+136>>2];t=b+164|0;g[t>>2]=+g[f+144>>2];f=b+168|0;g[f>>2]=+g[l+144>>2];l=c[d+28>>2]|0;u=l+(h*12|0)|0;v=+g[u>>2];w=+g[u+4>>2];x=+g[l+(h*12|0)+8>>2];u=d+32|0;y=c[u>>2]|
0;z=y+(h*12|0)|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[y+(h*12|0)+8>>2];h=l+(m*12|0)|0;D=+g[h>>2];E=+g[h+4>>2];F=+g[l+(m*12|0)+8>>2];l=y+(m*12|0)|0;G=+g[l>>2];H=+g[l+4>>2];I=+g[y+(m*12|0)+8>>2];J=+T(+x);K=+S(+x);x=+T(+F);L=+S(+F);F=+g[b+80>>2]-(c[k>>2]=p,+g[k>>2]);M=+g[b+84>>2]-(c[k>>2]=q,+g[k>>2]);N=K*F-J*M;O=J*F+K*M;M=+N;K=+O;q=b+124|0;g[q>>2]=M;g[q+4>>2]=K;K=+g[b+88>>2]-(c[k>>2]=r,+g[k>>2]);M=+g[b+92>>2]-+g[b+152>>2];F=L*K-x*M;J=x*K+L*M;M=+F;L=+J;r=b+132|0;g[r>>2]=M;g[r+4>>2]=L;r=b+116|0;L=D+F-v-N;v=E+
J-w-O;w=+L;E=+v;q=r;g[q>>2]=w;g[q+4>>2]=E;E=+Q(+(L*L+v*v));if(E>.004999999888241291){w=1/E;D=L*w;g[r>>2]=D;P=w*v;R=D}else{g[r>>2]=0;P=0;R=0}g[b+120>>2]=P;D=P*N-O*R;v=P*F-R*J;w=+g[s>>2];L=+g[t>>2];M=+g[o>>2];K=+g[f>>2];x=M+(w+D*D*L)+v*v*K;if(x!=0)U=1/x;else U=0;f=b+172|0;g[f>>2]=U;v=+g[b+68>>2];if(v>0){D=E-+g[b+104>>2];E=v*6.2831854820251465;v=E*U*E;V=+g[d>>2];W=V*(E*U*2*+g[b+72>>2]+v*V);o=b+96|0;g[o>>2]=W;if(W!=0)X=1/W;else X=0;g[o>>2]=X;g[b+76>>2]=v*D*V*X;V=x+X;if(V!=0)Y=1/V;else Y=0;g[f>>2]=Y}else{g[b+
96>>2]=0;g[b+76>>2]=0}if((a[d+24>>0]|0)==0){g[b+100>>2]=0;Z=A;_=B;$=G;aa=H;ba=C;ca=I;da=c[j>>2]|0;ea=c[u>>2]|0;fa=ea+(da*12|0)|0;ga=+Z;ha=+_;ia=fa;ja=ia;g[ja>>2]=ga;ka=ia+4|0;la=ka;g[la>>2]=ha;ma=c[j>>2]|0;na=c[u>>2]|0;oa=na+(ma*12|0)+8|0;g[oa>>2]=ba;pa=c[n>>2]|0;qa=na+(pa*12|0)|0;ra=+$;sa=+aa;ta=qa;ua=ta;g[ua>>2]=ra;va=ta+4|0;wa=va;g[wa>>2]=sa;xa=c[n>>2]|0;ya=c[u>>2]|0;za=ya+(xa*12|0)+8|0;g[za>>2]=ca;i=e;return}else{f=b+100|0;Y=+g[d+8>>2]*+g[f>>2];g[f>>2]=Y;V=R*Y;R=Y*P;Z=A-V*w;_=B-R*w;$=G+V*M;aa=
H+R*M;ba=C-L*(R*N-V*O);ca=I+K*(R*F-V*J);da=c[j>>2]|0;ea=c[u>>2]|0;fa=ea+(da*12|0)|0;ga=+Z;ha=+_;ia=fa;ja=ia;g[ja>>2]=ga;ka=ia+4|0;la=ka;g[la>>2]=ha;ma=c[j>>2]|0;na=c[u>>2]|0;oa=na+(ma*12|0)+8|0;g[oa>>2]=ba;pa=c[n>>2]|0;qa=na+(pa*12|0)|0;ra=+$;sa=+aa;ta=qa;ua=ta;g[ua>>2]=ra;va=ta+4|0;wa=va;g[wa>>2]=sa;xa=c[n>>2]|0;ya=c[u>>2]|0;za=ya+(xa*12|0)+8|0;g[za>>2]=ca;i=e;return}}function _f(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;d=i;e=a+
108|0;f=c[e>>2]|0;h=b+32|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+112|0;k=c[f>>2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(k*12|0)+8>>2];s=+g[a+128>>2];t=+g[a+124>>2];u=+g[a+136>>2];v=+g[a+132>>2];w=+g[a+116>>2];x=+g[a+120>>2];k=a+100|0;y=+g[k>>2];z=+g[a+172>>2]*(+g[a+76>>2]+(w*(p-r*u-(l-n*s))+x*(q+r*v-(m+n*t)))+ +g[a+96>>2]*y);A=-z;g[k>>2]=y-z;z=w*A;w=x*A;A=+g[a+156>>2];x=n-+g[a+164>>2]*(t*w-z*s);s=+g[a+160>>2];t=r+ +g[a+168>>2]*(w*v-z*u);u=+(l-A*
z);l=+(m-A*w);a=j;g[a>>2]=u;g[a+4>>2]=l;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=x;x=+(p+z*s);z=+(q+w*s);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=x;g[e+4>>2]=z;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=t;i=d;return}function $f(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;d=i;if(+g[a+68>>2]>0){e=1;i=d;return e|0}f=a+108|0;h=c[f>>2]|0;j=b+28|0;b=c[j>>2]|0;k=b+(h*12|0)|0;l=k;m=+g[l>>2];n=+g[l+4>>2];o=+g[b+(h*12|0)+8>>2];h=a+112|0;l=
c[h>>2]|0;p=b+(l*12|0)|0;q=+g[p>>2];r=+g[p+4>>2];s=+g[b+(l*12|0)+8>>2];t=+T(+o);u=+S(+o);v=+T(+s);w=+S(+s);x=+g[a+80>>2]-+g[a+140>>2];y=+g[a+84>>2]-+g[a+144>>2];z=u*x-t*y;A=t*x+u*y;y=+g[a+88>>2]-+g[a+148>>2];u=+g[a+92>>2]-+g[a+152>>2];x=w*y-v*u;t=v*y+w*u;u=q+x-m-z;w=r+t-n-A;y=+Q(+(u*u+w*w));if(y<1.1920928955078125E-7){B=0;C=u;D=w}else{v=1/y;B=y;C=u*v;D=w*v}v=B-+g[a+104>>2];B=v<.20000000298023224?v:.20000000298023224;v=B<-.20000000298023224?-.20000000298023224:B;B=-(+g[a+172>>2]*v);w=C*B;C=D*B;B=+g[a+
156>>2];D=o-+g[a+164>>2]*(z*C-A*w);A=+g[a+160>>2];z=s+ +g[a+168>>2]*(x*C-t*w);t=+(m-B*w);m=+(n-B*C);a=k;g[a>>2]=t;g[a+4>>2]=m;a=c[j>>2]|0;g[a+((c[f>>2]|0)*12|0)+8>>2]=D;D=+(q+A*w);w=+(r+A*C);f=a+((c[h>>2]|0)*12|0)|0;g[f>>2]=D;g[f+4>>2]=w;g[(c[j>>2]|0)+((c[h>>2]|0)*12|0)+8>>2]=z;if(v>0)E=v;else E=-v;e=E<.004999999888241291;i=d;return e|0}function ag(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+80>>2];h=+g[d+20>>2];i=+g[b+84>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+
12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function bg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+88>>2];h=+g[d+20>>2];i=+g[b+92>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function cg(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+100>>2]*c;c=d*+g[b+120>>2];g[a>>2]=+g[b+116>>2]*d;g[a+4>>2]=c;return}function dg(a,b){a=a|0;b=+b;return 0}function eg(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+
8>>2]|0;Rm(1552,e);c[e>>2]=f;Rm(1584,e);c[e>>2]=j;Rm(1616,e);c[e>>2]=d[a+61>>0]|0;Rm(1648,e);l=+g[a+84>>2];h[k>>3]=+g[a+80>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(1688,e);l=+g[a+92>>2];h[k>>3]=+g[a+88>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(1736,e);h[k>>3]=+g[a+104>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1784,e);h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1808,e);h[k>>
3]=+g[a+72>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(1840,e);c[e>>2]=c[a+56>>2];Rm(1872,e);i=b;return}function fg(a){a=a|0;return}function gg(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function hg(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;f=i;c[a+8>>2]=b;c[a+12>>2]=d;h=+g[e>>2]-+g[b+12>>2];j=e+4|0;k=+g[j>>2]-+g[b+16>>2];l=+g[b+24>>2];m=+g[b+20>>2];n=+(h*l+k*m);o=+(l*k-h*m);b=a+20|0;g[b>>2]=n;g[b+4>>2]=o;o=+g[e>>2]-+g[d+12>>2];n=+g[j>>2]-+g[d+16>>2];m=+g[d+24>>2];h=+g[d+20>>
2];k=+(o*m+n*h);l=+(m*n-o*h);d=a+28|0;g[d>>2]=k;g[d+4>>2]=l;i=f;return}function ig(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;vh(a,b);c[a>>2]=1968;e=b+20|0;f=c[e+4>>2]|0;h=a+68|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+28|0;h=c[f+4>>2]|0;e=a+76|0;c[e>>2]=c[f>>2];c[e+4>>2]=h;g[a+84>>2]=0;g[a+88>>2]=0;g[a+92>>2]=0;g[a+96>>2]=+g[b+36>>2];g[a+100>>2]=+g[b+40>>2];i=d;return}function jg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=
0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+104|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+108|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+128|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+136|0;c[o>>2]=r;c[o+4>>2]=s;o=b+144|0;g[o>>2]=+g[f+136>>2];t=+g[l+136>>2];g[b+148>>2]=t;u=+g[f+144>>2];g[b+152>>2]=u;v=
+g[l+144>>2];g[b+156>>2]=v;l=c[d+28>>2]|0;w=+g[l+(h*12|0)+8>>2];f=d+32|0;x=c[f>>2]|0;y=x+(h*12|0)|0;z=+g[y>>2];A=+g[y+4>>2];B=+g[x+(h*12|0)+8>>2];C=+g[l+(m*12|0)+8>>2];l=x+(m*12|0)|0;D=+g[l>>2];E=+g[l+4>>2];F=+g[x+(m*12|0)+8>>2];G=+T(+w);H=+S(+w);w=+T(+C);I=+S(+C);C=+g[b+68>>2]-(c[k>>2]=p,+g[k>>2]);J=+g[b+72>>2]-(c[k>>2]=q,+g[k>>2]);K=H*C-G*J;L=G*C+H*J;J=+K;H=+L;q=b+112|0;g[q>>2]=J;g[q+4>>2]=H;H=+g[b+76>>2]-(c[k>>2]=r,+g[k>>2]);J=+g[b+80>>2]-(c[k>>2]=s,+g[k>>2]);C=I*H-w*J;G=w*H+I*J;J=+C;I=+G;s=b+
120|0;g[s>>2]=J;g[s+4>>2]=I;I=+g[o>>2];J=I+t;H=J+L*u*L+G*v*G;w=u*K;M=v*C;N=-(L*w)-G*M;O=J+K*w+C*M;M=H*O-N*N;if(M!=0)P=1/M;else P=M;M=-(N*P);g[b+160>>2]=O*P;g[b+164>>2]=M;g[b+168>>2]=M;g[b+172>>2]=H*P;P=u+v;if(P>0)Q=1/P;else Q=P;g[b+176>>2]=Q;o=b+84|0;if((a[d+24>>0]|0)==0){g[o>>2]=0;g[b+88>>2]=0;g[b+92>>2]=0;R=z;U=A;V=D;W=E;X=B;Y=F;Z=c[j>>2]|0;_=c[f>>2]|0;$=_+(Z*12|0)|0;aa=+R;ba=+U;ca=$;da=ca;g[da>>2]=aa;ea=ca+4|0;fa=ea;g[fa>>2]=ba;ga=c[j>>2]|0;ha=c[f>>2]|0;ia=ha+(ga*12|0)+8|0;g[ia>>2]=X;ja=c[n>>2]|
0;ka=ha+(ja*12|0)|0;la=+V;ma=+W;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[n>>2]|0;sa=c[f>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=Y;i=e;return}else{s=d+8|0;Q=+g[s>>2];P=Q*+g[o>>2];g[o>>2]=P;o=b+88|0;H=Q*+g[o>>2];g[o>>2]=H;o=b+92|0;Q=+g[s>>2]*+g[o>>2];g[o>>2]=Q;R=z-I*P;U=A-I*H;V=D+t*P;W=E+t*H;X=B-u*(Q+(H*K-P*L));Y=F+v*(Q+(H*C-P*G));Z=c[j>>2]|0;_=c[f>>2]|0;$=_+(Z*12|0)|0;aa=+R;ba=+U;ca=$;da=ca;g[da>>2]=aa;ea=ca+4|0;fa=ea;g[fa>>2]=ba;ga=c[j>>2]|0;ha=c[f>>2]|0;ia=ha+(ga*12|0)+8|0;g[ia>>2]=X;
ja=c[n>>2]|0;ka=ha+(ja*12|0)|0;la=+V;ma=+W;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[n>>2]|0;sa=c[f>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=Y;i=e;return}}function kg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0;d=i;e=a+104|0;f=c[e>>2]|0;h=b+32|0;j=c[h>>2]|0;k=j+(f*12|0)|0;l=+g[k>>2];m=+g[k+4>>2];n=+g[j+(f*12|0)+8>>2];f=a+108|0;k=c[f>>2]|0;o=j+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[j+
(k*12|0)+8>>2];s=+g[a+144>>2];t=+g[a+148>>2];u=+g[a+152>>2];v=+g[a+156>>2];w=+g[b>>2];b=a+92|0;x=+g[b>>2];y=w*+g[a+100>>2];z=x-(r-n)*+g[a+176>>2];A=-y;B=z<y?z:y;y=B<A?A:B;g[b>>2]=y;B=y-x;x=n-u*B;n=r+v*B;B=+g[a+124>>2];r=+g[a+120>>2];y=+g[a+116>>2];A=+g[a+112>>2];z=y*x+(p-B*n-l);C=q+r*n-m-A*x;D=+g[a+164>>2]*z+ +g[a+172>>2]*C;b=a+84|0;k=b;E=+g[k>>2];F=+g[k+4>>2];G=E-(+g[a+160>>2]*z+ +g[a+168>>2]*C);g[b>>2]=G;k=a+88|0;C=+g[k>>2]-D;g[k>>2]=C;D=w*+g[a+96>>2];w=G*G+C*C;if(w>D*D){z=+Q(+w);if(z<1.1920928955078125E-7){H=
G;I=C}else{w=1/z;z=G*w;g[b>>2]=z;J=C*w;g[k>>2]=J;H=z;I=J}J=D*H;g[b>>2]=J;H=D*I;g[k>>2]=H;K=J;L=H}else{K=G;L=C}C=K-E;E=L-F;F=+(l-s*C);l=+(m-s*E);k=(c[h>>2]|0)+((c[e>>2]|0)*12|0)|0;g[k>>2]=F;g[k+4>>2]=l;k=c[h>>2]|0;g[k+((c[e>>2]|0)*12|0)+8>>2]=x-u*(A*E-C*y);y=+(p+t*C);p=+(q+t*E);e=k+((c[f>>2]|0)*12|0)|0;g[e>>2]=y;g[e+4>>2]=p;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=n+v*(E*r-C*B);i=d;return}function lg(a,b){a=a|0;b=b|0;return 1}function mg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=
+g[d+24>>2];f=+g[b+68>>2];h=+g[d+20>>2];i=+g[b+72>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function ng(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+76>>2];h=+g[d+20>>2];i=+g[b+80>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function og(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+88>>2]*c;g[a>>2]=+g[b+84>>2]*c;g[a+4>>2]=d;return}function pg(a,b){a=a|0;b=+b;return+(+g[a+92>>2]*b)}function qg(a){a=a|0;var b=
0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(2016,e);c[e>>2]=f;Rm(2048,e);c[e>>2]=j;Rm(2080,e);c[e>>2]=d[a+61>>0]|0;Rm(2112,e);l=+g[a+72>>2];h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(2152,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(2200,e);h[k>>3]=+g[a+96>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(2248,
e);h[k>>3]=+g[a+100>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(2280,e);c[e>>2]=c[a+56>>2];Rm(2312,e);i=b;return}function rg(a){a=a|0;return}function sg(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function tg(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;f=i;c[a+8>>2]=b;c[a+12>>2]=d;h=+g[e>>2]-+g[b+12>>2];j=e+4|0;k=+g[j>>2]-+g[b+16>>2];l=+g[b+24>>2];m=+g[b+20>>2];n=+(h*l+k*m);o=+(l*k-h*m);p=a+20|0;g[p>>2]=n;g[p+4>>2]=o;o=+g[e>>2]-+g[d+12>>2];n=+g[j>>2]-+g[d+16>>2];m=+g[d+24>>2];
h=+g[d+20>>2];k=+(o*m+n*h);l=+(m*n-o*h);j=a+28|0;g[j>>2]=k;g[j+4>>2]=l;g[a+36>>2]=+g[d+72>>2]-+g[b+72>>2];i=f;return}function ug(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;vh(a,b);c[a>>2]=2408;e=b+20|0;f=c[e+4>>2]|0;h=a+80|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+28|0;h=c[f+4>>2]|0;e=a+88|0;c[e>>2]=c[f>>2];c[e+4>>2]=h;g[a+96>>2]=+g[b+36>>2];g[a+68>>2]=+g[b+40>>2];g[a+72>>2]=+g[b+44>>2];g[a+104>>2]=0;g[a+108>>2]=0;g[a+112>>2]=0;i=d;return}function vg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,
q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0;e=i;i=i+48|0;f=e;h=c[b+48>>2]|0;j=c[h+8>>2]|0;l=b+116|0;c[l>>2]=j;m=c[b+52>>2]|0;n=c[m+8>>2]|0;o=b+120|0;c[o>>2]=n;p=h+44|0;q=c[p>>2]|0;r=c[p+4>>2]|0;p=b+140|0;c[p>>2]=q;c[p+4>>2]=r;p=m+44|0;s=c[p>>2]|0;t=c[p+4>>2]|0;p=b+148|0;c[p>>2]=s;c[p+4>>2]=t;p=b+
156|0;g[p>>2]=+g[h+136>>2];u=+g[m+136>>2];g[b+160>>2]=u;v=+g[h+144>>2];g[b+164>>2]=v;w=+g[m+144>>2];g[b+168>>2]=w;m=c[d+28>>2]|0;x=+g[m+(j*12|0)+8>>2];h=d+32|0;y=c[h>>2]|0;z=y+(j*12|0)|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[y+(j*12|0)+8>>2];D=+g[m+(n*12|0)+8>>2];m=y+(n*12|0)|0;E=+g[m>>2];F=+g[m+4>>2];G=+g[y+(n*12|0)+8>>2];H=+T(+x);I=+S(+x);J=+T(+D);K=+S(+D);n=b+124|0;L=+g[b+80>>2]-(c[k>>2]=q,+g[k>>2]);M=+g[b+84>>2]-(c[k>>2]=r,+g[k>>2]);N=I*L-H*M;O=H*L+I*M;M=+N;I=+O;r=n;g[r>>2]=M;g[r+4>>2]=I;r=b+132|0;I=+g[b+
88>>2]-(c[k>>2]=s,+g[k>>2]);M=+g[b+92>>2]-(c[k>>2]=t,+g[k>>2]);L=K*I-J*M;H=J*I+K*M;M=+L;K=+H;t=r;g[t>>2]=M;g[t+4>>2]=K;K=+g[p>>2];M=K+u;p=b+128|0;t=b+136|0;g[f>>2]=M+v*O*O+w*H*H;I=-(v*O*N)-w*H*L;g[f+12>>2]=I;J=-(v*O)-w*H;g[f+24>>2]=J;g[f+4>>2]=I;g[f+16>>2]=M+v*N*N+w*L*L;M=v*N+w*L;g[f+28>>2]=M;g[f+8>>2]=J;g[f+20>>2]=M;M=v+w;g[f+32>>2]=M;s=b+68|0;q=b+172|0;if(+g[s>>2]>0){Im(f,q);if(M>0)P=1/M;else P=0;J=D-x-+g[b+96>>2];x=+g[s>>2]*6.2831854820251465;D=x*P*x;L=+g[d>>2];N=L*(x*P*2*+g[b+72>>2]+L*D);s=b+
100|0;g[s>>2]=N;if(N!=0)Q=1/N;else Q=0;g[s>>2]=Q;g[b+76>>2]=J*L*D*Q;D=M+Q;if(D!=0)R=1/D;else R=0;g[b+204>>2]=R}else{Jm(f,q);g[b+100>>2]=0;g[b+76>>2]=0}q=b+104|0;if((a[d+24>>0]|0)==0){g[q>>2]=0;g[b+108>>2]=0;g[b+112>>2]=0;U=A;V=B;W=E;X=F;Y=C;Z=G;_=c[l>>2]|0;$=c[h>>2]|0;aa=$+(_*12|0)|0;ba=+U;ca=+V;da=aa;ea=da;g[ea>>2]=ba;fa=da+4|0;ga=fa;g[ga>>2]=ca;ha=c[l>>2]|0;ia=c[h>>2]|0;ja=ia+(ha*12|0)+8|0;g[ja>>2]=Y;ka=c[o>>2]|0;la=ia+(ka*12|0)|0;ma=+W;na=+X;oa=la;pa=oa;g[pa>>2]=ma;qa=oa+4|0;ra=qa;g[ra>>2]=na;
sa=c[o>>2]|0;ta=c[h>>2]|0;ua=ta+(sa*12|0)+8|0;g[ua>>2]=Z;i=e;return}else{R=+g[d+8>>2];D=R*+g[q>>2];g[q>>2]=D;q=b+108|0;Q=R*+g[q>>2];g[q>>2]=Q;q=b+112|0;M=R*+g[q>>2];g[q>>2]=M;U=A-K*D;V=B-K*Q;W=E+u*D;X=F+u*Q;Y=C-v*(M+(Q*+g[n>>2]-D*+g[p>>2]));Z=G+w*(M+(Q*+g[r>>2]-D*+g[t>>2]));_=c[l>>2]|0;$=c[h>>2]|0;aa=$+(_*12|0)|0;ba=+U;ca=+V;da=aa;ea=da;g[ea>>2]=ba;fa=da+4|0;ga=fa;g[ga>>2]=ca;ha=c[l>>2]|0;ia=c[h>>2]|0;ja=ia+(ha*12|0)+8|0;g[ja>>2]=Y;ka=c[o>>2]|0;la=ia+(ka*12|0)|0;ma=+W;na=+X;oa=la;pa=oa;g[pa>>2]=ma;
qa=oa+4|0;ra=qa;g[ra>>2]=na;sa=c[o>>2]|0;ta=c[h>>2]|0;ua=ta+(sa*12|0)+8|0;g[ua>>2]=Z;i=e;return}}function wg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0;d=i;e=a+116|0;f=c[e>>2]|0;h=b+32|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+120|0;k=c[f>>
2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(k*12|0)+8>>2];s=+g[a+156>>2];t=+g[a+160>>2];u=+g[a+164>>2];v=+g[a+168>>2];if(+g[a+68>>2]>0){k=a+112|0;w=+g[k>>2];x=+g[a+204>>2]*(r-n+ +g[a+76>>2]+ +g[a+100>>2]*w);y=-x;g[k>>2]=w-x;x=n-u*y;w=r+v*y;y=+g[a+136>>2];z=+g[a+132>>2];A=+g[a+128>>2];B=+g[a+124>>2];C=A*x+(p-y*w-l);D=q+z*w-m-B*x;E=+g[a+172>>2]*C+ +g[a+184>>2]*D;F=+g[a+176>>2]*C+ +g[a+188>>2]*D;D=-E;C=-F;k=a+104|0;g[k>>2]=+g[k>>2]-E;k=a+108|0;g[k>>2]=+g[k>>2]-F;G=C;H=D;I=x-u*(B*C-A*D);J=w+v*
(z*C-y*D);K=t*H;L=t*G;M=s*H;N=s*G;O=p+K;P=q+L;Q=l-M;R=m-N;S=+Q;T=+R;U=j;V=U;g[V>>2]=S;W=U+4|0;X=W;g[X>>2]=T;Y=c[e>>2]|0;Z=c[h>>2]|0;_=Z+(Y*12|0)+8|0;g[_>>2]=I;$=c[f>>2]|0;aa=Z+($*12|0)|0;ba=+O;ca=+P;da=aa;ea=da;g[ea>>2]=ba;fa=da+4|0;ga=fa;g[ga>>2]=ca;ha=c[f>>2]|0;ia=c[h>>2]|0;ja=ia+(ha*12|0)+8|0;g[ja>>2]=J;i=d;return}else{D=+g[a+136>>2];y=+g[a+132>>2];C=+g[a+128>>2];z=+g[a+124>>2];w=p-r*D-l+n*C;A=q+r*y-m-n*z;B=r-n;x=w*+g[a+172>>2]+A*+g[a+184>>2]+B*+g[a+196>>2];F=w*+g[a+176>>2]+A*+g[a+188>>2]+B*+g[a+
200>>2];E=w*+g[a+180>>2]+A*+g[a+192>>2]+B*+g[a+204>>2];B=-x;A=-F;k=a+104|0;g[k>>2]=+g[k>>2]-x;k=a+108|0;g[k>>2]=+g[k>>2]-F;k=a+112|0;g[k>>2]=+g[k>>2]-E;G=A;H=B;I=n-u*(z*A-C*B-E);J=r+v*(y*A-D*B-E);K=t*H;L=t*G;M=s*H;N=s*G;O=p+K;P=q+L;Q=l-M;R=m-N;S=+Q;T=+R;U=j;V=U;g[V>>2]=S;W=U+4|0;X=W;g[X>>2]=T;Y=c[e>>2]|0;Z=c[h>>2]|0;_=Z+(Y*12|0)+8|0;g[_>>2]=I;$=c[f>>2]|0;aa=Z+($*12|0)|0;ba=+O;ca=+P;da=aa;ea=da;g[ea>>2]=ba;fa=da+4|0;ga=fa;g[ga>>2]=ca;ha=c[f>>2]|0;ia=c[h>>2]|0;ja=ia+(ha*12|0)+8|0;g[ja>>2]=J;i=d;return}}
function xg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0;d=i;i=i+80|0;e=d+40|0;f=d+32|0;h=d+24|0;j=d+12|0;k=d;l=a+116|0;m=c[l>>2]|0;n=b+28|0;b=c[n>>2]|0;o=b+(m*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(m*12|0)+8>>2];m=a+120|0;o=c[m>>2]|0;s=b+(o*12|0)|0;t=+g[s>>2];u=+g[s+4>>2];v=+g[b+(o*12|0)+8>>2];w=+T(+r);x=+S(+r);y=+T(+v);z=+S(+v);A=+g[a+156>>2];B=+g[a+160>>2];C=+g[a+164>>
2];D=+g[a+168>>2];E=+g[a+80>>2]-+g[a+140>>2];F=+g[a+84>>2]-+g[a+144>>2];G=x*E-w*F;H=w*E+x*F;F=+g[a+88>>2]-+g[a+148>>2];x=+g[a+92>>2]-+g[a+152>>2];E=z*F-y*x;w=y*F+z*x;x=A+B;g[e>>2]=x+C*H*H+D*w*w;z=-(C*H*G)-D*w*E;g[e+12>>2]=z;F=-(C*H)-D*w;g[e+24>>2]=F;g[e+4>>2]=z;g[e+16>>2]=x+C*G*G+D*E*E;x=C*G+D*E;g[e+28>>2]=x;g[e+8>>2]=F;g[e+20>>2]=x;g[e+32>>2]=C+D;x=t+E-p-G;F=u+w-q-H;if(+g[a+68>>2]>0){g[f>>2]=x;g[f+4>>2]=F;z=+Q(+(F*F+x*x));Hm(h,e,f);y=-+g[h>>2];I=-+g[h+4>>2];J=I;K=y;L=E*I-w*y;M=G*I-H*y;N=0;O=z}else{z=
v-r-+g[a+96>>2];y=+Q(+(x*x+F*F));if(z>0)P=z;else P=-z;g[j>>2]=x;g[j+4>>2]=F;g[j+8>>2]=z;Gm(k,e,j);z=-+g[k>>2];F=-+g[k+4>>2];x=+g[k+8>>2];J=F;K=z;L=E*F-w*z-x;M=G*F-H*z-x;N=P;O=y}y=+(p-A*K);p=+(q-A*J);k=(c[n>>2]|0)+((c[l>>2]|0)*12|0)|0;g[k>>2]=y;g[k+4>>2]=p;k=c[n>>2]|0;g[k+((c[l>>2]|0)*12|0)+8>>2]=r-C*M;M=+(t+B*K);K=+(u+B*J);l=k+((c[m>>2]|0)*12|0)|0;g[l>>2]=M;g[l+4>>2]=K;g[(c[n>>2]|0)+((c[m>>2]|0)*12|0)+8>>2]=v+D*L;if(!(O<=.004999999888241291)){R=0;i=d;return R|0}R=N<=.03490658849477768;i=d;return R|
0}function yg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+80>>2];h=+g[d+20>>2];i=+g[b+84>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function zg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+88>>2];h=+g[d+20>>2];i=+g[b+92>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Ag(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+108>>2]*c;g[a>>2]=+g[b+104>>2]*c;g[a+4>>2]=d;return}
function Bg(a,b){a=a|0;b=+b;return+(+g[a+112>>2]*b)}function Cg(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(2456,e);c[e>>2]=f;Rm(2480,e);c[e>>2]=j;Rm(2512,e);c[e>>2]=d[a+61>>0]|0;Rm(2544,e);l=+g[a+84>>2];h[k>>3]=+g[a+80>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(2584,e);l=+g[a+92>>2];h[k>>3]=+g[a+88>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=
c[k+4>>2];Rm(2632,e);h[k>>3]=+g[a+96>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(2680,e);h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(2712,e);h[k>>3]=+g[a+72>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(2744,e);c[e>>2]=c[a+56>>2];Rm(2776,e);i=b;return}function Dg(a){a=a|0;return}function Eg(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Fg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,
M=0,N=0,O=0,P=0,Q=0,R=0;d=i;vh(a,b);c[a>>2]=2864;e=a+92|0;f=a+100|0;h=a+108|0;j=a+116|0;l=a+124|0;m=a+132|0;n=b+20|0;o=c[n>>2]|0;c[a+68>>2]=o;p=b+24|0;q=c[p>>2]|0;c[a+72>>2]=q;r=c[o+4>>2]|0;c[a+76>>2]=r;s=c[q+4>>2]|0;c[a+80>>2]=s;t=c[o+48>>2]|0;c[a+84>>2]=t;u=c[o+52>>2]|0;c[a+48>>2]=u;v=+g[u+20>>2];w=+g[u+24>>2];x=+g[t+20>>2];y=+g[t+24>>2];o=c[n>>2]|0;if((r|0)==1){z=+g[u+72>>2];A=+g[t+72>>2];r=o+68|0;n=c[r+4>>2]|0;B=h;c[B>>2]=c[r>>2];c[B+4>>2]=n;n=o+76|0;B=c[n+4>>2]|0;r=e;c[r>>2]=c[n>>2];c[r+4>>2]=
B;C=+g[o+116>>2];g[a+140>>2]=C;g[l>>2]=0;g[a+128>>2]=0;D=z-A-C}else{C=+g[t+16>>2];A=+g[t+12>>2];z=+g[u+16>>2];E=+g[u+12>>2];u=o+68|0;t=c[u>>2]|0;B=c[u+4>>2]|0;u=h;c[u>>2]=t;c[u+4>>2]=B;u=o+76|0;h=c[u>>2]|0;r=c[u+4>>2]|0;u=e;c[u>>2]=h;c[u+4>>2]=r;g[a+140>>2]=+g[o+100>>2];u=o+84|0;o=c[u>>2]|0;e=c[u+4>>2]|0;u=l;c[u>>2]=o;c[u+4>>2]=e;F=(c[k>>2]=t,+g[k>>2]);G=(c[k>>2]=B,+g[k>>2]);H=(c[k>>2]=h,+g[k>>2]);I=(c[k>>2]=r,+g[k>>2]);J=E-A+(w*H-v*I);A=z-C+(v*H+w*I);I=(c[k>>2]=o,+g[k>>2])*(y*J+x*A-F);D=I+(c[k>>
2]=e,+g[k>>2])*(y*A-x*J-G)}e=c[q+48>>2]|0;c[a+88>>2]=e;o=c[q+52>>2]|0;c[a+52>>2]=o;G=+g[o+20>>2];J=+g[o+24>>2];x=+g[e+20>>2];A=+g[e+24>>2];q=c[p>>2]|0;if((s|0)==1){y=+g[o+72>>2];I=+g[e+72>>2];s=q+68|0;p=c[s+4>>2]|0;r=j;c[r>>2]=c[s>>2];c[r+4>>2]=p;p=q+76|0;r=c[p+4>>2]|0;s=f;c[s>>2]=c[p>>2];c[s+4>>2]=r;F=+g[q+116>>2];g[a+144>>2]=F;g[m>>2]=0;g[a+136>>2]=0;K=y-I-F;L=b+28|0;M=+g[L>>2];N=a+152|0;g[N>>2]=M;O=K*M;P=D+O;Q=a+148|0;g[Q>>2]=P;R=a+156|0;g[R>>2]=0;i=d;return}else{F=+g[e+16>>2];I=+g[e+12>>2];y=
+g[o+16>>2];w=+g[o+12>>2];o=q+68|0;e=c[o>>2]|0;r=c[o+4>>2]|0;o=j;c[o>>2]=e;c[o+4>>2]=r;o=q+76|0;j=c[o>>2]|0;s=c[o+4>>2]|0;o=f;c[o>>2]=j;c[o+4>>2]=s;g[a+144>>2]=+g[q+100>>2];o=q+84|0;q=c[o>>2]|0;f=c[o+4>>2]|0;o=m;c[o>>2]=q;c[o+4>>2]=f;H=(c[k>>2]=e,+g[k>>2]);v=(c[k>>2]=r,+g[k>>2]);C=(c[k>>2]=j,+g[k>>2]);z=(c[k>>2]=s,+g[k>>2]);E=w-I+(J*C-G*z);I=y-F+(G*C+J*z);z=(c[k>>2]=q,+g[k>>2])*(A*E+x*I-H);K=z+(c[k>>2]=f,+g[k>>2])*(A*I-x*E-v);L=b+28|0;M=+g[L>>2];N=a+152|0;g[N>>2]=M;O=K*M;P=D+O;Q=a+148|0;g[Q>>2]=P;
R=a+156|0;g[R>>2]=0;i=d;return}}function Gg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0,Pa=0,Qa=0,Ra=0,Sa=0,Ta=0,Ua=0,Va=0,Wa=0,Xa=0,Ya=0,Za=
0,_a=0,$a=0,ab=0,bb=0,cb=0,db=0,eb=0,fb=0,gb=0,hb=0,ib=0,jb=0,kb=0,lb=0,mb=0,nb=0,ob=0,pb=0,qb=0,rb=0,sb=0,tb=0,ub=0,vb=0,wb=0,xb=0,yb=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+160|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+164|0;c[n>>2]=m;o=c[b+84>>2]|0;p=c[o+8>>2]|0;q=b+168|0;c[q>>2]=p;r=c[b+88>>2]|0;s=c[r+8>>2]|0;t=b+172|0;c[t>>2]=s;u=b+176|0;v=f+44|0;w=c[v+4>>2]|0;x=u;c[x>>2]=c[v>>2];c[x+4>>2]=w;w=b+184|0;x=l+44|0;v=c[x+4>>2]|0;y=w;c[y>>2]=c[x>>2];c[y+4>>2]=v;v=b+192|0;y=o+44|0;x=c[y+4>>2]|0;z=
v;c[z>>2]=c[y>>2];c[z+4>>2]=x;x=r+44|0;z=c[x>>2]|0;y=c[x+4>>2]|0;x=b+200|0;c[x>>2]=z;c[x+4>>2]=y;A=+g[f+136>>2];g[b+208>>2]=A;B=+g[l+136>>2];g[b+212>>2]=B;C=+g[o+136>>2];g[b+216>>2]=C;D=+g[r+136>>2];g[b+220>>2]=D;E=+g[f+144>>2];g[b+224>>2]=E;F=+g[l+144>>2];g[b+228>>2]=F;G=+g[o+144>>2];g[b+232>>2]=G;H=+g[r+144>>2];g[b+236>>2]=H;r=c[d+28>>2]|0;I=+g[r+(h*12|0)+8>>2];o=d+32|0;l=c[o>>2]|0;f=l+(h*12|0)|0;J=+g[f>>2];K=+g[f+4>>2];L=+g[l+(h*12|0)+8>>2];M=+g[r+(m*12|0)+8>>2];h=l+(m*12|0)|0;N=+g[h>>2];O=+g[h+
4>>2];P=+g[l+(m*12|0)+8>>2];Q=+g[r+(p*12|0)+8>>2];m=l+(p*12|0)|0;R=+g[m>>2];U=+g[m+4>>2];V=+g[l+(p*12|0)+8>>2];W=+g[r+(s*12|0)+8>>2];r=l+(s*12|0)|0;X=+g[r>>2];Y=+g[r+4>>2];Z=+g[l+(s*12|0)+8>>2];_=+T(+I);$=+S(+I);I=+T(+M);aa=+S(+M);M=+T(+Q);ba=+S(+Q);Q=+T(+W);ca=+S(+W);s=b+272|0;g[s>>2]=0;W=(c[k>>2]=z,+g[k>>2]);if((c[b+76>>2]|0)==1){g[b+240>>2]=0;g[b+244>>2]=0;g[b+256>>2]=1;g[b+264>>2]=1;da=E+G;ea=0;fa=0;ga=1;ha=1}else{ia=+g[b+124>>2];ja=+g[b+128>>2];ka=ba*ia-M*ja;la=M*ia+ba*ja;ja=+g[b+108>>2]-+g[v>>
2];ia=+g[b+112>>2]-+g[b+196>>2];ma=+g[b+92>>2]-+g[u>>2];na=+g[b+96>>2]-+g[b+180>>2];oa=+ka;pa=+la;u=b+240|0;g[u>>2]=oa;g[u+4>>2]=pa;pa=la*(ba*ja-M*ia)-ka*(M*ja+ba*ia);g[b+264>>2]=pa;ia=la*($*ma-_*na)-ka*(_*ma+$*na);g[b+256>>2]=ia;da=C+A+pa*G*pa+ia*E*ia;ea=ka;fa=la;ga=ia;ha=pa}pa=da+0;g[s>>2]=pa;if((c[b+80>>2]|0)==1){g[b+248>>2]=0;g[b+252>>2]=0;da=+g[b+152>>2];g[b+260>>2]=da;g[b+268>>2]=da;qa=da*da*(F+H);ra=0;sa=0;ta=da;ua=da}else{da=+g[b+132>>2];ia=+g[b+136>>2];la=ca*da-Q*ia;ka=Q*da+ca*ia;ia=+g[b+
116>>2]-W;W=+g[b+120>>2]-+g[b+204>>2];da=+g[b+100>>2]-+g[w>>2];na=+g[b+104>>2]-+g[b+188>>2];$=+g[b+152>>2];ma=la*$;_=ka*$;ba=+ma;ja=+_;w=b+248|0;g[w>>2]=ba;g[w+4>>2]=ja;ja=(ka*(ca*ia-Q*W)-la*(Q*ia+ca*W))*$;g[b+268>>2]=ja;W=$*(ka*(aa*da-I*na)-la*(I*da+aa*na));g[b+260>>2]=W;qa=$*$*(D+B)+ja*H*ja+W*W*F;ra=ma;sa=_;ta=W;ua=ja}ja=pa+qa;g[s>>2]=ja;if(ja>0)va=1/ja;else va=0;g[s>>2]=va;s=b+156|0;if((a[d+24>>0]|0)==0){g[s>>2]=0;wa=J;xa=K;ya=N;za=O;Aa=R;Ba=U;Ca=X;Da=Y;Ea=L;Fa=P;Ga=V;Ha=Z;Ia=c[j>>2]|0;Ja=c[o>>
2]|0;Ka=Ja+(Ia*12|0)|0;La=+wa;Ma=+xa;Na=Ka;Oa=Na;g[Oa>>2]=La;Pa=Na+4|0;Qa=Pa;g[Qa>>2]=Ma;Ra=c[j>>2]|0;Sa=c[o>>2]|0;Ta=Sa+(Ra*12|0)+8|0;g[Ta>>2]=Ea;Ua=c[n>>2]|0;Va=Sa+(Ua*12|0)|0;Wa=+ya;Xa=+za;Ya=Va;Za=Ya;g[Za>>2]=Wa;_a=Ya+4|0;$a=_a;g[$a>>2]=Xa;ab=c[n>>2]|0;bb=c[o>>2]|0;cb=bb+(ab*12|0)+8|0;g[cb>>2]=Fa;db=c[q>>2]|0;eb=bb+(db*12|0)|0;fb=+Aa;gb=+Ba;hb=eb;ib=hb;g[ib>>2]=fb;jb=hb+4|0;kb=jb;g[kb>>2]=gb;lb=c[q>>2]|0;mb=c[o>>2]|0;nb=mb+(lb*12|0)+8|0;g[nb>>2]=Ga;ob=c[t>>2]|0;pb=mb+(ob*12|0)|0;qb=+Ca;rb=+Da;
sb=pb;tb=sb;g[tb>>2]=qb;ub=sb+4|0;vb=ub;g[vb>>2]=rb;wb=c[t>>2]|0;xb=c[o>>2]|0;yb=xb+(wb*12|0)+8|0;g[yb>>2]=Ha;i=e;return}else{va=+g[s>>2];ja=A*va;A=va*B;B=va*C;C=va*D;wa=J+ea*ja;xa=K+ja*fa;ya=N+ra*A;za=O+A*sa;Aa=R-ea*B;Ba=U-fa*B;Ca=X-ra*C;Da=Y-sa*C;Ea=L+va*E*ga;Fa=P+va*F*ta;Ga=V-va*G*ha;Ha=Z-va*H*ua;Ia=c[j>>2]|0;Ja=c[o>>2]|0;Ka=Ja+(Ia*12|0)|0;La=+wa;Ma=+xa;Na=Ka;Oa=Na;g[Oa>>2]=La;Pa=Na+4|0;Qa=Pa;g[Qa>>2]=Ma;Ra=c[j>>2]|0;Sa=c[o>>2]|0;Ta=Sa+(Ra*12|0)+8|0;g[Ta>>2]=Ea;Ua=c[n>>2]|0;Va=Sa+(Ua*12|0)|0;Wa=
+ya;Xa=+za;Ya=Va;Za=Ya;g[Za>>2]=Wa;_a=Ya+4|0;$a=_a;g[$a>>2]=Xa;ab=c[n>>2]|0;bb=c[o>>2]|0;cb=bb+(ab*12|0)+8|0;g[cb>>2]=Fa;db=c[q>>2]|0;eb=bb+(db*12|0)|0;fb=+Aa;gb=+Ba;hb=eb;ib=hb;g[ib>>2]=fb;jb=hb+4|0;kb=jb;g[kb>>2]=gb;lb=c[q>>2]|0;mb=c[o>>2]|0;nb=mb+(lb*12|0)+8|0;g[nb>>2]=Ga;ob=c[t>>2]|0;pb=mb+(ob*12|0)|0;qb=+Ca;rb=+Da;sb=pb;tb=sb;g[tb>>2]=qb;ub=sb+4|0;vb=ub;g[vb>>2]=rb;wb=c[t>>2]|0;xb=c[o>>2]|0;yb=xb+(wb*12|0)+8|0;g[yb>>2]=Ha;i=e;return}}function Hg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=
0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;d=i;e=a+160|0;f=c[e>>2]|0;h=b+32|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=+g[j>>2];l=+g[j+4>>2];m=+g[b+(f*12|0)+8>>2];f=a+164|0;j=c[f>>2]|0;n=b+(j*12|0)|0;o=+g[n>>2];p=+g[n+4>>2];q=+g[b+(j*12|0)+8>>2];j=a+168|0;n=c[j>>2]|0;r=b+(n*12|0)|0;s=+g[r>>2];t=+g[r+4>>2];u=+g[b+(n*12|0)+8>>2];n=a+172|0;r=c[n>>2]|0;v=b+(r*12|0)|0;w=+g[v>>2];x=+g[v+4>>2];y=+g[b+(r*12|0)+8>>2];z=+g[a+240>>2];A=+g[a+244>>2];B=+g[a+248>>2];C=
+g[a+252>>2];D=+g[a+256>>2];E=+g[a+264>>2];F=+g[a+260>>2];G=+g[a+268>>2];H=+g[a+272>>2]*((k-s)*z+(l-t)*A+((o-w)*B+(p-x)*C)+(m*D-u*E+(q*F-y*G)));I=-H;r=a+156|0;g[r>>2]=+g[r>>2]-H;H=+g[a+208>>2]*I;J=m+ +g[a+224>>2]*I*D;D=+g[a+212>>2]*I;m=q+ +g[a+228>>2]*I*F;F=+g[a+216>>2]*I;q=u-+g[a+232>>2]*I*E;E=+g[a+220>>2]*I;u=y-+g[a+236>>2]*I*G;G=+(k+z*H);k=+(l+A*H);a=(c[h>>2]|0)+((c[e>>2]|0)*12|0)|0;g[a>>2]=G;g[a+4>>2]=k;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=J;J=+(o+B*D);o=+(p+D*C);e=a+((c[f>>2]|0)*12|0)|0;
g[e>>2]=J;g[e+4>>2]=o;e=c[h>>2]|0;g[e+((c[f>>2]|0)*12|0)+8>>2]=m;m=+(s-z*F);z=+(t-A*F);f=e+((c[j>>2]|0)*12|0)|0;g[f>>2]=m;g[f+4>>2]=z;f=c[h>>2]|0;g[f+((c[j>>2]|0)*12|0)+8>>2]=q;q=+(w-B*E);B=+(x-C*E);j=f+((c[n>>2]|0)*12|0)|0;g[j>>2]=q;g[j+4>>2]=B;g[(c[h>>2]|0)+((c[n>>2]|0)*12|0)+8>>2]=u;i=d;return}function Ig(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=
0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0;d=i;e=a+160|0;f=c[e>>2]|0;h=b+28|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+164|0;k=c[f>>2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(k*12|0)+8>>2];k=a+168|0;o=c[k>>2]|0;s=b+(o*12|0)|0;t=+g[s>>2];u=+g[s+4>>2];v=+g[b+(o*12|0)+8>>2];o=a+172|0;s=c[o>>2]|0;w=b+(s*12|0)|0;x=+g[w>>2];y=+g[w+4>>2];z=+g[b+(s*12|0)+8>>2];A=+T(+n);B=+S(+n);C=+T(+r);D=+S(+r);E=+T(+v);F=+S(+v);G=+T(+z);H=+S(+z);
if((c[a+76>>2]|0)==1){I=+g[a+224>>2];J=+g[a+232>>2];K=0;L=0;M=I;N=J;O=1;P=1;Q=n-v-+g[a+140>>2];R=I+J}else{J=+g[a+124>>2];I=+g[a+128>>2];U=F*J-E*I;V=E*J+F*I;W=+g[a+108>>2]-+g[a+192>>2];X=+g[a+112>>2]-+g[a+196>>2];Y=+g[a+92>>2]-+g[a+176>>2];Z=+g[a+96>>2]-+g[a+180>>2];_=B*Y-A*Z;$=A*Y+B*Z;Z=V*(F*W-E*X)-U*(E*W+F*X);B=V*_-U*$;Y=+g[a+232>>2];A=+g[a+224>>2];aa=l-t+_;_=m-u+$;K=U;L=V;M=A;N=Y;O=B;P=Z;Q=J*(F*aa+E*_-W)+I*(F*_-E*aa-X);R=+g[a+216>>2]+ +g[a+208>>2]+Z*Z*Y+B*A*B}if((c[a+80>>2]|0)==1){B=+g[a+152>>2];
A=+g[a+228>>2];Y=+g[a+236>>2];ba=B*B*(A+Y);ca=B;da=0;ea=0;fa=A;ga=Y;ha=B;ia=B;ja=r-z-+g[a+144>>2]}else{B=+g[a+132>>2];Y=+g[a+136>>2];A=H*B-G*Y;Z=G*B+H*Y;X=+g[a+116>>2]-+g[a+200>>2];aa=+g[a+120>>2]-+g[a+204>>2];E=+g[a+100>>2]-+g[a+184>>2];_=+g[a+104>>2]-+g[a+188>>2];F=D*E-C*_;I=C*E+D*_;_=+g[a+152>>2];D=_*(Z*(H*X-G*aa)-A*(G*X+H*aa));E=_*(Z*F-A*I);C=+g[a+236>>2];W=+g[a+228>>2];J=p-x+F;F=q-y+I;ba=_*_*(+g[a+220>>2]+ +g[a+212>>2])+D*D*C+E*W*E;ca=_;da=A*_;ea=Z*_;fa=W;ga=C;ha=E;ia=D;ja=B*(H*J+G*F-X)+Y*(H*
F-G*J-aa)}aa=R+0+ba;if(aa>0)ka=-(Q+ja*ca-+g[a+148>>2])/aa;else ka=0;aa=ka*+g[a+208>>2];ca=ka*+g[a+212>>2];ja=ka*+g[a+216>>2];Q=ka*+g[a+220>>2];ba=+(l+K*aa);l=+(m+L*aa);a=j;g[a>>2]=ba;g[a+4>>2]=l;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=n+O*ka*M;M=+(p+da*ca);p=+(q+ea*ca);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=M;g[e+4>>2]=p;e=c[h>>2]|0;g[e+((c[f>>2]|0)*12|0)+8>>2]=r+ha*ka*fa;fa=+(t-K*ja);K=+(u-L*ja);f=e+((c[k>>2]|0)*12|0)|0;g[f>>2]=fa;g[f+4>>2]=K;f=c[h>>2]|0;g[f+((c[k>>2]|0)*12|0)+8>>2]=v-P*ka*N;N=+(x-da*
Q);da=+(y-ea*Q);k=f+((c[o>>2]|0)*12|0)|0;g[k>>2]=N;g[k+4>>2]=da;g[(c[h>>2]|0)+((c[o>>2]|0)*12|0)+8>>2]=z-ia*ka*ga;i=d;return 1}function Jg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+92>>2];h=+g[d+20>>2];i=+g[b+96>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Kg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+100>>2];h=+g[d+20>>2];i=+g[b+104>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*
f-h*i);g[a+4>>2]=j;return}function Lg(a,b,c){a=a|0;b=b|0;c=+c;var d=0,e=0;d=+g[b+156>>2];e=d*+g[b+244>>2]*c;g[a>>2]=d*+g[b+240>>2]*c;g[a+4>>2]=e;return}function Mg(a,b){a=a|0;b=+b;return+(+g[a+156>>2]*+g[a+256>>2]*b)}function Ng(a){a=a|0;return+ +g[a+152>>2]}function Og(a){a=a|0;var b=0,e=0,f=0,j=0,l=0,m=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;l=c[(c[a+68>>2]|0)+56>>2]|0;m=c[(c[a+72>>2]|0)+56>>2]|0;Rm(2912,e);c[e>>2]=f;Rm(2936,e);c[e>>2]=j;Rm(2968,e);c[e>>2]=d[a+61>>
0]|0;Rm(3E3,e);c[e>>2]=l;Rm(3040,e);c[e>>2]=m;Rm(3072,e);h[k>>3]=+g[a+152>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(3104,e);c[e>>2]=c[a+56>>2];Rm(3128,e);i=b;return}function Pg(a){a=a|0;return}function Qg(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Rg(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;h=i;c[a+8>>2]=b;c[a+12>>2]=d;j=+g[e>>2]-+g[b+12>>2];k=e+4|0;l=+g[k>>2]-+g[b+16>>2];m=b+24|0;n=+g[m>>2];o=b+20|0;p=+g[o>>2];q=+(j*n+l*p);r=+(n*l-j*p);s=a+20|
0;g[s>>2]=q;g[s+4>>2]=r;r=+g[e>>2]-+g[d+12>>2];q=+g[k>>2]-+g[d+16>>2];p=+g[d+24>>2];j=+g[d+20>>2];l=+(r*p+q*j);n=+(p*q-r*j);k=a+28|0;g[k>>2]=l;g[k+4>>2]=n;n=+g[m>>2];l=+g[f>>2];j=+g[o>>2];r=+g[f+4>>2];q=+(n*l+j*r);p=+(n*r-l*j);f=a+36|0;g[f>>2]=q;g[f+4>>2]=p;g[a+44>>2]=+g[d+72>>2]-+g[b+72>>2];i=h;return}function Sg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;e=i;vh(b,d);c[b>>2]=3216;f=b+84|0;h=d+20|0;j=c[h+4>>2]|0;l=b+68|0;c[l>>2]=c[h>>2];c[l+4>>2]=j;j=d+28|0;l=c[j+4>>2]|0;h=b+
76|0;c[h>>2]=c[j>>2];c[h+4>>2]=l;l=d+36|0;h=c[l>>2]|0;j=c[l+4>>2]|0;l=f;c[l>>2]=h;c[l+4>>2]=j;m=(c[k>>2]=h,+g[k>>2]);n=(c[k>>2]=j,+g[k>>2]);o=+Q(+(m*m+n*n));if(o<1.1920928955078125E-7){p=n;q=m}else{r=1/o;o=m*r;g[f>>2]=o;m=n*r;g[b+88>>2]=m;p=m;q=o}o=+-p;p=+q;f=b+92|0;g[f>>2]=o;g[f+4>>2]=p;g[b+100>>2]=+g[d+44>>2];f=b+104|0;g[b+252>>2]=0;j=d+52|0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;g[b+120>>2]=+g[j>>2];g[b+124>>2]=+g[d+56>>2];g[b+128>>2]=+g[d+64>>2];g[b+132>>2]=+g[d+68>>2];a[b+136>>0]=a[d+
48>>0]|0;a[b+137>>0]=a[d+60>>0]|0;c[b+140>>2]=0;d=b+184|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;i=e;return}function Tg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0;e=i;f=c[b+48>>2]|0;h=
c[f+8>>2]|0;j=b+144|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+148|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+152|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+160|0;c[o>>2]=r;c[o+4>>2]=s;o=b+168|0;g[o>>2]=+g[f+136>>2];t=b+172|0;g[t>>2]=+g[l+136>>2];u=+g[f+144>>2];g[b+176>>2]=u;v=+g[l+144>>2];g[b+180>>2]=v;l=c[d+28>>2]|0;f=l+(h*12|0)|0;w=+g[f>>2];x=+g[f+4>>2];y=+g[l+(h*12|0)+8>>2];f=d+32|0;z=c[f>>2]|0;A=z+(h*12|0)|0;B=+g[A>>2];C=+g[A+4>>2];D=+g[z+(h*12|0)+8>>2];h=l+(m*12|
0)|0;E=+g[h>>2];F=+g[h+4>>2];G=+g[l+(m*12|0)+8>>2];l=z+(m*12|0)|0;H=+g[l>>2];I=+g[l+4>>2];J=+g[z+(m*12|0)+8>>2];K=+T(+y);L=+S(+y);y=+T(+G);M=+S(+G);G=+g[b+68>>2]-(c[k>>2]=p,+g[k>>2]);N=+g[b+72>>2]-(c[k>>2]=q,+g[k>>2]);O=L*G-K*N;P=K*G+L*N;N=+g[b+76>>2]-(c[k>>2]=r,+g[k>>2]);G=+g[b+80>>2]-(c[k>>2]=s,+g[k>>2]);Q=M*N-y*G;R=y*N+M*G;G=E-w+Q-O;w=F-x+R-P;x=+g[o>>2];F=+g[t>>2];E=+g[b+84>>2];M=+g[b+88>>2];N=L*E-K*M;y=K*E+L*M;M=+N;E=+y;t=b+184|0;g[t>>2]=M;g[t+4>>2]=E;E=O+G;O=P+w;P=E*y-O*N;g[b+208>>2]=P;M=Q*y-
R*N;g[b+212>>2]=M;U=x+F;V=u*P;W=v*M;X=U+P*V+M*W;if(X>0)Y=1/X;else Y=X;g[b+252>>2]=Y;Y=+g[b+92>>2];Z=+g[b+96>>2];_=L*Y-K*Z;$=K*Y+L*Z;Z=+_;L=+$;t=b+192|0;g[t>>2]=Z;g[t+4>>2]=L;L=E*$-O*_;g[b+200>>2]=L;O=Q*$-R*_;g[b+204>>2]=O;R=u*L;Q=v*O;E=R+Q;Z=R*P+Q*M;Y=v+u;K=V+W;g[b+216>>2]=U+L*R+O*Q;g[b+220>>2]=E;g[b+224>>2]=Z;g[b+228>>2]=E;g[b+232>>2]=Y==0?1:Y;g[b+236>>2]=K;g[b+240>>2]=Z;g[b+244>>2]=K;g[b+248>>2]=X;do if((a[b+136>>0]|0)!=0){X=G*N+w*y;K=+g[b+124>>2];Z=+g[b+120>>2];Y=K-Z;if(Y>0)aa=Y;else aa=-Y;if(aa<
.009999999776482582){c[b+140>>2]=3;break}if(X<=Z){t=b+140|0;if((c[t>>2]|0)==1)break;c[t>>2]=1;g[b+112>>2]=0;break}t=b+140|0;if(!(X>=K)){c[t>>2]=0;g[b+112>>2]=0;break}if((c[t>>2]|0)!=2){c[t>>2]=2;g[b+112>>2]=0}}else{c[b+140>>2]=0;g[b+112>>2]=0}while(0);if((a[b+137>>0]|0)==0)g[b+116>>2]=0;t=b+104|0;if((a[d+24>>0]|0)==0){c[t+0>>2]=0;c[t+4>>2]=0;c[t+8>>2]=0;c[t+12>>2]=0;ba=B;ca=C;da=H;ea=I;fa=D;ga=J;ha=c[j>>2]|0;ia=c[f>>2]|0;ja=ia+(ha*12|0)|0;ka=+ba;la=+ca;ma=ja;na=ma;g[na>>2]=ka;oa=ma+4|0;pa=oa;g[pa>>
2]=la;qa=c[j>>2]|0;ra=c[f>>2]|0;sa=ra+(qa*12|0)+8|0;g[sa>>2]=fa;ta=c[n>>2]|0;ua=ra+(ta*12|0)|0;va=+da;wa=+ea;xa=ua;ya=xa;g[ya>>2]=va;za=xa+4|0;Aa=za;g[Aa>>2]=wa;Ba=c[n>>2]|0;Ca=c[f>>2]|0;Da=Ca+(Ba*12|0)+8|0;g[Da>>2]=ga;i=e;return}else{o=d+8|0;aa=+g[o>>2];w=aa*+g[t>>2];g[t>>2]=w;t=b+108|0;G=aa*+g[t>>2];g[t>>2]=G;t=b+112|0;K=aa*+g[t>>2];g[t>>2]=K;t=b+116|0;aa=+g[o>>2]*+g[t>>2];g[t>>2]=aa;X=aa+K;K=w*_+N*X;N=w*$+X*y;ba=B-x*K;ca=C-x*N;da=H+F*K;ea=I+F*N;fa=D-u*(w*L+G+X*P);ga=J+v*(G+w*O+X*M);ha=c[j>>2]|
0;ia=c[f>>2]|0;ja=ia+(ha*12|0)|0;ka=+ba;la=+ca;ma=ja;na=ma;g[na>>2]=ka;oa=ma+4|0;pa=oa;g[pa>>2]=la;qa=c[j>>2]|0;ra=c[f>>2]|0;sa=ra+(qa*12|0)+8|0;g[sa>>2]=fa;ta=c[n>>2]|0;ua=ra+(ta*12|0)|0;va=+da;wa=+ea;xa=ua;ya=xa;g[ya>>2]=va;za=xa+4|0;Aa=za;g[Aa>>2]=wa;Ba=c[n>>2]|0;Ca=c[f>>2]|0;Da=Ca+(Ba*12|0)+8|0;g[Da>>2]=ga;i=e;return}}function Ug(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,
Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0,Ma=0,Na=0,Oa=0;e=i;i=i+64|0;f=e+44|0;h=e+32|0;j=e+24|0;k=e+16|0;l=e+8|0;m=e;n=b+144|0;o=c[n>>2]|0;p=d+32|0;q=c[p>>2]|0;r=q+(o*12|0)|0;s=+g[r>>2];t=+g[r+4>>2];u=+g[q+(o*12|0)+8>>2];o=b+148|0;r=c[o>>2]|0;v=q+(r*12|0)|0;w=+g[v>>2];x=+g[v+4>>2];y=+g[q+(r*12|0)+8>>2];
z=+g[b+168>>2];A=+g[b+172>>2];B=+g[b+176>>2];C=+g[b+180>>2];if((a[b+137>>0]|0)!=0?(c[b+140>>2]|0)!=3:0){D=+g[b+184>>2];E=+g[b+188>>2];F=+g[b+212>>2];G=+g[b+208>>2];r=b+116|0;H=+g[r>>2];I=+g[d>>2]*+g[b+128>>2];J=H+ +g[b+252>>2]*(+g[b+132>>2]-((w-s)*D+(x-t)*E+y*F-u*G));K=-I;L=J<I?J:I;I=L<K?K:L;g[r>>2]=I;L=I-H;H=D*L;D=E*L;M=t-z*D;N=x+A*D;O=s-z*H;P=w+A*H;Q=u-B*G*L;R=y+C*F*L}else{M=t;N=x;O=s;P=w;Q=u;R=y}y=P-O;u=N-M;r=b+192|0;d=b+196|0;q=b+204|0;v=b+200|0;w=y*+g[r>>2]+u*+g[d>>2]+R*+g[q>>2]-Q*+g[v>>2];s=
R-Q;if((a[b+136>>0]|0)!=0?(S=b+140|0,(c[S>>2]|0)!=0):0){T=b+184|0;U=b+188|0;V=b+212|0;W=b+208|0;X=b+104|0;x=+g[X>>2];Y=b+108|0;t=+g[Y>>2];Z=b+112|0;L=+g[Z>>2];_=b+216|0;F=-w;G=-s;H=-(y*+g[T>>2]+u*+g[U>>2]+R*+g[V>>2]-Q*+g[W>>2]);g[h>>2]=F;g[h+4>>2]=G;g[h+8>>2]=H;Gm(f,_,h);g[X>>2]=+g[f>>2]+ +g[X>>2];h=f+4|0;g[Y>>2]=+g[h>>2]+ +g[Y>>2];$=f+8|0;H=+g[$>>2]+ +g[Z>>2];g[Z>>2]=H;aa=c[S>>2]|0;if((aa|0)==2){u=H<0?H:0;g[Z>>2]=u;ba=u}else if((aa|0)==1){u=H>0?H:0;g[Z>>2]=u;ba=u}else ba=H;H=ba-L;ba=G-H*+g[b+244>>
2];g[j>>2]=F-+g[b+240>>2]*H;g[j+4>>2]=ba;Hm(k,_,j);ba=x+ +g[k>>2];H=t+ +g[k+4>>2];g[X>>2]=ba;g[Y>>2]=H;F=ba-x;x=H-t;t=+g[Z>>2]-L;g[f>>2]=F;g[h>>2]=x;g[$>>2]=t;ca=x+F*+g[q>>2]+t*+g[V>>2];da=F*+g[r>>2]+t*+g[T>>2];ea=F*+g[v>>2]+x+t*+g[W>>2];fa=F*+g[d>>2]+t*+g[U>>2];ga=z*fa;ha=z*da;ia=O-ha;ja=M-ga;ka=A*da;la=A*fa;ma=P+ka;na=N+la;oa=B*ea;pa=C*ca;qa=Q-oa;ra=R+pa;sa=c[n>>2]|0;ta=c[p>>2]|0;ua=ta+(sa*12|0)|0;va=+ia;wa=+ja;xa=ua;ya=xa;g[ya>>2]=va;za=xa+4|0;Aa=za;g[Aa>>2]=wa;Ba=c[n>>2]|0;Ca=c[p>>2]|0;Da=Ca+
(Ba*12|0)+8|0;g[Da>>2]=qa;Ea=c[o>>2]|0;Fa=Ca+(Ea*12|0)|0;Ga=+ma;Ha=+na;Ia=Fa;Ja=Ia;g[Ja>>2]=Ga;Ka=Ia+4|0;La=Ka;g[La>>2]=Ha;Ma=c[o>>2]|0;Na=c[p>>2]|0;Oa=Na+(Ma*12|0)+8|0;g[Oa>>2]=ra;i=e;return}g[m>>2]=-w;g[m+4>>2]=-s;Hm(l,b+216|0,m);s=+g[l>>2];m=b+104|0;g[m>>2]=s+ +g[m>>2];w=+g[l+4>>2];l=b+108|0;g[l>>2]=w+ +g[l>>2];ca=w+s*+g[q>>2];da=s*+g[r>>2];ea=s*+g[v>>2]+w;fa=s*+g[d>>2];ga=z*fa;ha=z*da;ia=O-ha;ja=M-ga;ka=A*da;la=A*fa;ma=P+ka;na=N+la;oa=B*ea;pa=C*ca;qa=Q-oa;ra=R+pa;sa=c[n>>2]|0;ta=c[p>>2]|0;ua=
ta+(sa*12|0)|0;va=+ia;wa=+ja;xa=ua;ya=xa;g[ya>>2]=va;za=xa+4|0;Aa=za;g[Aa>>2]=wa;Ba=c[n>>2]|0;Ca=c[p>>2]|0;Da=Ca+(Ba*12|0)+8|0;g[Da>>2]=qa;Ea=c[o>>2]|0;Fa=Ca+(Ea*12|0)|0;Ga=+ma;Ha=+na;Ia=Fa;Ja=Ia;g[Ja>>2]=Ga;Ka=Ia+4|0;La=Ka;g[La>>2]=Ha;Ma=c[o>>2]|0;Na=c[p>>2]|0;Oa=Na+(Ma*12|0)+8|0;g[Oa>>2]=ra;i=e;return}function Vg(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,
X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0;e=i;i=i+64|0;f=e+24|0;h=e+12|0;j=e;k=b+144|0;l=c[k>>2]|0;m=d+28|0;d=c[m>>2]|0;n=d+(l*12|0)|0;o=+g[n>>2];p=+g[n+4>>2];q=+g[d+(l*12|0)+8>>2];l=b+148|0;n=c[l>>2]|0;r=d+(n*12|0)|0;s=+g[r>>2];t=+g[r+4>>2];u=+g[d+(n*12|0)+8>>2];v=+T(+q);w=+S(+q);x=+T(+u);y=+S(+u);z=+g[b+168>>2];A=+g[b+172>>2];B=+g[b+176>>2];C=+g[b+180>>2];D=+g[b+68>>2]-+g[b+152>>2];E=+g[b+72>>2]-+g[b+156>>2];F=w*D-v*E;G=v*D+w*E;E=+g[b+76>>2]-+g[b+160>>2];D=+g[b+80>>2]-+g[b+164>>2];H=y*E-x*D;I=x*E+y*D;D=s+H-
o-F;y=t+I-p-G;E=+g[b+84>>2];x=+g[b+88>>2];J=w*E-v*x;K=v*E+w*x;x=F+D;F=G+y;G=K*x-J*F;E=H*K-I*J;L=+g[b+92>>2];M=+g[b+96>>2];N=w*L-v*M;O=v*L+w*M;M=O*x-N*F;F=H*O-I*N;I=N*D+O*y;H=u-q-+g[b+100>>2];if(I>0)P=I;else P=-I;if(H>0)Q=H;else Q=-H;do if((a[b+136>>0]|0)!=0){x=J*D+K*y;w=+g[b+124>>2];L=+g[b+120>>2];v=w-L;if(v>0)R=v;else R=-v;if(R<.009999999776482582){v=x<.20000000298023224?x:.20000000298023224;if(x>0)U=x;else U=-x;V=v<-.20000000298023224?-.20000000298023224:v;W=1;X=P>U?P:U;break}if(x<=L){v=x-L+.004999999888241291;
Y=v<0?v:0;v=L-x;V=Y<-.20000000298023224?-.20000000298023224:Y;W=1;X=P>v?P:v;break}if(x>=w){v=x-w;w=v+-.004999999888241291;x=w<.20000000298023224?w:.20000000298023224;V=x<0?0:x;W=1;X=P>v?P:v}else{V=0;W=0;X=P}}else{V=0;W=0;X=P}while(0);P=z+A;U=B*M;R=C*F;y=F*R+(P+M*U);D=R+U;if(W){v=E*R+G*U;U=B+C;R=B*G;x=C*E;w=x+R;g[f>>2]=y;g[f+4>>2]=D;g[f+8>>2]=v;g[f+12>>2]=D;g[f+16>>2]=U==0?1:U;g[f+20>>2]=w;g[f+24>>2]=v;g[f+28>>2]=w;g[f+32>>2]=E*x+(P+G*R);g[j>>2]=-I;g[j+4>>2]=-H;g[j+8>>2]=-V;Gm(h,f,j);Z=+g[h>>2];_=
+g[h+8>>2];$=+g[h+4>>2]}else{V=B+C;R=V==0?1:V;V=-I;I=-H;H=R*y-D*D;if(H!=0)aa=1/H;else aa=H;Z=(R*V-D*I)*aa;_=0;$=(y*I-D*V)*aa}aa=J*_+N*Z;N=K*_+O*Z;O=+(o-z*aa);o=+(p-z*N);h=(c[m>>2]|0)+((c[k>>2]|0)*12|0)|0;g[h>>2]=O;g[h+4>>2]=o;h=c[m>>2]|0;g[h+((c[k>>2]|0)*12|0)+8>>2]=q-B*(G*_+($+M*Z));M=+(s+A*aa);aa=+(t+A*N);k=h+((c[l>>2]|0)*12|0)|0;g[k>>2]=M;g[k+4>>2]=aa;g[(c[m>>2]|0)+((c[l>>2]|0)*12|0)+8>>2]=u+C*(E*_+($+F*Z));if(!(X<=.004999999888241291)){ba=0;i=e;return ba|0}ba=Q<=.03490658849477768;i=e;return ba|
0}function Wg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+68>>2];h=+g[d+20>>2];i=+g[b+72>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Xg(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+76>>2];h=+g[d+20>>2];i=+g[b+80>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Yg(a,b,c){a=a|0;b=b|0;c=+c;var d=0,e=0,f=0;d=+g[b+104>>2];e=+g[b+116>>2]+ +g[b+112>>2];f=(d*
+g[b+196>>2]+e*+g[b+188>>2])*c;g[a>>2]=(d*+g[b+192>>2]+ +g[b+184>>2]*e)*c;g[a+4>>2]=f;return}function Zg(a,b){a=a|0;b=+b;return+(+g[a+108>>2]*b)}function _g(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;b=c[a+48>>2]|0;d=+g[b+24>>2];e=+g[a+68>>2];f=+g[b+20>>2];h=+g[a+72>>2];i=c[a+52>>2]|0;j=+g[i+24>>2];k=+g[a+76>>2];l=+g[i+20>>2];m=+g[a+80>>2];n=+g[a+84>>2];o=+g[a+88>>2];return+((+g[i+12>>2]+(j*k-l*m)-(+g[b+12>>2]+(d*e-f*h)))*(d*n-f*o)+(k*l+j*m+ +g[i+16>>2]-(e*f+d*h+ +g[b+16>>2]))*(f*
n+d*o))}function $g(b){b=b|0;return(a[b+136>>0]|0)!=0|0}function ah(f,h){f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0;j=i;k=f+136|0;if((h&1|0)==(d[k>>0]|0|0)){i=j;return}l=c[f+48>>2]|0;m=l+4|0;n=e[m>>1]|0;if((n&2|0)==0){b[m>>1]=n|2;g[l+160>>2]=0}l=c[f+52>>2]|0;n=l+4|0;m=e[n>>1]|0;if((m&2|0)==0){b[n>>1]=m|2;g[l+160>>2]=0}a[k>>0]=h&1;g[f+112>>2]=0;i=j;return}function bh(b){b=b|0;return(a[b+137>>0]|0)!=0|0}function ch(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0;h=i;j=c[d+48>>2]|0;k=j+4|0;l=e[k>>1]|0;if((l&2|
0)==0){b[k>>1]=l|2;g[j+160>>2]=0}j=c[d+52>>2]|0;l=j+4|0;k=e[l>>1]|0;if((k&2|0)!=0){m=d+137|0;n=f&1;a[m>>0]=n;i=h;return}b[l>>1]=k|2;g[j+160>>2]=0;m=d+137|0;n=f&1;a[m>>0]=n;i=h;return}function dh(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0,l=0;f=i;h=c[a+48>>2]|0;j=h+4|0;k=e[j>>1]|0;if((k&2|0)==0){b[j>>1]=k|2;g[h+160>>2]=0}h=c[a+52>>2]|0;k=h+4|0;j=e[k>>1]|0;if((j&2|0)!=0){l=a+132|0;g[l>>2]=d;i=f;return}b[k>>1]=j|2;g[h+160>>2]=0;l=a+132|0;g[l>>2]=d;i=f;return}function eh(a,b){a=a|0;b=+b;return+(+g[a+116>>2]*
b)}function fh(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(3264,e);c[e>>2]=f;Rm(3296,e);c[e>>2]=j;Rm(3328,e);c[e>>2]=d[a+61>>0]|0;Rm(3360,e);l=+g[a+72>>2];h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(3400,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(3448,e);l=+g[a+88>>2];h[k>>3]=+g[a+
84>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(3496,e);h[k>>3]=+g[a+100>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(3536,e);c[e>>2]=d[a+136>>0]|0;Rm(3568,e);h[k>>3]=+g[a+120>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(3600,e);h[k>>3]=+g[a+124>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(3640,e);c[e>>2]=d[a+137>>0]|0;Rm(3680,e);h[k>>3]=+g[a+132>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(3712,e);h[k>>3]=+g[a+128>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];
Rm(3744,e);c[e>>2]=c[a+56>>2];Rm(3776,e);i=b;return}function gh(a){a=a|0;return}function hh(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function ih(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;vh(a,b);c[a>>2]=3872;e=b+20|0;f=c[e+4>>2]|0;h=a+68|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+28|0;h=c[f+4>>2]|0;e=a+76|0;c[e>>2]=c[f>>2];c[e+4>>2]=h;g[a+84>>2]=+g[b+36>>2];g[a+160>>2]=0;g[a+92>>2]=0;c[a+164>>2]=0;g[a+88>>2]=0;i=d;return}function jh(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,
v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+96|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+100|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+128|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+136|0;c[o>>2]=r;c[o+4>>2]=s;s=b+144|0;g[s>>2]=+g[f+136>>2];o=b+148|0;g[o>>2]=+g[l+136>>2];t=b+152|0;g[t>>2]=+g[f+144>>2];f=b+156|0;g[f>>2]=+g[l+144>>2];l=c[d+28>>2]|0;u=l+(h*12|0)|0;
v=+g[u>>2];w=+g[u+4>>2];x=+g[l+(h*12|0)+8>>2];u=d+32|0;y=c[u>>2]|0;z=y+(h*12|0)|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[y+(h*12|0)+8>>2];h=l+(m*12|0)|0;D=+g[h>>2];E=+g[h+4>>2];F=+g[l+(m*12|0)+8>>2];l=y+(m*12|0)|0;G=+g[l>>2];H=+g[l+4>>2];I=+g[y+(m*12|0)+8>>2];J=+T(+x);K=+S(+x);x=+T(+F);L=+S(+F);F=+g[b+68>>2]-(c[k>>2]=p,+g[k>>2]);M=+g[b+72>>2]-(c[k>>2]=q,+g[k>>2]);N=K*F-J*M;O=J*F+K*M;M=+N;K=+O;q=b+112|0;g[q>>2]=M;g[q+4>>2]=K;K=+g[b+76>>2]-(c[k>>2]=r,+g[k>>2]);M=+g[b+80>>2]-+g[b+140>>2];F=L*K-x*M;J=x*K+L*M;M=
+F;L=+J;r=b+120|0;g[r>>2]=M;g[r+4>>2]=L;r=b+104|0;L=D+F-v-N;v=E+J-w-O;w=+L;E=+v;q=r;g[q>>2]=w;g[q+4>>2]=E;q=b+108|0;E=+Q(+(L*L+v*v));g[b+88>>2]=E;c[b+164>>2]=E-+g[b+84>>2]>0?2:0;if(!(E>.004999999888241291)){g[r>>2]=0;g[q>>2]=0;g[b+160>>2]=0;g[b+92>>2]=0;i=e;return}w=1/E;E=w*L;g[r>>2]=E;L=w*v;g[q>>2]=L;v=N*L-O*E;w=L*F-E*J;D=+g[s>>2];M=+g[t>>2];K=+g[o>>2];x=+g[f>>2];P=K+(D+v*v*M)+w*w*x;if(P!=0)R=1/P;else R=0;g[b+160>>2]=R;if((a[d+24>>0]|0)==0){g[b+92>>2]=0;U=A;V=B;W=G;X=H;Y=C;Z=I}else{f=b+92|0;R=+g[d+
8>>2]*+g[f>>2];g[f>>2]=R;P=E*R;E=R*L;U=A-P*D;V=B-E*D;W=G+P*K;X=H+E*K;Y=C-M*(E*N-P*O);Z=I+x*(E*F-P*J)}J=+U;U=+V;f=(c[u>>2]|0)+((c[j>>2]|0)*12|0)|0;g[f>>2]=J;g[f+4>>2]=U;f=c[u>>2]|0;g[f+((c[j>>2]|0)*12|0)+8>>2]=Y;Y=+W;W=+X;j=f+((c[n>>2]|0)*12|0)|0;g[j>>2]=Y;g[j+4>>2]=W;g[(c[u>>2]|0)+((c[n>>2]|0)*12|0)+8>>2]=Z;i=e;return}function kh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;d=i;e=a+96|0;f=c[e>>2]|0;h=b+32|0;j=c[h>>2]|0;k=j+(f*12|
0)|0;l=k;m=+g[l>>2];n=+g[l+4>>2];o=+g[j+(f*12|0)+8>>2];f=a+100|0;l=c[f>>2]|0;p=j+(l*12|0)|0;q=+g[p>>2];r=+g[p+4>>2];s=+g[j+(l*12|0)+8>>2];t=+g[a+116>>2];u=+g[a+112>>2];v=+g[a+124>>2];w=+g[a+120>>2];x=+g[a+88>>2]-+g[a+84>>2];y=+g[a+104>>2];z=+g[a+108>>2];A=(q-s*v-(m-o*t))*y+(r+s*w-(n+o*u))*z;if(x<0)B=A+x*+g[b+4>>2];else B=A;b=a+92|0;A=+g[b>>2];x=A-B*+g[a+160>>2];B=x>0?0:x;g[b>>2]=B;x=B-A;A=y*x;y=z*x;x=+g[a+144>>2];z=o-+g[a+152>>2]*(u*y-A*t);t=+g[a+148>>2];u=s+ +g[a+156>>2]*(y*w-A*v);v=+(m-x*A);m=+(n-
x*y);a=k;g[a>>2]=v;g[a+4>>2]=m;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=z;z=+(q+A*t);A=+(r+y*t);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=z;g[e+4>>2]=A;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=u;i=d;return}function lh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;d=i;e=a+96|0;f=c[e>>2]|0;h=b+28|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+100|0;k=c[f>>2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+
(k*12|0)+8>>2];s=+T(+n);t=+S(+n);u=+T(+r);v=+S(+r);w=+g[a+68>>2]-+g[a+128>>2];x=+g[a+72>>2]-+g[a+132>>2];y=t*w-s*x;z=s*w+t*x;x=+g[a+76>>2]-+g[a+136>>2];t=+g[a+80>>2]-+g[a+140>>2];w=v*x-u*t;s=u*x+v*t;t=p+w-l-y;v=q+s-m-z;x=+Q(+(t*t+v*v));if(x<1.1920928955078125E-7){A=0;B=t;C=v}else{u=1/x;A=x;B=t*u;C=v*u}k=a+84|0;u=A-+g[k>>2];v=u<.20000000298023224?u:.20000000298023224;u=-(+g[a+160>>2]*(v<0?0:v));v=B*u;B=C*u;u=+g[a+144>>2];C=n-+g[a+152>>2]*(y*B-z*v);z=+g[a+148>>2];y=r+ +g[a+156>>2]*(w*B-s*v);s=+(l-u*
v);l=+(m-u*B);a=j;g[a>>2]=s;g[a+4>>2]=l;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=C;C=+(p+z*v);v=+(q+z*B);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=C;g[e+4>>2]=v;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=y;i=d;return A-+g[k>>2]<.004999999888241291|0}function mh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+68>>2];h=+g[d+20>>2];i=+g[b+72>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function nh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>
2]|0;e=+g[d+24>>2];f=+g[b+76>>2];h=+g[d+20>>2];i=+g[b+80>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function oh(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+92>>2]*c;c=d*+g[b+108>>2];g[a>>2]=+g[b+104>>2]*d;g[a+4>>2]=c;return}function ph(a,b){a=a|0;b=+b;return 0}function qh(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(3920,e);c[e>>2]=f;Rm(3944,e);c[e>>2]=j;Rm(3976,e);c[e>>2]=d[a+61>>0]|0;Rm(4008,e);l=+g[a+72>>
2];h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(4048,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(4096,e);h[k>>3]=+g[a+84>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4144,e);c[e>>2]=c[a+56>>2];Rm(4176,e);i=b;return}function rh(a){a=a|0;return}function sh(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function th(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,
k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;d=i;do switch(c[a>>2]|0){case 5:e=Em(b,168)|0;if((e|0)==0)f=0;else{vf(e,a);f=e}g=f;break;case 2:e=Em(b,256)|0;if((e|0)==0)h=0;else{Sg(e,a);h=e}g=h;break;case 7:e=Em(b,224)|0;if((e|0)==0)j=0;else{Sh(e,a);j=e}g=j;break;case 4:e=Em(b,196)|0;if((e|0)==0)k=0;else{di(e,a);k=e}g=k;break;case 3:e=Em(b,176)|0;if((e|0)==0)l=0;else{Yf(e,a);l=e}g=l;break;case 9:e=Em(b,180)|0;if((e|0)==0)m=0;else{ig(e,a);m=e}g=m;break;case 11:e=Em(b,192)|0;if((e|0)==0)n=0;else{Jf(e,a);n=e}g=n;break;
case 1:e=Em(b,228)|0;if((e|0)==0)o=0;else{Ah(e,a);o=e}g=o;break;case 8:e=Em(b,208)|0;if((e|0)==0)p=0;else{ug(e,a);p=e}g=p;break;case 6:e=Em(b,276)|0;if((e|0)==0)q=0;else{Fg(e,a);q=e}g=q;break;case 10:e=Em(b,168)|0;if((e|0)==0)r=0;else{ih(e,a);r=e}g=r;break;default:g=0}while(0);i=d;return g|0}function uh(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+24>>2]&127](a);do switch(c[a+4>>2]|0){case 9:Fm(b,a,180);break;case 2:Fm(b,a,256);break;case 1:Fm(b,a,228);break;case 7:Fm(b,a,224);break;case 8:Fm(b,
a,208);break;case 5:Fm(b,a,168);break;case 3:Fm(b,a,176);break;case 11:Fm(b,a,192);break;case 4:Fm(b,a,196);break;case 10:Fm(b,a,168);break;case 6:Fm(b,a,276);break;default:}while(0);i=d;return}function vh(b,d){b=b|0;d=d|0;var e=0;e=i;c[b>>2]=4264;c[b+4>>2]=c[d>>2];c[b+8>>2]=0;c[b+12>>2]=0;c[b+48>>2]=c[d+8>>2];c[b+52>>2]=c[d+12>>2];c[b+56>>2]=0;a[b+61>>0]=a[d+16>>0]|0;a[b+60>>0]=0;c[b+64>>2]=c[d+4>>2];d=b+16|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;c[d+16>>2]=0;c[d+20>>2]=0;c[d+24>>2]=0;
c[d+28>>2]=0;i=e;return}function wh(a){a=a|0;a=i;i=i+16|0;Rm(4312,a);i=a;return}function xh(a){a=a|0;return}function yh(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function zh(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;f=i;c[a+8>>2]=b;c[a+12>>2]=d;h=+g[e>>2]-+g[b+12>>2];j=e+4|0;k=+g[j>>2]-+g[b+16>>2];l=+g[b+24>>2];m=+g[b+20>>2];n=+(h*l+k*m);o=+(l*k-h*m);p=a+20|0;g[p>>2]=n;g[p+4>>2]=o;o=+g[e>>2]-+g[d+12>>2];n=+g[j>>2]-+g[d+16>>2];m=+g[d+24>>2];h=+g[d+20>>2];k=+(o*m+n*h);l=+(m*
n-o*h);j=a+28|0;g[j>>2]=k;g[j+4>>2]=l;g[a+36>>2]=+g[d+72>>2]-+g[b+72>>2];i=f;return}function Ah(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0;e=i;vh(b,d);c[b>>2]=4368;f=d+20|0;h=c[f+4>>2]|0;j=b+68|0;c[j>>2]=c[f>>2];c[j+4>>2]=h;h=d+28|0;j=c[h+4>>2]|0;f=b+76|0;c[f>>2]=c[h>>2];c[f+4>>2]=j;g[b+116>>2]=+g[d+36>>2];j=b+84|0;f=d+44|0;c[j+0>>2]=0;c[j+4>>2]=0;c[j+8>>2]=0;c[j+12>>2]=0;g[b+120>>2]=+g[f>>2];g[b+124>>2]=+g[d+48>>2];g[b+104>>2]=+g[d+60>>2];g[b+108>>2]=+g[d+56>>2];a[b+112>>0]=a[d+40>>0]|0;a[b+100>>0]=a[d+
52>>0]|0;c[b+224>>2]=0;i=e;return}function Bh(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+128|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+132|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+152|0;c[o>>2]=
p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+160|0;c[o>>2]=r;c[o+4>>2]=s;o=b+168|0;g[o>>2]=+g[f+136>>2];t=+g[l+136>>2];g[b+172>>2]=t;u=+g[f+144>>2];g[b+176>>2]=u;v=+g[l+144>>2];g[b+180>>2]=v;l=c[d+28>>2]|0;w=+g[l+(h*12|0)+8>>2];f=d+32|0;x=c[f>>2]|0;y=x+(h*12|0)|0;z=+g[y>>2];A=+g[y+4>>2];B=+g[x+(h*12|0)+8>>2];C=+g[l+(m*12|0)+8>>2];l=x+(m*12|0)|0;D=+g[l>>2];E=+g[l+4>>2];F=+g[x+(m*12|0)+8>>2];G=+T(+w);H=+S(+w);I=+T(+C);J=+S(+C);m=b+136|0;K=+g[b+68>>2]-(c[k>>2]=p,+g[k>>2]);L=+g[b+72>>2]-(c[k>>
2]=q,+g[k>>2]);M=H*K-G*L;N=G*K+H*L;L=+M;H=+N;q=m;g[q>>2]=L;g[q+4>>2]=H;H=+g[b+76>>2]-(c[k>>2]=r,+g[k>>2]);L=+g[b+80>>2]-(c[k>>2]=s,+g[k>>2]);K=J*H-I*L;G=I*H+J*L;L=+K;J=+G;s=b+144|0;g[s>>2]=L;g[s+4>>2]=J;J=+g[o>>2];L=u+v;o=L==0;H=J+t;s=b+140|0;g[b+184>>2]=H+u*N*N+v*G*G;I=-(u*N*M)-v*G*K;g[b+196>>2]=I;O=-(u*N)-v*G;g[b+208>>2]=O;g[b+188>>2]=I;g[b+200>>2]=H+u*M*M+v*K*K;H=u*M+v*K;g[b+212>>2]=H;g[b+192>>2]=O;g[b+204>>2]=H;g[b+216>>2]=L;if(L>0)P=1/L;else P=L;g[b+220>>2]=P;if((a[b+100>>0]|0)==0|o)g[b+96>>
2]=0;do if((a[b+112>>0]|0)==0|o)c[b+224>>2]=0;else{P=C-w-+g[b+116>>2];L=+g[b+124>>2];H=+g[b+120>>2];O=L-H;if(O>0)Q=O;else Q=-O;if(Q<.06981317698955536){c[b+224>>2]=3;break}if(P<=H){r=b+224|0;if((c[r>>2]|0)!=1)g[b+92>>2]=0;c[r>>2]=1;break}r=b+224|0;if(!(P>=L)){c[r>>2]=0;g[b+92>>2]=0;break}if((c[r>>2]|0)!=2)g[b+92>>2]=0;c[r>>2]=2}while(0);o=b+84|0;if((a[d+24>>0]|0)==0){c[o+0>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;c[o+12>>2]=0;R=z;U=A;V=D;W=E;X=B;Y=F;Z=c[j>>2]|0;_=c[f>>2]|0;$=_+(Z*12|0)|0;aa=+R;ba=+U;ca=$;da=
ca;g[da>>2]=aa;ea=ca+4|0;fa=ea;g[fa>>2]=ba;ga=c[j>>2]|0;ha=c[f>>2]|0;ia=ha+(ga*12|0)+8|0;g[ia>>2]=X;ja=c[n>>2]|0;ka=ha+(ja*12|0)|0;la=+V;ma=+W;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[n>>2]|0;sa=c[f>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=Y;i=e;return}else{r=d+8|0;Q=+g[r>>2];w=Q*+g[o>>2];g[o>>2]=w;o=b+88|0;C=Q*+g[o>>2];g[o>>2]=C;o=b+92|0;L=Q*+g[o>>2];g[o>>2]=L;o=b+96|0;Q=+g[r>>2]*+g[o>>2];g[o>>2]=Q;R=z-J*w;U=A-J*C;V=D+t*w;W=E+t*C;X=B-u*(L+(Q+(C*+g[m>>2]-w*+g[s>>2])));Y=F+v*(L+(Q+(C*K-w*
G)));Z=c[j>>2]|0;_=c[f>>2]|0;$=_+(Z*12|0)|0;aa=+R;ba=+U;ca=$;da=ca;g[da>>2]=aa;ea=ca+4|0;fa=ea;g[fa>>2]=ba;ga=c[j>>2]|0;ha=c[f>>2]|0;ia=ha+(ga*12|0)+8|0;g[ia>>2]=X;ja=c[n>>2]|0;ka=ha+(ja*12|0)|0;la=+V;ma=+W;na=ka;oa=na;g[oa>>2]=la;pa=na+4|0;qa=pa;g[qa>>2]=ma;ra=c[n>>2]|0;sa=c[f>>2]|0;ta=sa+(ra*12|0)+8|0;g[ta>>2]=Y;i=e;return}}function Ch(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,
P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0;e=i;i=i+80|0;f=e+60|0;h=e+48|0;j=e+40|0;k=e+32|0;l=e+24|0;m=e+16|0;n=e+8|0;o=e;p=b+128|0;q=c[p>>2]|0;r=d+32|0;s=c[r>>2]|0;t=s+(q*12|0)|0;u=+g[t>>2];v=+g[t+4>>2];w=+g[s+(q*12|0)+8>>2];q=b+132|0;t=c[q>>2]|0;x=s+(t*12|0)|0;y=+g[x>>2];z=+g[x+4>>2];A=+g[s+(t*12|0)+8>>2];B=+g[b+168>>2];
C=+g[b+172>>2];D=+g[b+176>>2];E=+g[b+180>>2];t=D+E==0;if((a[b+100>>0]|0)!=0?!((c[b+224>>2]|0)==3|t):0){s=b+96|0;F=+g[s>>2];G=+g[d>>2]*+g[b+104>>2];H=F-+g[b+220>>2]*(A-w-+g[b+108>>2]);I=-G;J=H<G?H:G;G=J<I?I:J;g[s>>2]=G;J=G-F;K=w-D*J;L=A+E*J}else{K=w;L=A}if((a[b+112>>0]|0)!=0?(s=b+224|0,!((c[s>>2]|0)==0|t)):0){t=b+148|0;d=b+144|0;x=b+140|0;M=b+136|0;A=y-L*+g[t>>2]-u+K*+g[x>>2];w=z+L*+g[d>>2]-v-K*+g[M>>2];g[f>>2]=A;g[f+4>>2]=w;g[f+8>>2]=L-K;N=b+184|0;Gm(h,N,f);J=+g[h>>2];F=-J;G=+g[h+4>>2];I=-G;H=+g[h+
8>>2];O=-H;h=c[s>>2]|0;do if((h|0)==2){s=b+84|0;f=b+92|0;P=+g[f>>2];Q=P-H;if(Q>0){R=P*+g[b+212>>2]-w;g[l>>2]=P*+g[b+208>>2]-A;g[l+4>>2]=R;Hm(m,N,l);R=+g[m>>2];P=+g[m+4>>2];S=-+g[f>>2];g[s>>2]=R+ +g[s>>2];T=b+88|0;g[T>>2]=P+ +g[T>>2];g[f>>2]=0;U=P;V=R;W=S;break}else{g[s>>2]=+g[s>>2]-J;s=b+88|0;g[s>>2]=+g[s>>2]-G;g[f>>2]=Q;U=I;V=F;W=O;break}}else if((h|0)==3){f=b+84|0;g[f>>2]=+g[f>>2]-J;f=b+88|0;g[f>>2]=+g[f>>2]-G;f=b+92|0;g[f>>2]=+g[f>>2]-H;U=I;V=F;W=O}else if((h|0)==1){f=b+84|0;s=b+92|0;Q=+g[s>>2];
S=Q-H;if(S<0){R=Q*+g[b+212>>2]-w;g[j>>2]=Q*+g[b+208>>2]-A;g[j+4>>2]=R;Hm(k,N,j);R=+g[k>>2];Q=+g[k+4>>2];P=-+g[s>>2];g[f>>2]=R+ +g[f>>2];T=b+88|0;g[T>>2]=Q+ +g[T>>2];g[s>>2]=0;U=Q;V=R;W=P;break}else{g[f>>2]=+g[f>>2]-J;f=b+88|0;g[f>>2]=+g[f>>2]-G;g[s>>2]=S;U=I;V=F;W=O;break}}else{U=I;V=F;W=O}while(0);X=W+(U*+g[d>>2]-V*+g[t>>2]);Y=W+(U*+g[M>>2]-V*+g[x>>2]);Z=U;_=V;$=C*_;aa=C*Z;ba=B*_;ca=B*Z;da=y+$;ea=z+aa;fa=u-ba;ga=v-ca;ha=D*Y;ia=E*X;ja=K-ha;ka=L+ia;la=c[p>>2]|0;ma=c[r>>2]|0;na=ma+(la*12|0)|0;oa=+fa;
pa=+ga;qa=na;ra=qa;g[ra>>2]=oa;sa=qa+4|0;ta=sa;g[ta>>2]=pa;ua=c[p>>2]|0;va=c[r>>2]|0;wa=va+(ua*12|0)+8|0;g[wa>>2]=ja;xa=c[q>>2]|0;ya=va+(xa*12|0)|0;za=+da;Aa=+ea;Ba=ya;Ca=Ba;g[Ca>>2]=za;Da=Ba+4|0;Ea=Da;g[Ea>>2]=Aa;Fa=c[q>>2]|0;Ga=c[r>>2]|0;Ha=Ga+(Fa*12|0)+8|0;g[Ha>>2]=ka;i=e;return}x=b+148|0;M=b+144|0;t=b+140|0;d=b+136|0;V=-(z+L*+g[M>>2]-v-K*+g[d>>2]);g[o>>2]=-(y-L*+g[x>>2]-u+K*+g[t>>2]);g[o+4>>2]=V;Hm(n,b+184|0,o);V=+g[n>>2];o=b+84|0;g[o>>2]=V+ +g[o>>2];U=+g[n+4>>2];n=b+88|0;g[n>>2]=U+ +g[n>>2];
X=U*+g[M>>2]-V*+g[x>>2];Y=U*+g[d>>2]-V*+g[t>>2];Z=U;_=V;$=C*_;aa=C*Z;ba=B*_;ca=B*Z;da=y+$;ea=z+aa;fa=u-ba;ga=v-ca;ha=D*Y;ia=E*X;ja=K-ha;ka=L+ia;la=c[p>>2]|0;ma=c[r>>2]|0;na=ma+(la*12|0)|0;oa=+fa;pa=+ga;qa=na;ra=qa;g[ra>>2]=oa;sa=qa+4|0;ta=sa;g[ta>>2]=pa;ua=c[p>>2]|0;va=c[r>>2]|0;wa=va+(ua*12|0)+8|0;g[wa>>2]=ja;xa=c[q>>2]|0;ya=va+(xa*12|0)|0;za=+da;Aa=+ea;Ba=ya;Ca=Ba;g[Ca>>2]=za;Da=Ba+4|0;Ea=Da;g[Ea>>2]=Aa;Fa=c[q>>2]|0;Ga=c[r>>2]|0;Ha=Ga+(Fa*12|0)+8|0;g[Ha>>2]=ka;i=e;return}function Dh(b,d){b=b|0;
d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0;e=i;f=b+128|0;h=c[f>>2]|0;j=d+28|0;d=c[j>>2]|0;k=d+(h*12|0)|0;l=k;m=+g[l>>2];n=+g[l+4>>2];o=+g[d+(h*12|0)+8>>2];h=b+132|0;l=c[h>>2]|0;p=d+(l*12|0)|0;q=+g[p>>2];r=+g[p+4>>2];s=+g[d+(l*12|0)+8>>2];l=b+176|0;d=b+180|0;if((a[b+112>>0]|0)!=0){t=+g[d>>2];u=+g[l>>2];p=c[b+224>>2]|0;if((p|0)==0|t+u==0){v=u;w=t;x=o;y=s;z=0}else{A=s-o-+g[b+116>>2];if((p|0)==1){B=A-+g[b+
120>>2];C=B+.03490658849477768;D=C<0?C:0;E=-B;F=-(+g[b+220>>2]*(D<-.13962635397911072?-.13962635397911072:D))}else if((p|0)==3){D=A-+g[b+120>>2];B=D<.13962635397911072?D:.13962635397911072;D=B<-.13962635397911072?-.13962635397911072:B;B=-(+g[b+220>>2]*D);if(D>0){E=D;F=B}else{E=-D;F=B}}else if((p|0)==2){B=A-+g[b+124>>2];A=B+-.03490658849477768;D=A<.13962635397911072?A:.13962635397911072;E=B;F=-(+g[b+220>>2]*(D<0?0:D))}else{E=0;F=0}v=u;w=t;x=o-F*u;y=s+F*t;z=E}}else{v=+g[l>>2];w=+g[d>>2];x=o;y=s;z=0}s=
+T(+x);o=+S(+x);E=+T(+y);t=+S(+y);F=+g[b+68>>2]-+g[b+152>>2];u=+g[b+72>>2]-+g[b+156>>2];D=o*F-s*u;B=s*F+o*u;u=+g[b+76>>2]-+g[b+160>>2];o=+g[b+80>>2]-+g[b+164>>2];F=t*u-E*o;s=E*u+t*o;o=q+F-m-D;t=r+s-n-B;u=+Q(+(o*o+t*t));E=+g[b+168>>2];A=+g[b+172>>2];C=E+A;G=C+B*B*v+s*s*w;H=D*v;I=F*w;J=-(B*H)-s*I;K=C+D*H+F*I;I=G*K-J*J;if(I!=0)L=1/I;else L=I;I=-((o*K-t*J)*L);K=-((t*G-o*J)*L);L=+(m-E*I);m=+(n-E*K);b=k;g[b>>2]=L;g[b+4>>2]=m;b=c[j>>2]|0;g[b+((c[f>>2]|0)*12|0)+8>>2]=x-v*(D*K-B*I);B=+(q+A*I);q=+(r+A*K);f=
b+((c[h>>2]|0)*12|0)|0;g[f>>2]=B;g[f+4>>2]=q;g[(c[j>>2]|0)+((c[h>>2]|0)*12|0)+8>>2]=y+w*(F*K-s*I);if(!(u<=.004999999888241291)){M=0;i=e;return M|0}M=z<=.03490658849477768;i=e;return M|0}function Eh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+68>>2];h=+g[d+20>>2];i=+g[b+72>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Fh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+76>>2];h=+g[d+20>>2];i=
+g[b+80>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Gh(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+88>>2]*c;g[a>>2]=+g[b+84>>2]*c;g[a+4>>2]=d;return}function Hh(a,b){a=a|0;b=+b;return+(+g[a+92>>2]*b)}function Ih(a){a=a|0;return+(+g[(c[a+52>>2]|0)+72>>2]-+g[(c[a+48>>2]|0)+72>>2]-+g[a+116>>2])}function Jh(b){b=b|0;return(a[b+100>>0]|0)!=0|0}function Kh(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0;h=i;j=c[d+48>>2]|0;k=j+4|0;l=e[k>>1]|0;if((l&2|0)==0){b[k>>1]=l|2;g[j+
160>>2]=0}j=c[d+52>>2]|0;l=j+4|0;k=e[l>>1]|0;if((k&2|0)!=0){m=d+100|0;n=f&1;a[m>>0]=n;i=h;return}b[l>>1]=k|2;g[j+160>>2]=0;m=d+100|0;n=f&1;a[m>>0]=n;i=h;return}function Lh(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0,l=0;f=i;h=c[a+48>>2]|0;j=h+4|0;k=e[j>>1]|0;if((k&2|0)==0){b[j>>1]=k|2;g[h+160>>2]=0}h=c[a+52>>2]|0;k=h+4|0;j=e[k>>1]|0;if((j&2|0)!=0){l=a+108|0;g[l>>2]=d;i=f;return}b[k>>1]=j|2;g[h+160>>2]=0;l=a+108|0;g[l>>2]=d;i=f;return}function Mh(b){b=b|0;return(a[b+112>>0]|0)!=0|0}function Nh(f,h){f=f|0;
h=h|0;var j=0,k=0,l=0,m=0,n=0;j=i;k=f+112|0;if((h&1|0)==(d[k>>0]|0|0)){i=j;return}l=c[f+48>>2]|0;m=l+4|0;n=e[m>>1]|0;if((n&2|0)==0){b[m>>1]=n|2;g[l+160>>2]=0}l=c[f+52>>2]|0;n=l+4|0;m=e[n>>1]|0;if((m&2|0)==0){b[n>>1]=m|2;g[l+160>>2]=0}a[k>>0]=h&1;g[f+92>>2]=0;i=j;return}function Oh(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(4416,e);c[e>>2]=f;Rm(4448,e);c[e>>2]=j;Rm(4480,e);c[e>>2]=d[a+61>>0]|0;Rm(4512,e);l=+g[a+72>>2];h[k>>3]=+g[a+68>>
2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(4552,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(4600,e);h[k>>3]=+g[a+116>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4648,e);c[e>>2]=d[a+112>>0]|0;Rm(4680,e);h[k>>3]=+g[a+120>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4712,e);h[k>>3]=+g[a+124>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4744,e);c[e>>2]=d[a+100>>0]|0;Rm(4776,
e);h[k>>3]=+g[a+108>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4808,e);h[k>>3]=+g[a+104>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(4840,e);c[e>>2]=c[a+56>>2];Rm(4872,e);i=b;return}function Ph(a){a=a|0;return}function Qh(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Rh(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;h=i;c[a+8>>2]=b;c[a+12>>2]=d;j=+g[e>>2]-+g[b+12>>2];k=e+4|0;l=+g[k>>2]-+g[b+16>>2];m=b+24|0;n=+g[m>>2];o=b+20|0;p=+g[o>>2];q=+(j*n+l*p);r=+(n*l-j*
p);b=a+20|0;g[b>>2]=q;g[b+4>>2]=r;r=+g[e>>2]-+g[d+12>>2];q=+g[k>>2]-+g[d+16>>2];p=+g[d+24>>2];j=+g[d+20>>2];l=+(r*p+q*j);n=+(p*q-r*j);d=a+28|0;g[d>>2]=l;g[d+4>>2]=n;n=+g[m>>2];l=+g[f>>2];j=+g[o>>2];r=+g[f+4>>2];q=+(n*l+j*r);p=+(n*r-l*j);f=a+36|0;g[f>>2]=q;g[f+4>>2]=p;i=h;return}function Sh(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0;e=i;vh(b,d);c[b>>2]=4968;f=d+20|0;h=c[f+4>>2]|0;j=b+76|0;c[j>>2]=c[f>>2];c[j+4>>2]=h;h=d+28|0;j=c[h+4>>2]|0;f=b+84|0;c[f>>2]=c[h>>2];c[f+4>>2]=j;j=d+36|0;f=c[j>>2]|0;h=c[j+4>>
2]|0;j=b+92|0;c[j>>2]=f;c[j+4>>2]=h;j=b+100|0;g[j>>2]=-(c[k>>2]=h,+g[k>>2]);c[j+4>>2]=f;g[b+204>>2]=0;g[b+108>>2]=0;g[b+208>>2]=0;g[b+112>>2]=0;g[b+212>>2]=0;g[b+116>>2]=0;g[b+120>>2]=+g[d+48>>2];g[b+124>>2]=+g[d+52>>2];a[b+128>>0]=a[d+44>>0]|0;g[b+68>>2]=+g[d+56>>2];g[b+72>>2]=+g[d+60>>2];g[b+216>>2]=0;g[b+220>>2]=0;d=b+172|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;i=e;return}function Th(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,
B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+132|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+136|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+140|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+148|0;c[o>>2]=r;c[o+4>>2]=s;t=+g[f+136>>2];o=b+156|0;
g[o>>2]=t;u=+g[l+136>>2];v=b+160|0;g[v>>2]=u;w=+g[f+144>>2];f=b+164|0;g[f>>2]=w;x=+g[l+144>>2];l=b+168|0;g[l>>2]=x;y=c[d+28>>2]|0;z=y+(h*12|0)|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[y+(h*12|0)+8>>2];z=d+32|0;D=c[z>>2]|0;E=D+(h*12|0)|0;F=+g[E>>2];G=+g[E+4>>2];H=+g[D+(h*12|0)+8>>2];h=y+(m*12|0)|0;I=+g[h>>2];J=+g[h+4>>2];K=+g[y+(m*12|0)+8>>2];y=D+(m*12|0)|0;L=+g[y>>2];M=+g[y+4>>2];N=+g[D+(m*12|0)+8>>2];O=+T(+C);P=+S(+C);C=+T(+K);Q=+S(+K);K=+g[b+76>>2]-(c[k>>2]=p,+g[k>>2]);R=+g[b+80>>2]-(c[k>>2]=q,+g[k>>2]);
U=P*K-O*R;V=O*K+P*R;R=+g[b+84>>2]-(c[k>>2]=r,+g[k>>2]);K=+g[b+88>>2]-(c[k>>2]=s,+g[k>>2]);W=Q*R-C*K;X=C*R+Q*K;K=I+W-A-U;A=J+X-B-V;B=+g[b+100>>2];J=+g[b+104>>2];I=P*B-O*J;Q=O*B+P*J;J=+I;B=+Q;s=b+180|0;g[s>>2]=J;g[s+4>>2]=B;B=U+K;U=V+A;V=Q*B-I*U;g[b+196>>2]=V;J=W*Q-X*I;g[b+200>>2]=J;R=t+u;u=R+V*w*V+J*x*J;if(u>0)Y=1/u;else Y=u;g[b+204>>2]=Y;s=b+212|0;g[s>>2]=0;r=b+216|0;g[r>>2]=0;q=b+220|0;g[q>>2]=0;Y=+g[b+68>>2];if(Y>0){u=+g[b+92>>2];t=+g[b+96>>2];C=P*u-O*t;Z=O*u+P*t;t=+C;P=+Z;p=b+172|0;g[p>>2]=t;g[p+
4>>2]=P;P=B*Z-U*C;g[b+188>>2]=P;U=W*Z-X*C;g[b+192>>2]=U;X=R+P*w*P+U*x*U;if(X>0){U=1/X;g[s>>2]=U;P=Y*6.2831854820251465;Y=P*U*P;R=+g[d>>2];W=R*(P*U*2*+g[b+72>>2]+R*Y);if(W>0)_=1/W;else _=W;g[q>>2]=_;g[r>>2]=(K*C+A*Z)*R*Y*_;Y=X+_;g[s>>2]=Y;if(Y>0)g[s>>2]=1/Y}}else g[b+116>>2]=0;if((a[b+128>>0]|0)!=0){Y=x+w;s=b+208|0;g[s>>2]=Y;if(Y>0)g[s>>2]=1/Y}else{g[b+208>>2]=0;g[b+112>>2]=0}if((a[d+24>>0]|0)==0){g[b+108>>2]=0;g[b+116>>2]=0;g[b+112>>2]=0;$=F;aa=G;ba=L;ca=M;da=H;ea=N;fa=c[j>>2]|0;ga=c[z>>2]|0;ha=ga+
(fa*12|0)|0;ia=+$;ja=+aa;ka=ha;la=ka;g[la>>2]=ia;ma=ka+4|0;na=ma;g[na>>2]=ja;oa=c[j>>2]|0;pa=c[z>>2]|0;qa=pa+(oa*12|0)+8|0;g[qa>>2]=da;ra=c[n>>2]|0;sa=pa+(ra*12|0)|0;ta=+ba;ua=+ca;va=sa;wa=va;g[wa>>2]=ta;xa=va+4|0;ya=xa;g[ya>>2]=ua;za=c[n>>2]|0;Aa=c[z>>2]|0;Ba=Aa+(za*12|0)+8|0;g[Ba>>2]=ea;i=e;return}else{s=d+8|0;d=b+108|0;Y=+g[s>>2]*+g[d>>2];g[d>>2]=Y;d=b+116|0;w=+g[s>>2]*+g[d>>2];g[d>>2]=w;d=b+112|0;x=+g[s>>2]*+g[d>>2];g[d>>2]=x;_=Y*I+w*+g[b+172>>2];I=Y*Q+w*+g[b+176>>2];Q=+g[o>>2];X=+g[v>>2];$=F-
_*Q;aa=G-I*Q;ba=L+_*X;ca=M+I*X;da=H-(x+(Y*V+w*+g[b+188>>2]))*+g[f>>2];ea=N+(x+(Y*J+w*+g[b+192>>2]))*+g[l>>2];fa=c[j>>2]|0;ga=c[z>>2]|0;ha=ga+(fa*12|0)|0;ia=+$;ja=+aa;ka=ha;la=ka;g[la>>2]=ia;ma=ka+4|0;na=ma;g[na>>2]=ja;oa=c[j>>2]|0;pa=c[z>>2]|0;qa=pa+(oa*12|0)+8|0;g[qa>>2]=da;ra=c[n>>2]|0;sa=pa+(ra*12|0)|0;ta=+ba;ua=+ca;va=sa;wa=va;g[wa>>2]=ta;xa=va+4|0;ya=xa;g[ya>>2]=ua;za=c[n>>2]|0;Aa=c[z>>2]|0;Ba=Aa+(za*12|0)+8|0;g[Ba>>2]=ea;i=e;return}}function Uh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=
0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;d=i;e=+g[a+156>>2];f=+g[a+160>>2];h=+g[a+164>>2];j=+g[a+168>>2];k=a+132|0;l=c[k>>2]|0;m=b+32|0;n=c[m>>2]|0;o=n+(l*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[n+(l*12|0)+8>>2];l=a+136|0;o=c[l>>2]|0;s=n+(o*12|0)|0;t=+g[s>>2];u=+g[s+4>>2];v=+g[n+(o*12|0)+8>>2];w=+g[a+172>>2];x=+g[a+176>>2];y=+g[a+192>>2];z=+g[a+188>>2];o=a+116|0;A=+g[o>>2];B=+g[a+212>>2]*(+g[a+216>>2]+(v*y+(w*(t-p)+x*(u-q))-r*z)+ +g[a+220>>2]*A);C=-B;g[o>>2]=A-B;B=w*C;w=
x*C;x=p-e*B;p=q-e*w;q=r-h*z*C;z=t+f*B;B=u+f*w;w=v+j*y*C;o=a+112|0;C=+g[o>>2];y=+g[b>>2]*+g[a+120>>2];v=C-+g[a+208>>2]*(w-q-+g[a+124>>2]);u=-y;t=v<y?v:y;y=t<u?u:t;g[o>>2]=y;t=y-C;C=q-h*t;q=w+j*t;t=+g[a+180>>2];w=+g[a+184>>2];y=+g[a+200>>2];u=+g[a+196>>2];v=+g[a+204>>2]*((z-x)*t+(B-p)*w+y*q-u*C);r=-v;o=a+108|0;g[o>>2]=+g[o>>2]-v;v=t*r;t=w*r;w=+(x-e*v);x=+(p-e*t);o=(c[m>>2]|0)+((c[k>>2]|0)*12|0)|0;g[o>>2]=w;g[o+4>>2]=x;o=c[m>>2]|0;g[o+((c[k>>2]|0)*12|0)+8>>2]=C-h*u*r;u=+(z+f*v);v=+(B+f*t);k=o+((c[l>>
2]|0)*12|0)|0;g[k>>2]=u;g[k+4>>2]=v;g[(c[m>>2]|0)+((c[l>>2]|0)*12|0)+8>>2]=q+j*y*r;i=d;return}function Vh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;d=i;e=a+132|0;f=c[e>>2]|0;h=b+28|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=+g[j>>2];l=+g[j+4>>2];m=+g[b+(f*12|0)+8>>2];f=a+136|0;j=c[f>>2]|0;n=b+(j*12|0)|0;o=+g[n>>2];p=+g[n+4>>2];q=+g[b+(j*12|0)+8>>2];r=+T(+m);s=+S(+m);t=+T(+q);u=+S(+q);v=+g[a+76>>2]-+g[a+140>>
2];w=+g[a+80>>2]-+g[a+144>>2];x=s*v-r*w;y=r*v+s*w;w=+g[a+84>>2]-+g[a+148>>2];v=+g[a+88>>2]-+g[a+152>>2];z=u*w-t*v;A=t*w+u*v;v=o-k+z-x;u=p-l+A-y;w=+g[a+100>>2];t=+g[a+104>>2];B=s*w-r*t;C=r*w+s*t;t=B*v+C*u;s=+g[a+156>>2];w=+g[a+160>>2];r=+g[a+164>>2];D=+g[a+196>>2];E=+g[a+168>>2];F=+g[a+200>>2];G=s+w+D*r*D+F*E*F;if(G!=0)H=-t/G;else H=0;G=B*H;F=C*H;D=+(k-G*s);k=+(l-F*s);a=(c[h>>2]|0)+((c[e>>2]|0)*12|0)|0;g[a>>2]=D;g[a+4>>2]=k;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=m-(C*(x+v)-B*(y+u))*H*r;r=+(o+G*w);
G=+(p+F*w);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=r;g[e+4>>2]=G;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=q+(z*C-A*B)*H*E;if(t>0){I=t;J=I<=.004999999888241291;i=d;return J|0}I=-t;J=I<=.004999999888241291;i=d;return J|0}function Wh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+76>>2];h=+g[d+20>>2];i=+g[b+80>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Xh(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+
84>>2];h=+g[d+20>>2];i=+g[b+88>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Yh(a,b,c){a=a|0;b=b|0;c=+c;var d=0,e=0,f=0;d=+g[b+108>>2];e=+g[b+116>>2];f=(d*+g[b+184>>2]+e*+g[b+176>>2])*c;g[a>>2]=(d*+g[b+180>>2]+e*+g[b+172>>2])*c;g[a+4>>2]=f;return}function Zh(a,b){a=a|0;b=+b;return+(+g[a+112>>2]*b)}function _h(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0,l=0;f=i;h=c[a+48>>2]|0;j=h+4|0;k=e[j>>1]|0;if((k&2|0)==0){b[j>>1]=k|2;g[h+160>>2]=0}h=c[a+52>>2]|0;k=h+4|0;j=e[k>>1]|
0;if((j&2|0)!=0){l=a+124|0;g[l>>2]=d;i=f;return}b[k>>1]=j|2;g[h+160>>2]=0;l=a+124|0;g[l>>2]=d;i=f;return}function $h(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(5016,e);c[e>>2]=f;Rm(5040,e);c[e>>2]=j;Rm(5072,e);c[e>>2]=d[a+61>>0]|0;Rm(5104,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5144,e);l=+g[a+88>>2];h[k>>3]=+g[a+84>>2];c[e>>2]=c[k>>2];c[e+4>>2]=
c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5192,e);l=+g[a+96>>2];h[k>>3]=+g[a+92>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5240,e);c[e>>2]=d[a+128>>0]|0;Rm(5280,e);h[k>>3]=+g[a+124>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5312,e);h[k>>3]=+g[a+120>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5344,e);h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5376,e);h[k>>3]=+g[a+72>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];
Rm(5408,e);c[e>>2]=c[a+56>>2];Rm(5440,e);i=b;return}function ai(a){a=a|0;return}function bi(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function ci(a,b,d,e,f,h,j,k){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;h=h|0;j=j|0;k=+k;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0;l=i;c[a+8>>2]=b;c[a+12>>2]=d;m=e;n=c[m+4>>2]|0;o=a+20|0;c[o>>2]=c[m>>2];c[o+4>>2]=n;n=f;o=c[n+4>>2]|0;m=a+28|0;c[m>>2]=c[n>>2];c[m+4>>2]=o;p=+g[h>>2]-+g[b+12>>2];o=h+4|0;q=+g[o>>2]-+g[b+16>>2];r=+g[b+24>>2];s=+g[b+20>>2];t=+(p*r+q*s);u=+(r*q-p*s);b=a+
36|0;g[b>>2]=t;g[b+4>>2]=u;u=+g[j>>2]-+g[d+12>>2];b=j+4|0;t=+g[b>>2]-+g[d+16>>2];s=+g[d+24>>2];p=+g[d+20>>2];q=+(u*s+t*p);r=+(s*t-u*p);d=a+44|0;g[d>>2]=q;g[d+4>>2]=r;r=+g[h>>2]-+g[e>>2];q=+g[o>>2]-+g[e+4>>2];g[a+52>>2]=+Q(+(r*r+q*q));q=+g[j>>2]-+g[f>>2];r=+g[b>>2]-+g[f+4>>2];g[a+56>>2]=+Q(+(q*q+r*r));g[a+60>>2]=k;i=l;return}function di(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0;d=i;vh(a,b);c[a>>2]=5528;e=b+20|0;f=c[e+4>>2]|0;h=a+68|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+28|0;h=c[f+4>>2]|0;e=a+76|0;c[e>>
2]=c[f>>2];c[e+4>>2]=h;h=b+36|0;e=c[h+4>>2]|0;f=a+92|0;c[f>>2]=c[h>>2];c[f+4>>2]=e;e=b+44|0;f=c[e+4>>2]|0;h=a+100|0;c[h>>2]=c[e>>2];c[h+4>>2]=f;f=b+52|0;g[a+84>>2]=+g[f>>2];h=b+56|0;g[a+88>>2]=+g[h>>2];j=+g[b+60>>2];g[a+112>>2]=j;g[a+108>>2]=+g[f>>2]+j*+g[h>>2];g[a+116>>2]=0;i=d;return}function ei(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,
ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0;e=i;f=c[b+48>>2]|0;h=c[f+8>>2]|0;j=b+120|0;c[j>>2]=h;l=c[b+52>>2]|0;m=c[l+8>>2]|0;n=b+124|0;c[n>>2]=m;o=f+44|0;p=c[o>>2]|0;q=c[o+4>>2]|0;o=b+160|0;c[o>>2]=p;c[o+4>>2]=q;o=l+44|0;r=c[o>>2]|0;s=c[o+4>>2]|0;o=b+168|0;c[o>>2]=r;c[o+4>>2]=s;s=b+176|0;g[s>>2]=+g[f+136>>2];o=b+180|0;g[o>>2]=+g[l+136>>2];t=b+184|0;g[t>>2]=+g[f+144>>2];f=b+188|0;g[f>>2]=+g[l+144>>2];l=c[d+28>>2]|0;u=l+(h*12|0)|
0;v=+g[u>>2];w=+g[u+4>>2];x=+g[l+(h*12|0)+8>>2];u=d+32|0;y=c[u>>2]|0;z=y+(h*12|0)|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[y+(h*12|0)+8>>2];h=l+(m*12|0)|0;D=+g[h>>2];E=+g[h+4>>2];F=+g[l+(m*12|0)+8>>2];l=y+(m*12|0)|0;G=+g[l>>2];H=+g[l+4>>2];I=+g[y+(m*12|0)+8>>2];J=+T(+x);K=+S(+x);x=+T(+F);L=+S(+F);m=b+144|0;F=+g[b+92>>2]-(c[k>>2]=p,+g[k>>2]);M=+g[b+96>>2]-(c[k>>2]=q,+g[k>>2]);N=K*F-J*M;O=J*F+K*M;M=+N;K=+O;q=m;g[q>>2]=M;g[q+4>>2]=K;K=+g[b+100>>2]-(c[k>>2]=r,+g[k>>2]);M=+g[b+104>>2]-+g[b+172>>2];F=L*K-x*M;J=x*
K+L*M;M=+F;L=+J;r=b+152|0;g[r>>2]=M;g[r+4>>2]=L;r=b+128|0;L=v+N-+g[b+68>>2];N=w+O-+g[b+72>>2];O=+L;w=+N;q=r;g[q>>2]=O;g[q+4>>2]=w;q=b+136|0;w=D+F-+g[b+76>>2];D=E+J-+g[b+80>>2];E=+w;O=+D;p=q;g[p>>2]=E;g[p+4>>2]=O;O=+Q(+(L*L+N*N));E=+Q(+(w*w+D*D));if(O>.04999999701976776){v=1/O;O=L*v;g[r>>2]=O;P=v*N;R=O}else{g[r>>2]=0;P=0;R=0}g[b+132>>2]=P;if(E>.04999999701976776){O=1/E;E=O*w;g[q>>2]=E;U=O*D;V=E}else{g[q>>2]=0;U=0;V=0}g[b+140>>2]=U;E=+g[m>>2];D=+g[b+148>>2];O=E*P-D*R;w=F*U-J*V;N=+g[s>>2];v=+g[t>>2];
L=+g[o>>2];M=+g[f>>2];K=+g[b+112>>2];x=N+O*O*v+K*K*(L+w*w*M);if(x>0)W=1/x;else W=x;g[b+192>>2]=W;if((a[d+24>>0]|0)==0){g[b+116>>2]=0;X=A;Y=B;Z=G;_=H;$=C;aa=I;ba=c[j>>2]|0;ca=c[u>>2]|0;da=ca+(ba*12|0)|0;ea=+X;fa=+Y;ga=da;ha=ga;g[ha>>2]=ea;ia=ga+4|0;ja=ia;g[ja>>2]=fa;ka=c[j>>2]|0;la=c[u>>2]|0;ma=la+(ka*12|0)+8|0;g[ma>>2]=$;na=c[n>>2]|0;oa=la+(na*12|0)|0;pa=+Z;qa=+_;ra=oa;sa=ra;g[sa>>2]=pa;ta=ra+4|0;ua=ta;g[ua>>2]=qa;va=c[n>>2]|0;wa=c[u>>2]|0;xa=wa+(va*12|0)+8|0;g[xa>>2]=aa;i=e;return}else{f=b+116|0;
W=+g[d+8>>2]*+g[f>>2];g[f>>2]=W;x=-W;w=R*x;R=P*x;x=-(W*K);K=V*x;V=U*x;X=A+w*N;Y=B+R*N;Z=G+K*L;_=H+V*L;$=C+v*(R*E-w*D);aa=I+M*(V*F-K*J);ba=c[j>>2]|0;ca=c[u>>2]|0;da=ca+(ba*12|0)|0;ea=+X;fa=+Y;ga=da;ha=ga;g[ha>>2]=ea;ia=ga+4|0;ja=ia;g[ja>>2]=fa;ka=c[j>>2]|0;la=c[u>>2]|0;ma=la+(ka*12|0)+8|0;g[ma>>2]=$;na=c[n>>2]|0;oa=la+(na*12|0)|0;pa=+Z;qa=+_;ra=oa;sa=ra;g[sa>>2]=pa;ta=ra+4|0;ua=ta;g[ua>>2]=qa;va=c[n>>2]|0;wa=c[u>>2]|0;xa=wa+(va*12|0)+8|0;g[xa>>2]=aa;i=e;return}}function fi(a,b){a=a|0;b=b|0;var d=0,
e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;d=i;e=a+120|0;f=c[e>>2]|0;h=b+32|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+124|0;k=c[f>>2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(k*12|0)+8>>2];s=+g[a+148>>2];t=+g[a+144>>2];u=+g[a+156>>2];v=+g[a+152>>2];w=+g[a+128>>2];x=+g[a+132>>2];y=+g[a+112>>2];z=+g[a+136>>2];A=+g[a+140>>2];B=+g[a+192>>2]*(-((l-n*s)*w+(m+n*t)*x)-y*((p-r*u)*z+(q+r*v)*A));k=a+116|0;g[k>>
2]=+g[k>>2]-B;C=w*B;w=x*B;x=y*B;B=z*x;z=x*A;A=+g[a+176>>2];x=n+ +g[a+184>>2]*(w*t-C*s);s=+g[a+180>>2];t=r+ +g[a+188>>2]*(z*v-B*u);u=+(l+C*A);C=+(m+w*A);a=j;g[a>>2]=u;g[a+4>>2]=C;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=x;x=+(p+B*s);B=+(q+z*s);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=x;g[e+4>>2]=B;g[(c[h>>2]|0)+((c[f>>2]|0)*12|0)+8>>2]=t;i=d;return}function gi(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=
0,L=0;d=i;e=a+120|0;f=c[e>>2]|0;h=b+28|0;b=c[h>>2]|0;j=b+(f*12|0)|0;k=j;l=+g[k>>2];m=+g[k+4>>2];n=+g[b+(f*12|0)+8>>2];f=a+124|0;k=c[f>>2]|0;o=b+(k*12|0)|0;p=+g[o>>2];q=+g[o+4>>2];r=+g[b+(k*12|0)+8>>2];s=+T(+n);t=+S(+n);u=+T(+r);v=+S(+r);w=+g[a+92>>2]-+g[a+160>>2];x=+g[a+96>>2]-+g[a+164>>2];y=t*w-s*x;z=s*w+t*x;x=+g[a+100>>2]-+g[a+168>>2];t=+g[a+104>>2]-+g[a+172>>2];w=v*x-u*t;s=u*x+v*t;t=l+y-+g[a+68>>2];v=m+z-+g[a+72>>2];x=p+w-+g[a+76>>2];u=q+s-+g[a+80>>2];A=+Q(+(t*t+v*v));B=+Q(+(x*x+u*u));if(A>.04999999701976776){C=
1/A;D=v*C;E=t*C}else{D=0;E=0}if(B>.04999999701976776){C=1/B;F=u*C;G=x*C}else{F=0;G=0}C=y*D-z*E;x=w*F-s*G;u=+g[a+176>>2];t=+g[a+184>>2];v=+g[a+180>>2];H=+g[a+188>>2];I=+g[a+112>>2];J=u+C*C*t+I*I*(v+x*x*H);if(J>0)K=1/J;else K=J;J=+g[a+108>>2]-A-B*I;if(J>0)L=J;else L=-J;B=K*J;J=E*B;E=D*B;D=B*I;I=G*D;G=F*D;D=+(l+J*u);l=+(m+E*u);a=j;g[a>>2]=D;g[a+4>>2]=l;a=c[h>>2]|0;g[a+((c[e>>2]|0)*12|0)+8>>2]=n+(y*E-z*J)*t;t=+(p+I*v);p=+(q+G*v);e=a+((c[f>>2]|0)*12|0)|0;g[e>>2]=t;g[e+4>>2]=p;g[(c[h>>2]|0)+((c[f>>2]|0)*
12|0)+8>>2]=r+H*(w*G-s*I);i=d;return L<.004999999888241291|0}function hi(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+48>>2]|0;e=+g[d+24>>2];f=+g[b+92>>2];h=+g[d+20>>2];i=+g[b+96>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function ii(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+100>>2];h=+g[d+20>>2];i=+g[b+104>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function ji(a,b,c){a=a|0;b=b|0;c=+c;var d=
0,e=0;d=+g[b+116>>2];e=d*+g[b+140>>2]*c;g[a>>2]=d*+g[b+136>>2]*c;g[a+4>>2]=e;return}function ki(a,b){a=a|0;b=+b;return 0}function li(a){a=a|0;var b=0,e=0,f=0,j=0,l=0;b=i;i=i+16|0;e=b;f=c[(c[a+48>>2]|0)+8>>2]|0;j=c[(c[a+52>>2]|0)+8>>2]|0;Rm(5576,e);c[e>>2]=f;Rm(5600,e);c[e>>2]=j;Rm(5632,e);c[e>>2]=d[a+61>>0]|0;Rm(5664,e);l=+g[a+72>>2];h[k>>3]=+g[a+68>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5704,e);l=+g[a+80>>2];h[k>>3]=+g[a+76>>2];c[e>>2]=c[k>>
2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5752,e);l=+g[a+96>>2];h[k>>3]=+g[a+92>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5800,e);l=+g[a+104>>2];h[k>>3]=+g[a+100>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];j=e+8|0;h[k>>3]=l;c[j>>2]=c[k>>2];c[j+4>>2]=c[k+4>>2];Rm(5848,e);h[k>>3]=+g[a+84>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5896,e);h[k>>3]=+g[a+88>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5928,e);h[k>>3]=
+g[a+112>>2];c[e>>2]=c[k>>2];c[e+4>>2]=c[k+4>>2];Rm(5960,e);c[e>>2]=c[a+56>>2];Rm(5984,e);i=b;return}function mi(a,b){a=a|0;b=b|0;var c=0,d=0;c=a+68|0;g[c>>2]=+g[c>>2]-+g[b>>2];c=b+4|0;d=a+72|0;g[d>>2]=+g[d>>2]-+g[c>>2];d=a+76|0;g[d>>2]=+g[d>>2]-+g[b>>2];b=a+80|0;g[b>>2]=+g[b>>2]-+g[c>>2];return}function ni(a){a=a|0;return}function oi(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function pi(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0;g=i;h=Em(f,148)|0;if((h|0)==0){j=0;i=g;return j|0}wi(h,a,
b,d,e);c[h>>2]=6072;j=h;i=g;return j|0}function qi(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function ri(a,d,e,f){a=a|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0;h=i;i=i+48|0;j=h;k=c[(c[a+48>>2]|0)+12>>2]|0;c[j>>2]=488;c[j+4>>2]=1;g[j+8>>2]=.009999999776482582;l=j+28|0;c[l+0>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;b[l+16>>1]=0;Ge(k,j,c[a+56>>2]|0);ff(d,j,e,c[(c[a+52>>2]|0)+12>>2]|0,f);i=h;return}function si(a){a=a|0;return}function ti(a){a=a|0;var b=0;b=i;sn(a);
i=b;return}function ui(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0;h=i;if((a[6352]|0)==0){c[1540]=6;c[6164>>2]=53;a[6168>>0]=1;c[6256>>2]=7;c[6260>>2]=54;a[6264>>0]=1;c[6184>>2]=7;c[6188>>2]=54;a[6192>>0]=0;c[6280>>2]=8;c[6284>>2]=55;a[6288>>0]=1;c[6208>>2]=9;c[6212>>2]=56;a[6216>>0]=1;c[6172>>2]=9;c[6176>>2]=56;a[6180>>0]=0;c[6232>>2]=10;c[6236>>2]=57;a[6240>>0]=1;c[6268>>2]=10;c[6272>>2]=57;a[6276>>0]=0;c[6304>>2]=11;c[6308>>2]=58;a[6312>>0]=1;c[6196>>2]=11;c[6200>>2]=58;a[6204>>
0]=0;c[6328>>2]=12;c[6332>>2]=59;a[6336>>0]=1;c[6292>>2]=12;c[6296>>2]=59;a[6300>>0]=0;a[6352]=1}j=c[(c[b+12>>2]|0)+4>>2]|0;k=c[(c[e+12>>2]|0)+4>>2]|0;l=c[6160+(j*48|0)+(k*12|0)>>2]|0;if((l|0)==0){m=0;i=h;return m|0}if((a[6160+(j*48|0)+(k*12|0)+8>>0]|0)==0){m=ob[l&15](e,f,b,d,g)|0;i=h;return m|0}else{m=ob[l&15](b,d,e,f,g)|0;i=h;return m|0}return 0}function vi(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0;h=i;j=c[d+48>>2]|0;k=c[d+52>>2]|0;if(((c[d+124>>2]|0)>0?(a[j+38>>0]|0)==0:0)?(a[k+38>>0]|0)==0:
0){l=c[j+8>>2]|0;m=l+4|0;n=e[m>>1]|0;if((n&2|0)==0){b[m>>1]=n|2;g[l+160>>2]=0}l=c[k+8>>2]|0;n=l+4|0;m=e[n>>1]|0;if((m&2|0)==0){b[n>>1]=m|2;g[l+160>>2]=0}}gb[c[6160+((c[(c[j+12>>2]|0)+4>>2]|0)*48|0)+((c[(c[k+12>>2]|0)+4>>2]|0)*12|0)+4>>2]&63](d,f);i=h;return}function wi(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0;h=i;c[a>>2]=6368;c[a+4>>2]=4;c[a+48>>2]=b;c[a+52>>2]=e;c[a+56>>2]=d;c[a+60>>2]=f;c[a+124>>2]=0;c[a+128>>2]=0;f=b+16|0;d=a+8|0;j=d+40|0;do{c[d>>2]=0;d=d+4|0}while((d|0)<(j|
0));g[a+136>>2]=+Q(+(+g[f>>2]*+g[e+16>>2]));k=+g[b+20>>2];l=+g[e+20>>2];g[a+140>>2]=k>l?k:l;g[a+144>>2]=0;i=h;return}function xi(d,f){d=d|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;h=i;i=i+64|0;j=h;k=d+64|0;l=j+0|0;m=k+0|0;n=l+64|0;do{c[l>>2]=c[m>>2];l=l+4|0;m=m+4|0}while((l|0)<(n|0));m=d+4|0;l=c[m>>2]|0;c[m>>2]=l|4;n=l>>>1;l=c[d+48>>2]|0;o=c[d+52>>2]|0;p=(a[o+38>>0]|a[l+38>>0])<<24>>24!=0;q=c[l+8>>2]|0;r=c[o+8>>2]|0;s=q+12|0;t=r+12|0;if(!p){pb[c[c[d>>
2]>>2]&31](d,k,s,t);k=d+124|0;u=(c[k>>2]|0)>0;a:do if(u){v=c[j+60>>2]|0;if((v|0)>0)w=0;else{x=0;while(1){g[d+(x*20|0)+72>>2]=0;g[d+(x*20|0)+76>>2]=0;x=x+1|0;if((x|0)>=(c[k>>2]|0))break a}}do{x=d+(w*20|0)+72|0;g[x>>2]=0;y=d+(w*20|0)+76|0;g[y>>2]=0;z=c[d+(w*20|0)+80>>2]|0;A=0;while(1){B=A+1|0;if((c[j+(A*20|0)+16>>2]|0)==(z|0)){C=7;break}if((B|0)<(v|0))A=B;else break}if((C|0)==7){C=0;g[x>>2]=+g[j+(A*20|0)+8>>2];g[y>>2]=+g[j+(A*20|0)+12>>2]}w=w+1|0}while((w|0)<(c[k>>2]|0))}while(0);k=n&1;if(u^(k|0)!=
0){w=q+4|0;C=e[w>>1]|0;if((C&2|0)==0){b[w>>1]=C|2;g[q+160>>2]=0}q=r+4|0;C=e[q>>1]|0;if((C&2|0)==0){b[q>>1]=C|2;g[r+160>>2]=0;D=k;E=u}else{D=k;E=u}}else{D=k;E=u}}else{u=lf(c[l+12>>2]|0,c[d+56>>2]|0,c[o+12>>2]|0,c[d+60>>2]|0,s,t)|0;c[d+124>>2]=0;D=n&1;E=u}u=c[m>>2]|0;c[m>>2]=E?u|2:u&-3;u=(D|0)==0;D=E^1;m=(f|0)==0;if(!(u^1|D|m))gb[c[(c[f>>2]|0)+8>>2]&63](f,d);if(!(u|E|m))gb[c[(c[f>>2]|0)+12>>2]&63](f,d);if(p|D|m){i=h;return}ib[c[(c[f>>2]|0)+32>>2]&7](f,d,j);i=h;return}function yi(a){a=a|0;return}function zi(a){a=
a|0;var b=0;b=i;sn(a);i=b;return}function Ai(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0;e=i;b=Em(f,148)|0;if((b|0)==0){g=0;i=e;return g|0}wi(b,a,0,d,0);c[b>>2]=6392;g=b;i=e;return g|0}function Bi(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function Ci(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;Ue(b,c[(c[a+48>>2]|0)+12>>2]|0,d,c[(c[a+52>>2]|0)+12>>2]|0,e);i=f;return}function Di(a){a=a|0;return}function Ei(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Fi(a,
b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0;e=i;b=Em(f,148)|0;if((b|0)==0){g=0;i=e;return g|0}wi(b,a,0,d,0);c[b>>2]=6464;g=b;i=e;return g|0}function Gi(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function Hi(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;Te(b,c[(c[a+48>>2]|0)+12>>2]|0,d,c[(c[a+52>>2]|0)+12>>2]|0,e);i=f;return}function Ii(a){a=a|0;return}function Ji(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Ki(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=
0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;e=i;c[b+0>>2]=c[d+0>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];c[b+12>>2]=c[d+12>>2];c[b+16>>2]=c[d+16>>2];c[b+20>>2]=c[d+20>>2];c[b+24>>2]=c[d+24>>2];f=c[d+44>>2]|0;h=b+36|0;c[h>>2]=f;j=c[d+32>>2]|0;k=b+52|0;c[k>>2]=j;l=b+40|0;c[l>>2]=Ym(f,j*88|0)|0;j=Ym(c[h>>2]|0,(c[k>>2]|0)*156|0)|0;h=b+44|0;c[h>>2]=j;c[b+28>>2]=c[d+36>>2];c[b+32>>2]=c[d+40>>2];f=c[d+28>>2]|0;d=b+48|0;c[d>>2]=f;if((c[k>>2]|0)<=0){i=e;return}m=b+24|0;n=b+8|0;b=f;f=j;
j=0;while(1){o=c[b+(j<<2)>>2]|0;p=c[o+48>>2]|0;q=c[o+52>>2]|0;r=+g[(c[p+12>>2]|0)+8>>2];s=+g[(c[q+12>>2]|0)+8>>2];t=c[p+8>>2]|0;p=c[q+8>>2]|0;q=c[o+124>>2]|0;g[f+(j*156|0)+136>>2]=+g[o+136>>2];g[f+(j*156|0)+140>>2]=+g[o+140>>2];g[f+(j*156|0)+144>>2]=+g[o+144>>2];u=t+8|0;c[f+(j*156|0)+112>>2]=c[u>>2];v=p+8|0;c[f+(j*156|0)+116>>2]=c[v>>2];w=t+136|0;g[f+(j*156|0)+120>>2]=+g[w>>2];x=p+136|0;g[f+(j*156|0)+124>>2]=+g[x>>2];y=t+144|0;g[f+(j*156|0)+128>>2]=+g[y>>2];z=p+144|0;g[f+(j*156|0)+132>>2]=+g[z>>2];
c[f+(j*156|0)+152>>2]=j;c[f+(j*156|0)+148>>2]=q;A=f+(j*156|0)+80|0;c[A+0>>2]=0;c[A+4>>2]=0;c[A+8>>2]=0;c[A+12>>2]=0;c[A+16>>2]=0;c[A+20>>2]=0;c[A+24>>2]=0;c[A+28>>2]=0;A=c[l>>2]|0;c[A+(j*88|0)+32>>2]=c[u>>2];c[A+(j*88|0)+36>>2]=c[v>>2];g[A+(j*88|0)+40>>2]=+g[w>>2];g[A+(j*88|0)+44>>2]=+g[x>>2];x=t+44|0;t=c[x+4>>2]|0;w=A+(j*88|0)+48|0;c[w>>2]=c[x>>2];c[w+4>>2]=t;t=p+44|0;p=c[t+4>>2]|0;w=A+(j*88|0)+56|0;c[w>>2]=c[t>>2];c[w+4>>2]=p;g[A+(j*88|0)+64>>2]=+g[y>>2];g[A+(j*88|0)+68>>2]=+g[z>>2];z=o+104|0;y=
c[z+4>>2]|0;p=A+(j*88|0)+16|0;c[p>>2]=c[z>>2];c[p+4>>2]=y;y=o+112|0;p=c[y+4>>2]|0;z=A+(j*88|0)+24|0;c[z>>2]=c[y>>2];c[z+4>>2]=p;c[A+(j*88|0)+84>>2]=q;g[A+(j*88|0)+76>>2]=r;g[A+(j*88|0)+80>>2]=s;c[A+(j*88|0)+72>>2]=c[o+120>>2];if((q|0)>0){p=0;do{z=o+(p*20|0)+64|0;if((a[m>>0]|0)==0){g[f+(j*156|0)+(p*36|0)+16>>2]=0;g[f+(j*156|0)+(p*36|0)+20>>2]=0}else{g[f+(j*156|0)+(p*36|0)+16>>2]=+g[n>>2]*+g[o+(p*20|0)+72>>2];g[f+(j*156|0)+(p*36|0)+20>>2]=+g[n>>2]*+g[o+(p*20|0)+76>>2]}y=f+(j*156|0)+(p*36|0)|0;g[f+(j*
156|0)+(p*36|0)+24>>2]=0;g[f+(j*156|0)+(p*36|0)+28>>2]=0;g[f+(j*156|0)+(p*36|0)+32>>2]=0;w=A+(j*88|0)+(p<<3)|0;c[y+0>>2]=0;c[y+4>>2]=0;c[y+8>>2]=0;c[y+12>>2]=0;y=z;z=c[y+4>>2]|0;t=w;c[t>>2]=c[y>>2];c[t+4>>2]=z;p=p+1|0}while((p|0)!=(q|0))}q=j+1|0;if((q|0)>=(c[k>>2]|0))break;b=c[d>>2]|0;f=c[h>>2]|0;j=q}i=e;return}function Li(a){a=a|0;var b=0,d=0;b=i;d=a+36|0;_m(c[d>>2]|0,c[a+44>>2]|0);_m(c[d>>2]|0,c[a+40>>2]|0);i=b;return}function Mi(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,
r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0;b=i;i=i+64|0;d=b+48|0;e=b+32|0;f=b;h=a+52|0;if((c[h>>2]|0)<=0){i=b;return}j=a+44|0;k=a+40|0;l=a+48|0;m=a+28|0;n=a+32|0;a=d+8|0;o=d+12|0;p=e+8|0;q=e+12|0;r=0;do{s=c[j>>2]|0;t=c[k>>2]|0;u=+g[t+(r*88|0)+76>>2];v=+g[t+(r*88|0)+80>>2];w=(c[(c[l>>2]|0)+(c[s+(r*156|0)+152>>2]<<2)>>2]|0)+64|0;x=c[s+(r*156|0)+112>>2]|0;y=c[s+(r*156|0)+116>>2]|
0;z=+g[s+(r*156|0)+120>>2];A=+g[s+(r*156|0)+124>>2];B=+g[s+(r*156|0)+128>>2];C=+g[s+(r*156|0)+132>>2];D=t+(r*88|0)+48|0;E=+g[D>>2];F=+g[D+4>>2];D=t+(r*88|0)+56|0;G=+g[D>>2];H=+g[D+4>>2];D=c[m>>2]|0;t=D+(x*12|0)|0;I=+g[t>>2];J=+g[t+4>>2];K=+g[D+(x*12|0)+8>>2];t=c[n>>2]|0;L=t+(x*12|0)|0;M=+g[L>>2];N=+g[L+4>>2];O=+g[t+(x*12|0)+8>>2];x=D+(y*12|0)|0;P=+g[x>>2];Q=+g[x+4>>2];R=+g[D+(y*12|0)+8>>2];D=t+(y*12|0)|0;U=+g[D>>2];V=+g[D+4>>2];W=+g[t+(y*12|0)+8>>2];X=+T(+K);g[a>>2]=X;Y=+S(+K);g[o>>2]=Y;K=+T(+R);
g[p>>2]=K;Z=+S(+R);g[q>>2]=Z;R=+(I-(E*Y-F*X));_=+(J-(F*Y+E*X));y=d;g[y>>2]=R;g[y+4>>2]=_;_=+(P-(G*Z-H*K));R=+(Q-(H*Z+G*K));y=e;g[y>>2]=_;g[y+4>>2]=R;jf(f,w,d,u,e,v);w=s+(r*156|0)+72|0;y=f;t=c[y+4>>2]|0;D=w;c[D>>2]=c[y>>2];c[D+4>>2]=t;t=s+(r*156|0)+148|0;D=c[t>>2]|0;do if((D|0)>0){y=s+(r*156|0)+76|0;v=z+A;x=s+(r*156|0)+140|0;L=0;do{$=f+(L<<3)+8|0;u=+g[$>>2]-I;aa=f+(L<<3)+12|0;R=+u;_=+(+g[aa>>2]-J);ba=s+(r*156|0)+(L*36|0)|0;g[ba>>2]=R;g[ba+4>>2]=_;_=+g[$>>2]-P;R=+_;K=+(+g[aa>>2]-Q);aa=s+(r*156|0)+(L*
36|0)+8|0;g[aa>>2]=R;g[aa+4>>2]=K;K=+g[y>>2];R=+g[s+(r*156|0)+(L*36|0)+4>>2];G=+g[w>>2];Z=u*K-R*G;H=+g[s+(r*156|0)+(L*36|0)+12>>2];X=K*_-G*H;G=v+Z*B*Z+X*C*X;if(G>0)ca=1/G;else ca=0;g[s+(r*156|0)+(L*36|0)+24>>2]=ca;G=+g[y>>2];X=-+g[w>>2];Z=u*X-G*R;K=_*X-G*H;G=v+Z*B*Z+K*C*K;if(G>0)da=1/G;else da=0;g[s+(r*156|0)+(L*36|0)+28>>2]=da;aa=s+(r*156|0)+(L*36|0)+32|0;g[aa>>2]=0;G=+g[w>>2]*(U-W*H-M+O*R)+ +g[y>>2]*(V+W*_-N-O*u);if(G<-1)g[aa>>2]=-(G*+g[x>>2]);L=L+1|0}while((L|0)!=(D|0));if((c[t>>2]|0)==2){v=+g[s+
(r*156|0)+76>>2];G=+g[w>>2];u=+g[s+(r*156|0)>>2]*v-+g[s+(r*156|0)+4>>2]*G;_=v*+g[s+(r*156|0)+8>>2]-G*+g[s+(r*156|0)+12>>2];R=v*+g[s+(r*156|0)+36>>2]-G*+g[s+(r*156|0)+40>>2];H=v*+g[s+(r*156|0)+44>>2]-G*+g[s+(r*156|0)+48>>2];G=z+A;v=B*u;K=C*_;Z=G+u*v+_*K;_=G+R*B*R+H*C*H;u=G+v*R+K*H;H=Z*_-u*u;if(!(Z*Z<H*1E3)){c[t>>2]=1;break}g[s+(r*156|0)+96>>2]=Z;g[s+(r*156|0)+100>>2]=u;g[s+(r*156|0)+104>>2]=u;g[s+(r*156|0)+108>>2]=_;if(H!=0)ea=1/H;else ea=H;H=-(ea*u);g[s+(r*156|0)+80>>2]=_*ea;g[s+(r*156|0)+84>>2]=
H;g[s+(r*156|0)+88>>2]=H;g[s+(r*156|0)+92>>2]=Z*ea}}while(0);r=r+1|0}while((r|0)<(c[h>>2]|0));i=b;return}function Ni(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0;b=i;d=a+52|0;if((c[d>>2]|0)<=0){i=b;return}e=a+44|0;f=a+32|0;a=c[f>>2]|0;h=0;do{j=c[e>>2]|0;k=c[j+(h*156|0)+112>>2]|0;l=c[j+(h*156|0)+116>>2]|0;m=+g[j+(h*156|0)+120>>2];n=+g[j+(h*156|0)+128>>2];o=+g[j+(h*
156|0)+124>>2];p=+g[j+(h*156|0)+132>>2];q=c[j+(h*156|0)+148>>2]|0;r=a+(k*12|0)|0;s=r;t=+g[s>>2];u=+g[s+4>>2];v=+g[a+(k*12|0)+8>>2];s=a+(l*12|0)|0;w=+g[s>>2];x=+g[s+4>>2];y=+g[a+(l*12|0)+8>>2];s=j+(h*156|0)+72|0;z=+g[s>>2];A=+g[s+4>>2];if((q|0)>0){B=t;C=u;D=w;E=x;s=0;F=v;G=y;while(1){H=+g[j+(h*156|0)+(s*36|0)+16>>2];I=+g[j+(h*156|0)+(s*36|0)+20>>2];J=z*H+A*I;K=A*H-z*I;I=F-n*(+g[j+(h*156|0)+(s*36|0)>>2]*K-+g[j+(h*156|0)+(s*36|0)+4>>2]*J);H=B-m*J;L=C-m*K;M=G+p*(K*+g[j+(h*156|0)+(s*36|0)+8>>2]-J*+g[j+
(h*156|0)+(s*36|0)+12>>2]);N=D+o*J;J=E+o*K;s=s+1|0;if((s|0)==(q|0)){O=L;P=J;Q=N;R=H;S=I;T=M;break}else{B=H;C=L;D=N;E=J;F=I;G=M}}}else{O=u;P=x;Q=w;R=t;S=v;T=y}G=+R;F=+O;q=r;g[q>>2]=G;g[q+4>>2]=F;q=c[f>>2]|0;g[q+(k*12|0)+8>>2]=S;F=+Q;G=+P;s=q+(l*12|0)|0;g[s>>2]=F;g[s+4>>2]=G;a=c[f>>2]|0;g[a+(l*12|0)+8>>2]=T;h=h+1|0}while((h|0)<(c[d>>2]|0));i=b;return}function Oi(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=
0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0;b=i;d=a+52|0;if((c[d>>2]|0)<=0){i=b;return}e=a+44|0;f=a+32|0;a=c[f>>2]|0;h=0;do{j=c[e>>2]|0;k=j+(h*156|0)|0;l=c[j+(h*156|0)+112>>2]|0;m=c[j+(h*156|0)+116>>2]|0;n=+g[j+(h*156|0)+120>>2];o=+g[j+(h*156|0)+128>>2];p=+g[j+(h*156|0)+124>>2];q=+g[j+(h*156|0)+132>>2];r=j+(h*156|0)+148|0;s=c[r>>2]|0;t=a+(l*12|0)|0;u=t;v=+g[u>>2];w=+g[u+4>>2];x=
+g[a+(l*12|0)+8>>2];u=a+(m*12|0)|0;y=+g[u>>2];z=+g[u+4>>2];A=+g[a+(m*12|0)+8>>2];u=j+(h*156|0)+72|0;B=+g[u>>2];C=+g[u+4>>2];D=-B;E=+g[j+(h*156|0)+136>>2];if((s|0)>0){u=j+(h*156|0)+144|0;F=y;G=z;H=v;I=w;J=0;K=x;L=A;do{M=+g[j+(h*156|0)+(J*36|0)+12>>2];N=+g[j+(h*156|0)+(J*36|0)+8>>2];O=+g[j+(h*156|0)+(J*36|0)+4>>2];P=+g[j+(h*156|0)+(J*36|0)>>2];Q=E*+g[j+(h*156|0)+(J*36|0)+16>>2];R=j+(h*156|0)+(J*36|0)+20|0;S=+g[R>>2];T=S-+g[j+(h*156|0)+(J*36|0)+28>>2]*(C*(F-L*M-H+K*O)+(G+L*N-I-K*P)*D-+g[u>>2]);U=-Q;
V=T<Q?T:Q;Q=V<U?U:V;V=Q-S;g[R>>2]=Q;Q=C*V;S=V*D;H=H-n*Q;I=I-n*S;K=K-o*(P*S-O*Q);F=F+p*Q;G=G+p*S;L=L+q*(N*S-M*Q);J=J+1|0}while((J|0)!=(s|0));if((c[r>>2]|0)==1){D=+g[j+(h*156|0)+12>>2];E=+g[j+(h*156|0)+8>>2];Q=+g[j+(h*156|0)+4>>2];M=+g[k>>2];s=j+(h*156|0)+16|0;S=+g[s>>2];N=S-+g[j+(h*156|0)+24>>2]*(B*(F-L*D-H+K*Q)+C*(G+L*E-I-K*M)-+g[j+(h*156|0)+32>>2]);O=N>0?N:0;N=O-S;g[s>>2]=O;O=B*N;S=C*N;W=H-n*O;X=I-n*S;Y=F+p*O;Z=G+p*S;_=K-o*(M*S-Q*O);$=L+q*(E*S-D*O)}else{aa=I;ba=H;ca=G;da=F;ea=K;fa=L;ga=8}}else{aa=
w;ba=v;ca=z;da=y;ea=x;fa=A;ga=8}do if((ga|0)==8){ga=0;s=j+(h*156|0)+16|0;O=+g[s>>2];J=j+(h*156|0)+52|0;D=+g[J>>2];S=+g[j+(h*156|0)+12>>2];E=+g[j+(h*156|0)+8>>2];Q=+g[j+(h*156|0)+4>>2];M=+g[k>>2];N=+g[j+(h*156|0)+48>>2];P=+g[j+(h*156|0)+44>>2];V=+g[j+(h*156|0)+40>>2];U=+g[j+(h*156|0)+36>>2];T=+g[j+(h*156|0)+104>>2];ha=+g[j+(h*156|0)+100>>2];ia=B*(da-fa*S-ba+ea*Q)+C*(ca+fa*E-aa-ea*M)-+g[j+(h*156|0)+32>>2]-(O*+g[j+(h*156|0)+96>>2]+D*T);ja=B*(da-fa*N-ba+ea*V)+C*(ca+fa*P-aa-ea*U)-+g[j+(h*156|0)+68>>2]-
(O*ha+D*+g[j+(h*156|0)+108>>2]);ka=+g[j+(h*156|0)+80>>2]*ia+ +g[j+(h*156|0)+88>>2]*ja;la=ia*+g[j+(h*156|0)+84>>2]+ja*+g[j+(h*156|0)+92>>2];ma=-ka;na=-la;if(!(!(ka<=-0)|!(la<=-0))){la=ma-O;ka=na-D;oa=B*la;pa=C*la;la=B*ka;qa=C*ka;ka=oa+la;ra=pa+qa;g[s>>2]=ma;g[J>>2]=na;W=ba-n*ka;X=aa-n*ra;Y=da+p*ka;Z=ca+p*ra;_=ea-o*(M*pa-Q*oa+(U*qa-V*la));$=fa+q*(E*pa-S*oa+(P*qa-N*la));break}la=ia*+g[j+(h*156|0)+24>>2];qa=-la;if(la<=-0?ja+ha*qa>=0:0){ha=qa-O;la=0-D;oa=B*ha;pa=C*ha;ha=B*la;ra=C*la;la=ha+oa;ka=ra+pa;
g[s>>2]=qa;g[J>>2]=0;W=ba-n*la;X=aa-n*ka;Y=da+p*la;Z=ca+p*ka;_=ea-o*(pa*M-oa*Q+(ra*U-ha*V));$=fa+q*(pa*E-oa*S+(ra*P-ha*N));break}ha=ja*+g[j+(h*156|0)+60>>2];ra=-ha;if(ha<=-0?ia+T*ra>=0:0){T=0-O;ha=ra-D;oa=B*T;pa=C*T;T=B*ha;ka=C*ha;ha=oa+T;la=pa+ka;g[s>>2]=0;g[J>>2]=ra;W=ba-n*ha;X=aa-n*la;Y=da+p*ha;Z=ca+p*la;_=ea-o*(pa*M-oa*Q+(ka*U-T*V));$=fa+q*(pa*E-oa*S+(ka*P-T*N));break}if(!(ia>=0)|!(ja>=0)){W=ba;X=aa;Y=da;Z=ca;_=ea;$=fa}else{ja=0-O;O=0-D;D=B*ja;ia=C*ja;ja=B*O;T=C*O;O=D+ja;ka=ia+T;g[s>>2]=0;g[J>>
2]=0;W=ba-n*O;X=aa-n*ka;Y=da+p*O;Z=ca+p*ka;_=ea-o*(ia*M-D*Q+(T*U-ja*V));$=fa+q*(ia*E-D*S+(T*P-ja*N))}}while(0);q=+W;o=+X;j=t;g[j>>2]=q;g[j+4>>2]=o;j=c[f>>2]|0;g[j+(l*12|0)+8>>2]=_;o=+Y;q=+Z;k=j+(m*12|0)|0;g[k>>2]=o;g[k+4>>2]=q;a=c[f>>2]|0;g[a+(m*12|0)+8>>2]=$;h=h+1|0}while((h|0)<(c[d>>2]|0));i=b;return}function Pi(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0;b=i;d=c[a+52>>2]|0;if((d|0)<=0){i=b;return}e=c[a+44>>2]|0;f=c[a+48>>2]|0;a=0;do{h=c[f+(c[e+(a*156|0)+152>>2]<<2)>>2]|0;j=c[e+(a*156|0)+148>>2]|0;
if((j|0)>0){k=0;do{g[h+(k*20|0)+72>>2]=+g[e+(a*156|0)+(k*36|0)+16>>2];g[h+(k*20|0)+76>>2]=+g[e+(a*156|0)+(k*36|0)+20>>2];k=k+1|0}while((k|0)<(j|0))}a=a+1|0}while((a|0)<(d|0));i=b;return}function Qi(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0;b=i;i=i+64|0;d=b+40|
0;e=b+24|0;f=b;h=a+52|0;if((c[h>>2]|0)<=0){j=0;k=j>=-.014999999664723873;i=b;return k|0}l=a+40|0;m=a+28|0;a=d+8|0;n=d+12|0;o=e+8|0;p=e+12|0;q=f+8|0;r=f+16|0;s=c[m>>2]|0;t=0;u=0;while(1){v=c[l>>2]|0;w=v+(t*88|0)|0;x=c[v+(t*88|0)+32>>2]|0;y=c[v+(t*88|0)+36>>2]|0;z=v+(t*88|0)+48|0;A=+g[z>>2];B=+g[z+4>>2];C=+g[v+(t*88|0)+40>>2];D=+g[v+(t*88|0)+64>>2];z=v+(t*88|0)+56|0;E=+g[z>>2];F=+g[z+4>>2];G=+g[v+(t*88|0)+44>>2];H=+g[v+(t*88|0)+68>>2];z=c[v+(t*88|0)+84>>2]|0;v=s+(x*12|0)|0;I=+g[v>>2];J=+g[v+4>>2];K=
+g[s+(x*12|0)+8>>2];v=s+(y*12|0)|0;L=+g[v>>2];M=+g[v+4>>2];N=+g[s+(y*12|0)+8>>2];if((z|0)>0){O=C+G;P=I;Q=J;R=L;U=M;V=K;W=N;v=0;X=u;do{Y=+T(+V);g[a>>2]=Y;Z=+S(+V);g[n>>2]=Z;_=+T(+W);g[o>>2]=_;$=+S(+W);g[p>>2]=$;aa=+(P-(A*Z-B*Y));ba=+(Q-(B*Z+A*Y));ca=d;g[ca>>2]=aa;g[ca+4>>2]=ba;ba=+(R-(E*$-F*_));aa=+(U-(F*$+E*_));ca=e;g[ca>>2]=ba;g[ca+4>>2]=aa;Ri(f,w,d,e,v);ca=f;aa=+g[ca>>2];ba=+g[ca+4>>2];ca=q;_=+g[ca>>2];$=+g[ca+4>>2];Y=+g[r>>2];Z=_-P;da=$-Q;ea=_-R;_=$-U;X=X<Y?X:Y;$=(Y+.004999999888241291)*.20000000298023224;
Y=$<0?$:0;$=ba*Z-aa*da;fa=ba*ea-aa*_;ga=fa*H*fa+(O+$*D*$);if(ga>0)ha=-(Y<-.20000000298023224?-.20000000298023224:Y)/ga;else ha=0;ga=aa*ha;aa=ba*ha;P=P-C*ga;Q=Q-C*aa;V=V-D*(Z*aa-da*ga);R=R+G*ga;U=U+G*aa;W=W+H*(ea*aa-_*ga);v=v+1|0}while((v|0)!=(z|0));ia=Q;ja=P;ka=U;la=R;ma=c[m>>2]|0;na=V;oa=W;pa=X}else{ia=J;ja=I;ka=M;la=L;ma=s;na=K;oa=N;pa=u}H=+ja;G=+ia;z=ma+(x*12|0)|0;g[z>>2]=H;g[z+4>>2]=G;z=c[m>>2]|0;g[z+(x*12|0)+8>>2]=na;G=+la;H=+ka;v=z+(y*12|0)|0;g[v>>2]=G;g[v+4>>2]=H;s=c[m>>2]|0;g[s+(y*12|0)+8>>
2]=oa;t=t+1|0;if((t|0)>=(c[h>>2]|0)){j=pa;break}else u=pa}k=j>=-.014999999664723873;i=b;return k|0}function Ri(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;h=i;j=c[b+72>>2]|0;if((j|0)==2){k=e+12|0;l=+g[k>>2];m=+g[b+16>>2];n=e+8|0;o=+g[n>>2];p=+g[b+20>>2];q=l*m-o*p;r=m*o+l*p;p=+q;l=+r;s=a;g[s>>2]=p;g[s+4>>2]=l;l=+g[k>>2];p=+g[b+24>>2];o=+g[n>>2];m=+g[b+28>>2];t=+g[d+12>>2];u=+g[b+(f<<3)>>2];v=+g[d+8>>2];w=+g[b+(f<<3)+4>>2];
x=+g[d>>2]+(t*u-v*w);y=u*v+t*w+ +g[d+4>>2];g[a+16>>2]=q*(x-(+g[e>>2]+(l*p-o*m)))+(y-(p*o+l*m+ +g[e+4>>2]))*r-+g[b+76>>2]-+g[b+80>>2];m=+x;x=+y;n=a+8|0;g[n>>2]=m;g[n+4>>2]=x;x=+-q;q=+-r;n=a;g[n>>2]=x;g[n+4>>2]=q;i=h;return}else if((j|0)==1){n=d+12|0;q=+g[n>>2];x=+g[b+16>>2];k=d+8|0;r=+g[k>>2];m=+g[b+20>>2];y=q*x-r*m;l=x*r+q*m;m=+y;q=+l;s=a;g[s>>2]=m;g[s+4>>2]=q;q=+g[n>>2];m=+g[b+24>>2];r=+g[k>>2];x=+g[b+28>>2];o=+g[e+12>>2];p=+g[b+(f<<3)>>2];w=+g[e+8>>2];t=+g[b+(f<<3)+4>>2];v=+g[e>>2]+(o*p-w*t);u=
p*w+o*t+ +g[e+4>>2];g[a+16>>2]=y*(v-(+g[d>>2]+(q*m-r*x)))+(u-(m*r+q*x+ +g[d+4>>2]))*l-+g[b+76>>2]-+g[b+80>>2];l=+v;v=+u;f=a+8|0;g[f>>2]=l;g[f+4>>2]=v;i=h;return}else if((j|0)==0){v=+g[d+12>>2];l=+g[b+24>>2];u=+g[d+8>>2];x=+g[b+28>>2];q=+g[d>>2]+(v*l-u*x);r=l*u+v*x+ +g[d+4>>2];x=+g[e+12>>2];v=+g[b>>2];u=+g[e+8>>2];l=+g[b+4>>2];m=+g[e>>2]+(x*v-u*l);y=v*u+x*l+ +g[e+4>>2];l=m-q;x=y-r;u=+l;v=+x;e=a;g[e>>2]=u;g[e+4>>2]=v;v=+Q(+(l*l+x*x));if(v<1.1920928955078125E-7){z=l;A=x}else{u=1/v;v=l*u;g[a>>2]=v;t=
x*u;g[a+4>>2]=t;z=v;A=t}t=+((q+m)*.5);m=+((r+y)*.5);e=a+8|0;g[e>>2]=t;g[e+4>>2]=m;g[a+16>>2]=l*z+x*A-+g[b+76>>2]-+g[b+80>>2];i=h;return}else{g[a+16>>2]=0;b=8784;e=c[b+4>>2]|0;d=a;c[d>>2]=c[b>>2];c[d+4>>2]=e;e=8784;d=c[e+4>>2]|0;b=a+8|0;c[b>>2]=c[e>>2];c[b+4>>2]=d;i=h;return}}function Si(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,
aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0;e=i;i=i+64|0;f=e+40|0;h=e+24|0;j=e;k=a+52|0;if((c[k>>2]|0)<=0){l=0;m=l>=-.007499999832361937;i=e;return m|0}n=a+40|0;o=a+28|0;a=f+8|0;p=f+12|0;q=h+8|0;r=h+12|0;s=j+8|0;t=j+16|0;u=0;v=0;while(1){w=c[n>>2]|0;x=w+(u*88|0)|0;y=c[w+(u*88|0)+32>>2]|0;z=c[w+(u*88|0)+36>>2]|0;A=w+(u*88|0)+48|0;B=+g[A>>2];C=+g[A+4>>2];A=w+(u*88|0)+56|0;D=+g[A>>2];E=+g[A+4>>2];A=c[w+(u*88|0)+84>>2]|0;if((y|0)==(b|0)|(y|0)==(d|0)){F=+g[w+
(u*88|0)+64>>2];G=+g[w+(u*88|0)+40>>2]}else{F=0;G=0}if((z|0)==(b|0)|(z|0)==(d|0)){H=+g[w+(u*88|0)+68>>2];I=+g[w+(u*88|0)+44>>2]}else{H=0;I=0}w=c[o>>2]|0;J=w+(y*12|0)|0;K=+g[J>>2];L=+g[J+4>>2];M=+g[w+(y*12|0)+8>>2];J=w+(z*12|0)|0;N=+g[J>>2];O=+g[J+4>>2];P=+g[w+(z*12|0)+8>>2];if((A|0)>0){Q=G+I;R=N;U=O;V=K;W=L;X=M;Y=P;J=0;Z=v;do{_=+T(+X);g[a>>2]=_;$=+S(+X);g[p>>2]=$;aa=+T(+Y);g[q>>2]=aa;ba=+S(+Y);g[r>>2]=ba;ca=+(V-(B*$-C*_));da=+(W-(C*$+B*_));ea=f;g[ea>>2]=ca;g[ea+4>>2]=da;da=+(R-(D*ba-E*aa));ca=+(U-
(E*ba+D*aa));ea=h;g[ea>>2]=da;g[ea+4>>2]=ca;Ri(j,x,f,h,J);ea=j;ca=+g[ea>>2];da=+g[ea+4>>2];ea=s;aa=+g[ea>>2];ba=+g[ea+4>>2];_=+g[t>>2];$=aa-V;fa=ba-W;ga=aa-R;aa=ba-U;Z=Z<_?Z:_;ba=(_+.004999999888241291)*.75;_=ba<0?ba:0;ba=da*$-ca*fa;ha=da*ga-ca*aa;ia=ha*H*ha+(Q+ba*F*ba);if(ia>0)ja=-(_<-.20000000298023224?-.20000000298023224:_)/ia;else ja=0;ia=ca*ja;ca=da*ja;V=V-G*ia;W=W-G*ca;X=X-F*($*ca-fa*ia);R=R+I*ia;U=U+I*ca;Y=Y+H*(ga*ca-aa*ia);J=J+1|0}while((J|0)!=(A|0));ka=W;la=V;ma=U;na=R;oa=c[o>>2]|0;pa=X;
qa=Y;ra=Z}else{ka=L;la=K;ma=O;na=N;oa=w;pa=M;qa=P;ra=v}Q=+la;D=+ka;A=oa+(y*12|0)|0;g[A>>2]=Q;g[A+4>>2]=D;A=c[o>>2]|0;g[A+(y*12|0)+8>>2]=pa;D=+na;Q=+ma;J=A+(z*12|0)|0;g[J>>2]=D;g[J+4>>2]=Q;g[(c[o>>2]|0)+(z*12|0)+8>>2]=qa;u=u+1|0;if((u|0)>=(c[k>>2]|0)){l=ra;break}else v=ra}m=l>=-.007499999832361937;i=e;return m|0}function Ti(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0;e=i;b=Em(f,148)|0;if((b|0)==0){g=0;i=e;return g|0}wi(b,a,0,d,0);c[b>>2]=6528;g=b;i=e;return g|0}function Ui(a,b){a=a|0;b=b|0;var d=
0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function Vi(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;cf(b,c[(c[a+48>>2]|0)+12>>2]|0,d,c[(c[a+52>>2]|0)+12>>2]|0,e);i=f;return}function Wi(a){a=a|0;return}function Xi(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Yi(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0,j=0;g=i;h=Em(f,148)|0;if((h|0)==0){j=0;i=g;return j|0}wi(h,a,b,d,e);c[h>>2]=6600;j=h;i=g;return j|0}function Zi(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);
Fm(b,a,148);i=d;return}function _i(a,d,e,f){a=a|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0;h=i;i=i+48|0;j=h;k=c[(c[a+48>>2]|0)+12>>2]|0;c[j>>2]=488;c[j+4>>2]=1;g[j+8>>2]=.009999999776482582;l=j+28|0;c[l+0>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;b[l+16>>1]=0;Ge(k,j,c[a+56>>2]|0);cf(d,j,e,c[(c[a+52>>2]|0)+12>>2]|0,f);i=h;return}function $i(a){a=a|0;return}function aj(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function bj(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0;e=i;b=Em(f,148)|0;if((b|0)==0){g=0;
i=e;return g|0}wi(b,a,0,d,0);c[b>>2]=6672;g=b;i=e;return g|0}function cj(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function dj(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;ff(b,c[(c[a+48>>2]|0)+12>>2]|0,d,c[(c[a+52>>2]|0)+12>>2]|0,e);i=f;return}function ej(a){a=a|0;return}function fj(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function gj(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=0;e=i;b=Em(f,148)|0;if((b|0)==0){g=0;i=e;return g|0}wi(b,a,0,d,0);c[b>>2]=6744;
g=b;i=e;return g|0}function hj(a,b){a=a|0;b=b|0;var d=0;d=i;eb[c[(c[a>>2]|0)+4>>2]&127](a);Fm(b,a,148);i=d;return}function ij(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0;f=i;gf(b,c[(c[a+48>>2]|0)+12>>2]|0,d,c[(c[a+52>>2]|0)+12>>2]|0,e);i=f;return}function jj(a){a=a|0;return}function kj(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function lj(a){a=a|0;var d=0;d=i;b[a+32>>1]=1;b[a+34>>1]=-1;b[a+36>>1]=0;c[a+40>>2]=0;c[a+24>>2]=0;c[a+28>>2]=0;c[a+0>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;c[a+12>>2]=0;i=d;return}function mj(d,
e,f,h){d=d|0;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0;j=i;c[d+40>>2]=c[h+4>>2];g[d+16>>2]=+g[h+8>>2];g[d+20>>2]=+g[h+12>>2];c[d+8>>2]=f;c[d+4>>2]=0;f=d+32|0;k=h+22|0;b[f+0>>1]=b[k+0>>1]|0;b[f+2>>1]=b[k+2>>1]|0;b[f+4>>1]=b[k+4>>1]|0;a[d+38>>0]=a[h+20>>0]|0;k=c[h>>2]|0;f=nb[c[(c[k>>2]|0)+8>>2]&31](k,e)|0;c[d+12>>2]=f;k=bb[c[(c[f>>2]|0)+12>>2]&7](f)|0;f=Em(e,k*28|0)|0;e=d+24|0;c[e>>2]=f;if((k|0)>0){l=f;m=0}else{n=d+28|0;c[n>>2]=0;o=h+16|0;p=+g[o>>2];g[d>>2]=p;i=j;return}do{c[l+(m*28|0)+16>>
2]=0;l=c[e>>2]|0;c[l+(m*28|0)+24>>2]=-1;m=m+1|0}while((m|0)!=(k|0));n=d+28|0;c[n>>2]=0;o=h+16|0;p=+g[o>>2];g[d>>2]=p;i=j;return}function nj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=a+12|0;f=c[e>>2]|0;g=bb[c[(c[f>>2]|0)+12>>2]&7](f)|0;f=a+24|0;Fm(b,c[f>>2]|0,g*28|0);c[f>>2]=0;f=c[e>>2]|0;g=c[f+4>>2]|0;if((g|0)==1){eb[c[c[f>>2]>>2]&127](f);Fm(b,f,48);c[e>>2]=0;i=d;return}else if((g|0)==3){eb[c[c[f>>2]>>2]&127](f);Fm(b,f,40);c[e>>2]=0;i=d;return}else if((g|0)==0){eb[c[c[f>>2]>>2]&127](f);Fm(b,f,20);
c[e>>2]=0;i=d;return}else if((g|0)==2){eb[c[c[f>>2]>>2]&127](f);Fm(b,f,152);c[e>>2]=0;i=d;return}else{c[e>>2]=0;i=d;return}}function oj(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;f=a+12|0;g=c[f>>2]|0;h=bb[c[(c[g>>2]|0)+12>>2]&7](g)|0;g=a+28|0;c[g>>2]=h;if((h|0)<=0){i=e;return}h=a+24|0;j=0;do{k=c[h>>2]|0;l=k+(j*28|0)|0;m=c[f>>2]|0;pb[c[(c[m>>2]|0)+28>>2]&31](m,l,d,j);c[k+(j*28|0)+24>>2]=Oe(b,l,l)|0;c[k+(j*28|0)+16>>2]=a;c[k+(j*28|0)+20>>2]=j;j=j+1|0}while((j|0)<(c[g>>2]|0));i=
e;return}function pj(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=a+28|0;if((c[e>>2]|0)<=0){c[e>>2]=0;i=d;return}f=a+24|0;a=0;do{g=(c[f>>2]|0)+(a*28|0)+24|0;Pe(b,c[g>>2]|0);c[g>>2]=-1;a=a+1|0}while((a|0)<(c[e>>2]|0));c[e>>2]=0;i=d;return}function qj(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0;f=i;i=i+48|0;h=f+24|0;j=f+8|0;k=f;l=a+28|0;if((c[l>>2]|0)<=0){i=f;return}m=a+24|0;n=a+12|0;a=h+4|0;o=j+4|0;p=h+8|0;q=j+8|
0;r=h+12|0;s=j+12|0;t=e+4|0;u=d+4|0;v=k+4|0;w=0;do{x=c[m>>2]|0;y=c[n>>2]|0;z=x+(w*28|0)+20|0;pb[c[(c[y>>2]|0)+28>>2]&31](y,h,d,c[z>>2]|0);y=c[n>>2]|0;pb[c[(c[y>>2]|0)+28>>2]&31](y,j,e,c[z>>2]|0);z=x+(w*28|0)|0;A=+g[h>>2];B=+g[j>>2];C=+g[a>>2];D=+g[o>>2];E=+(A<B?A:B);B=+(C<D?C:D);y=z;g[y>>2]=E;g[y+4>>2]=B;B=+g[p>>2];E=+g[q>>2];D=+g[r>>2];C=+g[s>>2];A=+(B>E?B:E);E=+(D>C?D:C);y=x+(w*28|0)+8|0;g[y>>2]=A;g[y+4>>2]=E;E=+g[t>>2]-+g[u>>2];g[k>>2]=+g[e>>2]-+g[d>>2];g[v>>2]=E;Qe(b,c[x+(w*28|0)+24>>2]|0,z,k);
w=w+1|0}while((w|0)<(c[l>>2]|0));i=f;return}function rj(b,d){b=b|0;d=d|0;var e=0,f=0,h=0;e=i;Cm(b);Wm(b+76|0);Sj(b+102880|0);c[b+102992>>2]=0;c[b+102996>>2]=0;f=b+102960|0;h=b+103004|0;c[f+0>>2]=0;c[f+4>>2]=0;c[f+8>>2]=0;c[f+12>>2]=0;c[f+16>>2]=0;a[h>>0]=1;a[b+103005>>0]=1;a[b+103006>>0]=0;a[b+103007>>0]=1;a[b+102988>>0]=1;h=d;d=c[h+4>>2]|0;f=b+102980|0;c[f>>2]=c[h>>2];c[f+4>>2]=d;c[b+102876>>2]=4;g[b+103E3>>2]=0;c[b+102956>>2]=b;c[b+103040>>2]=8792;c[b+103044>>2]=c[2206];d=b+103008|0;c[d+0>>2]=0;
c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;c[d+16>>2]=0;c[d+20>>2]=0;c[d+24>>2]=0;c[d+28>>2]=0;i=e;return}function qb(a){a=a|0;var b=0;b=i;i=i+a|0;i=i+7&-8;return b|0}function rb(){return i|0}function sb(a){a=a|0;i=a}function tb(a,b){a=a|0;b=b|0;if((p|0)==0){p=a;q=b}}function ub(b){b=b|0;a[k>>0]=a[b>>0];a[k+1>>0]=a[b+1>>0];a[k+2>>0]=a[b+2>>0];a[k+3>>0]=a[b+3>>0]}function vb(b){b=b|0;a[k>>0]=a[b>>0];a[k+1>>0]=a[b+1>>0];a[k+2>>0]=a[b+2>>0];a[k+3>>0]=a[b+3>>0];a[k+4>>0]=a[b+4>>0];a[k+5>>0]=a[b+5>>0];a[k+6>>
0]=a[b+6>>0];a[k+7>>0]=a[b+7>>0]}function wb(a){a=a|0;E=a}function xb(){return E|0}function yb(a){a=a|0;return+ +(c[a+60>>2]|0)}function zb(d,e,f,j,k,l,m,n,o,p,q){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=p|0;q=+q;var r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0;r=i;i=i+1104|0;s=r;t=r+1072|0;u=r+1032|0;v=r+8|0;h[s>>3]=l;c[t>>2]=0;g[t+16>>2]=e;g[t+8>>2]=f;a[t+20>>0]=j!=0&1;g[t+12>>2]=k;c[t+4>>2]=s;b[t+22>>1]=~~m;b[t+26>>1]=~~n;b[t+24>>1]=~~o;c[u>>2]=760;c[u+4>>2]=3;g[u+8>>2]=.009999999776482582;c[u+12>>
2]=0;c[u+16>>2]=0;a[u+36>>0]=0;a[u+37>>0]=0;s=~~(q*.5);if(q>0){w=0;x=0}else{De(u,v,s);c[t>>2]=u;y=Mj(d,t)|0;Ce(u);i=r;return y|0}while(1){o=+ +g[p+(w<<2)>>2];n=+ +g[p+((w|1)<<2)>>2];z=v+(x<<3)|0;g[z>>2]=o;g[z+4>>2]=n;w=w+2|0;if(!(+(w|0)<q))break;else x=x+1|0}De(u,v,s);c[t>>2]=u;y=Mj(d,t)|0;Ce(u);i=r;return y|0}function Ab(a){a=a|0;Ha(a|0)|0;xa()}function Bb(d,e,f,j,k,l,m,n,o,p,q,r){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;var s=0,t=0,u=0,v=0;s=i;i=i+64|0;t=s;u=s+28|0;v=s+8|0;h[t>>
3]=l;g[u+16>>2]=e;g[u+8>>2]=f;a[u+20>>0]=j!=0&1;g[u+12>>2]=k;c[u+4>>2]=t;b[u+22>>1]=~~m;b[u+26>>1]=~~n;b[u+24>>1]=~~o;c[v>>2]=680;t=v+4|0;c[t+0>>2]=0;c[t+4>>2]=0;c[t+8>>2]=0;g[v+12>>2]=p;g[v+16>>2]=q;g[v+8>>2]=r;c[u>>2]=v;v=Mj(d,u)|0;i=s;return v|0}function Cb(a){a=a|0;return}function Db(b,d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B){b=b|0;d=+d;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;z=+z;A=+A;B=+B;var C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=
0,O=0,P=0,Q=0;C=i;i=i+112|0;D=C;E=C+28|0;F=C+8|0;h[D>>3]=y;G=E+8|0;H=E+20|0;I=E+4|0;J=E+16|0;K=E+28|0;L=E+32|0;M=E+33|0;N=E+34|0;O=E+35|0;P=E+36|0;Q=E+40|0;c[Q+0>>2]=0;c[Q+4>>2]=0;c[Q+8>>2]=0;c[Q+12>>2]=0;c[Q+16>>2]=0;c[Q+20>>2]=0;c[Q+24>>2]=0;g[J>>2]=d;g[K>>2]=e;a[L>>0]=~~f;a[M>>0]=~~j;a[N>>0]=~~k;a[O>>0]=~~l;c[E>>2]=~~m>>>0;c[E+72>>2]=0;c[I>>2]=~~o>>>0;g[E+64>>2]=p;p=+q;q=+r;I=H;g[I>>2]=p;g[I+4>>2]=q;q=+s;s=+t;I=G;g[I>>2]=q;g[I+4>>2]=s;c[E+60>>2]=0;c[E+56>>2]=~~v;c[E+48>>2]=0;c[E+44>>2]=0;g[P>>
2]=w;g[E+52>>2]=x;c[E+68>>2]=D;c[F>>2]=680;c[F+4>>2]=0;x=+z;z=+A;D=F+12|0;g[D>>2]=x;g[D+4>>2]=z;g[F+8>>2]=B;c[Q>>2]=F;F=Fk(b,E)|0;i=C;return F|0}function Eb(a,b,d,e,f,h,j,k){a=a|0;b=+b;d=+d;e=+e;f=+f;h=+h;j=+j;k=+k;var l=0,m=0,n=0,o=0;l=i;i=i+48|0;m=l+16|0;n=l;c[m>>2]=680;o=m+4|0;c[o+0>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;g[m+12>>2]=b;g[m+16>>2]=d;g[m+8>>2]=e;g[n>>2]=f;g[n+4>>2]=h;g[n+8>>2]=j;g[n+12>>2]=k;k=+(Ck(a,m,n,0)|0);i=l;return+k}function Fb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y){d=d|0;e=+e;f=+f;
j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;var z=0,A=0,B=0,C=0;z=i;i=i+96|0;A=z;B=z+56|0;C=z+8|0;h[A>>3]=l;g[B+16>>2]=e;g[B+8>>2]=f;a[B+20>>0]=j!=0&1;g[B+12>>2]=k;c[B+4>>2]=A;b[B+22>>1]=~~m;b[B+26>>1]=~~n;b[B+24>>1]=~~o;c[C>>2]=488;c[C+4>>2]=1;g[C+8>>2]=.009999999776482582;A=C+28|0;c[A+0>>2]=0;c[A+4>>2]=0;c[A+8>>2]=0;c[A+12>>2]=0;b[A+16>>1]=0;o=+r;r=+s;A=C+28|0;g[A>>2]=o;g[A+4>>2]=r;r=+t;t=+u;A=C+12|0;g[A>>2]=r;g[A+4>>2]=t;t=+v;v=+w;A=C+20|0;g[A>>2]=t;g[A+4>>2]=
v;v=+x;x=+y;A=C+36|0;g[A>>2]=v;g[A+4>>2]=x;a[C+44>>0]=p!=0&1;a[C+45>>0]=q!=0&1;c[B>>2]=C;C=Mj(d,B)|0;i=z;return C|0}function Gb(a){a=a|0;return}function Hb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;var v=0,w=0,x=0,y=0,z=0;v=i;i=i+224|0;w=v;x=v+184|0;y=v+160|0;z=v+8|0;h[w>>3]=l;g[x+16>>2]=e;g[x+8>>2]=f;a[x+20>>0]=j!=0&1;g[x+12>>2]=k;c[x+4>>2]=w;b[x+22>>1]=~~m;b[x+26>>1]=~~n;b[x+24>>1]=~~o;g[y>>2]=p;g[y+4>>2]=q;g[y+8>>2]=r;g[y+12>>2]=
s;g[y+16>>2]=t;g[y+20>>2]=u;c[z>>2]=592;c[z+4>>2]=2;g[z+8>>2]=.009999999776482582;c[z+148>>2]=0;g[z+12>>2]=0;g[z+16>>2]=0;oe(z,y,3);c[x>>2]=z;z=Mj(d,x)|0;i=v;return z|0}function Ib(a){a=a|0;return}function Jb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;var x=0,y=0,z=0,A=0,B=0;x=i;i=i+224|0;y=x;z=x+192|0;A=x+160|0;B=x+8|0;h[y>>3]=l;g[z+16>>2]=e;g[z+8>>2]=f;a[z+20>>0]=j!=0&1;g[z+12>>2]=k;c[z+4>>2]=y;b[z+22>>1]=~~m;b[z+26>>
1]=~~n;b[z+24>>1]=~~o;g[A>>2]=p;g[A+4>>2]=q;g[A+8>>2]=r;g[A+12>>2]=s;g[A+16>>2]=t;g[A+20>>2]=u;g[A+24>>2]=v;g[A+28>>2]=w;c[B>>2]=592;c[B+4>>2]=2;g[B+8>>2]=.009999999776482582;c[B+148>>2]=0;g[B+12>>2]=0;g[B+16>>2]=0;oe(B,A,4);c[z>>2]=B;B=Mj(d,z)|0;i=x;return B|0}function Kb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;var z=0,A=0,B=0,C=0,D=0;z=i;i=i+240|0;A=z;B=z+200|0;C=z+160|0;D=z+8|0;h[A>>3]=l;g[B+16>>2]=e;
g[B+8>>2]=f;a[B+20>>0]=j!=0&1;g[B+12>>2]=k;c[B+4>>2]=A;b[B+22>>1]=~~m;b[B+26>>1]=~~n;b[B+24>>1]=~~o;g[C>>2]=p;g[C+4>>2]=q;g[C+8>>2]=r;g[C+12>>2]=s;g[C+16>>2]=t;g[C+20>>2]=u;g[C+24>>2]=v;g[C+28>>2]=w;g[C+32>>2]=x;g[C+36>>2]=y;c[D>>2]=592;c[D+4>>2]=2;g[D+8>>2]=.009999999776482582;c[D+148>>2]=0;g[D+12>>2]=0;g[D+16>>2]=0;oe(D,C,5);c[B>>2]=D;D=Mj(d,B)|0;i=z;return D|0}function Lb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;
w=+w;x=+x;y=+y;z=+z;A=+A;var B=0,C=0,D=0,E=0,F=0;B=i;i=i+240|0;C=B;D=B+208|0;E=B+160|0;F=B+8|0;h[C>>3]=l;g[D+16>>2]=e;g[D+8>>2]=f;a[D+20>>0]=j!=0&1;g[D+12>>2]=k;c[D+4>>2]=C;b[D+22>>1]=~~m;b[D+26>>1]=~~n;b[D+24>>1]=~~o;g[E>>2]=p;g[E+4>>2]=q;g[E+8>>2]=r;g[E+12>>2]=s;g[E+16>>2]=t;g[E+20>>2]=u;g[E+24>>2]=v;g[E+28>>2]=w;g[E+32>>2]=x;g[E+36>>2]=y;g[E+40>>2]=z;g[E+44>>2]=A;c[F>>2]=592;c[F+4>>2]=2;g[F+8>>2]=.009999999776482582;c[F+148>>2]=0;g[F+12>>2]=0;g[F+16>>2]=0;oe(F,E,6);c[D>>2]=F;F=Mj(d,D)|0;i=B;return F|
0}function Mb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;z=+z;A=+A;B=+B;C=+C;var D=0,E=0,F=0,G=0,H=0;D=i;i=i+256|0;E=D;F=D+216|0;G=D+160|0;H=D+8|0;h[E>>3]=l;g[F+16>>2]=e;g[F+8>>2]=f;a[F+20>>0]=j!=0&1;g[F+12>>2]=k;c[F+4>>2]=E;b[F+22>>1]=~~m;b[F+26>>1]=~~n;b[F+24>>1]=~~o;g[G>>2]=p;g[G+4>>2]=q;g[G+8>>2]=r;g[G+12>>2]=s;g[G+16>>2]=t;g[G+20>>2]=u;g[G+24>>2]=v;g[G+28>>2]=w;g[G+32>>2]=x;g[G+36>>2]=y;g[G+40>>
2]=z;g[G+44>>2]=A;g[G+48>>2]=B;g[G+52>>2]=C;c[H>>2]=592;c[H+4>>2]=2;g[H+8>>2]=.009999999776482582;c[H+148>>2]=0;g[H+12>>2]=0;g[H+16>>2]=0;oe(H,G,7);c[F>>2]=H;H=Mj(d,F)|0;i=D;return H|0}function Nb(d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E){d=d|0;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;z=+z;A=+A;B=+B;C=+C;D=+D;E=+E;var F=0,G=0,H=0,I=0,J=0;F=i;i=i+256|0;G=F;H=F+224|0;I=F+160|0;J=F+8|0;h[G>>3]=l;g[H+16>>2]=e;g[H+8>>2]=f;a[H+20>>0]=j!=0&1;g[H+
12>>2]=k;c[H+4>>2]=G;b[H+22>>1]=~~m;b[H+26>>1]=~~n;b[H+24>>1]=~~o;g[I>>2]=p;g[I+4>>2]=q;g[I+8>>2]=r;g[I+12>>2]=s;g[I+16>>2]=t;g[I+20>>2]=u;g[I+24>>2]=v;g[I+28>>2]=w;g[I+32>>2]=x;g[I+36>>2]=y;g[I+40>>2]=z;g[I+44>>2]=A;g[I+48>>2]=B;g[I+52>>2]=C;g[I+56>>2]=D;g[I+60>>2]=E;c[J>>2]=592;c[J+4>>2]=2;g[J+8>>2]=.009999999776482582;c[J+148>>2]=0;g[J+12>>2]=0;g[J+16>>2]=0;oe(J,I,8);c[H>>2]=J;J=Mj(d,H)|0;i=F;return J|0}function Ob(b,d,e,f,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G){b=b|0;d=+d;e=+e;f=+f;j=
+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;w=+w;x=+x;y=+y;z=+z;A=+A;B=+B;C=+C;D=+D;E=+E;F=+F;G=+G;var H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0;H=i;i=i+272|0;I=H;J=H+192|0;K=H+160|0;L=H+8|0;h[I>>3]=y;M=J+8|0;N=J+20|0;O=J+4|0;P=J+16|0;Q=J+28|0;R=J+32|0;S=J+33|0;T=J+34|0;U=J+35|0;V=J+36|0;W=J+40|0;c[W+0>>2]=0;c[W+4>>2]=0;c[W+8>>2]=0;c[W+12>>2]=0;c[W+16>>2]=0;c[W+20>>2]=0;c[W+24>>2]=0;g[P>>2]=d;g[Q>>2]=e;a[R>>0]=~~f;a[S>>0]=~~j;a[T>>0]=~~k;a[U>>0]=~~l;c[J>>2]=
~~m>>>0;c[J+72>>2]=0;c[O>>2]=~~o>>>0;g[J+64>>2]=p;p=+q;q=+r;O=N;g[O>>2]=p;g[O+4>>2]=q;q=+s;s=+t;O=M;g[O>>2]=q;g[O+4>>2]=s;c[J+60>>2]=0;c[J+56>>2]=~~v;c[J+48>>2]=0;c[J+44>>2]=0;g[V>>2]=w;g[J+52>>2]=x;c[J+68>>2]=I;g[K>>2]=z;g[K+4>>2]=A;g[K+8>>2]=B;g[K+12>>2]=C;g[K+16>>2]=D;g[K+20>>2]=E;g[K+24>>2]=F;g[K+28>>2]=G;c[L>>2]=592;c[L+4>>2]=2;g[L+8>>2]=.009999999776482582;c[L+148>>2]=0;g[L+12>>2]=0;g[L+16>>2]=0;oe(L,K,4);c[W>>2]=L;L=Fk(b,J)|0;i=H;return L|0}function Pb(a,b,d,e,f,h,j,k,l,m,n,o,p){a=a|0;b=+b;
d=+d;e=+e;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;var q=0,r=0,s=0,t=0;q=i;i=i+208|0;r=q+168|0;s=q+16|0;t=q;g[r>>2]=b;g[r+4>>2]=d;g[r+8>>2]=e;g[r+12>>2]=f;g[r+16>>2]=h;g[r+20>>2]=j;g[r+24>>2]=k;g[r+28>>2]=l;c[s>>2]=592;c[s+4>>2]=2;g[s+8>>2]=.009999999776482582;c[s+148>>2]=0;g[s+12>>2]=0;g[s+16>>2]=0;oe(s,r,4);g[t>>2]=m;g[t+4>>2]=n;g[t+8>>2]=o;g[t+12>>2]=p;p=+(Ck(a,s,t,0)|0);i=q;return+p}function Qb(a,d,e){a=a|0;d=+d;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0;f=i;h=d;if((c[a>>2]|0)!=2){i=f;return}j=
a+4|0;k=b[j>>1]|0;if((e!=0?(k&2)==0:0)?(l=k&65535,(l&2|0)==0):0){m=(l|2)&65535;b[j>>1]=m;g[a+160>>2]=0;n=m}else n=k;if((n&2)==0){i=f;return}n=a+88|0;g[n>>2]=+g[n>>2]+h*+g[a+144>>2];i=f;return}function Rb(a,d,e,f,h,j){a=a|0;d=+d;e=+e;f=+f;h=+h;j=+j;var k=0,l=0,m=0,n=0,o=0,p=0,q=0;k=i;l=d;d=e;e=f;f=h;if((c[a>>2]|0)!=2){i=k;return}m=a+4|0;n=b[m>>1]|0;if((j!=0?(n&2)==0:0)?(o=n&65535,(o&2|0)==0):0){p=(o|2)&65535;b[m>>1]=p;g[a+160>>2]=0;q=p}else q=n;if((q&2)==0){i=k;return}q=a+92|0;g[q>>2]=l+ +g[q>>2];
q=a+96|0;g[q>>2]=d+ +g[q>>2];q=a+100|0;g[q>>2]=+g[q>>2]+(d*(e-+g[a+60>>2])-l*(f-+g[a+64>>2]));i=k;return}function Sb(a,d,e,f){a=a|0;d=+d;e=+e;f=+f;var h=0,j=0,k=0,l=0,m=0,n=0,o=0;h=i;j=d;d=e;if((c[a>>2]|0)!=2){i=h;return}k=a+4|0;l=b[k>>1]|0;if((f!=0?(l&2)==0:0)?(m=l&65535,(m&2|0)==0):0){n=(m|2)&65535;b[k>>1]=n;g[a+160>>2]=0;o=n}else o=l;if((o&2)==0){i=h;return}o=a+92|0;g[o>>2]=j+ +g[o>>2];o=a+96|0;g[o>>2]=d+ +g[o>>2];i=h;return}function Tb(a,d,e){a=a|0;d=+d;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0;f=
i;h=d;if((c[a>>2]|0)!=2){i=f;return}j=a+4|0;k=b[j>>1]|0;if((e!=0?(k&2)==0:0)?(l=k&65535,(l&2|0)==0):0){m=(l|2)&65535;b[j>>1]=m;g[a+160>>2]=0;n=m}else n=k;if((n&2)==0){i=f;return}n=a+100|0;g[n>>2]=h+ +g[n>>2];i=f;return}function Ub(a,b){a=a|0;b=b|0;var c=0;c=i;Nj(a,b);i=c;return}function Vb(a){a=a|0;return+ +g[a+72>>2]}function Wb(a){a=a|0;return+ +g[a+88>>2]}function Xb(a){a=a|0;var b=0,c=0;b=+g[a+44>>2];c=+g[a+48>>2];return+(+g[a+140>>2]+ +g[a+132>>2]*(b*b+c*c))}function Yb(a,b){a=a|0;b=b|0;var c=
0;c=+g[a+84>>2];g[b>>2]=+g[a+80>>2];g[b+4>>2]=c;return}function Zb(a,b,c,d){a=a|0;b=+b;c=+c;d=d|0;var e=0,f=0;e=b-+g[a+12>>2];b=c-+g[a+16>>2];c=+g[a+24>>2];f=+g[a+20>>2];g[d>>2]=e*c+b*f;g[d+4>>2]=c*b-e*f;return}function _b(a,b,c,d){a=a|0;b=+b;c=+c;d=d|0;var e=0,f=0;e=b-+g[a+12>>2];b=c-+g[a+16>>2];c=+g[a+24>>2];f=+g[a+20>>2];g[d>>2]=e*c+b*f;g[d+4>>2]=c*b-e*f;return}function $b(a){a=a|0;return+ +g[a+132>>2]}function ac(a,b){a=a|0;b=b|0;var c=0;c=+g[a+16>>2];g[b>>2]=+g[a+12>>2];g[b+4>>2]=c;return}function bc(a,
b){a=a|0;b=b|0;g[b>>2]=+g[a+12>>2];g[b+4>>2]=+g[a+16>>2];g[b+8>>2]=+g[a+20>>2];g[b+12>>2]=+g[a+24>>2];return}function cc(a){a=a|0;return+ +((c[a>>2]|0)>>>0)}function dc(a,b){a=a|0;b=b|0;var c=0;c=+g[a+64>>2];g[b>>2]=+g[a+60>>2];g[b+4>>2]=c;return}function ec(a,b,c,d){a=a|0;b=+b;c=+c;d=d|0;var e=0,f=0,h=0;e=b;b=c;c=+g[a+24>>2];f=+g[a+20>>2];h=b*c+e*f+ +g[a+16>>2];g[d>>2]=+g[a+12>>2]+(e*c-b*f);g[d+4>>2]=h;return}function fc(a,b,c,d){a=a|0;b=+b;c=+c;d=d|0;var e=0,f=0,h=0;e=b;b=c;c=+g[a+24>>2];f=+g[a+
20>>2];h=b*c+e*f+ +g[a+16>>2];g[d>>2]=+g[a+12>>2]+(e*c-b*f);g[d+4>>2]=h;return}function gc(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0;f=i;h=a+4|0;j=e[h>>1]|0;if(!(d!=0)){b[h>>1]=j&65533;g[a+160>>2]=0;k=a+80|0;c[k+0>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;c[k+16>>2]=0;c[k+20>>2]=0;i=f;return}if((j&2|0)!=0){i=f;return}b[h>>1]=j|2;g[a+160>>2]=0;i=f;return}function hc(a,d){a=a|0;d=+d;var f=0,h=0,j=0,k=0;f=i;h=d;if((c[a>>2]|0)==0){i=f;return}if(h*h>0?(j=a+4|0,k=e[j>>1]|0,(k&2|0)==0):0){b[j>>1]=k|2;g[a+160>>
2]=0}g[a+88>>2]=h;i=f;return}function ic(a,d,f){a=a|0;d=+d;f=+f;var h=0,j=0,k=0,l=0;h=i;j=d;d=f;if((c[a>>2]|0)==0){i=h;return}if(j*j+d*d>0?(k=a+4|0,l=e[k>>1]|0,(l&2|0)==0):0){b[k>>1]=l|2;g[a+160>>2]=0}f=+j;j=+d;l=a+80|0;g[l>>2]=f;g[l+4>>2]=j;i=h;return}function jc(a,b,c,d,e){a=a|0;b=+b;c=+c;d=+d;e=+e;var f=0,h=0;f=i;i=i+16|0;h=f;g[h>>2]=b;g[h+4>>2]=c;g[h+8>>2]=d;g[h+12>>2]=e;Oj(a,h);i=f;return}function kc(a,b,c,d){a=a|0;b=+b;c=+c;d=+d;var e=0,f=0;e=i;i=i+16|0;f=e;g[f>>2]=b;g[f+4>>2]=c;Qj(a,f,d);i=
e;return}function lc(a,b){a=a|0;b=+b;var c=0;c=i;Jj(a,~~b>>>0);i=c;return}function mc(a,b,d){a=a|0;b=+b;d=+d;var e=0,f=0,h=0;e=i;i=i+16|0;f=e;g[f>>2]=b;g[f+4>>2]=d;h=c[a+12>>2]|0;d=+((hb[c[(c[h>>2]|0)+16>>2]&15](h,(c[a+8>>2]|0)+12|0,f)|0)&1);i=e;return+d}function nc(a){a=a|0;return}function oc(a){a=a|0;return}function pc(a){a=a|0;return}function qc(a,b){a=+a;b=+b;var c=0,d=0,e=0;c=i;i=i+16|0;d=c;e=qn(103048)|0;g[d>>2]=a;g[d+4>>2]=b;rj(e,d);i=c;return e|0}function rc(b,d,e,f,h,j,k,l,m,n,o,p,q,r,s,
t,u){b=b|0;d=+d;e=+e;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=u|0;var v=0,w=0,x=0,y=0,z=0;v=i;i=i+64|0;w=v;x=w+44|0;y=w+4|0;z=w+36|0;c[y+0>>2]=0;c[y+4>>2]=0;c[y+8>>2]=0;c[y+12>>2]=0;c[y+16>>2]=0;c[y+20>>2]=0;a[w+40>>0]=d!=0&1;a[z>>0]=e!=0&1;g[w+12>>2]=f;g[w+24>>2]=h;g[w+32>>2]=j;a[w+37>>0]=k!=0&1;a[w+39>>0]=l!=0&1;a[w+38>>0]=m!=0&1;g[w+48>>2]=n;g[w+28>>2]=o;g[w+16>>2]=p;g[w+20>>2]=q;g[y>>2]=r;g[w+8>>2]=s;c[w>>2]=~~t>>>0;c[x>>2]=u;u=vj(b,w)|0;i=v;return u|0}function sc(b,
d,e,f,h,j,k,l,m,n,o,p,q,r,s,t,u,v){b=b|0;d=+d;e=+e;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;v=+v;var w=0,x=0,y=0;w=i;i=i+96|0;x=w;a[x>>0]=0;g[x+4>>2]=1;g[x+8>>2]=1;c[x+16>>2]=0;g[x+72>>2]=d;g[x+24>>2]=e;a[x+76>>0]=f!=0&1;g[x+56>>2]=h;g[x+28>>2]=j;g[x+80>>2]=k;g[x+52>>2]=l;g[x+20>>2]=m;g[x+12>>2]=n;g[x+48>>2]=o;g[x+32>>2]=p;c[x+68>>2]=~~q;g[x+64>>2]=r;g[x+60>>2]=s;g[x+44>>2]=t;g[x+40>>2]=u;g[x+36>>2]=v;y=zj(b,x)|0;i=w;return y|0}function tc(a){a=a|0;var b=0;b=i;if((a|0)!=
0){sj(a);sn(a)}i=b;return}function uc(a,b){a=a|0;b=b|0;var c=0;c=i;wj(a,b);i=c;return}function vc(a,b){a=a|0;b=b|0;var c=0;c=i;xj(a,b);i=c;return}function wc(a,b){a=a|0;b=b|0;var c=0;c=i;tj(a,b);i=c;return}function xc(a,b,c,d,e){a=a|0;b=+b;c=+c;d=+d;e=+e;var f=0,h=0,j=0,k=0;f=i;i=i+16|0;h=f;j=+b;b=+c;k=h;g[k>>2]=j;g[k+4>>2]=b;b=+d;d=+e;k=h+8|0;g[k>>2]=b;g[k+4>>2]=d;Dj(a,16,h);i=f;return}function yc(a,b,c,d,e){a=a|0;b=+b;c=+c;d=+d;e=+e;var f=0,h=0,j=0;f=i;i=i+16|0;h=f+8|0;j=f;g[h>>2]=b;g[h+4>>2]=c;
g[j>>2]=d;g[j+4>>2]=e;Ej(a,24,h,j);i=f;return}function zc(a){a=a|0;var b=0;b=i;uj(a,8);i=b;return}function Ac(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0,f=0;d=i;e=+b;b=+c;f=a+102980|0;g[f>>2]=e;g[f+4>>2]=b;i=d;return}function Bc(a,b,c,d){a=a|0;b=+b;c=+c;d=+d;var e=0;e=i;Cj(a,b,~~c,~~d,3);i=e;return}function Cc(a){a=a|0;return a+64|0}function Dc(a){a=a|0;var b=0,d=0,e=0;b=i;d=c[a+48>>2]|0;e=c[a+52>>2]|0;jf(32,a+64|0,(c[d+8>>2]|0)+12|0,+g[(c[d+12>>2]|0)+8>>2],(c[e+8>>2]|0)+12|0,+g[(c[e+12>>2]|0)+8>>2]);i=b;
return 32}function Ec(b,d,e,f,h,j,k,l,m,n,o){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;var p=0,q=0,r=0;p=i;i=i+48|0;q=p;c[q+0>>2]=0;c[q+4>>2]=0;c[q+8>>2]=0;c[q+12>>2]=0;c[q>>2]=3;r=q+20|0;c[r>>2]=0;c[r+4>>2]=0;c[q+8>>2]=d;c[q+12>>2]=e;a[q+16>>0]=f!=0&1;g[q+44>>2]=h;g[q+40>>2]=j;g[q+36>>2]=k;k=+l;l=+m;e=q+20|0;g[e>>2]=k;g[e+4>>2]=l;l=+n;n=+o;e=q+28|0;g[e>>2]=l;g[e+4>>2]=n;e=yj(b,q)|0;i=p;return e|0}function Fc(b,d,e,f,h,j,k,l,m,n){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;
var o=0,p=0,q=0,r=0,s=0,t=0;o=i;i=i+64|0;p=o+16|0;q=o+8|0;r=o;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;c[p>>2]=3;s=p+20|0;t=p+36|0;c[s+0>>2]=0;c[s+4>>2]=0;c[s+8>>2]=0;c[s+12>>2]=0;g[t>>2]=1;a[p+16>>0]=l!=0&1;g[p+44>>2]=m;g[p+40>>2]=n;g[q>>2]=f;g[q+4>>2]=h;g[r>>2]=j;g[r+4>>2]=k;Xf(p,d,e,q,r);r=yj(b,p)|0;i=o;return r|0}function Gc(b,d,e,f,h,j,k,l,m,n){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;var o=0,p=0,q=0;o=i;i=i+48|0;p=o;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;c[p>>2]=
9;q=p+20|0;c[q+0>>2]=0;c[q+4>>2]=0;c[q+8>>2]=0;c[q+12>>2]=0;c[q+16>>2]=0;c[p+8>>2]=d;c[p+12>>2]=e;a[p+16>>0]=f!=0&1;f=+h;h=+j;e=p+20|0;g[e>>2]=f;g[e+4>>2]=h;h=+k;k=+l;e=p+28|0;g[e>>2]=h;g[e+4>>2]=k;g[p+36>>2]=m;g[p+40>>2]=n;e=yj(b,p)|0;i=o;return e|0}function Hc(b,d,e,f,h,j,k,l){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;var m=0,n=0,o=0,p=0;m=i;i=i+64|0;n=m+8|0;o=m;c[n+0>>2]=0;c[n+4>>2]=0;c[n+8>>2]=0;c[n+12>>2]=0;c[n>>2]=9;p=n+20|0;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;c[p+16>>2]=0;a[n+
16>>0]=j!=0&1;g[n+36>>2]=k;g[n+40>>2]=l;g[o>>2]=f;g[o+4>>2]=h;hg(n,d,e,o);o=yj(b,n)|0;i=m;return o|0}function Ic(a){a=a|0;var b=0,c=0;b=i;c=+Ng(a);i=b;return+c}function Jc(b,d,e,f,h,j,k){b=b|0;d=d|0;e=e|0;f=+f;h=h|0;j=j|0;k=+k;var l=0,m=0;l=i;i=i+32|0;m=l;c[m+0>>2]=0;c[m+4>>2]=0;c[m+8>>2]=0;c[m+12>>2]=0;c[m>>2]=6;c[m+8>>2]=d;c[m+12>>2]=e;a[m+16>>0]=f!=0&1;c[m+20>>2]=h;c[m+24>>2]=j;g[m+28>>2]=k;j=yj(b,m)|0;i=l;return j|0}function Kc(a){a=a|0;return c[a+48>>2]|0}function Lc(a){a=a|0;return c[a+52>>
2]|0}function Mc(a,b){a=a|0;b=+b;var c=0;c=i;Sf(a,b);i=c;return}function Nc(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0;d=i;i=i+16|0;e=d;g[e>>2]=b;g[e+4>>2]=c;Rf(a,e);i=d;return}function Oc(b,d,e,f,h,j,k,l,m,n){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;var o=0,p=0;o=i;i=i+48|0;p=o;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;c[p>>2]=11;c[p+8>>2]=d;c[p+12>>2]=e;a[p+16>>0]=f!=0&1;g[p+28>>2]=h;g[p+40>>2]=j;j=+k;k=+l;e=p+20|0;g[e>>2]=j;g[e+4>>2]=k;g[p+32>>2]=m;g[p+36>>2]=n;e=yj(b,p)|0;i=o;return e|
0}function Pc(b,d,e,f,h,j,k){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;var l=0,m=0;l=i;i=i+48|0;m=l;c[m+0>>2]=0;c[m+4>>2]=0;c[m+8>>2]=0;c[m+12>>2]=0;c[m>>2]=11;g[m+20>>2]=0;g[m+24>>2]=0;g[m+28>>2]=0;a[m+16>>0]=f!=0&1;g[m+40>>2]=h;g[m+32>>2]=j;g[m+36>>2]=k;If(m,d,e);e=yj(b,m)|0;i=l;return e|0}function Qc(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0;d=i;i=i+16|0;e=d;g[e>>2]=b;g[e+4>>2]=c;wf(a,e);i=d;return}function Rc(b,d,e,f,h,j,k,l,m){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;var n=0,o=0;n=i;i=i+48|0;o=n;
c[o+0>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;c[o+12>>2]=0;c[o>>2]=5;c[o+8>>2]=d;c[o+12>>2]=e;a[o+16>>0]=f!=0&1;g[o+36>>2]=h;g[o+32>>2]=j;g[o+28>>2]=k;k=+l;l=+m;e=o+20|0;g[e>>2]=k;g[e+4>>2]=l;e=yj(b,o)|0;i=n;return e|0}function Sc(a,b){a=a|0;b=+b;var c=0;c=i;ah(a,b!=0);i=c;return}function Tc(a,b){a=a|0;b=+b;var c=0;c=i;ch(a,b!=0);i=c;return}function Uc(a){a=a|0;var b=0,c=0;b=i;c=+_g(a);i=b;return+c}function Vc(a){a=a|0;return+ +g[a+132>>2]}function Wc(a,b){a=a|0;b=+b;var c=0,d=0;c=i;d=+eh(a,b);i=c;return+d}
function Xc(a){a=a|0;var b=0,c=0;b=i;c=+(($g(a)|0)&1);i=b;return+c}function Yc(a){a=a|0;var b=0,c=0;b=i;c=+((bh(a)|0)&1);i=b;return+c}function Zc(a,b){a=a|0;b=+b;var c=0;c=i;dh(a,b);i=c;return}function _c(b,d,e,f,h,j,k,l,m,n,o,p,q,r,s,t,u){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;t=+t;u=+u;var v=0,w=0,x=0;v=i;i=i+80|0;w=v;c[w+0>>2]=0;c[w+4>>2]=0;c[w+8>>2]=0;c[w+12>>2]=0;c[w>>2]=2;x=w+20|0;c[x>>2]=0;c[x+4>>2]=0;c[w+8>>2]=d;c[w+12>>2]=e;a[w+16>>0]=f!=0&1;a[w+48>>
0]=h!=0&1;a[w+60>>0]=j!=0&1;j=+k;k=+l;e=w+20|0;g[e>>2]=j;g[e+4>>2]=k;k=+m;m=+n;e=w+28|0;g[e>>2]=k;g[e+4>>2]=m;m=+o;o=+p;e=w+36|0;g[e>>2]=m;g[e+4>>2]=o;g[w+52>>2]=q;g[w+64>>2]=r;g[w+68>>2]=s;g[w+44>>2]=t;g[w+56>>2]=u;e=yj(b,w)|0;i=v;return e|0}function $c(b,d,e,f,h,j,k,l,m,n,o,p,q,r){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;var s=0,t=0,u=0,v=0,w=0,x=0;s=i;i=i+96|0;t=s+16|0;u=s+8|0;v=s;c[t+0>>2]=0;c[t+4>>2]=0;c[t+8>>2]=0;c[t+12>>2]=0;c[t>>2]=2;w=t+20|0;x=t+36|0;c[w+0>>
2]=0;c[w+4>>2]=0;c[w+8>>2]=0;c[w+12>>2]=0;g[x>>2]=1;g[t+40>>2]=0;g[t+44>>2]=0;a[t+16>>0]=l!=0&1;a[t+48>>0]=m!=0&1;a[t+60>>0]=n!=0&1;g[t+52>>2]=o;g[t+64>>2]=p;g[t+68>>2]=q;g[t+56>>2]=r;g[u>>2]=f;g[u+4>>2]=h;g[v>>2]=j;g[v+4>>2]=k;Rg(t,d,e,u,v);v=yj(b,t)|0;i=s;return v|0}function ad(b,d,e,f,h,j,k,l,m,n,o,p,q,r,s){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;var t=0,u=0;t=i;i=i+64|0;u=t;c[u+0>>2]=0;c[u+4>>2]=0;c[u+8>>2]=0;c[u>>2]=4;c[u+8>>2]=d;c[u+12>>2]=e;a[u+16>>0]=
f!=0&1;f=+h;h=+j;e=u+20|0;g[e>>2]=f;g[e+4>>2]=h;h=+k;k=+l;e=u+28|0;g[e>>2]=h;g[e+4>>2]=k;g[u+52>>2]=m;g[u+56>>2]=n;n=+o;o=+p;e=u+36|0;g[e>>2]=n;g[e+4>>2]=o;o=+q;q=+r;e=u+44|0;g[e>>2]=o;g[e+4>>2]=q;g[u+60>>2]=s;e=yj(b,u)|0;i=t;return e|0}function bd(b,d,e,f,h,j,k,l,m,n,o,p,q){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;var r=0,s=0,t=0,u=0,v=0,w=0;r=i;i=i+96|0;s=r+32|0;t=r+24|0;u=r+16|0;v=r+8|0;w=r;c[s+0>>2]=0;c[s+4>>2]=0;c[s+8>>2]=0;c[s+12>>2]=0;c[s>>2]=4;g[s+20>>2]=-1;g[s+
24>>2]=1;g[s+28>>2]=1;g[s+32>>2]=1;g[s+36>>2]=-1;g[s+40>>2]=0;g[s+44>>2]=1;g[s+48>>2]=0;g[s+52>>2]=0;g[s+56>>2]=0;g[s+60>>2]=1;a[s+16>>0]=q!=0&1;g[t>>2]=l;g[t+4>>2]=m;g[u>>2]=n;g[u+4>>2]=o;g[v>>2]=f;g[v+4>>2]=h;g[w>>2]=j;g[w+4>>2]=k;ci(s,d,e,t,u,v,w,p);w=yj(b,s)|0;i=r;return w|0}function cd(a,b){a=a|0;b=+b;var c=0;c=i;Nh(a,b!=0);i=c;return}function dd(a,b){a=a|0;b=+b;var c=0;c=i;Kh(a,b!=0);i=c;return}function ed(a){a=a|0;var b=0,c=0;b=i;c=+Ih(a);i=b;return+c}function fd(a){a=a|0;var b=0,c=0;b=i;c=
+((Mh(a)|0)&1);i=b;return+c}function gd(a){a=a|0;var b=0,c=0;b=i;c=+((Jh(a)|0)&1);i=b;return+c}function hd(b,d,e,f,h,j,k,l,m,n,o,p,q,r,s){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;var t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;t=i;i=i+64|0;u=t;c[u+0>>2]=0;c[u+4>>2]=0;c[u+8>>2]=0;c[u+12>>2]=0;c[u>>2]=1;v=u+20|0;w=u+44|0;x=u+48|0;y=u+60|0;z=u+56|0;A=u+52|0;c[v+0>>2]=0;c[v+4>>2]=0;c[v+8>>2]=0;c[v+12>>2]=0;c[u+8>>2]=d;c[u+12>>2]=e;a[u+16>>0]=f!=0&1;a[u+40>>0]=h!=0&1;a[A>>0]=j!=
0&1;j=+l;l=+m;A=u+20|0;g[A>>2]=j;g[A+4>>2]=l;l=+n;n=+o;A=u+28|0;g[A>>2]=l;g[A+4>>2]=n;g[w>>2]=k;g[y>>2]=p;g[z>>2]=q;g[u+36>>2]=r;g[x>>2]=s;x=yj(b,u)|0;i=t;return x|0}function id(b,d,e,f,h,j,k,l,m,n,o,p){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;var q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0;q=i;i=i+80|0;r=q+8|0;s=q;c[r+0>>2]=0;c[r+4>>2]=0;c[r+8>>2]=0;c[r+12>>2]=0;c[r>>2]=1;t=r+20|0;u=r+44|0;v=r+48|0;w=r+60|0;x=r+56|0;y=r+52|0;c[t+0>>2]=0;c[t+4>>2]=0;c[t+8>>2]=0;c[t+12>>2]=0;c[t+16>>
2]=0;a[r+16>>0]=j!=0&1;a[r+40>>0]=k!=0&1;a[y>>0]=l!=0&1;g[u>>2]=m;g[w>>2]=n;g[x>>2]=o;g[v>>2]=p;g[s>>2]=f;g[s+4>>2]=h;zh(r,d,e,s);s=yj(b,r)|0;i=q;return s|0}function jd(a,b){a=a|0;b=+b;var c=0;c=i;Lh(a,b);i=c;return}function kd(b,d,e,f,h,j,k,l,m){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;var n=0,o=0;n=i;i=i+48|0;o=n;c[o+0>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;c[o+12>>2]=0;c[o>>2]=10;c[o+8>>2]=d;c[o+12>>2]=e;a[o+16>>0]=f!=0&1;f=+h;h=+j;e=o+20|0;g[e>>2]=f;g[e+4>>2]=h;h=+k;k=+l;e=o+28|0;g[e>>2]=h;g[e+
4>>2]=k;g[o+36>>2]=m;e=yj(b,o)|0;i=n;return e|0}function ld(b,d,e,f,h,j,k,l,m,n,o){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;var p=0,q=0,r=0;p=i;i=i+48|0;q=p;c[q+0>>2]=0;c[q+4>>2]=0;c[q+8>>2]=0;c[q+12>>2]=0;c[q>>2]=8;r=q+20|0;c[r+0>>2]=0;c[r+4>>2]=0;c[r+8>>2]=0;c[r+12>>2]=0;c[q+8>>2]=d;c[q+12>>2]=e;a[q+16>>0]=f!=0&1;g[q+44>>2]=h;g[q+40>>2]=j;j=+k;k=+l;e=q+20|0;g[e>>2]=j;g[e+4>>2]=k;k=+m;m=+n;e=q+28|0;g[e>>2]=k;g[e+4>>2]=m;g[q+36>>2]=o;e=yj(b,q)|0;i=p;return e|0}function md(b,d,e,f,
h,j,k,l){b=b|0;d=d|0;e=e|0;f=+f;h=+h;j=+j;k=+k;l=+l;var m=0,n=0,o=0,p=0;m=i;i=i+64|0;n=m+8|0;o=m;c[n+0>>2]=0;c[n+4>>2]=0;c[n+8>>2]=0;c[n+12>>2]=0;c[n>>2]=8;p=n+20|0;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;c[p+16>>2]=0;a[n+16>>0]=j!=0&1;g[n+44>>2]=k;g[n+40>>2]=l;g[o>>2]=f;g[o+4>>2]=h;tg(n,d,e,o);o=yj(b,n)|0;i=m;return o|0}function nd(a,b){a=a|0;b=+b;var c=0;c=i;_h(a,b);i=c;return}function od(a,b){a=a|0;b=+b;g[a+68>>2]=b;return}function pd(b,d,e,f,h,j,k,l,m,n,o,p,q,r,s){b=b|0;d=d|0;e=e|0;f=
+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;s=+s;var t=0,u=0,v=0;t=i;i=i+64|0;u=t;c[u+0>>2]=0;c[u+4>>2]=0;c[u+8>>2]=0;c[u+12>>2]=0;c[u>>2]=7;v=u+20|0;c[v>>2]=0;c[v+4>>2]=0;c[u+8>>2]=d;c[u+12>>2]=e;a[u+16>>0]=f!=0&1;g[u+60>>2]=h;a[u+44>>0]=j!=0&1;g[u+56>>2]=k;k=+l;l=+m;e=u+20|0;g[e>>2]=k;g[e+4>>2]=l;l=+n;n=+o;e=u+28|0;g[e>>2]=l;g[e+4>>2]=n;n=+p;p=+q;e=u+36|0;g[e>>2]=n;g[e+4>>2]=p;g[u+48>>2]=r;g[u+52>>2]=s;e=yj(b,u)|0;i=t;return e|0}function qd(b,d,e,f,h,j,k,l,m,n,o,p,q){b=b|0;d=d|0;e=e|0;
f=+f;h=+h;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;var r=0,s=0,t=0,u=0,v=0,w=0;r=i;i=i+80|0;s=r+16|0;t=r+8|0;u=r;c[s+0>>2]=0;c[s+4>>2]=0;c[s+8>>2]=0;c[s+12>>2]=0;c[s>>2]=7;v=s+20|0;w=s+36|0;c[v+0>>2]=0;c[v+4>>2]=0;c[v+8>>2]=0;c[v+12>>2]=0;g[w>>2]=1;g[s+40>>2]=0;a[s+16>>0]=l!=0&1;g[s+60>>2]=m;a[s+44>>0]=n!=0&1;g[s+56>>2]=o;g[s+48>>2]=p;g[s+52>>2]=q;g[t>>2]=f;g[t+4>>2]=h;g[u>>2]=j;g[u+4>>2]=k;Rh(s,d,e,t,u);u=yj(b,s)|0;i=r;return u|0}function rd(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0;d=i;i=i+16|0;e=d;g[e>>
2]=b;g[e+4>>2]=c;ok(a,e);i=d;return}function sd(a,b,c){a=a|0;b=+b;c=+c;var d=0,e=0;d=i;i=i+16|0;e=d;g[e>>2]=b;g[e+4>>2]=c;pk(a,e);i=d;return}function td(a,b){a=a|0;b=+b;var c=0;c=i;qk(a,b!=0);i=c;return}function ud(a){a=a|0;return+ +(c[a+4>>2]|0)}function vd(a){a=a|0;return+ +((c[a+8>>2]|0)-(c[a+4>>2]|0)|0)}function wd(b,d,e,f,j,k,l,m,n,o,p,q,r){b=b|0;d=+d;e=+e;f=+f;j=+j;k=+k;l=+l;m=+m;n=+n;o=+o;p=+p;q=+q;r=+r;var s=0,t=0,u=0,v=0;s=i;i=i+64|0;t=s+8|0;u=s;v=s+16|0;h[t>>3]=l;h[u>>3]=p;a[v+20>>0]=~~d;
a[v+21>>0]=~~f;a[v+22>>0]=~~e;a[v+23>>0]=~~j;c[v>>2]=~~k>>>0;c[v+32>>2]=t;g[v+24>>2]=m;m=+n;n=+o;t=v+4|0;g[t>>2]=m;g[t+4>>2]=n;c[v+28>>2]=u;n=+q;q=+r;u=v+12|0;g[u>>2]=n;g[u+4>>2]=q;q=+(wk(b,v)|0);i=s;return+q}function xd(a){a=a|0;var b=0,c=0;b=i;c=uk(a)|0;i=b;return c|0}function yd(a){a=a|0;return+ +(c[a+44>>2]|0)}function zd(a){a=a|0;return c[a+96>>2]|0}function Ad(a){a=a|0;return c[a+104>>2]|0}function Bd(a,b){a=a|0;b=+b;g[a+340>>2]=b;return}function Cd(a,b){a=a|0;b=+b;var c=0;c=b;g[a+320>>2]=c;
g[a+28>>2]=1/c;return}function Dd(a,b){a=a|0;b=+b;var c=0;c=b*2;g[a+32>>2]=c;g[a+40>>2]=c*c;g[a+36>>2]=1/c;return}function Ed(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Fd(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=+e;var f=0;a=i;f=+La(b|0,+ +g[c>>2],+ +g[c+4>>2],+ +g[d>>2],+ +g[d+4>>2],+e);i=a;return+f}function Gd(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=+f;return 0}function Hd(a,b){a=a|0;b=b|0;return 1}function Id(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Jd(a,b){a=a|0;b=b|0;var c=0;a=i;
c=Xa(b|0)|0;i=a;return c|0}function Kd(a,b,c){a=a|0;b=b|0;c=c|0;return 0}function Ld(a,b){a=a|0;b=b|0;return 1}function Md(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Nd(a,b){a=a|0;b=b|0;a=i;Pa(b|0);i=a;return}function Od(a,b){a=a|0;b=b|0;a=i;Wa(b|0);i=a;return}function Pd(a,b,c){a=a|0;b=b|0;c=c|0;return}function Qd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return}function Rd(a,b,c){a=a|0;b=b|0;c=c|0;return}function Sd(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return}function Td(a,b,c){a=a|0;b=b|0;c=c|0;a=i;ya(b|
0,c|0);i=a;return}function Ud(a,b,c){a=a|0;b=b|0;c=c|0;a=i;Ya(b|0,c|0);i=a;return}function Vd(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Wd(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Xd(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function Yd(){c[2]=280;c[4]=176;c[6]=72;return}function Zd(d,e){d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,P=0,Q=0,R=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=
0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0,Fa=0,Ga=0,Ha=0;f=i;i=i+320|0;h=f;j=f+284|0;k=f+248|0;l=f+236|0;m=f+144|0;n=f+120|0;o=f+16|0;p=f+12|0;q=f+8|0;Km(h);c[104]=(c[104]|0)+1;c[d>>2]=0;r=e+128|0;s=d+4|0;g[s>>2]=+g[r>>2];t=e+28|0;u=j+0|0;v=e+56|0;w=u+36|0;do{c[u>>2]=c[v>>2];u=u+4|0;v=v+4|0}while((u|0)<(w|0));u=k+0|0;v=e+92|0;w=u+36|0;do{c[u>>2]=c[v>>2];u=u+4|0;v=v+4|0}while((u|0)<(w|0));v=j+24|0;x=
+g[v>>2];y=+O(+(x/6.2831854820251465))*6.2831854820251465;z=x-y;g[v>>2]=z;u=j+28|0;x=+g[u>>2]-y;g[u>>2]=x;w=k+24|0;y=+g[w>>2];A=+O(+(y/6.2831854820251465))*6.2831854820251465;B=y-A;g[w>>2]=B;C=k+28|0;y=+g[C>>2]-A;g[C>>2]=y;A=+g[r>>2];D=+g[e+24>>2]+ +g[e+52>>2]+-.014999999664723873;E=D<.004999999888241291?.004999999888241291:D;b[l+4>>1]=0;c[m+0>>2]=c[e+0>>2];c[m+4>>2]=c[e+4>>2];c[m+8>>2]=c[e+8>>2];c[m+12>>2]=c[e+12>>2];c[m+16>>2]=c[e+16>>2];c[m+20>>2]=c[e+20>>2];c[m+24>>2]=c[e+24>>2];r=m+28|0;c[r+
0>>2]=c[t+0>>2];c[r+4>>2]=c[t+4>>2];c[r+8>>2]=c[t+8>>2];c[r+12>>2]=c[t+12>>2];c[r+16>>2]=c[t+16>>2];c[r+20>>2]=c[t+20>>2];c[r+24>>2]=c[t+24>>2];a[m+88>>0]=0;r=j+8|0;F=j+12|0;G=j+16|0;H=j+20|0;I=j+4|0;J=k+8|0;K=k+12|0;L=k+16|0;M=k+20|0;N=k+4|0;P=m+56|0;Q=m+64|0;R=m+68|0;U=m+72|0;V=m+80|0;W=m+84|0;X=n+16|0;D=E+.0012499999720603228;Y=E+-.0012499999720603228;Z=z;z=x;x=B;B=y;_=0;y=0;a:while(1){$=1-y;aa=$*Z+y*z;ba=+T(+aa);ca=+S(+aa);aa=+g[j>>2];da=+g[I>>2];ea=$*x+y*B;fa=+T(+ea);ga=+S(+ea);ea=+g[k>>2];ha=
+g[N>>2];ia=$*+g[J>>2]+y*+g[L>>2]-(ga*ea-fa*ha);ja=$*+g[K>>2]+y*+g[M>>2]-(fa*ea+ga*ha);ha=+($*+g[r>>2]+y*+g[G>>2]-(ca*aa-ba*da));ea=+($*+g[F>>2]+y*+g[H>>2]-(ba*aa+ca*da));ka=P;g[ka>>2]=ha;g[ka+4>>2]=ea;g[Q>>2]=ba;g[R>>2]=ca;ca=+ia;ia=+ja;ka=U;g[ka>>2]=ca;g[ka+4>>2]=ia;g[V>>2]=fa;g[W>>2]=ga;de(n,l,m);ga=+g[X>>2];if(ga<=0){la=3;break}if(ga<D){la=5;break}+_d(o,l,e,j,t,k,y);ka=0;ga=A;while(1){fa=+$d(o,p,q,ga);if(fa>D){la=8;break a}if(fa>Y){ma=ga;break}na=c[p>>2]|0;oa=c[q>>2]|0;ia=+ae(o,na,oa,y);if(ia<
Y){la=11;break a}if(!(ia<=D)){pa=y;qa=ga;ra=0;sa=ia;ta=fa}else{la=13;break a}while(1){if((ra&1|0)==0)ua=(pa+qa)*.5;else ua=pa+(E-sa)*(qa-pa)/(ta-sa);ra=ra+1|0;c[110]=(c[110]|0)+1;fa=+ae(o,na,oa,ua);ia=fa-E;if(ia>0)va=ia;else va=-ia;if(va<.0012499999720603228){wa=ua;break}xa=fa>E;if((ra|0)==50){wa=ga;break}else{pa=xa?ua:pa;qa=xa?qa:ua;sa=xa?fa:sa;ta=xa?ta:fa}}oa=c[112]|0;c[112]=(oa|0)>(ra|0)?oa:ra;ka=ka+1|0;if((ka|0)==8){ma=y;break}else ga=wa}ka=_+1|0;c[106]=(c[106]|0)+1;if((ka|0)==20){la=25;break}Z=
+g[v>>2];z=+g[u>>2];x=+g[w>>2];B=+g[C>>2];_=ka;y=ma}if((la|0)==3){c[d>>2]=2;g[s>>2]=0;ya=_;za=c[108]|0;Aa=(za|0)>(ya|0);Ba=Aa?za:ya;c[108]=Ba;Ca=+Mm(h);Da=+g[102];Ea=Da>Ca;Fa=Ea?Da:Ca;g[102]=Fa;Ga=+g[100];Ha=Ca+Ga;g[100]=Ha;i=f;return}else if((la|0)==5){c[d>>2]=3;g[s>>2]=y;ya=_;za=c[108]|0;Aa=(za|0)>(ya|0);Ba=Aa?za:ya;c[108]=Ba;Ca=+Mm(h);Da=+g[102];Ea=Da>Ca;Fa=Ea?Da:Ca;g[102]=Fa;Ga=+g[100];Ha=Ca+Ga;g[100]=Ha;i=f;return}else if((la|0)==8){c[d>>2]=4;g[s>>2]=A}else if((la|0)==11){c[d>>2]=1;g[s>>2]=y}else if((la|
0)==13){c[d>>2]=3;g[s>>2]=y}else if((la|0)==25){c[d>>2]=1;g[s>>2]=ma;ya=20;za=c[108]|0;Aa=(za|0)>(ya|0);Ba=Aa?za:ya;c[108]=Ba;Ca=+Mm(h);Da=+g[102];Ea=Da>Ca;Fa=Ea?Da:Ca;g[102]=Fa;Ga=+g[100];Ha=Ca+Ga;g[100]=Ha;i=f;return}c[106]=(c[106]|0)+1;ya=_+1|0;za=c[108]|0;Aa=(za|0)>(ya|0);Ba=Aa?za:ya;c[108]=Ba;Ca=+Mm(h);Da=+g[102];Ea=Da>Ca;Fa=Ea?Da:Ca;g[102]=Fa;Ga=+g[100];Ha=Ca+Ga;g[100]=Ha;i=f;return}function _d(e,f,h,j,k,l,m){e=e|0;f=f|0;h=h|0;j=j|0;k=k|0;l=l|0;m=+m;var n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=
0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0;n=i;c[e>>2]=h;c[e+4>>2]=k;o=b[f+4>>1]|0;p=e+8|0;q=p+0|0;r=j+0|0;j=q+36|0;do{c[q>>2]=c[r>>2];q=q+4|0;r=r+4|0}while((q|0)<(j|0));s=e+44|0;q=s+0|0;r=l+0|0;j=q+36|0;do{c[q>>2]=c[r>>2];q=q+4|0;r=r+4|0}while((q|0)<(j|0));t=1-m;u=t*+g[e+32>>2]+ +g[e+36>>2]*m;v=+T(+u);w=+S(+u);u=+g[p>>2];x=+g[e+12>>2];y=t*+g[e+16>>2]+ +g[e+24>>2]*m-(w*u-v*x);z=t*+g[e+20>>2]+ +g[e+28>>2]*m-(v*u+w*x);x=t*+g[e+68>>2]+ +g[e+72>>2]*m;u=+T(+x);A=+S(+x);x=+g[s>>
2];B=+g[e+48>>2];C=t*+g[e+52>>2]+ +g[e+60>>2]*m-(A*x-u*B);D=t*+g[e+56>>2]+ +g[e+64>>2]*m-(u*x+A*B);if(o<<16>>16==1){c[e+80>>2]=0;o=(c[h+16>>2]|0)+(d[f+6>>0]<<3)|0;B=+g[o>>2];x=+g[o+4>>2];o=(c[k+16>>2]|0)+(d[f+9>>0]<<3)|0;m=+g[o>>2];t=+g[o+4>>2];o=e+92|0;E=C+(A*m-u*t)-(y+(w*B-v*x));F=D+(u*m+A*t)-(z+(v*B+w*x));x=+E;B=+F;s=o;g[s>>2]=x;g[s+4>>2]=B;B=+Q(+(E*E+F*F));if(B<1.1920928955078125E-7)G=0;else{x=1/B;g[o>>2]=E*x;g[e+96>>2]=F*x;G=B}o=8784;s=c[o+4>>2]|0;p=e+84|0;c[p>>2]=c[o>>2];c[p+4>>2]=s;H=G;i=n;
return+H}s=f+6|0;p=f+7|0;o=e+80|0;if((a[s>>0]|0)==(a[p>>0]|0)){c[o>>2]=2;r=c[k+16>>2]|0;q=r+(d[f+9>>0]<<3)|0;G=+g[q>>2];B=+g[q+4>>2];q=r+(d[f+10>>0]<<3)|0;x=+g[q>>2];F=+g[q+4>>2];q=e+92|0;E=x-G;t=F-B;m=-E;I=+t;J=+m;r=q;g[r>>2]=I;g[r+4>>2]=J;J=+Q(+(t*t+E*E));if(J<1.1920928955078125E-7){K=t;L=m}else{E=1/J;J=t*E;g[q>>2]=J;t=E*m;g[e+96>>2]=t;K=J;L=t}t=(G+x)*.5;x=(B+F)*.5;F=+t;B=+x;r=e+84|0;g[r>>2]=F;g[r+4>>2]=B;r=(c[h+16>>2]|0)+(d[s>>0]<<3)|0;B=+g[r>>2];F=+g[r+4>>2];G=(A*K-u*L)*(y+(w*B-v*F)-(C+(A*t-u*
x)))+(u*K+A*L)*(z+(v*B+w*F)-(D+(u*t+A*x)));if(!(G<0)){H=G;i=n;return+H}x=+-K;K=+-L;r=q;g[r>>2]=x;g[r+4>>2]=K;H=-G;i=n;return+H}else{c[o>>2]=1;o=c[h+16>>2]|0;h=o+(d[s>>0]<<3)|0;G=+g[h>>2];K=+g[h+4>>2];h=o+(d[p>>0]<<3)|0;x=+g[h>>2];L=+g[h+4>>2];h=e+92|0;t=x-G;F=L-K;B=-t;J=+F;m=+B;p=h;g[p>>2]=J;g[p+4>>2]=m;m=+Q(+(F*F+t*t));if(m<1.1920928955078125E-7){M=F;N=B}else{t=1/m;m=F*t;g[h>>2]=m;F=t*B;g[e+96>>2]=F;M=m;N=F}F=(G+x)*.5;x=(K+L)*.5;L=+F;K=+x;p=e+84|0;g[p>>2]=L;g[p+4>>2]=K;p=(c[k+16>>2]|0)+(d[f+9>>0]<<
3)|0;K=+g[p>>2];L=+g[p+4>>2];G=(w*M-v*N)*(C+(A*K-u*L)-(y+(w*F-v*x)))+(v*M+w*N)*(D+(u*K+A*L)-(z+(v*F+w*x)));if(!(G<0)){H=G;i=n;return+H}x=+-M;M=+-N;p=h;g[p>>2]=x;g[p+4>>2]=M;H=-G;i=n;return+H}return 0}function $d(a,b,d,e){a=a|0;b=b|0;d=d|0;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0;f=i;h=1-e;j=h*+g[a+32>>2]+ +g[a+36>>2]*e;k=+T(+j);l=+S(+j);j=+g[a+8>>2];m=+g[a+12>>2];n=h*+g[a+16>>2]+ +g[a+24>>2]*e-(l*j-k*m);o=h*+g[a+20>>2]+
+g[a+28>>2]*e-(k*j+l*m);m=h*+g[a+68>>2]+ +g[a+72>>2]*e;j=+T(+m);p=+S(+m);m=+g[a+44>>2];q=+g[a+48>>2];r=h*+g[a+52>>2]+ +g[a+60>>2]*e-(p*m-j*q);s=h*+g[a+56>>2]+ +g[a+64>>2]*e-(j*m+p*q);t=c[a+80>>2]|0;if((t|0)==0){q=+g[a+92>>2];m=+g[a+96>>2];e=l*q+k*m;h=l*m-k*q;u=-q;v=-m;w=p*u+j*v;x=p*v-j*u;y=c[a>>2]|0;z=c[y+16>>2]|0;A=c[y+20>>2]|0;if((A|0)>1){y=0;u=h*+g[z+4>>2]+e*+g[z>>2];B=1;while(1){v=e*+g[z+(B<<3)>>2]+h*+g[z+(B<<3)+4>>2];C=v>u;D=C?B:y;B=B+1|0;if((B|0)==(A|0)){E=D;break}else{y=D;u=C?v:u}}}else E=
0;c[b>>2]=E;E=c[a+4>>2]|0;y=c[E+16>>2]|0;A=c[E+20>>2]|0;if((A|0)>1){E=0;u=x*+g[y+4>>2]+w*+g[y>>2];B=1;while(1){h=w*+g[y+(B<<3)>>2]+x*+g[y+(B<<3)+4>>2];C=h>u;D=C?B:E;B=B+1|0;if((B|0)==(A|0)){F=D;break}else{E=D;u=C?h:u}}}else F=0;c[d>>2]=F;E=z+(c[b>>2]<<3)|0;u=+g[E>>2];x=+g[E+4>>2];E=y+(F<<3)|0;w=+g[E>>2];h=+g[E+4>>2];G=q*(r+(p*w-j*h)-(n+(l*u-k*x)))+m*(s+(j*w+p*h)-(o+(k*u+l*x)));i=f;return+G}else if((t|0)==1){x=+g[a+92>>2];u=+g[a+96>>2];h=l*x-k*u;w=k*x+l*u;u=+g[a+84>>2];x=+g[a+88>>2];m=n+(l*u-k*x);
q=o+(k*u+l*x);x=-h;u=-w;e=p*x+j*u;v=p*u-j*x;c[b>>2]=-1;E=c[a+4>>2]|0;F=c[E+16>>2]|0;y=c[E+20>>2]|0;if((y|0)>1){E=0;x=v*+g[F+4>>2]+e*+g[F>>2];z=1;while(1){u=e*+g[F+(z<<3)>>2]+v*+g[F+(z<<3)+4>>2];A=u>x;B=A?z:E;z=z+1|0;if((z|0)==(y|0)){H=B;break}else{E=B;x=A?u:x}}}else H=0;c[d>>2]=H;E=F+(H<<3)|0;x=+g[E>>2];v=+g[E+4>>2];G=h*(r+(p*x-j*v)-m)+w*(s+(j*x+p*v)-q);i=f;return+G}else if((t|0)==2){q=+g[a+92>>2];v=+g[a+96>>2];x=p*q-j*v;w=j*q+p*v;v=+g[a+84>>2];q=+g[a+88>>2];m=r+(p*v-j*q);r=s+(j*v+p*q);q=-x;p=-w;
v=l*q+k*p;j=l*p-k*q;c[d>>2]=-1;t=c[a>>2]|0;a=c[t+16>>2]|0;E=c[t+20>>2]|0;if((E|0)>1){t=0;q=j*+g[a+4>>2]+v*+g[a>>2];H=1;while(1){p=v*+g[a+(H<<3)>>2]+j*+g[a+(H<<3)+4>>2];F=p>q;y=F?H:t;H=H+1|0;if((H|0)==(E|0)){I=y;break}else{t=y;q=F?p:q}}}else I=0;c[b>>2]=I;t=a+(I<<3)|0;q=+g[t>>2];j=+g[t+4>>2];G=x*(n+(l*q-k*j)-m)+w*(o+(k*q+l*j)-r);i=f;return+G}else{c[b>>2]=-1;c[d>>2]=-1;G=0;i=f;return+G}return 0}function ae(a,b,d,e){a=a|0;b=b|0;d=d|0;e=+e;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=
0,w=0,x=0;f=i;h=1-e;j=h*+g[a+32>>2]+ +g[a+36>>2]*e;k=+T(+j);l=+S(+j);j=+g[a+8>>2];m=+g[a+12>>2];n=h*+g[a+16>>2]+ +g[a+24>>2]*e-(l*j-k*m);o=h*+g[a+20>>2]+ +g[a+28>>2]*e-(k*j+l*m);m=h*+g[a+68>>2]+ +g[a+72>>2]*e;j=+T(+m);p=+S(+m);m=+g[a+44>>2];q=+g[a+48>>2];r=h*+g[a+52>>2]+ +g[a+60>>2]*e-(p*m-j*q);s=h*+g[a+56>>2]+ +g[a+64>>2]*e-(j*m+p*q);t=c[a+80>>2]|0;if((t|0)==0){u=(c[(c[a>>2]|0)+16>>2]|0)+(b<<3)|0;q=+g[u>>2];m=+g[u+4>>2];u=(c[(c[a+4>>2]|0)+16>>2]|0)+(d<<3)|0;e=+g[u>>2];h=+g[u+4>>2];v=+g[a+92>>2]*
(r+(p*e-j*h)-(n+(l*q-k*m)))+ +g[a+96>>2]*(s+(j*e+p*h)-(o+(k*q+l*m)));i=f;return+v}else if((t|0)==1){m=+g[a+92>>2];q=+g[a+96>>2];h=+g[a+84>>2];e=+g[a+88>>2];u=(c[(c[a+4>>2]|0)+16>>2]|0)+(d<<3)|0;w=+g[u>>2];x=+g[u+4>>2];v=(l*m-k*q)*(r+(p*w-j*x)-(n+(l*h-k*e)))+(k*m+l*q)*(s+(j*w+p*x)-(o+(k*h+l*e)));i=f;return+v}else if((t|0)==2){e=+g[a+92>>2];h=+g[a+96>>2];x=+g[a+84>>2];w=+g[a+88>>2];t=(c[(c[a>>2]|0)+16>>2]|0)+(b<<3)|0;q=+g[t>>2];m=+g[t+4>>2];v=(p*e-j*h)*(n+(l*q-k*m)-(r+(p*x-j*w)))+(j*e+p*h)*(o+(k*q+
l*m)-(s+(j*x+p*w)));i=f;return+v}else{v=0;i=f;return+v}return 0}function be(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0;e=i;f=c[b+4>>2]|0;if((f|0)==0){c[a+16>>2]=b+12;c[a+20>>2]=1;g[a+24>>2]=+g[b+8>>2];i=e;return}else if((f|0)==2){c[a+16>>2]=b+20;c[a+20>>2]=c[b+148>>2];g[a+24>>2]=+g[b+8>>2];i=e;return}else if((f|0)==1){c[a+16>>2]=b+12;c[a+20>>2]=2;g[a+24>>2]=+g[b+8>>2];i=e;return}else if((f|0)==3){f=b+12|0;h=(c[f>>2]|0)+(d<<3)|0;j=c[h+4>>2]|0;k=a;c[k>>2]=c[h>>2];c[k+4>>2]=j;j=d+1|0;d=a+8|0;k=
c[f>>2]|0;if((j|0)<(c[b+16>>2]|0)){f=k+(j<<3)|0;j=c[f+4>>2]|0;h=d;c[h>>2]=c[f>>2];c[h+4>>2]=j}else{j=k;k=c[j+4>>2]|0;h=d;c[h>>2]=c[j>>2];c[h+4>>2]=k}c[a+16>>2]=a;c[a+20>>2]=2;g[a+24>>2]=+g[b+8>>2];i=e;return}else{i=e;return}}function ce(a){a=a|0;var b=0,d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;b=i;d=a+16|0;e=+g[d>>2];f=+g[d+4>>2];d=a+36|0;h=a+52|0;j=+g[h>>2];k=+g[h+4>>2];h=a+72|0;l=a+88|0;m=+g[l>>2];n=+g[l+4>>2];o=j-e;p=k-f;q=e*o+f*p;r=j*o+k*
p;s=m-e;t=n-f;u=e*s+f*t;v=m*s+n*t;w=m-j;x=n-k;y=j*w+k*x;z=m*w+n*x;x=o*t-p*s;s=(j*n-k*m)*x;p=(f*m-e*n)*x;n=(e*k-f*j)*x;if(!(!(q>=-0)|!(u>=-0))){g[a+24>>2]=1;c[a+108>>2]=1;i=b;return}if(!(!(q<-0)|!(r>0)|!(n<=0))){x=1/(r-q);g[a+24>>2]=r*x;g[a+60>>2]=-(q*x);c[a+108>>2]=2;i=b;return}if(!(!(u<-0)|!(v>0)|!(p<=0))){x=1/(v-u);g[a+24>>2]=v*x;g[a+96>>2]=-(u*x);c[a+108>>2]=2;A=d+0|0;B=h+0|0;C=A+36|0;do{c[A>>2]=c[B>>2];A=A+4|0;B=B+4|0}while((A|0)<(C|0));i=b;return}if(!(!(r<=0)|!(y>=-0))){g[a+60>>2]=1;c[a+108>>
2]=1;A=a+0|0;B=d+0|0;C=A+36|0;do{c[A>>2]=c[B>>2];A=A+4|0;B=B+4|0}while((A|0)<(C|0));i=b;return}if(!(!(v<=0)|!(z<=0))){g[a+96>>2]=1;c[a+108>>2]=1;A=a+0|0;B=h+0|0;C=A+36|0;do{c[A>>2]=c[B>>2];A=A+4|0;B=B+4|0}while((A|0)<(C|0));i=b;return}if(!(y<-0)|!(z>0)|!(s<=0)){v=1/(n+(s+p));g[a+24>>2]=s*v;g[a+60>>2]=p*v;g[a+96>>2]=n*v;c[a+108>>2]=3;i=b;return}else{v=1/(z-y);g[a+60>>2]=z*v;g[a+96>>2]=-(y*v);c[a+108>>2]=2;A=a+0|0;B=h+0|0;C=A+36|0;do{c[A>>2]=c[B>>2];A=A+4|0;B=B+4|0}while((A|0)<(C|0));i=b;return}}function de(d,
e,f){d=d|0;e=e|0;f=f|0;var h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0;h=i;i=i+176|0;j=h+152|0;l=h+136|0;m=h;n=h+124|0;o=h+112|0;c[114]=(c[114]|0)+1;p=f+28|0;q=f+56|0;c[j+0>>2]=c[q+0>>2];c[j+4>>2]=c[q+4>>2];c[j+8>>2]=c[q+8>>2];c[j+12>>2]=c[q+12>>2];q=f+72|
0;c[l+0>>2]=c[q+0>>2];c[l+4>>2]=c[q+4>>2];c[l+8>>2]=c[q+8>>2];c[l+12>>2]=c[q+12>>2];ee(m,e,f,j,p,l);c[n+0>>2]=0;c[n+4>>2]=0;c[n+8>>2]=0;c[o+0>>2]=0;c[o+4>>2]=0;c[o+8>>2]=0;p=m+108|0;r=+g[j+12>>2];s=+g[j+8>>2];q=f+16|0;t=f+20|0;u=+g[j>>2];v=+g[j+4>>2];w=+g[l+12>>2];x=+g[l+8>>2];j=f+44|0;y=f+48|0;z=+g[l>>2];A=+g[l+4>>2];l=m+16|0;B=m+20|0;C=m+52|0;D=m+56|0;E=m+16|0;F=m+36|0;G=m+52|0;H=m+24|0;I=m+60|0;J=c[p>>2]|0;K=0;a:while(1){L=(J|0)>0;if(L){M=0;do{c[n+(M<<2)>>2]=c[m+(M*36|0)+28>>2];c[o+(M<<2)>>2]=
c[m+(M*36|0)+32>>2];M=M+1|0}while((M|0)!=(J|0))}do if((J|0)==2){M=E;N=+g[M>>2];O=+g[M+4>>2];M=G;P=+g[M>>2];R=+g[M+4>>2];S=P-N;T=R-O;U=N*S+O*T;if(U>=-0){g[H>>2]=1;c[p>>2]=1;V=13;break}O=P*S+R*T;if(!(O<=0)){T=1/(O-U);g[H>>2]=O*T;g[I>>2]=-(U*T);c[p>>2]=2;V=14;break}else{g[I>>2]=1;c[p>>2]=1;M=m+0|0;W=F+0|0;X=M+36|0;do{c[M>>2]=c[W>>2];M=M+4|0;W=W+4|0}while((M|0)<(X|0));V=13;break}}else if((J|0)==3){ce(m);W=c[p>>2]|0;if((W|0)==3){V=11;break a}else{Y=W;V=12}}else{Y=J;V=12}while(0);do if((V|0)==12){V=0;if((Y|
0)==1){V=13;break}else if((Y|0)==2){V=14;break}W=8784;T=+g[W>>2];Z=T;_=+g[W+4>>2];$=Y}while(0);do if((V|0)==13){V=0;Z=-+g[l>>2];_=-+g[B>>2];$=1}else if((V|0)==14){V=0;T=+g[l>>2];U=+g[C>>2]-T;O=+g[B>>2];R=+g[D>>2]-O;if(T*R-U*O>0){Z=-R;_=U;$=2;break}else{Z=R;_=-U;$=2;break}}while(0);if(_*_+Z*Z<1.4210854715202004E-14){aa=$;ba=K;V=31;break}W=m+($*36|0)|0;U=-Z;R=-_;O=r*U+s*R;T=r*R-s*U;M=c[q>>2]|0;X=c[t>>2]|0;if((X|0)>1){ca=0;U=T*+g[M+4>>2]+O*+g[M>>2];da=1;while(1){R=O*+g[M+(da<<3)>>2]+T*+g[M+(da<<3)+4>>
2];ea=R>U;fa=ea?da:ca;da=da+1|0;if((da|0)==(X|0)){ga=fa;break}else{ca=fa;U=ea?R:U}}}else ga=0;c[m+($*36|0)+28>>2]=ga;U=+g[M+(ga<<3)>>2];T=+g[M+(ga<<3)+4>>2];O=u+(r*U-s*T);R=+O;S=+(U*s+r*T+v);ca=W;g[ca>>2]=R;g[ca+4>>2]=S;S=Z*w+_*x;R=_*w-Z*x;ca=c[j>>2]|0;X=c[y>>2]|0;if((X|0)>1){da=0;T=R*+g[ca+4>>2]+S*+g[ca>>2];ea=1;while(1){U=S*+g[ca+(ea<<3)>>2]+R*+g[ca+(ea<<3)+4>>2];fa=U>T;ha=fa?ea:da;ea=ea+1|0;if((ea|0)==(X|0)){ia=ha;break}else{da=ha;T=fa?U:T}}}else ia=0;c[m+($*36|0)+32>>2]=ia;T=+g[ca+(ia<<3)>>2];
R=+g[ca+(ia<<3)+4>>2];S=z+(w*T-x*R);U=+S;P=+(T*x+w*R+A);da=m+($*36|0)+8|0;g[da>>2]=U;g[da+4>>2]=P;P=+(S-O);S=+(+g[m+($*36|0)+12>>2]-+g[m+($*36|0)+4>>2]);da=m+($*36|0)+16|0;g[da>>2]=P;g[da+4>>2]=S;ja=K+1|0;c[116]=(c[116]|0)+1;if(L){da=0;do{if((ga|0)==(c[n+(da<<2)>>2]|0)?(ia|0)==(c[o+(da<<2)>>2]|0):0){V=30;break a}da=da+1|0}while((da|0)<(J|0))}da=(c[p>>2]|0)+1|0;c[p>>2]=da;if((ja|0)<20){J=da;K=ja}else{aa=da;ba=ja;V=31;break}}if((V|0)==11){J=c[118]|0;c[118]=(J|0)>(K|0)?J:K;ka=d+8|0;la=K;V=35}else if((V|
0)==30){aa=c[p>>2]|0;ba=ja;V=31}do if((V|0)==31){ja=c[118]|0;c[118]=(ja|0)>(ba|0)?ja:ba;ja=d+8|0;if((aa|0)==1){p=m;K=c[p>>2]|0;J=c[p+4>>2]|0;p=d;c[p>>2]=K;c[p+4>>2]=J;p=m+8|0;o=c[p>>2]|0;ia=c[p+4>>2]|0;p=ja;c[p>>2]=o;c[p+4>>2]=ia;A=(c[k>>2]=K,+g[k>>2]);w=(c[k>>2]=o,+g[k>>2]);x=(c[k>>2]=J,+g[k>>2]);ma=w;na=A;oa=(c[k>>2]=ia,+g[k>>2]);pa=x;qa=1;ra=ja;sa=ba;break}else if((aa|0)==2){x=+g[H>>2];A=+g[I>>2];w=x*+g[m>>2]+A*+g[m+36>>2];z=x*+g[m+4>>2]+A*+g[m+40>>2];Z=+w;_=+z;ia=d;g[ia>>2]=Z;g[ia+4>>2]=_;_=x*
+g[m+8>>2]+A*+g[m+44>>2];Z=x*+g[m+12>>2]+A*+g[m+48>>2];A=+_;x=+Z;ia=ja;g[ia>>2]=A;g[ia+4>>2]=x;ma=_;na=w;oa=Z;pa=z;qa=2;ra=ja;sa=ba;break}else if((aa|0)==3){ka=ja;la=ba;V=35;break}else{ma=+g[ja>>2];na=+g[d>>2];oa=+g[d+12>>2];pa=+g[d+4>>2];qa=aa;ra=ja;sa=ba;break}}while(0);if((V|0)==35){z=+g[H>>2];Z=+g[I>>2];w=+g[m+96>>2];_=z*+g[m>>2]+Z*+g[m+36>>2]+w*+g[m+72>>2];x=z*+g[m+4>>2]+Z*+g[m+40>>2]+w*+g[m+76>>2];w=+_;Z=+x;I=d;g[I>>2]=w;g[I+4>>2]=Z;I=ka;g[I>>2]=w;g[I+4>>2]=Z;ma=_;na=_;oa=x;pa=x;qa=3;ra=ka;
sa=la}x=na-ma;la=d+4|0;ka=d+12|0;ma=pa-oa;I=d+16|0;g[I>>2]=+Q(+(x*x+ma*ma));c[d+20>>2]=sa;if((qa|0)==2){ma=+g[l>>2]-+g[C>>2];x=+g[B>>2]-+g[D>>2];ta=+Q(+(ma*ma+x*x));V=39}else if((qa|0)!=3){g[e>>2]=0;b[e+4>>1]=qa;if((qa|0)>0){ua=0;V=41}}else{x=+g[l>>2];ma=+g[B>>2];ta=(+g[C>>2]-x)*(+g[m+92>>2]-ma)-(+g[D>>2]-ma)*(+g[m+88>>2]-x);V=39}if((V|0)==39){g[e>>2]=ta;b[e+4>>1]=qa;ua=0;V=41}if((V|0)==41)while(1){V=0;a[e+ua+6>>0]=c[m+(ua*36|0)+28>>2];a[e+ua+9>>0]=c[m+(ua*36|0)+32>>2];ua=ua+1|0;if((ua|0)>=(qa|0))break;
else V=41}if((a[f+88>>0]|0)==0){i=h;return}ta=+g[f+24>>2];x=+g[f+52>>2];ma=+g[I>>2];oa=ta+x;if(!(ma>oa&ma>1.1920928955078125E-7)){pa=+((+g[d>>2]+ +g[ra>>2])*.5);na=+((+g[la>>2]+ +g[ka>>2])*.5);f=d;g[f>>2]=pa;g[f+4>>2]=na;f=ra;g[f>>2]=pa;g[f+4>>2]=na;g[I>>2]=0;i=h;return}g[I>>2]=ma-oa;oa=+g[ra>>2];ma=+g[d>>2];na=oa-ma;pa=+g[ka>>2];_=+g[la>>2];Z=pa-_;w=+Q(+(na*na+Z*Z));if(w<1.1920928955078125E-7){va=na;wa=Z}else{z=1/w;va=na*z;wa=Z*z}g[d>>2]=ta*va+ma;g[la>>2]=ta*wa+_;g[ra>>2]=oa-x*va;g[ka>>2]=pa-x*wa;
i=h;return}function ee(a,e,f,h,j,k){a=a|0;e=e|0;f=f|0;h=h|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;l=i;m=b[e+4>>1]|0;n=m&65535;o=a+108|0;c[o>>2]=n;if(m<<16>>16==0)p=n;else{n=f+16|0;m=j+16|0;q=h+12|0;r=h+8|0;s=h+4|0;t=k+12|0;u=k+8|0;v=k+4|0;w=0;do{x=d[e+w+6>>0]|0;c[a+(w*36|0)+28>>2]=x;y=d[e+w+9>>0]|0;c[a+(w*36|0)+32>>2]=y;z=(c[n>>2]|0)+(x<<3)|0;A=+g[z>>2];B=+g[z+4>>2];z=(c[m>>2]|0)+(y<<3)|0;C=+g[z>>2];D=+g[z+4>>2];E=+g[q>>
2];F=+g[r>>2];G=+g[h>>2]+(A*E-B*F);H=+G;I=+(E*B+A*F+ +g[s>>2]);z=a+(w*36|0)|0;g[z>>2]=H;g[z+4>>2]=I;I=+g[t>>2];H=+g[u>>2];F=+g[k>>2]+(C*I-D*H);A=+F;B=+(D*I+C*H+ +g[v>>2]);z=a+(w*36|0)+8|0;g[z>>2]=A;g[z+4>>2]=B;B=+(F-G);G=+(+g[a+(w*36|0)+12>>2]-+g[a+(w*36|0)+4>>2]);z=a+(w*36|0)+16|0;g[z>>2]=B;g[z+4>>2]=G;g[a+(w*36|0)+24>>2]=0;w=w+1|0;z=c[o>>2]|0}while((w|0)<(z|0));p=z}do if((p|0)>1){G=+g[e>>2];if((p|0)==2){B=+g[a+16>>2]-+g[a+52>>2];F=+g[a+20>>2]-+g[a+56>>2];J=+Q(+(B*B+F*F))}else if((p|0)==3){F=+g[a+
16>>2];B=+g[a+20>>2];J=(+g[a+52>>2]-F)*(+g[a+92>>2]-B)-(+g[a+56>>2]-B)*(+g[a+88>>2]-F)}else J=0;if(!(J<G*.5)?!(G*2<J|J<1.1920928955078125E-7):0){K=11;break}c[o>>2]=0}else K=11;while(0);if((K|0)==11?(p|0)!=0:0){i=l;return}c[a+28>>2]=0;c[a+32>>2]=0;p=c[f+16>>2]|0;J=+g[p>>2];G=+g[p+4>>2];p=c[j+16>>2]|0;F=+g[p>>2];B=+g[p+4>>2];A=+g[h+12>>2];H=+g[h+8>>2];C=+g[h>>2]+(J*A-G*H);I=A*G+J*H+ +g[h+4>>2];H=+C;J=+I;h=a;g[h>>2]=H;g[h+4>>2]=J;J=+g[k+12>>2];H=+g[k+8>>2];G=+g[k>>2]+(F*J-B*H);A=B*J+F*H+ +g[k+4>>2];
H=+G;F=+A;k=a+8|0;g[k>>2]=H;g[k+4>>2]=F;F=+(G-C);C=+(A-I);k=a+16|0;g[k>>2]=F;g[k+4>>2]=C;g[a+24>>2]=1;c[o>>2]=1;i=l;return}function fe(a,d){a=a|0;d=d|0;var e=0,f=0,h=0,j=0;e=i;f=Em(d,48)|0;if((f|0)==0)h=0;else{c[f>>2]=488;c[f+4>>2]=1;g[f+8>>2]=.009999999776482582;d=f+28|0;c[d+0>>2]=0;c[d+4>>2]=0;c[d+8>>2]=0;c[d+12>>2]=0;b[d+16>>1]=0;h=f}f=a+4|0;d=c[f+4>>2]|0;j=h+4|0;c[j>>2]=c[f>>2];c[j+4>>2]=d;d=h+12|0;j=a+12|0;c[d+0>>2]=c[j+0>>2];c[d+4>>2]=c[j+4>>2];c[d+8>>2]=c[j+8>>2];c[d+12>>2]=c[j+12>>2];c[d+
16>>2]=c[j+16>>2];c[d+20>>2]=c[j+20>>2];c[d+24>>2]=c[j+24>>2];c[d+28>>2]=c[j+28>>2];b[d+32>>1]=b[j+32>>1]|0;i=e;return h|0}function ge(a){a=a|0;return 1}function he(a,b,c){a=a|0;b=b|0;c=c|0;return 0}function ie(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0;f=i;h=+g[b+12>>2];j=+g[a+12>>2];k=+g[b+8>>2];l=+g[a+16>>2];m=+g[b>>2];n=m+(h*j-k*l);o=+g[b+4>>2];p=j*k+h*l+o;l=+g[a+20>>2];j=+g[a+24>>2];q=m+(h*l-k*j);m=
o+(k*l+h*j);j=+g[c>>2];h=j-n;l=+g[c+4>>2];k=l-p;o=q-n;n=m-p;p=h*o+k*n;do if(p>0){r=o*o+n*n;if(p>r){s=j-q;t=l-m;break}else{u=p/r;s=h-o*u;t=k-n*u;break}}else{s=h;t=k}while(0);k=+Q(+(t*t+s*s));g[d>>2]=k;if(k>0){h=1/k;v=s*h;w=t*h;x=+v;y=+w;z=e;A=z;g[A>>2]=x;B=z+4|0;C=B;g[C>>2]=y;i=f;return}else{d=8784;h=+g[d>>2];v=h;w=+g[d+4>>2];x=+v;y=+w;z=e;A=z;g[A>>2]=x;B=z+4|0;C=B;g[C>>2]=y;i=f;return}}function je(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,
v=0,w=0,x=0;e=i;f=+g[d>>2];h=+g[c>>2]-f;j=+g[d+4>>2];k=+g[c+4>>2]-j;l=d+12|0;m=+g[l>>2];n=d+8|0;o=+g[n>>2];p=h*m+k*o;q=m*k-h*o;h=+g[c+8>>2]-f;f=+g[c+12>>2]-j;j=m*h+o*f-p;k=m*f-o*h-q;d=a+12|0;h=+g[d>>2];o=+g[d+4>>2];d=a+20|0;f=+g[d>>2];m=f-h;f=+g[d+4>>2]-o;r=-m;s=m*m+f*f;t=+Q(+s);if(t<1.1920928955078125E-7){u=f;v=r}else{w=1/t;u=f*w;v=w*r}r=(o-q)*v+(h-p)*u;w=k*v+j*u;if(w==0){x=0;i=e;return x|0}t=r/w;if(t<0){x=0;i=e;return x|0}if(s==0?1:+g[c+16>>2]<t){x=0;i=e;return x|0}w=(m*(p+j*t-h)+f*(q+k*t-o))/s;
if(w<0|w>1){x=0;i=e;return x|0}g[b+8>>2]=t;t=+g[l>>2];w=+g[n>>2];s=u*t-v*w;o=v*t+u*w;if(r>0){r=+-s;w=+-o;n=b;g[n>>2]=r;g[n+4>>2]=w;x=1;i=e;return x|0}else{w=+s;s=+o;n=b;g[n>>2]=w;g[n+4>>2]=s;x=1;i=e;return x|0}return 0}function ke(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;d=i;e=+g[c+12>>2];f=+g[a+12>>2];h=+g[c+8>>2];j=+g[a+16>>2];k=+g[c>>2];l=k+(e*f-h*j);m=+g[c+4>>2];n=f*h+e*j+m;j=+g[a+20>>2];f=+g[a+24>>2];o=k+(e*j-h*f);k=m+(h*j+e*f);f=+g[a+8>>2];e=+((l<o?l:o)-f);j=
+((n<k?n:k)-f);a=b;g[a>>2]=e;g[a+4>>2]=j;j=+(f+(l>o?l:o));o=+(f+(n>k?n:k));a=b+8|0;g[a>>2]=j;g[a+4>>2]=o;i=d;return}function le(a,b,c){a=a|0;b=b|0;c=+c;var d=0,e=0;d=i;g[b>>2]=0;c=+((+g[a+12>>2]+ +g[a+20>>2])*.5);e=+((+g[a+16>>2]+ +g[a+24>>2])*.5);a=b+4|0;g[a>>2]=c;g[a+4>>2]=e;g[b+12>>2]=0;i=d;return}function me(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0;d=i;e=Em(b,152)|0;if((e|0)==0)f=0;else{c[e>>2]=592;c[e+4>>2]=2;g[e+8>>2]=.009999999776482582;c[e+148>>2]=0;g[e+12>>2]=0;g[e+16>>2]=0;f=e}e=a+4|0;b=c[e+
4>>2]|0;h=f+4|0;c[h>>2]=c[e>>2];c[h+4>>2]=b;An(f+12|0,a+12|0,140)|0;i=d;return f|0}function ne(a){a=a|0;return 1}function oe(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;e=i;i=i+96|0;f=e+32|0;h=e;if((d|0)<3){c[a+148>>2]=4;g[a+20>>2]=-1;g[a+24>>2]=-1;g[a+28>>2]=1;g[a+32>>2]=-1;g[a+36>>2]=1;g[a+40>>2]=1;g[a+44>>2]=-1;g[a+48>>2]=1;g[a+84>>2]=0;g[a+88>>2]=-1;g[a+92>>2]=1;g[a+96>>2]=0;g[a+100>>2]=0;g[a+
104>>2]=1;g[a+108>>2]=-1;g[a+112>>2]=0;g[a+12>>2]=0;g[a+16>>2]=0;i=e;return}j=(d|0)<8?d:8;d=0;l=0;while(1){m=b+(d<<3)|0;n=c[m>>2]|0;o=c[m+4>>2]|0;p=(c[k>>2]=n,+g[k>>2]);q=(c[k>>2]=o,+g[k>>2]);a:do if((l|0)>0){m=0;while(1){r=p-+g[f+(m<<3)>>2];s=q-+g[f+(m<<3)+4>>2];m=m+1|0;if(r*r+s*s<.0024999999441206455){t=l;break a}if((m|0)>=(l|0)){u=7;break}}}else u=7;while(0);if((u|0)==7){u=0;m=f+(l<<3)|0;c[m>>2]=n;c[m+4>>2]=o;t=l+1|0}d=d+1|0;if((d|0)==(j|0))break;else l=t}if((t|0)<3){c[a+148>>2]=4;g[a+20>>2]=-1;
g[a+24>>2]=-1;g[a+28>>2]=1;g[a+32>>2]=-1;g[a+36>>2]=1;g[a+40>>2]=1;g[a+44>>2]=-1;g[a+48>>2]=1;g[a+84>>2]=0;g[a+88>>2]=-1;g[a+92>>2]=1;g[a+96>>2]=0;g[a+100>>2]=0;g[a+104>>2]=1;g[a+108>>2]=-1;g[a+112>>2]=0;g[a+12>>2]=0;g[a+16>>2]=0;i=e;return}l=0;j=1;q=+g[f>>2];while(1){p=+g[f+(j<<3)>>2];if(!(p>q))if(p==q?+g[f+(j<<3)+4>>2]<+g[f+(l<<3)+4>>2]:0)u=22;else{v=l;w=q}else u=22;if((u|0)==22){u=0;v=j;w=p}j=j+1|0;if((j|0)==(t|0)){x=v;y=0;break}else{l=v;q=w}}while(1){c[h+(y<<2)>>2]=x;l=0;j=1;while(1){if((l|0)!=
(x|0)){w=+g[f+(x<<3)>>2];q=+g[f+(l<<3)>>2]-w;p=+g[f+(x<<3)+4>>2];s=+g[f+(l<<3)+4>>2]-p;r=+g[f+(j<<3)>>2]-w;w=+g[f+(j<<3)+4>>2]-p;p=q*w-s*r;u=p<0?j:l;if(p==0?r*r+w*w>q*q+s*s:0)z=j;else z=u}else z=j;j=j+1|0;if((j|0)==(t|0))break;else l=z}A=y+1|0;if((z|0)==(v|0))break;else{x=z;y=A}}c[a+148>>2]=A;z=(y|0)>-1;if(z){x=0;do{v=f+(c[h+(x<<2)>>2]<<3)|0;t=c[v+4>>2]|0;l=a+(x<<3)+20|0;c[l>>2]=c[v>>2];c[l+4>>2]=t;x=x+1|0}while((x|0)!=(A|0));if(z){z=0;do{x=z;z=z+1|0;h=(z|0)<(A|0)?z:0;s=+g[a+(h<<3)+24>>2]-+g[a+(x<<
3)+24>>2];f=a+(x<<3)+84|0;q=+s;w=+-(+g[a+(h<<3)+20>>2]-+g[a+(x<<3)+20>>2]);h=f;g[h>>2]=q;g[h+4>>2]=w;h=a+(x<<3)+88|0;w=+g[h>>2];q=+Q(+(s*s+w*w));if(!(q<1.1920928955078125E-7)){r=1/q;g[f>>2]=s*r;g[h>>2]=w*r}}while((z|0)!=(A|0))}}z=a+12|0;h=a+20|0;if((y|0)>-1){r=0;w=0;s=0;y=0;while(1){f=a+(y<<3)+20|0;q=+g[f>>2];p=+g[f+4>>2];y=y+1|0;if((y|0)<(A|0))B=a+(y<<3)+20|0;else B=h;f=B;C=+g[f>>2];D=+g[f+4>>2];E=(q*D-p*C)*.5;F=s+E;G=E*.3333333432674408;E=r+(q+0+C)*G;C=w+(p+0+D)*G;if((y|0)==(A|0)){H=E;I=C;J=F;break}else{r=
E;w=C;s=F}}}else{H=0;I=0;J=0}s=1/J;J=+(H*s);H=+(I*s);A=z;g[A>>2]=J;g[A+4>>2]=H;i=e;return}function pe(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;e=i;f=+g[d>>2]-+g[b>>2];h=+g[d+4>>2]-+g[b+4>>2];j=+g[b+12>>2];k=+g[b+8>>2];l=f*j+h*k;m=j*h-f*k;b=c[a+148>>2]|0;if((b|0)>0)n=0;else{o=1;i=e;return o|0}while(1){if((l-+g[a+(n<<3)+20>>2])*+g[a+(n<<3)+84>>2]+(m-+g[a+(n<<3)+24>>2])*+g[a+(n<<3)+88>>2]>0){o=0;p=4;break}n=n+1|0;if((n|0)>=(b|0)){o=1;p=4;break}}if((p|0)==4){i=e;return o|0}return 0}
function qe(a,b,d,e,f,h){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0;h=i;j=+g[d>>2]-+g[b>>2];k=+g[d+4>>2]-+g[b+4>>2];d=b+12|0;l=+g[d>>2];m=b+8|0;n=+g[m>>2];o=j*l+k*n;p=l*k-j*n;b=c[a+148>>2]|0;q=(b|0)>0;if(q){n=o;j=p;r=0;k=-3.4028234663852886E38;while(1){s=a+(r<<3)+84|0;l=(o-+g[a+(r<<3)+20>>2])*+g[s>>2]+(p-+g[a+(r<<3)+24>>2])*+g[a+(r<<3)+88>>2];if(l>k){t=s;u=+g[t>>2];v=+g[t+4>>2];w=u;x=l}else{v=j;w=n;x=k}r=
r+1|0;if((r|0)>=(b|0))break;else{n=w;j=v;k=x}}if(x>0){k=x*x;if(q){j=v;n=w;q=0;l=k;while(1){u=o-+g[a+(q<<3)+20>>2];y=p-+g[a+(q<<3)+24>>2];z=u*u+y*y;r=l>z;A=r?y:j;y=r?u:n;u=r?z:l;q=q+1|0;if((q|0)>=(b|0)){B=A;C=y;D=u;break}else{j=A;n=y;l=u}}}else{B=v;C=w;D=k}g[e>>2]=+Q(+D);D=+g[d>>2];k=+g[m>>2];l=C*D-B*k;n=B*D+C*k;k=+l;C=+n;b=f;g[b>>2]=k;g[b+4>>2]=C;C=+Q(+(l*l+n*n));if(C<1.1920928955078125E-7){i=h;return}k=1/C;g[f>>2]=l*k;g[f+4>>2]=n*k;i=h;return}else{E=v;F=w;G=x}}else{E=p;F=o;G=-3.4028234663852886E38}g[e>>
2]=G;G=+g[d>>2];o=+g[m>>2];p=+(F*G-E*o);x=+(E*G+F*o);m=f;g[m>>2]=p;g[m+4>>2]=x;i=h;return}function re(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;f=i;h=+g[e>>2];j=+g[d>>2]-h;k=+g[e+4>>2];l=+g[d+4>>2]-k;m=e+12|0;n=+g[m>>2];o=e+8|0;p=+g[o>>2];q=j*n+l*p;r=n*l-j*p;j=+g[d+8>>2]-h;h=+g[d+12>>2]-k;k=n*j+p*h-q;l=n*h-p*j-r;e=c[a+148>>2]|0;if((e|0)<=0){s=0;i=f;return s|0}t=0;u=-1;j=0;p=+g[d+16>>2];a:while(1){h=+g[a+(t<<3)+84>>2];n=
+g[a+(t<<3)+88>>2];v=(+g[a+(t<<3)+20>>2]-q)*h+(+g[a+(t<<3)+24>>2]-r)*n;w=k*h+l*n;do if(w==0)if(v<0){s=0;x=15;break a}else{y=u;z=j;A=p}else{if(w<0?v<j*w:0){y=t;z=v/w;A=p;break}if(w>0?v<p*w:0){y=u;z=j;A=v/w}else{y=u;z=j;A=p}}while(0);t=t+1|0;if(A<z){s=0;x=15;break}if((t|0)>=(e|0)){x=13;break}else{u=y;j=z;p=A}}if((x|0)==13){if(!((y|0)>-1)){s=0;i=f;return s|0}g[b+8>>2]=z;z=+g[m>>2];A=+g[a+(y<<3)+84>>2];p=+g[o>>2];j=+g[a+(y<<3)+88>>2];l=+(z*A-p*j);k=+(A*p+z*j);y=b;g[y>>2]=l;g[y+4>>2]=k;s=1;i=f;return s|
0}else if((x|0)==15){i=f;return s|0}return 0}function se(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;e=i;f=+g[d+12>>2];h=+g[a+20>>2];j=+g[d+8>>2];k=+g[a+24>>2];l=+g[d>>2];m=l+(f*h-j*k);n=+g[d+4>>2];o=h*j+f*k+n;d=c[a+148>>2]|0;if((d|0)>1){k=m;h=o;p=m;q=o;r=1;while(1){s=+g[a+(r<<3)+20>>2];t=+g[a+(r<<3)+24>>2];u=l+(f*s-j*t);v=s*j+f*t+n;t=k<u?k:u;s=h<v?h:v;w=p>u?p:u;u=q>v?q:v;r=r+1|0;if((r|0)>=(d|0)){x=s;y=t;z=u;A=w;break}else{k=
t;h=s;p=w;q=u}}}else{x=o;y=m;z=o;A=m}m=+g[a+8>>2];o=+(y-m);y=+(x-m);a=b;g[a>>2]=o;g[a+4>>2]=y;y=+(A+m);A=+(z+m);a=b+8|0;g[a>>2]=y;g[a+4>>2]=A;i=e;return}function te(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0;e=i;f=c[a+148>>2]|0;h=(f|0)>0;if(h){j=0;k=0;l=0;do{j=j+ +g[a+(l<<3)+20>>2];k=k+ +g[a+(l<<3)+24>>2];l=l+1|0}while((l|0)<(f|0));m=1/+(f|0);n=j*m;j=k*m;if(h){h=a+20|0;l=a+24|0;m=0;k=0;o=0;p=0;q=0;
while(1){r=+g[a+(q<<3)+20>>2]-n;s=+g[a+(q<<3)+24>>2]-j;q=q+1|0;t=(q|0)<(f|0);if(t){u=a+(q<<3)+20|0;v=a+(q<<3)+24|0}else{u=h;v=l}w=+g[u>>2]-n;x=+g[v>>2]-j;y=r*x-s*w;z=y*.5;A=p+z;B=z*.3333333432674408;z=m+(r+w)*B;C=k+(s+x)*B;B=o+y*.0833333358168602*(w*w+(r*r+r*w)+(x*x+(s*s+s*x)));if(!t){D=C;E=z;F=n;G=j;H=B;I=A;break}else{m=z;k=C;o=B;p=A}}}else{D=0;E=0;F=n;G=j;H=0;I=0}}else{j=1/+(f|0);D=0;E=0;F=j*0;G=j*0;H=0;I=0}j=I*d;g[b>>2]=j;n=1/I;I=E*n;E=D*n;n=F+I;F=G+E;G=+n;D=+F;f=b+4|0;g[f>>2]=G;g[f+4>>2]=D;g[b+
12>>2]=H*d+j*(n*n+F*F-(I*I+E*E));i=e;return}function ue(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0;d=i;e=Em(b,20)|0;if((e|0)==0)f=0;else{c[e>>2]=680;b=e+4|0;c[b+0>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;f=e}e=a+4|0;b=c[e+4>>2]|0;g=f+4|0;c[g>>2]=c[e>>2];c[g+4>>2]=b;b=a+12|0;a=c[b+4>>2]|0;g=f+12|0;c[g>>2]=c[b>>2];c[g+4>>2]=a;i=d;return f|0}function ve(a){a=a|0;return 1}function we(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=+g[b+12>>2];e=+g[a+12>>2];f=+g[b+8>>2];h=+g[a+16>>2];i=+g[c>>2]-(+g[b>>
2]+(d*e-f*h));j=+g[c+4>>2]-(+g[b+4>>2]+(e*f+d*h));h=+g[a+8>>2];return i*i+j*j<=h*h|0}function xe(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0;f=i;h=+g[b+12>>2];j=+g[a+12>>2];k=+g[b+8>>2];l=+g[a+16>>2];m=+g[c>>2]-(+g[b>>2]+(h*j-k*l));n=+g[c+4>>2]-(+g[b+4>>2]+(j*k+h*l));l=+Q(+(m*m+n*n));g[d>>2]=l-+g[a+8>>2];h=1/l;l=+(m*h);m=+(n*h);a=e;g[a>>2]=l;g[a+4>>2]=m;i=f;return}function ye(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;e=i;f=+g[d+
12>>2];h=+g[a+12>>2];j=+g[d+8>>2];k=+g[a+16>>2];l=+g[c>>2];m=l-(+g[d>>2]+(f*h-j*k));n=+g[c+4>>2];o=n-(+g[d+4>>2]+(h*j+f*k));k=+g[a+8>>2];f=+g[c+8>>2]-l;l=+g[c+12>>2]-n;n=m*f+o*l;j=f*f+l*l;h=n*n-(m*m+o*o-k*k)*j;if(h<0|j<1.1920928955078125E-7){p=0;i=e;return p|0}k=n+ +Q(+h);h=-k;if(!(k<=-0)){p=0;i=e;return p|0}if(!(j*+g[c+16>>2]>=h)){p=0;i=e;return p|0}k=h/j;g[b+8>>2]=k;j=m+f*k;f=o+l*k;k=+j;l=+f;c=b;g[c>>2]=k;g[c+4>>2]=l;l=+Q(+(j*j+f*f));if(l<1.1920928955078125E-7){p=1;i=e;return p|0}k=1/l;g[b>>2]=
j*k;g[b+4>>2]=f*k;p=1;i=e;return p|0}function ze(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0,h=0,i=0,j=0,k=0;e=+g[c+12>>2];f=+g[a+12>>2];h=+g[c+8>>2];i=+g[a+16>>2];j=+g[c>>2]+(e*f-h*i);k=+g[c+4>>2]+(f*h+e*i);c=a+8|0;i=+g[c>>2];g[b>>2]=j-i;g[b+4>>2]=k-i;i=+g[c>>2];g[b+8>>2]=j+i;g[b+12>>2]=k+i;return}function Ae(a,b,d){a=a|0;b=b|0;d=+d;var e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0;e=a+8|0;f=+g[e>>2];h=f*d*3.1415927410125732*f;g[b>>2]=h;i=a+12|0;j=i;k=c[j+4>>2]|0;l=b+4|0;c[l>>2]=c[j>>2];c[l+4>>2]=k;f=+g[e>>2];
d=+g[i>>2];m=+g[a+16>>2];g[b+12>>2]=h*(f*f*.5+(d*d+m*m));return}function Be(a){a=a|0;var b=0;b=i;c[a>>2]=760;Qm(c[a+12>>2]|0);sn(a);i=b;return}function Ce(a){a=a|0;var b=0,d=0;b=i;c[a>>2]=760;d=a+12|0;Qm(c[d>>2]|0);c[d>>2]=0;c[a+16>>2]=0;i=b;return}function De(a,d,e){a=a|0;d=d|0;e=e|0;var f=0,g=0,h=0;f=i;g=a+16|0;c[g>>2]=e;h=Pm(e<<3)|0;c[a+12>>2]=h;An(h|0,d|0,c[g>>2]<<3|0)|0;g=a+20|0;c[g+0>>2]=0;c[g+4>>2]=0;c[g+8>>2]=0;c[g+12>>2]=0;b[g+16>>1]=0;i=f;return}function Ee(d,e){d=d|0;e=e|0;var f=0,h=0,
j=0,k=0,l=0;f=i;h=Em(e,40)|0;if((h|0)==0)j=0;else{c[h>>2]=760;c[h+4>>2]=3;g[h+8>>2]=.009999999776482582;c[h+12>>2]=0;c[h+16>>2]=0;a[h+36>>0]=0;a[h+37>>0]=0;j=h}h=c[d+12>>2]|0;e=c[d+16>>2]|0;k=j+16|0;c[k>>2]=e;l=Pm(e<<3)|0;c[j+12>>2]=l;An(l|0,h|0,c[k>>2]<<3|0)|0;k=j+20|0;c[k+0>>2]=0;c[k+4>>2]=0;c[k+8>>2]=0;c[k+12>>2]=0;b[k+16>>1]=0;k=d+20|0;h=c[k+4>>2]|0;l=j+20|0;c[l>>2]=c[k>>2];c[l+4>>2]=h;h=d+28|0;l=c[h+4>>2]|0;k=j+28|0;c[k>>2]=c[h>>2];c[k+4>>2]=l;a[j+36>>0]=a[d+36>>0]|0;a[j+37>>0]=a[d+37>>0]|0;
i=f;return j|0}function Fe(a){a=a|0;return(c[a+16>>2]|0)+-1|0}function Ge(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0;f=i;c[d+4>>2]=1;g[d+8>>2]=+g[b+8>>2];h=b+12|0;j=(c[h>>2]|0)+(e<<3)|0;k=c[j+4>>2]|0;l=d+12|0;c[l>>2]=c[j>>2];c[l+4>>2]=k;k=(c[h>>2]|0)+(e+1<<3)|0;l=c[k+4>>2]|0;j=d+20|0;c[j>>2]=c[k>>2];c[j+4>>2]=l;l=d+28|0;if((e|0)>0){j=(c[h>>2]|0)+(e+-1<<3)|0;k=c[j+4>>2]|0;m=l;c[m>>2]=c[j>>2];c[m+4>>2]=k;a[d+44>>0]=1}else{k=b+20|0;m=c[k+4>>2]|0;j=l;c[j>>2]=c[k>>2];c[j+4>>2]=m;a[d+44>>0]=a[b+
36>>0]|0}m=d+36|0;if(((c[b+16>>2]|0)+-2|0)>(e|0)){j=(c[h>>2]|0)+(e+2<<3)|0;e=c[j+4>>2]|0;h=m;c[h>>2]=c[j>>2];c[h+4>>2]=e;a[d+45>>0]=1;i=f;return}else{e=b+28|0;h=c[e+4>>2]|0;j=m;c[j>>2]=c[e>>2];c[j+4>>2]=h;a[d+45>>0]=a[b+37>>0]|0;i=f;return}}function He(d,e,f,h,j,k){d=d|0;e=e|0;f=f|0;h=h|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0;l=i;i=i+48|0;m=l;c[m>>2]=488;n=m+4|0;o=m+8|0;p=m+28|0;c[p+0>>2]=0;c[p+4>>2]=0;c[p+8>>2]=0;c[p+12>>2]=0;b[p+16>>1]=0;c[n>>2]=1;g[o>>2]=+g[d+8>>2];o=c[d+12>>2]|0;n=o+(k<<
3)|0;p=c[n+4>>2]|0;q=m+12|0;c[q>>2]=c[n>>2];c[q+4>>2]=p;p=o+(k+1<<3)|0;q=c[p+4>>2]|0;n=m+20|0;c[n>>2]=c[p>>2];c[n+4>>2]=q;q=m+28|0;if((k|0)>0){n=o+(k+-1<<3)|0;p=c[n+4>>2]|0;r=q;c[r>>2]=c[n>>2];c[r+4>>2]=p;a[m+44>>0]=1}else{p=d+20|0;r=c[p+4>>2]|0;n=q;c[n>>2]=c[p>>2];c[n+4>>2]=r;a[m+44>>0]=a[d+36>>0]|0}r=m+36|0;if(((c[d+16>>2]|0)+-2|0)>(k|0)){n=o+(k+2<<3)|0;k=c[n+4>>2]|0;o=r;c[o>>2]=c[n>>2];c[o+4>>2]=k;a[m+45>>0]=1;ie(m,e,f,h,j,0);i=l;return}else{k=d+28|0;o=c[k+4>>2]|0;n=r;c[n>>2]=c[k>>2];c[n+4>>2]=
o;a[m+45>>0]=a[d+37>>0]|0;ie(m,e,f,h,j,0);i=l;return}}function Ie(a,b,c){a=a|0;b=b|0;c=c|0;return 0}function Je(a,d,e,f,h){a=a|0;d=d|0;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0;j=i;i=i+48|0;k=j;c[k>>2]=488;c[k+4>>2]=1;g[k+8>>2]=.009999999776482582;l=k+28|0;c[l+0>>2]=0;c[l+4>>2]=0;c[l+8>>2]=0;c[l+12>>2]=0;b[l+16>>1]=0;l=h+1|0;m=(l|0)==(c[a+16>>2]|0)?0:l;l=c[a+12>>2]|0;a=l+(h<<3)|0;h=c[a+4>>2]|0;n=k+12|0;c[n>>2]=c[a>>2];c[n+4>>2]=h;h=l+(m<<3)|0;m=c[h+4>>2]|0;l=k+20|0;c[l>>2]=c[h>>2];c[l+4>>2]=m;m=je(k,
d,e,f,0)|0;i=j;return m|0}function Ke(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0;f=i;h=e+1|0;j=(h|0)==(c[a+16>>2]|0)?0:h;h=c[a+12>>2]|0;k=+g[d+12>>2];l=+g[h+(e<<3)>>2];m=+g[d+8>>2];n=+g[h+(e<<3)+4>>2];o=+g[d>>2];p=o+(k*l-m*n);q=+g[d+4>>2];r=l*m+k*n+q;n=+g[h+(j<<3)>>2];l=+g[h+(j<<3)+4>>2];s=o+(k*n-m*l);o=q+(m*n+k*l);l=+(p<s?p:s);k=+(r<o?r:o);j=b;g[j>>2]=l;g[j+4>>2]=k;k=+(p>s?p:s);s=+(r>o?r:o);j=b+8|0;g[j>>2]=k;g[j+4>>2]=s;i=f;return}function Le(a,b,d){a=a|
0;b=b|0;d=+d;a=i;c[b+0>>2]=0;c[b+4>>2]=0;c[b+8>>2]=0;c[b+12>>2]=0;i=a;return}function Me(a){a=a|0;var b=0;b=i;Ve(a);c[a+28>>2]=0;c[a+48>>2]=16;c[a+52>>2]=0;c[a+44>>2]=Pm(128)|0;c[a+36>>2]=16;c[a+40>>2]=0;c[a+32>>2]=Pm(64)|0;i=b;return}function Ne(a){a=a|0;var b=0;b=i;Qm(c[a+32>>2]|0);Qm(c[a+44>>2]|0);We(a);i=b;return}function Oe(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0;e=i;f=Ye(a,b,d)|0;d=a+28|0;c[d>>2]=(c[d>>2]|0)+1;d=a+40|0;b=c[d>>2]|0;g=a+36|0;h=a+32|0;if((b|0)==(c[g>>2]|0)){a=c[h>>2]|
0;c[g>>2]=b<<1;g=Pm(b<<3)|0;c[h>>2]=g;An(g|0,a|0,c[d>>2]<<2|0)|0;Qm(a);j=c[d>>2]|0}else j=b;c[(c[h>>2]|0)+(j<<2)>>2]=f;c[d>>2]=(c[d>>2]|0)+1;i=e;return f|0}function Pe(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0;d=i;e=a+40|0;f=c[e>>2]|0;if((f|0)>0){g=c[a+32>>2]|0;h=f;f=0;while(1){j=g+(f<<2)|0;if((c[j>>2]|0)==(b|0)){c[j>>2]=-1;k=c[e>>2]|0}else k=h;f=f+1|0;if((f|0)>=(k|0))break;else h=k}}k=a+28|0;c[k>>2]=(c[k>>2]|0)+-1;_e(a,b);i=d;return}function Qe(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,
h=0,j=0;f=i;if(!(af(a,b,d,e)|0)){i=f;return}e=a+40|0;d=c[e>>2]|0;g=a+36|0;h=a+32|0;if((d|0)==(c[g>>2]|0)){a=c[h>>2]|0;c[g>>2]=d<<1;g=Pm(d<<3)|0;c[h>>2]=g;An(g|0,a|0,c[e>>2]<<2|0)|0;Qm(a);j=c[e>>2]|0}else j=d;c[(c[h>>2]|0)+(j<<2)>>2]=b;c[e>>2]=(c[e>>2]|0)+1;i=f;return}function Re(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=a+40|0;f=c[e>>2]|0;g=a+36|0;h=a+32|0;if((f|0)==(c[g>>2]|0)){a=c[h>>2]|0;c[g>>2]=f<<1;g=Pm(f<<3)|0;c[h>>2]=g;An(g|0,a|0,c[e>>2]<<2|0)|0;Qm(a);j=c[e>>2]|0}else j=f;c[(c[h>>
2]|0)+(j<<2)>>2]=b;c[e>>2]=(c[e>>2]|0)+1;i=d;return}function Se(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;d=i;e=a+56|0;f=c[e>>2]|0;if((f|0)==(b|0)){i=d;return 1}g=a+52|0;h=c[g>>2]|0;j=a+48|0;k=a+44|0;if((h|0)==(c[j>>2]|0)){a=c[k>>2]|0;c[j>>2]=h<<1;j=Pm(h<<4)|0;c[k>>2]=j;An(j|0,a|0,c[g>>2]<<3|0)|0;Qm(a);l=c[e>>2]|0;m=c[g>>2]|0}else{l=f;m=h}h=c[k>>2]|0;c[h+(m<<3)>>2]=(l|0)>(b|0)?b:l;l=c[e>>2]|0;c[h+(c[g>>2]<<3)+4>>2]=(l|0)<(b|0)?b:l;c[g>>2]=(c[g>>2]|0)+1;i=d;return 1}function Te(a,b,
d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0;h=i;j=a+60|0;c[j>>2]=0;k=b+12|0;l=+g[d+12>>2];m=+g[k>>2];n=+g[d+8>>2];o=+g[b+16>>2];p=e+12|0;q=+g[f+12>>2];r=+g[p>>2];s=+g[f+8>>2];t=+g[e+16>>2];u=+g[f>>2]+(q*r-s*t)-(+g[d>>2]+(l*m-n*o));v=r*s+q*t+ +g[f+4>>2]-(m*n+l*o+ +g[d+4>>2]);o=+g[b+8>>2]+ +g[e+8>>2];if(u*u+v*v>o*o){i=h;return}c[a+56>>2]=0;e=k;k=c[e+4>>2]|0;b=a+48|0;c[b>>2]=c[e>>2];c[b+4>>2]=k;g[a+40>>2]=0;g[a+44>>2]=0;c[j>>2]=1;j=p;p=c[j+4>>2]|0;
k=a;c[k>>2]=c[j>>2];c[k+4>>2]=p;c[a+16>>2]=0;i=h;return}function Ue(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0;h=i;j=a+60|0;c[j>>2]=0;l=e+12|0;m=+g[f+12>>2];n=+g[l>>2];o=+g[f+8>>2];p=+g[e+16>>2];q=+g[f>>2]+(m*n-o*p)-+g[d>>2];r=n*o+m*p+ +g[f+4>>2]-+g[d+4>>2];p=+g[d+12>>2];m=+g[d+8>>2];o=q*p+r*m;n=p*r-q*m;m=+g[b+8>>2]+ +g[e+8>>2];e=c[b+148>>2]|0;do if((e|0)>0){d=0;f=0;q=-3.4028234663852886E38;while(1){r=(o-
+g[b+(d<<3)+20>>2])*+g[b+(d<<3)+84>>2]+(n-+g[b+(d<<3)+24>>2])*+g[b+(d<<3)+88>>2];if(r>m){s=19;break}t=r>q;q=t?r:q;f=t?d:f;d=d+1|0;if((d|0)>=(e|0)){s=4;break}}if((s|0)==4){u=f;v=q<1.1920928955078125E-7;break}else if((s|0)==19){i=h;return}}else{u=0;v=1}while(0);s=u+1|0;d=b+(u<<3)+20|0;t=c[d>>2]|0;w=c[d+4>>2]|0;r=(c[k>>2]=t,+g[k>>2]);p=(c[k>>2]=w,+g[k>>2]);d=b+(((s|0)<(e|0)?s:0)<<3)+20|0;s=c[d>>2]|0;e=c[d+4>>2]|0;x=(c[k>>2]=s,+g[k>>2]);y=(c[k>>2]=e,+g[k>>2]);if(v){c[j>>2]=1;c[a+56>>2]=1;v=b+(u<<3)+84|
0;d=c[v+4>>2]|0;z=a+40|0;c[z>>2]=c[v>>2];c[z+4>>2]=d;A=+((r+x)*.5);B=+((p+y)*.5);d=a+48|0;g[d>>2]=A;g[d+4>>2]=B;d=l;z=c[d+4>>2]|0;v=a;c[v>>2]=c[d>>2];c[v+4>>2]=z;c[a+16>>2]=0;i=h;return}B=o-r;A=n-p;C=o-x;D=n-y;if(B*(x-r)+A*(y-p)<=0){if(B*B+A*A>m*m){i=h;return}c[j>>2]=1;c[a+56>>2]=1;z=a+40|0;E=+B;F=+A;v=z;g[v>>2]=E;g[v+4>>2]=F;F=+Q(+(B*B+A*A));if(!(F<1.1920928955078125E-7)){E=1/F;g[z>>2]=B*E;g[a+44>>2]=A*E}z=a+48|0;c[z>>2]=t;c[z+4>>2]=w;w=l;z=c[w+4>>2]|0;t=a;c[t>>2]=c[w>>2];c[t+4>>2]=z;c[a+16>>2]=
0;i=h;return}if(!(C*(r-x)+D*(p-y)<=0)){E=(r+x)*.5;x=(p+y)*.5;z=b+(u<<3)+84|0;if((o-E)*+g[z>>2]+(n-x)*+g[b+(u<<3)+88>>2]>m){i=h;return}c[j>>2]=1;c[a+56>>2]=1;u=z;z=c[u+4>>2]|0;b=a+40|0;c[b>>2]=c[u>>2];c[b+4>>2]=z;n=+E;E=+x;z=a+48|0;g[z>>2]=n;g[z+4>>2]=E;z=l;b=c[z+4>>2]|0;u=a;c[u>>2]=c[z>>2];c[u+4>>2]=b;c[a+16>>2]=0;i=h;return}if(C*C+D*D>m*m){i=h;return}c[j>>2]=1;c[a+56>>2]=1;j=a+40|0;m=+C;E=+D;b=j;g[b>>2]=m;g[b+4>>2]=E;E=+Q(+(C*C+D*D));if(!(E<1.1920928955078125E-7)){m=1/E;g[j>>2]=C*m;g[a+44>>2]=D*
m}j=a+48|0;c[j>>2]=s;c[j+4>>2]=e;e=l;l=c[e+4>>2]|0;j=a;c[j>>2]=c[e>>2];c[j+4>>2]=l;c[a+16>>2]=0;i=h;return}function Ve(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0;b=i;c[a>>2]=-1;d=a+12|0;c[d>>2]=16;c[a+8>>2]=0;e=Pm(576)|0;f=a+4|0;c[f>>2]=e;xn(e|0,0,(c[d>>2]|0)*36|0)|0;e=(c[d>>2]|0)+-1|0;g=c[f>>2]|0;if((e|0)>0){f=0;do{h=f;f=f+1|0;c[g+(h*36|0)+20>>2]=f;c[g+(h*36|0)+32>>2]=-1;h=(c[d>>2]|0)+-1|0}while((f|0)<(h|0));j=h}else j=e;c[g+(j*36|0)+20>>2]=-1;c[g+(((c[d>>2]|0)+-1|0)*36|0)+32>>2]=-1;c[a+16>>2]=0;c[a+
20>>2]=0;c[a+24>>2]=0;i=b;return}function We(a){a=a|0;var b=0;b=i;Qm(c[a+4>>2]|0);i=b;return}function Xe(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0;b=i;d=a+16|0;e=c[d>>2]|0;f=a+4|0;g=c[f>>2]|0;if((e|0)==-1){h=a+12|0;j=c[h>>2]|0;c[h>>2]=j<<1;k=Pm(j*72|0)|0;c[f>>2]=k;j=a+8|0;An(k|0,g|0,(c[j>>2]|0)*36|0)|0;Qm(g);k=c[j>>2]|0;l=(c[h>>2]|0)+-1|0;m=c[f>>2]|0;if((k|0)<(l|0)){f=k;do{k=f;f=f+1|0;c[m+(k*36|0)+20>>2]=f;c[m+(k*36|0)+32>>2]=-1;k=(c[h>>2]|0)+-1|0}while((f|0)<(k|0));n=k}else n=
l;c[m+(n*36|0)+20>>2]=-1;c[m+(((c[h>>2]|0)+-1|0)*36|0)+32>>2]=-1;h=c[j>>2]|0;c[d>>2]=h;o=j;p=m;q=h}else{o=a+8|0;p=g;q=e}e=p+(q*36|0)+20|0;c[d>>2]=c[e>>2];c[e>>2]=-1;c[p+(q*36|0)+24>>2]=-1;c[p+(q*36|0)+28>>2]=-1;c[p+(q*36|0)+32>>2]=0;c[p+(q*36|0)+16>>2]=0;c[o>>2]=(c[o>>2]|0)+1;i=b;return q|0}function Ye(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0;e=i;f=Xe(a)|0;h=a+4|0;j=+(+g[b>>2]+-.10000000149011612);k=+(+g[b+4>>2]+-.10000000149011612);l=(c[h>>2]|0)+(f*36|0)|0;g[l>>2]=j;g[l+4>>2]=k;k=+(+g[b+
8>>2]+.10000000149011612);j=+(+g[b+12>>2]+.10000000149011612);b=(c[h>>2]|0)+(f*36|0)+8|0;g[b>>2]=k;g[b+4>>2]=j;c[(c[h>>2]|0)+(f*36|0)+16>>2]=d;c[(c[h>>2]|0)+(f*36|0)+32>>2]=0;Ze(a,f);i=e;return f|0}function Ze(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;d=i;e=a+24|0;c[e>>2]=(c[e>>2]|0)+1;e=c[a>>2]|0;if((e|0)==-1){c[a>>2]=b;c[(c[a+4>>2]|0)+(b*36|0)+20>>2]=-1;i=d;return}f=a+4|0;h=c[f>>2]|0;j=+g[h+(b*36|0)>>
2];k=+g[h+(b*36|0)+4>>2];l=+g[h+(b*36|0)+8>>2];m=+g[h+(b*36|0)+12>>2];n=c[h+(e*36|0)+24>>2]|0;a:do if((n|0)==-1)o=e;else{p=n;q=e;while(1){r=c[h+(q*36|0)+28>>2]|0;s=+g[h+(q*36|0)+8>>2];t=+g[h+(q*36|0)>>2];u=+g[h+(q*36|0)+12>>2];v=+g[h+(q*36|0)+4>>2];w=((s>l?s:l)-(t<j?t:j)+((u>m?u:m)-(v<k?v:k)))*2;x=w*2;y=(w-(s-t+(u-v))*2)*2;v=+g[h+(p*36|0)>>2];u=j<v?j:v;t=+g[h+(p*36|0)+4>>2];s=k<t?k:t;w=+g[h+(p*36|0)+8>>2];z=l>w?l:w;A=+g[h+(p*36|0)+12>>2];B=m>A?m:A;if((c[h+(p*36|0)+24>>2]|0)==-1)C=(z-u+(B-s))*2;else C=
(z-u+(B-s))*2-(w-v+(A-t))*2;t=y+C;A=+g[h+(r*36|0)>>2];v=j<A?j:A;w=+g[h+(r*36|0)+4>>2];s=k<w?k:w;B=+g[h+(r*36|0)+8>>2];u=l>B?l:B;z=+g[h+(r*36|0)+12>>2];D=m>z?m:z;if((c[h+(r*36|0)+24>>2]|0)==-1)E=(u-v+(D-s))*2;else E=(u-v+(D-s))*2-(B-A+(z-w))*2;w=y+E;if(x<t&x<w){o=q;break a}F=t<w?p:r;p=c[h+(F*36|0)+24>>2]|0;if((p|0)==-1){o=F;break}else q=F}}while(0);e=c[h+(o*36|0)+20>>2]|0;h=Xe(a)|0;n=c[f>>2]|0;c[n+(h*36|0)+20>>2]=e;c[n+(h*36|0)+16>>2]=0;n=c[f>>2]|0;E=+g[n+(o*36|0)>>2];C=+g[n+(o*36|0)+4>>2];w=+(j<E?
j:E);E=+(k<C?k:C);q=n+(h*36|0)|0;g[q>>2]=w;g[q+4>>2]=E;E=+g[n+(o*36|0)+8>>2];w=+g[n+(o*36|0)+12>>2];C=+(l>E?l:E);E=+(m>w?m:w);q=n+(h*36|0)+8|0;g[q>>2]=C;g[q+4>>2]=E;q=c[f>>2]|0;c[q+(h*36|0)+32>>2]=(c[q+(o*36|0)+32>>2]|0)+1;if((e|0)==-1){c[q+(h*36|0)+24>>2]=o;c[q+(h*36|0)+28>>2]=b;c[q+(o*36|0)+20>>2]=h;n=q+(b*36|0)+20|0;c[n>>2]=h;c[a>>2]=h;G=c[n>>2]|0}else{n=q+(e*36|0)+24|0;if((c[n>>2]|0)==(o|0))c[n>>2]=h;else c[q+(e*36|0)+28>>2]=h;c[q+(h*36|0)+24>>2]=o;c[q+(h*36|0)+28>>2]=b;c[q+(o*36|0)+20>>2]=h;
c[q+(b*36|0)+20>>2]=h;G=h}if((G|0)==-1){i=d;return}else H=G;do{G=bf(a,H)|0;h=c[f>>2]|0;b=c[h+(G*36|0)+24>>2]|0;q=c[h+(G*36|0)+28>>2]|0;o=c[h+(b*36|0)+32>>2]|0;e=c[h+(q*36|0)+32>>2]|0;c[h+(G*36|0)+32>>2]=((o|0)>(e|0)?o:e)+1;E=+g[h+(b*36|0)>>2];C=+g[h+(q*36|0)>>2];w=+g[h+(b*36|0)+4>>2];m=+g[h+(q*36|0)+4>>2];l=+(E<C?E:C);C=+(w<m?w:m);e=h+(G*36|0)|0;g[e>>2]=l;g[e+4>>2]=C;C=+g[h+(b*36|0)+8>>2];l=+g[h+(q*36|0)+8>>2];m=+g[h+(b*36|0)+12>>2];w=+g[h+(q*36|0)+12>>2];E=+(C>l?C:l);l=+(m>w?m:w);q=h+(G*36|0)+8|
0;g[q>>2]=E;g[q+4>>2]=l;H=c[(c[f>>2]|0)+(G*36|0)+20>>2]|0}while(!((H|0)==-1));i=d;return}function _e(a,b){a=a|0;b=b|0;var d=0,e=0,f=0;d=i;$e(a,b);e=a+16|0;f=c[a+4>>2]|0;c[f+(b*36|0)+20>>2]=c[e>>2];c[f+(b*36|0)+32>>2]=-1;c[e>>2]=b;b=a+8|0;c[b>>2]=(c[b>>2]|0)+-1;i=d;return}function $e(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;d=i;if((c[a>>2]|0)==(b|0)){c[a>>2]=-1;i=d;return}e=a+4|0;f=c[e>>2]|0;h=c[f+(b*36|0)+20>>2]|0;j=f+(h*36|0)+20|0;k=c[j>>2]|0;l=c[f+(h*36|0)+24>>2]|
0;if((l|0)==(b|0))m=c[f+(h*36|0)+28>>2]|0;else m=l;if((k|0)==-1){c[a>>2]=m;c[f+(m*36|0)+20>>2]=-1;l=a+16|0;c[j>>2]=c[l>>2];c[f+(h*36|0)+32>>2]=-1;c[l>>2]=h;l=a+8|0;c[l>>2]=(c[l>>2]|0)+-1;i=d;return}l=f+(k*36|0)+24|0;if((c[l>>2]|0)==(h|0))c[l>>2]=m;else c[f+(k*36|0)+28>>2]=m;c[f+(m*36|0)+20>>2]=k;m=a+16|0;c[j>>2]=c[m>>2];c[f+(h*36|0)+32>>2]=-1;c[m>>2]=h;h=a+8|0;c[h>>2]=(c[h>>2]|0)+-1;h=k;do{k=bf(a,h)|0;m=c[e>>2]|0;f=c[m+(k*36|0)+24>>2]|0;j=c[m+(k*36|0)+28>>2]|0;n=+g[m+(f*36|0)>>2];o=+g[m+(j*36|0)>>
2];p=+g[m+(f*36|0)+4>>2];q=+g[m+(j*36|0)+4>>2];r=+(n<o?n:o);o=+(p<q?p:q);l=m+(k*36|0)|0;g[l>>2]=r;g[l+4>>2]=o;o=+g[m+(f*36|0)+8>>2];r=+g[m+(j*36|0)+8>>2];q=+g[m+(f*36|0)+12>>2];p=+g[m+(j*36|0)+12>>2];n=+(o>r?o:r);r=+(q>p?q:p);l=m+(k*36|0)+8|0;g[l>>2]=n;g[l+4>>2]=r;l=c[e>>2]|0;m=c[l+(f*36|0)+32>>2]|0;f=c[l+(j*36|0)+32>>2]|0;c[l+(k*36|0)+32>>2]=((m|0)>(f|0)?m:f)+1;h=c[l+(k*36|0)+20>>2]|0}while(!((h|0)==-1));i=d;return}function af(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,
p=0,q=0,r=0,s=0,t=0,u=0;f=i;h=a+4|0;j=c[h>>2]|0;if(((+g[j+(b*36|0)>>2]<=+g[d>>2]?+g[j+(b*36|0)+4>>2]<=+g[d+4>>2]:0)?+g[d+8>>2]<=+g[j+(b*36|0)+8>>2]:0)?+g[d+12>>2]<=+g[j+(b*36|0)+12>>2]:0){k=0;i=f;return k|0}$e(a,b);j=d;l=+g[j>>2];m=+g[j+4>>2];j=d+8|0;n=+g[j>>2];o=l+-.10000000149011612;l=m+-.10000000149011612;m=n+.10000000149011612;n=+g[j+4>>2]+.10000000149011612;p=+g[e>>2]*2;q=+g[e+4>>2]*2;if(p<0){r=o+p;s=m}else{r=o;s=p+m}if(q<0){t=l+q;u=n}else{t=l;u=q+n}e=c[h>>2]|0;n=+r;r=+t;h=e+(b*36|0)|0;g[h>>
2]=n;g[h+4>>2]=r;r=+s;s=+u;h=e+(b*36|0)+8|0;g[h>>2]=r;g[h+4>>2]=s;Ze(a,b);k=1;i=f;return k|0}function bf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;d=i;e=c[a+4>>2]|0;f=e+(b*36|0)|0;h=e+(b*36|0)+24|0;j=c[h>>2]|0;if((j|0)==-1){k=b;i=d;return k|0}l=e+(b*36|0)+32|0;if((c[l>>2]|0)<2){k=b;i=d;return k|0}m=e+(b*36|0)+28|0;n=c[m>>2]|0;o=e+(j*36|0)|0;p=e+(n*36|0)|0;q=e+(n*36|0)+32|0;r=e+(j*36|0)+32|0;
s=(c[q>>2]|0)-(c[r>>2]|0)|0;if((s|0)>1){t=e+(n*36|0)+24|0;u=c[t>>2]|0;v=e+(n*36|0)+28|0;w=c[v>>2]|0;x=e+(u*36|0)|0;y=e+(w*36|0)|0;c[t>>2]=b;t=e+(b*36|0)+20|0;z=e+(n*36|0)+20|0;c[z>>2]=c[t>>2];c[t>>2]=n;t=c[z>>2]|0;do if(!((t|0)==-1)){z=e+(t*36|0)+24|0;if((c[z>>2]|0)==(b|0)){c[z>>2]=n;break}else{c[e+(t*36|0)+28>>2]=n;break}}else c[a>>2]=n;while(0);t=e+(u*36|0)+32|0;z=e+(w*36|0)+32|0;if((c[t>>2]|0)>(c[z>>2]|0)){c[v>>2]=u;c[m>>2]=w;c[e+(w*36|0)+20>>2]=b;A=+g[o>>2];B=+g[y>>2];C=A<B?A:B;B=+g[e+(j*36|0)+
4>>2];A=+g[e+(w*36|0)+4>>2];D=+C;E=+(B<A?B:A);F=f;g[F>>2]=D;g[F+4>>2]=E;E=+g[e+(j*36|0)+8>>2];D=+g[e+(w*36|0)+8>>2];A=+g[e+(j*36|0)+12>>2];B=+g[e+(w*36|0)+12>>2];G=+(E>D?E:D);D=+(A>B?A:B);F=e+(b*36|0)+8|0;g[F>>2]=G;g[F+4>>2]=D;D=+g[x>>2];G=+g[e+(b*36|0)+4>>2];B=+g[e+(u*36|0)+4>>2];A=+(C<D?C:D);D=+(G<B?G:B);F=p;g[F>>2]=A;g[F+4>>2]=D;D=+g[e+(b*36|0)+8>>2];A=+g[e+(u*36|0)+8>>2];B=+g[e+(b*36|0)+12>>2];G=+g[e+(u*36|0)+12>>2];C=+(D>A?D:A);A=+(B>G?B:G);F=e+(n*36|0)+8|0;g[F>>2]=C;g[F+4>>2]=A;F=c[r>>2]|0;
H=c[z>>2]|0;I=((F|0)>(H|0)?F:H)+1|0;c[l>>2]=I;H=c[t>>2]|0;J=(I|0)>(H|0)?I:H}else{c[v>>2]=w;c[m>>2]=u;c[e+(u*36|0)+20>>2]=b;A=+g[o>>2];C=+g[x>>2];G=A<C?A:C;C=+g[e+(j*36|0)+4>>2];A=+g[e+(u*36|0)+4>>2];B=+G;D=+(C<A?C:A);x=f;g[x>>2]=B;g[x+4>>2]=D;D=+g[e+(j*36|0)+8>>2];B=+g[e+(u*36|0)+8>>2];A=+g[e+(j*36|0)+12>>2];C=+g[e+(u*36|0)+12>>2];E=+(D>B?D:B);B=+(A>C?A:C);u=e+(b*36|0)+8|0;g[u>>2]=E;g[u+4>>2]=B;B=+g[y>>2];E=+g[e+(b*36|0)+4>>2];C=+g[e+(w*36|0)+4>>2];A=+(G<B?G:B);B=+(E<C?E:C);y=p;g[y>>2]=A;g[y+4>>2]=
B;B=+g[e+(b*36|0)+8>>2];A=+g[e+(w*36|0)+8>>2];C=+g[e+(b*36|0)+12>>2];E=+g[e+(w*36|0)+12>>2];G=+(B>A?B:A);A=+(C>E?C:E);w=e+(n*36|0)+8|0;g[w>>2]=G;g[w+4>>2]=A;w=c[r>>2]|0;y=c[t>>2]|0;t=((w|0)>(y|0)?w:y)+1|0;c[l>>2]=t;y=c[z>>2]|0;J=(t|0)>(y|0)?t:y}c[q>>2]=J+1;k=n;i=d;return k|0}if(!((s|0)<-1)){k=b;i=d;return k|0}s=e+(j*36|0)+24|0;J=c[s>>2]|0;y=e+(j*36|0)+28|0;t=c[y>>2]|0;z=e+(J*36|0)|0;w=e+(t*36|0)|0;c[s>>2]=b;s=e+(b*36|0)+20|0;u=e+(j*36|0)+20|0;c[u>>2]=c[s>>2];c[s>>2]=j;s=c[u>>2]|0;do if(!((s|0)==-1)){u=
e+(s*36|0)+24|0;if((c[u>>2]|0)==(b|0)){c[u>>2]=j;break}else{c[e+(s*36|0)+28>>2]=j;break}}else c[a>>2]=j;while(0);a=e+(J*36|0)+32|0;s=e+(t*36|0)+32|0;if((c[a>>2]|0)>(c[s>>2]|0)){c[y>>2]=J;c[h>>2]=t;c[e+(t*36|0)+20>>2]=b;A=+g[p>>2];G=+g[w>>2];E=A<G?A:G;G=+g[e+(n*36|0)+4>>2];A=+g[e+(t*36|0)+4>>2];C=+E;B=+(G<A?G:A);u=f;g[u>>2]=C;g[u+4>>2]=B;B=+g[e+(n*36|0)+8>>2];C=+g[e+(t*36|0)+8>>2];A=+g[e+(n*36|0)+12>>2];G=+g[e+(t*36|0)+12>>2];D=+(B>C?B:C);C=+(A>G?A:G);u=e+(b*36|0)+8|0;g[u>>2]=D;g[u+4>>2]=C;C=+g[z>>
2];D=+g[e+(b*36|0)+4>>2];G=+g[e+(J*36|0)+4>>2];A=+(E<C?E:C);C=+(D<G?D:G);u=o;g[u>>2]=A;g[u+4>>2]=C;C=+g[e+(b*36|0)+8>>2];A=+g[e+(J*36|0)+8>>2];G=+g[e+(b*36|0)+12>>2];D=+g[e+(J*36|0)+12>>2];E=+(C>A?C:A);A=+(G>D?G:D);u=e+(j*36|0)+8|0;g[u>>2]=E;g[u+4>>2]=A;u=c[q>>2]|0;x=c[s>>2]|0;m=((u|0)>(x|0)?u:x)+1|0;c[l>>2]=m;x=c[a>>2]|0;K=(m|0)>(x|0)?m:x}else{c[y>>2]=t;c[h>>2]=J;c[e+(J*36|0)+20>>2]=b;A=+g[p>>2];E=+g[z>>2];D=A<E?A:E;E=+g[e+(n*36|0)+4>>2];A=+g[e+(J*36|0)+4>>2];G=+D;C=+(E<A?E:A);z=f;g[z>>2]=G;g[z+
4>>2]=C;C=+g[e+(n*36|0)+8>>2];G=+g[e+(J*36|0)+8>>2];A=+g[e+(n*36|0)+12>>2];E=+g[e+(J*36|0)+12>>2];B=+(C>G?C:G);G=+(A>E?A:E);J=e+(b*36|0)+8|0;g[J>>2]=B;g[J+4>>2]=G;G=+g[w>>2];B=+g[e+(b*36|0)+4>>2];E=+g[e+(t*36|0)+4>>2];A=+(D<G?D:G);G=+(B<E?B:E);w=o;g[w>>2]=A;g[w+4>>2]=G;G=+g[e+(b*36|0)+8>>2];A=+g[e+(t*36|0)+8>>2];E=+g[e+(b*36|0)+12>>2];B=+g[e+(t*36|0)+12>>2];D=+(G>A?G:A);A=+(E>B?E:B);t=e+(j*36|0)+8|0;g[t>>2]=D;g[t+4>>2]=A;t=c[q>>2]|0;q=c[a>>2]|0;a=((t|0)>(q|0)?t:q)+1|0;c[l>>2]=a;l=c[s>>2]|0;K=(a|0)>
(l|0)?a:l}c[r>>2]=K+1;k=j;i=d;return k|0}function cf(b,d,e,f,h){b=b|0;d=d|0;e=e|0;f=f|0;h=h|0;var j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;j=i;l=b+60|0;c[l>>2]=0;m=f+12|0;n=+g[h+12>>2];o=+g[m>>2];p=+g[h+8>>2];q=+g[f+16>>2];r=+g[h>>2]+(n*o-p*q)-+g[e>>2];s=o*p+n*q+ +g[h+4>>2]-+g[e+4>>2];q=+g[e+12>>2];n=+g[e+8>>2];p=r*q+s*n;o=q*s-r*n;e=d+12|0;h=c[e>>2]|0;t=c[e+4>>2]|0;n=(c[k>>2]=h,+g[k>>2]);r=(c[k>>2]=t,+g[k>>2]);e=d+20|0;u=c[e>>2]|0;
v=c[e+4>>2]|0;s=(c[k>>2]=u,+g[k>>2]);q=(c[k>>2]=v,+g[k>>2]);w=s-n;x=q-r;y=w*(s-p)+x*(q-o);z=p-n;A=o-r;B=z*w+A*x;C=+g[d+8>>2]+ +g[f+8>>2];if(B<=0){if(z*z+A*A>C*C){i=j;return}if((a[d+44>>0]|0)!=0?(f=d+28|0,D=+g[f>>2],(n-p)*(n-D)+(r-o)*(r-+g[f+4>>2])>0):0){i=j;return}c[l>>2]=1;c[b+56>>2]=0;g[b+40>>2]=0;g[b+44>>2]=0;f=b+48|0;c[f>>2]=h;c[f+4>>2]=t;f=b+16|0;c[f>>2]=0;a[f>>0]=0;a[f+1>>0]=0;a[f+2>>0]=0;a[f+3>>0]=0;f=m;e=c[f+4>>2]|0;E=b;c[E>>2]=c[f>>2];c[E+4>>2]=e;i=j;return}if(y<=0){D=p-s;F=o-q;if(D*D+F*
F>C*C){i=j;return}if((a[d+45>>0]|0)!=0?(e=d+36|0,G=+g[e>>2],D*(G-s)+F*(+g[e+4>>2]-q)>0):0){i=j;return}c[l>>2]=1;c[b+56>>2]=0;g[b+40>>2]=0;g[b+44>>2]=0;e=b+48|0;c[e>>2]=u;c[e+4>>2]=v;v=b+16|0;c[v>>2]=0;a[v>>0]=1;a[v+1>>0]=0;a[v+2>>0]=0;a[v+3>>0]=0;v=m;e=c[v+4>>2]|0;u=b;c[u>>2]=c[v>>2];c[u+4>>2]=e;i=j;return}F=1/(w*w+x*x);G=p-(n*y+s*B)*F;s=o-(r*y+q*B)*F;if(G*G+s*s>C*C){i=j;return}C=-x;if(w*A+z*C<0){H=x;I=-w}else{H=C;I=w}w=+Q(+(I*I+H*H));if(w<1.1920928955078125E-7){J=H;K=I}else{C=1/w;J=H*C;K=I*C}c[l>>
2]=1;c[b+56>>2]=1;C=+J;J=+K;l=b+40|0;g[l>>2]=C;g[l+4>>2]=J;l=b+48|0;c[l>>2]=h;c[l+4>>2]=t;t=b+16|0;c[t>>2]=0;a[t>>0]=0;a[t+1>>0]=0;a[t+2>>0]=1;a[t+3>>0]=0;t=m;m=c[t+4>>2]|0;l=b;c[l>>2]=c[t>>2];c[l+4>>2]=m;i=j;return}function df(b,d,e,f,h,j){b=b|0;d=d|0;e=e|0;f=f|0;h=h|0;j=j|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=
0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Da=0,Ea=0;l=i;i=i+144|0;m=l+128|0;n=l+24|0;o=l+72|0;p=l+48|0;q=l;r=b+132|0;s=+g[f+12>>2];t=+g[j+8>>2];u=+g[f+8>>2];v=+g[j+12>>2];w=s*t-u*v;x=t*u+s*v;v=+w;t=+x;y=+g[j>>2]-+g[f>>2];z=+g[j+4>>2]-+g[f+4>>2];A=s*y+u*z;B=s*z-u*y;y=+A;u=+B;f=r;g[f>>2]=y;g[f+4>>2]=u;f=b+140|0;g[f>>2]=v;g[f+4>>2]=t;f=b+144|0;t=+g[h+12>>2];j=b+140|0;v=+g[h+16>>2];u=A+(x*t-w*v);C=b+136|0;A=t*w+x*v+B;B=+u;v=+A;D=b+148|0;g[D>>2]=B;g[D+
4>>2]=v;D=e+28|0;E=c[D>>2]|0;F=c[D+4>>2]|0;D=b+156|0;c[D>>2]=E;c[D+4>>2]=F;D=b+164|0;G=e+12|0;H=c[G>>2]|0;I=c[G+4>>2]|0;G=D;c[G>>2]=H;c[G+4>>2]=I;G=b+172|0;J=e+20|0;K=c[J>>2]|0;L=c[J+4>>2]|0;J=G;c[J>>2]=K;c[J+4>>2]=L;J=e+36|0;M=c[J>>2]|0;N=c[J+4>>2]|0;J=b+180|0;c[J>>2]=M;c[J+4>>2]=N;J=(a[e+44>>0]|0)!=0;O=(a[e+45>>0]|0)!=0;v=(c[k>>2]=K,+g[k>>2]);B=(c[k>>2]=H,+g[k>>2]);x=v-B;w=(c[k>>2]=L,+g[k>>2]);L=b+168|0;t=(c[k>>2]=I,+g[k>>2]);y=w-t;z=+Q(+(x*x+y*y));s=(c[k>>2]=E,+g[k>>2]);P=(c[k>>2]=F,+g[k>>2]);
R=(c[k>>2]=M,+g[k>>2]);S=(c[k>>2]=N,+g[k>>2]);if(z<1.1920928955078125E-7){T=x;U=y}else{V=1/z;T=x*V;U=y*V}N=b+196|0;V=-T;g[N>>2]=U;M=b+200|0;g[M>>2]=V;y=(u-B)*U+(A-t)*V;if(J){V=B-s;B=t-P;t=+Q(+(V*V+B*B));if(t<1.1920928955078125E-7){W=V;X=B}else{x=1/t;W=V*x;X=B*x}x=-W;g[b+188>>2]=X;g[b+192>>2]=x;Y=U*W-T*X>=0;Z=(u-s)*X+(A-P)*x}else{Y=0;Z=0}a:do if(!O){if(!J){F=y>=0;a[b+248>>0]=F&1;E=b+212|0;if(F){_=E;$=64;break}else{aa=E;$=65;break}}E=Z>=0;if(Y){if(!E){F=y>=0;a[b+248>>0]=F&1;I=b+212|0;if(F)ba=I;else{x=
+-U;P=+T;F=I;g[F>>2]=x;g[F+4>>2]=P;F=N;I=c[F>>2]|0;H=c[F+4>>2]|0;F=b+228|0;c[F>>2]=I;c[F+4>>2]=H;H=b+236|0;g[H>>2]=-(c[k>>2]=I,+g[k>>2]);g[H+4>>2]=P;break}}else{a[b+248>>0]=1;ba=b+212|0}H=N;I=c[H+4>>2]|0;F=ba;c[F>>2]=c[H>>2];c[F+4>>2]=I;I=b+188|0;F=c[I+4>>2]|0;H=b+228|0;c[H>>2]=c[I>>2];c[H+4>>2]=F;P=+-+g[N>>2];x=+-+g[M>>2];F=b+236|0;g[F>>2]=P;g[F+4>>2]=x;break}else{if(E){E=y>=0;a[b+248>>0]=E&1;F=b+212|0;if(E){E=N;H=c[E>>2]|0;I=c[E+4>>2]|0;E=F;c[E>>2]=H;c[E+4>>2]=I;E=b+228|0;c[E>>2]=H;c[E+4>>2]=I;
x=+-(c[k>>2]=H,+g[k>>2]);P=+T;H=b+236|0;g[H>>2]=x;g[H+4>>2]=P;break}else ca=F}else{a[b+248>>0]=0;ca=b+212|0}P=+-U;x=+T;F=ca;g[F>>2]=P;g[F+4>>2]=x;F=N;H=c[F+4>>2]|0;I=b+228|0;c[I>>2]=c[F>>2];c[I+4>>2]=H;x=+-+g[b+188>>2];P=+-+g[b+192>>2];H=b+236|0;g[H>>2]=x;g[H+4>>2]=P;break}}else{P=R-v;x=S-w;X=+Q(+(P*P+x*x));if(X<1.1920928955078125E-7){da=P;ea=x}else{s=1/X;da=P*s;ea=x*s}s=-da;H=b+204|0;g[H>>2]=ea;I=b+208|0;g[I>>2]=s;F=T*ea-U*da>0;x=(u-v)*ea+(A-w)*s;if(!J){E=y>=0;if(!O){a[b+248>>0]=E&1;K=b+212|0;if(E){_=
K;$=64;break}else{aa=K;$=65;break}}if(F){if(!E){K=x>=0;a[b+248>>0]=K&1;e=b+212|0;if(K)fa=e;else{s=+-U;P=+T;K=e;g[K>>2]=s;g[K+4>>2]=P;K=b+228|0;g[K>>2]=s;g[K+4>>2]=P;K=N;e=c[K+4>>2]|0;ga=b+236|0;c[ga>>2]=c[K>>2];c[ga+4>>2]=e;break}}else{a[b+248>>0]=1;fa=b+212|0}e=N;ga=c[e+4>>2]|0;K=fa;c[K>>2]=c[e>>2];c[K+4>>2]=ga;P=+-+g[N>>2];s=+-+g[M>>2];ga=b+228|0;g[ga>>2]=P;g[ga+4>>2]=s;ga=b+204|0;K=c[ga+4>>2]|0;e=b+236|0;c[e>>2]=c[ga>>2];c[e+4>>2]=K;break}else{if(E){E=x>=0;a[b+248>>0]=E&1;K=b+212|0;if(E){E=N;e=
c[E>>2]|0;ga=c[E+4>>2]|0;E=K;c[E>>2]=e;c[E+4>>2]=ga;s=+-(c[k>>2]=e,+g[k>>2]);P=+T;E=b+228|0;g[E>>2]=s;g[E+4>>2]=P;E=b+236|0;c[E>>2]=e;c[E+4>>2]=ga;break}else ha=K}else{a[b+248>>0]=0;ha=b+212|0}P=+-U;s=+T;K=ha;g[K>>2]=P;g[K+4>>2]=s;s=+-+g[b+204>>2];P=+-+g[b+208>>2];K=b+228|0;g[K>>2]=s;g[K+4>>2]=P;K=N;ga=c[K+4>>2]|0;E=b+236|0;c[E>>2]=c[K>>2];c[E+4>>2]=ga;break}}if(Y&F){if(!(Z>=0)&!(y>=0)){ga=x>=0;a[b+248>>0]=ga&1;E=b+212|0;if(ga)ia=E;else{P=+-U;s=+T;ga=E;g[ga>>2]=P;g[ga+4>>2]=s;ga=b+228|0;g[ga>>2]=
P;g[ga+4>>2]=s;ga=b+236|0;g[ga>>2]=P;g[ga+4>>2]=s;break}}else{a[b+248>>0]=1;ia=b+212|0}ga=N;E=c[ga+4>>2]|0;K=ia;c[K>>2]=c[ga>>2];c[K+4>>2]=E;E=b+188|0;K=c[E+4>>2]|0;ga=b+228|0;c[ga>>2]=c[E>>2];c[ga+4>>2]=K;K=b+204|0;ga=c[K+4>>2]|0;E=b+236|0;c[E>>2]=c[K>>2];c[E+4>>2]=ga;break}if(Y){do if(!(Z>=0)){if(y>=0){ga=x>=0;a[b+248>>0]=ga&1;E=b+212|0;if(ga){ja=E;break}else ka=E}else{a[b+248>>0]=0;ka=b+212|0}s=+-U;P=+T;E=ka;g[E>>2]=s;g[E+4>>2]=P;P=+-+g[H>>2];s=+-+g[I>>2];E=b+228|0;g[E>>2]=P;g[E+4>>2]=s;s=+-+g[N>>
2];P=+-+g[M>>2];E=b+236|0;g[E>>2]=s;g[E+4>>2]=P;break a}else{a[b+248>>0]=1;ja=b+212|0}while(0);E=N;ga=c[E+4>>2]|0;K=ja;c[K>>2]=c[E>>2];c[K+4>>2]=ga;ga=b+188|0;K=c[ga+4>>2]|0;E=b+228|0;c[E>>2]=c[ga>>2];c[E+4>>2]=K;K=N;E=c[K+4>>2]|0;ga=b+236|0;c[ga>>2]=c[K>>2];c[ga+4>>2]=E;break}if(!F){if(!(!(Z>=0)|!(y>=0))){E=x>=0;a[b+248>>0]=E&1;ga=b+212|0;if(E){E=N;K=c[E>>2]|0;e=c[E+4>>2]|0;E=ga;c[E>>2]=K;c[E+4>>2]=e;E=b+228|0;c[E>>2]=K;c[E+4>>2]=e;E=b+236|0;c[E>>2]=K;c[E+4>>2]=e;break}else la=ga}else{a[b+248>>0]=
0;la=b+212|0}P=+-U;s=+T;ga=la;g[ga>>2]=P;g[ga+4>>2]=s;s=+-+g[H>>2];P=+-+g[I>>2];ga=b+228|0;g[ga>>2]=s;g[ga+4>>2]=P;P=+-+g[b+188>>2];s=+-+g[b+192>>2];ga=b+236|0;g[ga>>2]=P;g[ga+4>>2]=s;break}do if(!(x>=0)){if(Z>=0){ga=y>=0;a[b+248>>0]=ga&1;e=b+212|0;if(ga){ma=e;break}else na=e}else{a[b+248>>0]=0;na=b+212|0}s=+-U;P=+T;e=na;g[e>>2]=s;g[e+4>>2]=P;P=+-+g[N>>2];s=+-+g[M>>2];e=b+228|0;g[e>>2]=P;g[e+4>>2]=s;s=+-+g[b+188>>2];P=+-+g[b+192>>2];e=b+236|0;g[e>>2]=s;g[e+4>>2]=P;break a}else{a[b+248>>0]=1;ma=b+
212|0}while(0);I=N;H=c[I+4>>2]|0;F=ma;c[F>>2]=c[I>>2];c[F+4>>2]=H;H=N;F=c[H+4>>2]|0;I=b+228|0;c[I>>2]=c[H>>2];c[I+4>>2]=F;F=b+204|0;I=c[F+4>>2]|0;H=b+236|0;c[H>>2]=c[F>>2];c[H+4>>2]=I}while(0);if(($|0)==64){ma=N;na=c[ma>>2]|0;la=c[ma+4>>2]|0;ma=_;c[ma>>2]=na;c[ma+4>>2]=la;y=+-(c[k>>2]=na,+g[k>>2]);Z=+T;na=b+228|0;g[na>>2]=y;g[na+4>>2]=Z;na=b+236|0;g[na>>2]=y;g[na+4>>2]=Z}else if(($|0)==65){Z=+-U;U=+T;na=aa;g[na>>2]=Z;g[na+4>>2]=U;na=N;aa=c[na>>2]|0;la=c[na+4>>2]|0;na=b+228|0;c[na>>2]=aa;c[na+4>>2]=
la;na=b+236|0;c[na>>2]=aa;c[na+4>>2]=la}la=h+148|0;na=b+128|0;c[na>>2]=c[la>>2];if((c[la>>2]|0)>0){aa=0;do{U=+g[f>>2];Z=+g[h+(aa<<3)+20>>2];T=+g[j>>2];y=+g[h+(aa<<3)+24>>2];w=+(+g[r>>2]+(U*Z-T*y));A=+(Z*T+U*y+ +g[C>>2]);ma=b+(aa<<3)|0;g[ma>>2]=w;g[ma+4>>2]=A;A=+g[f>>2];w=+g[h+(aa<<3)+84>>2];y=+g[j>>2];U=+g[h+(aa<<3)+88>>2];T=+(A*w-y*U);Z=+(w*y+A*U);ma=b+(aa<<3)+64|0;g[ma>>2]=T;g[ma+4>>2]=Z;aa=aa+1|0}while((aa|0)<(c[la>>2]|0))}la=b+244|0;g[la>>2]=.019999999552965164;aa=d+60|0;c[aa>>2]=0;ma=b+248|0;
_=c[na>>2]|0;if((_|0)<=0){i=l;return}Z=+g[b+164>>2];T=+g[L>>2];U=+g[b+212>>2];A=+g[b+216>>2];y=3.4028234663852886E38;L=0;do{w=U*(+g[b+(L<<3)>>2]-Z)+A*(+g[b+(L<<3)+4>>2]-T);y=w<y?w:y;L=L+1|0}while((L|0)!=(_|0));if(y>.019999999552965164){i=l;return}ef(m,b);_=c[m>>2]|0;if((_|0)!=0){T=+g[m+8>>2];if(T>+g[la>>2]){i=l;return}if(T>y*.9800000190734863+.0010000000474974513){L=c[m+4>>2]|0;m=d+56|0;if((_|0)==1){oa=n;pa=m;$=77}else{c[m>>2]=2;m=D;_=c[m+4>>2]|0;ja=n;c[ja>>2]=c[m>>2];c[ja+4>>2]=_;_=n+8|0;a[_>>0]=
0;ja=L&255;a[_+1>>0]=ja;a[_+2>>0]=0;a[_+3>>0]=1;_=G;m=c[_+4>>2]|0;ka=n+12|0;c[ka>>2]=c[_>>2];c[ka+4>>2]=m;m=n+20|0;a[m>>0]=0;a[m+1>>0]=ja;a[m+2>>0]=0;a[m+3>>0]=1;c[o>>2]=L;m=L+1|0;ja=(m|0)<(c[na>>2]|0)?m:0;c[o+4>>2]=ja;m=b+(L<<3)|0;ka=c[m>>2]|0;_=c[m+4>>2]|0;m=o+8|0;c[m>>2]=ka;c[m+4>>2]=_;m=b+(ja<<3)|0;ja=c[m>>2]|0;Y=c[m+4>>2]|0;m=o+16|0;c[m>>2]=ja;c[m+4>>2]=Y;m=b+(L<<3)+64|0;ia=c[m>>2]|0;ha=c[m+4>>2]|0;m=o+24|0;c[m>>2]=ia;c[m+4>>2]=ha;qa=Y;ra=ja;sa=_;ta=ka;ua=ia;va=ha;wa=n;xa=L;ya=0}}else $=75}else $=
75;if(($|0)==75){oa=n;pa=d+56|0;$=77}do if(($|0)==77){c[pa>>2]=1;L=c[na>>2]|0;if((L|0)>1){y=+g[b+216>>2];T=+g[b+212>>2];ha=0;A=T*+g[b+64>>2]+y*+g[b+68>>2];ia=1;while(1){Z=T*+g[b+(ia<<3)+64>>2]+y*+g[b+(ia<<3)+68>>2];ka=Z<A;_=ka?ia:ha;ia=ia+1|0;if((ia|0)>=(L|0)){za=_;break}else{ha=_;A=ka?Z:A}}}else za=0;ha=za+1|0;ia=(ha|0)<(L|0)?ha:0;ha=b+(za<<3)|0;ka=c[ha+4>>2]|0;_=n;c[_>>2]=c[ha>>2];c[_+4>>2]=ka;ka=n+8|0;a[ka>>0]=0;a[ka+1>>0]=za;a[ka+2>>0]=1;a[ka+3>>0]=0;ka=b+(ia<<3)|0;_=c[ka+4>>2]|0;ha=n+12|0;c[ha>>
2]=c[ka>>2];c[ha+4>>2]=_;_=n+20|0;a[_>>0]=0;a[_+1>>0]=ia;a[_+2>>0]=1;a[_+3>>0]=0;if((a[ma>>0]|0)==0){c[o>>2]=1;c[o+4>>2]=0;_=G;ia=c[_>>2]|0;ha=c[_+4>>2]|0;_=o+8|0;c[_>>2]=ia;c[_+4>>2]=ha;_=D;ka=c[_>>2]|0;ja=c[_+4>>2]|0;_=o+16|0;c[_>>2]=ka;c[_+4>>2]=ja;_=(g[k>>2]=-+g[N>>2],c[k>>2]|0);Y=(g[k>>2]=-+g[M>>2],c[k>>2]|0);m=o+24|0;c[m>>2]=_;c[m+4>>2]=Y;qa=ja;ra=ka;sa=ha;ta=ia;ua=_;va=Y;wa=oa;xa=1;ya=1;break}else{c[o>>2]=0;c[o+4>>2]=1;Y=D;_=c[Y>>2]|0;ia=c[Y+4>>2]|0;Y=o+8|0;c[Y>>2]=_;c[Y+4>>2]=ia;Y=G;ha=c[Y>>
2]|0;ka=c[Y+4>>2]|0;Y=o+16|0;c[Y>>2]=ha;c[Y+4>>2]=ka;Y=N;ja=c[Y>>2]|0;m=c[Y+4>>2]|0;Y=o+24|0;c[Y>>2]=ja;c[Y+4>>2]=m;qa=ka;ra=ha;sa=ia;ta=_;ua=ja;va=m;wa=oa;xa=0;ya=1;break}}while(0);A=(c[k>>2]=va,+g[k>>2]);y=(c[k>>2]=ua,+g[k>>2]);T=(c[k>>2]=ta,+g[k>>2]);Z=(c[k>>2]=sa,+g[k>>2]);U=(c[k>>2]=ra,+g[k>>2]);w=(c[k>>2]=qa,+g[k>>2]);qa=o+32|0;ra=o+24|0;sa=o+28|0;ea=-y;g[qa>>2]=A;g[o+36>>2]=ea;ta=o+44|0;y=-A;va=ta;g[va>>2]=y;c[va+4>>2]=ua;va=o+8|0;oa=o+12|0;v=A*T+Z*ea;g[o+40>>2]=v;N=o+52|0;g[N>>2]=U*y+(c[k>>
2]=ua,+g[k>>2])*w;if((kf(p,wa,qa,v,xa)|0)<2){i=l;return}if((kf(q,p,ta,+g[N>>2],c[o+4>>2]|0)|0)<2){i=l;return}N=d+40|0;if(ya){ya=ra;ta=c[ya>>2]|0;p=c[ya+4>>2]|0;ya=N;c[ya>>2]=ta;c[ya+4>>2]=p;p=va;ya=c[p>>2]|0;xa=c[p+4>>2]|0;p=d+48|0;c[p>>2]=ya;c[p+4>>2]=xa;v=(c[k>>2]=ya,+g[k>>2]);w=(c[k>>2]=ta,+g[k>>2]);y=+g[oa>>2];U=+g[sa>>2];ea=+g[q>>2];Z=+g[q+4>>2];T=+g[la>>2];if(!((ea-v)*w+(Z-y)*U<=T)){Aa=T;Ba=0}else{T=ea-+g[r>>2];ea=Z-+g[C>>2];Z=+g[f>>2];A=+g[j>>2];u=+(T*Z+ea*A);da=+(Z*ea-T*A);ta=d;g[ta>>2]=u;
g[ta+4>>2]=da;c[d+16>>2]=c[q+8>>2];Aa=+g[la>>2];Ba=1}da=+g[q+12>>2];u=+g[q+16>>2];if(!((da-v)*w+(u-y)*U<=Aa))Ca=Ba;else{Aa=da-+g[r>>2];da=u-+g[C>>2];u=+g[f>>2];U=+g[j>>2];y=+(Aa*u+da*U);w=+(u*da-Aa*U);j=d+(Ba*20|0)|0;g[j>>2]=y;g[j+4>>2]=w;c[d+(Ba*20|0)+16>>2]=c[q+20>>2];Ca=Ba+1|0}}else{Ba=c[o>>2]|0;o=h+(Ba<<3)+84|0;j=c[o+4>>2]|0;f=N;c[f>>2]=c[o>>2];c[f+4>>2]=j;j=h+(Ba<<3)+20|0;Ba=c[j+4>>2]|0;h=d+48|0;c[h>>2]=c[j>>2];c[h+4>>2]=Ba;w=+g[va>>2];y=+g[ra>>2];U=+g[oa>>2];Aa=+g[sa>>2];da=+g[la>>2];if(!((+g[q>>
2]-w)*y+(+g[q+4>>2]-U)*Aa<=da)){Da=da;Ea=0}else{sa=q;oa=c[sa+4>>2]|0;ra=d;c[ra>>2]=c[sa>>2];c[ra+4>>2]=oa;oa=q+8|0;ra=d+16|0;a[ra+2>>0]=a[oa+3>>0]|0;a[ra+3>>0]=a[oa+2>>0]|0;a[ra>>0]=a[oa+1>>0]|0;a[ra+1>>0]=a[oa>>0]|0;Da=+g[la>>2];Ea=1}la=q+12|0;if(!((+g[la>>2]-w)*y+(+g[q+16>>2]-U)*Aa<=Da))Ca=Ea;else{oa=la;la=c[oa+4>>2]|0;ra=d+(Ea*20|0)|0;c[ra>>2]=c[oa>>2];c[ra+4>>2]=la;la=q+20|0;q=d+(Ea*20|0)+16|0;a[q+2>>0]=a[la+3>>0]|0;a[q+3>>0]=a[la+2>>0]|0;a[q>>0]=a[la+1>>0]|0;a[q+1>>0]=a[la>>0]|0;Ca=Ea+1|0}}c[aa>>
2]=Ca;i=l;return}function ef(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0;d=i;c[a>>2]=0;e=a+4|0;c[e>>2]=-1;f=a+8|0;g[f>>2]=-3.4028234663852886E38;h=+g[b+216>>2];j=+g[b+212>>2];k=c[b+128>>2]|0;if((k|0)<=0){i=d;return}l=+g[b+164>>2];m=+g[b+168>>2];n=+g[b+172>>2];o=+g[b+176>>2];p=+g[b+244>>2];q=b+228|0;r=b+232|0;s=b+236|0;t=b+240|0;u=-3.4028234663852886E38;v=0;while(1){w=+g[b+(v<<3)+64>>2];x=-w;y=-+g[b+(v<<3)+68>>
2];z=+g[b+(v<<3)>>2];A=+g[b+(v<<3)+4>>2];B=(z-l)*x+(A-m)*y;C=(z-n)*x+(A-o)*y;D=B<C?B:C;if(D>p)break;if(!(h*w+j*y>=0))if(D>u?!((x-+g[q>>2])*j+(y-+g[r>>2])*h<-.03490658849477768):0)E=8;else F=u;else if(D>u?!((x-+g[s>>2])*j+(y-+g[t>>2])*h<-.03490658849477768):0)E=8;else F=u;if((E|0)==8){E=0;c[a>>2]=2;c[e>>2]=v;g[f>>2]=D;F=D}G=v+1|0;if((G|0)<(k|0)){u=F;v=G}else{E=10;break}}if((E|0)==10){i=d;return}c[a>>2]=2;c[e>>2]=v;g[f>>2]=D;i=d;return}function ff(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;var f=0;f=
i;i=i+256|0;df(f,a,b,c,d,e);i=f;return}function gf(b,d,e,f,h){b=b|0;d=d|0;e=e|0;f=f|0;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,S=0,T=0,U=0,V=0,W=0;j=i;i=i+96|0;k=j+92|0;l=j+88|0;m=j;n=j+80|0;o=j+56|0;p=j+32|0;q=j+24|0;r=b+60|0;c[r>>2]=0;s=+g[d+8>>2]+ +g[f+8>>2];c[k>>2]=0;t=+hf(k,d,e,f,h);if(t>s){i=j;return}c[l>>2]=0;u=+hf(l,f,h,d,e);if(u>s){i=j;return}if(u>t+5.000000237487257E-4){t=+g[h>>2];u=
+g[h+4>>2];v=+g[h+8>>2];w=+g[h+12>>2];x=+g[e>>2];y=+g[e+4>>2];z=+g[e+8>>2];A=+g[e+12>>2];B=c[l>>2]|0;c[b+56>>2]=2;C=t;D=u;E=w;F=v;G=A;H=z;I=x;J=y;K=B;L=1;M=f;N=d}else{y=+g[e>>2];x=+g[e+4>>2];z=+g[e+8>>2];A=+g[e+12>>2];v=+g[h>>2];w=+g[h+4>>2];u=+g[h+8>>2];t=+g[h+12>>2];h=c[k>>2]|0;c[b+56>>2]=1;C=y;D=x;E=A;F=z;G=t;H=u;I=v;J=w;K=h;L=0;M=d;N=f}f=c[N+148>>2]|0;w=+g[M+(K<<3)+84>>2];v=+g[M+(K<<3)+88>>2];u=E*w-F*v;t=F*w+E*v;v=G*u+H*t;w=G*t-H*u;if((f|0)>0){d=0;h=0;u=3.4028234663852886E38;while(1){t=v*+g[N+
(d<<3)+84>>2]+w*+g[N+(d<<3)+88>>2];k=t<u;e=k?d:h;d=d+1|0;if((d|0)==(f|0)){O=e;break}else{h=e;u=k?t:u}}}else O=0;h=O+1|0;d=(h|0)<(f|0)?h:0;u=+g[N+(O<<3)+20>>2];w=+g[N+(O<<3)+24>>2];v=+(I+(G*u-H*w));t=+(J+(H*u+G*w));h=m;g[h>>2]=v;g[h+4>>2]=t;h=K&255;f=m+8|0;a[f>>0]=h;a[f+1>>0]=O;a[f+2>>0]=1;a[f+3>>0]=0;t=+g[N+(d<<3)+20>>2];v=+g[N+(d<<3)+24>>2];w=+(I+(G*t-H*v));u=+(J+(H*t+G*v));N=m+12|0;g[N>>2]=w;g[N+4>>2]=u;N=m+20|0;a[N>>0]=h;a[N+1>>0]=d;a[N+2>>0]=1;a[N+3>>0]=0;N=K+1|0;d=(N|0)<(c[M+148>>2]|0)?N:0;N=
M+(K<<3)+20|0;u=+g[N>>2];w=+g[N+4>>2];N=M+(d<<3)+20|0;v=+g[N>>2];t=+g[N+4>>2];z=v-u;A=t-w;x=+Q(+(z*z+A*A));if(x<1.1920928955078125E-7){P=z;R=A}else{y=1/x;P=z*y;R=A*y}y=E*P-F*R;A=E*R+F*P;g[n>>2]=y;g[n+4>>2]=A;z=-y;x=C+(E*u-F*w);S=D+(F*u+E*w);T=x*A+S*z;g[q>>2]=z;g[q+4>>2]=-A;if((kf(o,m,q,s-(x*y+S*A),K)|0)<2){i=j;return}if((kf(p,o,n,s+((C+(E*v-F*t))*y+(D+(F*v+E*t))*A),d)|0)<2){i=j;return}E=+R;R=+-P;d=b+40|0;g[d>>2]=E;g[d+4>>2]=R;R=+((u+v)*.5);v=+((w+t)*.5);d=b+48|0;g[d>>2]=R;g[d+4>>2]=v;v=+g[p>>2];R=
+g[p+4>>2];d=!(A*v+R*z-T<=s);if(L<<24>>24==0){if(d)U=0;else{t=v-I;w=R-J;u=+(G*t+H*w);E=+(G*w-H*t);L=b;g[L>>2]=u;g[L+4>>2]=E;c[b+16>>2]=c[p+8>>2];U=1}E=+g[p+12>>2];u=+g[p+16>>2];if(!(A*E+u*z-T<=s))V=U;else{t=E-I;E=u-J;u=+(G*t+H*E);w=+(G*E-H*t);L=b+(U*20|0)|0;g[L>>2]=u;g[L+4>>2]=w;c[b+(U*20|0)+16>>2]=c[p+20>>2];V=U+1|0}}else{if(d)W=0;else{w=v-I;v=R-J;R=+(G*w+H*v);u=+(G*v-H*w);d=b;g[d>>2]=R;g[d+4>>2]=u;d=b+16|0;U=c[p+8>>2]|0;c[d>>2]=U;a[d>>0]=U>>>8;a[d+1>>0]=U;a[d+2>>0]=U>>>24;a[d+3>>0]=U>>>16;W=1}u=
+g[p+12>>2];R=+g[p+16>>2];if(!(A*u+R*z-T<=s))V=W;else{s=u-I;I=R-J;J=+(G*s+H*I);R=+(G*I-H*s);U=b+(W*20|0)|0;g[U>>2]=J;g[U+4>>2]=R;U=b+(W*20|0)+16|0;b=c[p+20>>2]|0;c[U>>2]=b;a[U>>0]=b>>>8;a[U+1>>0]=b;a[U+2>>0]=b>>>24;a[U+3>>0]=b>>>16;V=W+1|0}}c[r>>2]=V;i=j;return}function hf(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0;h=i;j=c[b+148>>2]|0;k=c[e+148>>2]|0;l=+g[f+12>>2];m=+g[d+8>>2];n=+g[f+8>>2];o=+g[d+12>>2];p=l*m-n*o;q=
m*n+l*o;o=+g[d>>2]-+g[f>>2];m=+g[d+4>>2]-+g[f+4>>2];r=l*o+n*m;s=l*m-n*o;if((j|0)<=0){t=0;u=-3.4028234663852886E38;c[a>>2]=t;i=h;return+u}if((k|0)>0){v=0;w=0;x=-3.4028234663852886E38}else{f=0;d=0;o=-3.4028234663852886E38;while(1){y=o<3.4028234663852886E38;n=y?3.4028234663852886E38:o;z=y?d:f;d=d+1|0;if((d|0)==(j|0)){t=z;u=n;break}else{f=z;o=n}}c[a>>2]=t;i=h;return+u}while(1){o=+g[b+(w<<3)+84>>2];n=+g[b+(w<<3)+88>>2];m=q*o-p*n;l=p*o+q*n;n=+g[b+(w<<3)+20>>2];o=+g[b+(w<<3)+24>>2];A=r+(q*n-p*o);B=s+(p*
n+q*o);f=0;o=3.4028234663852886E38;do{n=m*(+g[e+(f<<3)+20>>2]-A)+l*(+g[e+(f<<3)+24>>2]-B);o=n<o?n:o;f=f+1|0}while((f|0)!=(k|0));f=o>x;B=f?o:x;d=f?w:v;w=w+1|0;if((w|0)==(j|0)){t=d;u=B;break}else{v=d;x=B}}c[a>>2]=t;i=h;return+u}function jf(a,b,d,e,f,h){a=a|0;b=b|0;d=d|0;e=+e;f=f|0;h=+h;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0;j=i;k=b+60|0;if((c[k>>2]|0)==0){i=j;return}l=c[b+56>>2]|0;if((l|0)==2){m=f+12|0;n=+g[m>>2];o=+g[b+40>>2];p=f+8|0;
q=+g[p>>2];r=+g[b+44>>2];s=n*o-q*r;t=o*q+n*r;r=+s;n=+t;u=a;g[u>>2]=r;g[u+4>>2]=n;n=+g[m>>2];r=+g[b+48>>2];q=+g[p>>2];o=+g[b+52>>2];v=+g[f>>2]+(n*r-q*o);w=r*q+n*o+ +g[f+4>>2];if((c[k>>2]|0)>0){p=d+12|0;m=d+8|0;u=d+4|0;x=a+4|0;o=s;n=t;y=0;while(1){q=+g[p>>2];r=+g[b+(y*20|0)>>2];z=+g[m>>2];A=+g[b+(y*20|0)+4>>2];B=+g[d>>2]+(q*r-z*A);C=r*z+q*A+ +g[u>>2];A=h-(o*(B-v)+(C-w)*n);q=B+o*A;z=C+n*A;A=B-o*e;B=C-n*e;C=+((A+q)*.5);r=+((B+z)*.5);D=a+(y<<3)+8|0;g[D>>2]=C;g[D+4>>2]=r;g[a+(y<<2)+24>>2]=+g[a>>2]*(A-q)+
+g[x>>2]*(B-z);y=y+1|0;z=+g[a>>2];B=+g[x>>2];if((y|0)>=(c[k>>2]|0)){E=z;F=B;break}else{o=z;n=B}}}else{E=s;F=t}t=+-E;E=+-F;y=a;g[y>>2]=t;g[y+4>>2]=E;i=j;return}else if((l|0)==0){g[a>>2]=1;y=a+4|0;g[y>>2]=0;E=+g[d+12>>2];t=+g[b+48>>2];F=+g[d+8>>2];s=+g[b+52>>2];n=+g[d>>2]+(E*t-F*s);o=t*F+E*s+ +g[d+4>>2];s=+g[f+12>>2];E=+g[b>>2];F=+g[f+8>>2];t=+g[b+4>>2];w=+g[f>>2]+(s*E-F*t);v=E*F+s*t+ +g[f+4>>2];t=n-w;s=o-v;if(t*t+s*s>1.4210854715202004E-14){s=w-n;t=v-o;F=+s;E=+t;x=a;g[x>>2]=F;g[x+4>>2]=E;E=+Q(+(s*
s+t*t));if(E<1.1920928955078125E-7){G=s;H=t}else{F=1/E;E=s*F;g[a>>2]=E;s=t*F;g[y>>2]=s;G=E;H=s}}else{G=1;H=0}s=n+G*e;n=o+H*e;o=w-G*h;w=v-H*h;v=+((s+o)*.5);E=+((n+w)*.5);y=a+8|0;g[y>>2]=v;g[y+4>>2]=E;g[a+24>>2]=G*(o-s)+H*(w-n);i=j;return}else if((l|0)==1){l=d+12|0;n=+g[l>>2];w=+g[b+40>>2];y=d+8|0;H=+g[y>>2];s=+g[b+44>>2];o=n*w-H*s;G=w*H+n*s;s=+o;n=+G;x=a;g[x>>2]=s;g[x+4>>2]=n;n=+g[l>>2];s=+g[b+48>>2];H=+g[y>>2];w=+g[b+52>>2];E=+g[d>>2]+(n*s-H*w);v=s*H+n*w+ +g[d+4>>2];if((c[k>>2]|0)<=0){i=j;return}d=
f+12|0;y=f+8|0;l=f+4|0;x=a+4|0;w=o;o=G;u=0;while(1){G=+g[d>>2];n=+g[b+(u*20|0)>>2];H=+g[y>>2];s=+g[b+(u*20|0)+4>>2];F=+g[f>>2]+(G*n-H*s);t=n*H+G*s+ +g[l>>2];s=e-(w*(F-E)+(t-v)*o);G=F+w*s;H=t+o*s;s=F-w*h;F=t-o*h;t=+((s+G)*.5);n=+((F+H)*.5);m=a+(u<<3)+8|0;g[m>>2]=t;g[m+4>>2]=n;g[a+(u<<2)+24>>2]=+g[a>>2]*(s-G)+ +g[x>>2]*(F-H);m=u+1|0;if((m|0)>=(c[k>>2]|0))break;w=+g[a>>2];o=+g[x>>2];u=m}i=j;return}else{i=j;return}}function kf(b,d,e,f,h){b=b|0;d=d|0;e=e|0;f=+f;h=h|0;var j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=
0,r=0,s=0,t=0,u=0;j=i;k=+g[e>>2];l=+g[e+4>>2];e=d+4|0;m=k*+g[d>>2]+l*+g[e>>2]-f;n=d+12|0;o=d+16|0;p=k*+g[n>>2]+l*+g[o>>2]-f;if(!(m<=0))q=0;else{c[b+0>>2]=c[d+0>>2];c[b+4>>2]=c[d+4>>2];c[b+8>>2]=c[d+8>>2];q=1}if(!(p<=0))r=q;else{s=q+1|0;t=b+(q*12|0)|0;c[t+0>>2]=c[n+0>>2];c[t+4>>2]=c[n+4>>2];c[t+8>>2]=c[n+8>>2];r=s}if(!(m*p<0)){u=r;i=j;return u|0}f=m/(m-p);p=+g[d>>2];m=+g[e>>2];l=+(p+f*(+g[n>>2]-p));p=+(m+f*(+g[o>>2]-m));o=b+(r*12|0)|0;g[o>>2]=l;g[o+4>>2]=p;o=b+(r*12|0)+8|0;a[o>>0]=h;a[o+1>>0]=a[d+
9>>0]|0;a[o+2>>0]=0;a[o+3>>0]=1;u=r+1|0;i=j;return u|0}function lf(d,e,f,h,j,k){d=d|0;e=e|0;f=f|0;h=h|0;j=j|0;k=k|0;var l=0,m=0,n=0,o=0;l=i;i=i+128|0;m=l+36|0;n=l+24|0;o=l;c[m+16>>2]=0;c[m+20>>2]=0;g[m+24>>2]=0;c[m+44>>2]=0;c[m+48>>2]=0;g[m+52>>2]=0;be(m,d,e);be(m+28|0,f,h);h=m+56|0;c[h+0>>2]=c[j+0>>2];c[h+4>>2]=c[j+4>>2];c[h+8>>2]=c[j+8>>2];c[h+12>>2]=c[j+12>>2];j=m+72|0;c[j+0>>2]=c[k+0>>2];c[j+4>>2]=c[k+4>>2];c[j+8>>2]=c[k+8>>2];c[j+12>>2]=c[k+12>>2];a[m+88>>0]=1;b[n+4>>1]=0;de(o,n,m);i=l;return+g[o+
16>>2]<1.1920928955078125E-6|0}function mf(a,b,d,e,f,g){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0;h=i;j=a+40|0;c[j>>2]=b;c[a+44>>2]=d;c[a+48>>2]=e;c[a+28>>2]=0;c[a+36>>2]=0;c[a+32>>2]=0;c[a>>2]=f;c[a+4>>2]=g;c[a+8>>2]=Ym(f,b<<2)|0;c[a+12>>2]=Ym(c[a>>2]|0,d<<2)|0;c[a+16>>2]=Ym(c[a>>2]|0,e<<2)|0;c[a+24>>2]=Ym(c[a>>2]|0,(c[j>>2]|0)*12|0)|0;c[a+20>>2]=Ym(c[a>>2]|0,(c[j>>2]|0)*12|0)|0;i=h;return}function nf(a){a=a|0;var b=0;b=i;_m(c[a>>2]|0,c[a+20>>2]|0);_m(c[a>>2]|0,c[a+24>>2]|0);_m(c[a>>2]|0,c[a+
16>>2]|0);_m(c[a>>2]|0,c[a+12>>2]|0);_m(c[a>>2]|0,c[a+8>>2]|0);i=b;return}function of(d,e,f,h,j){d=d|0;e=e|0;f=f|0;h=h|0;j=j|0;var l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,R=0,U=0,V=0,W=0,X=0,Y=0;l=i;i=i+176|0;m=l+148|0;n=l;o=l+112|0;p=l+64|0;q=l+8|0;Km(n);r=+g[f>>2];s=d+28|0;if((c[s>>2]|0)>0){t=d+8|0;u=h+4|0;v=d+20|0;w=d+24|0;x=0;do{y=c[(c[t>>2]|0)+(x<<2)>>2]|0;z=y+60|0;A=c[z>>2]|0;B=c[z+4>>2]|0;C=+g[y+72>>2];z=y+
80|0;D=+g[z>>2];E=+g[z+4>>2];F=+g[y+88>>2];z=y+52|0;c[z>>2]=A;c[z+4>>2]=B;g[y+68>>2]=C;if((c[y>>2]|0)==2){G=+g[y+156>>2];H=+g[y+136>>2];I=1/(r*+g[y+148>>2]+1);J=(D+r*(G*+g[h>>2]+H*+g[y+92>>2]))*I;K=(E+r*(G*+g[u>>2]+H*+g[y+96>>2]))*I;L=(F+r*+g[y+144>>2]*+g[y+100>>2])*(1/(r*+g[y+152>>2]+1))}else{J=D;K=E;L=F}y=(c[v>>2]|0)+(x*12|0)|0;c[y>>2]=A;c[y+4>>2]=B;g[(c[v>>2]|0)+(x*12|0)+8>>2]=C;C=+J;F=+K;B=(c[w>>2]|0)+(x*12|0)|0;g[B>>2]=C;g[B+4>>2]=F;g[(c[w>>2]|0)+(x*12|0)+8>>2]=L;x=x+1|0}while((x|0)<(c[s>>2]|
0));M=w;N=v}else{M=d+24|0;N=d+20|0}c[o+0>>2]=c[f+0>>2];c[o+4>>2]=c[f+4>>2];c[o+8>>2]=c[f+8>>2];c[o+12>>2]=c[f+12>>2];c[o+16>>2]=c[f+16>>2];c[o+20>>2]=c[f+20>>2];c[o+24>>2]=c[f+24>>2];v=c[N>>2]|0;c[o+28>>2]=v;w=c[M>>2]|0;c[o+32>>2]=w;c[p+0>>2]=c[f+0>>2];c[p+4>>2]=c[f+4>>2];c[p+8>>2]=c[f+8>>2];c[p+12>>2]=c[f+12>>2];c[p+16>>2]=c[f+16>>2];c[p+20>>2]=c[f+20>>2];c[p+24>>2]=c[f+24>>2];x=d+12|0;c[p+28>>2]=c[x>>2];u=d+36|0;c[p+32>>2]=c[u>>2];c[p+36>>2]=v;c[p+40>>2]=w;c[p+44>>2]=c[d>>2];Ki(q,p);Mi(q);if((a[f+
24>>0]|0)!=0)Ni(q);p=d+32|0;if((c[p>>2]|0)>0){w=d+16|0;v=0;do{h=c[(c[w>>2]|0)+(v<<2)>>2]|0;gb[c[(c[h>>2]|0)+32>>2]&63](h,o);v=v+1|0}while((v|0)<(c[p>>2]|0))}g[e+12>>2]=+Mm(n);v=f+12|0;if((c[v>>2]|0)>0){w=d+16|0;h=0;do{if((c[p>>2]|0)>0){t=0;do{B=c[(c[w>>2]|0)+(t<<2)>>2]|0;gb[c[(c[B>>2]|0)+36>>2]&63](B,o);t=t+1|0}while((t|0)<(c[p>>2]|0))}Oi(q);h=h+1|0}while((h|0)<(c[v>>2]|0))}Pi(q);g[e+16>>2]=+Mm(n);if((c[s>>2]|0)>0){v=c[M>>2]|0;h=0;do{w=c[N>>2]|0;t=w+(h*12|0)|0;B=t;L=+g[B>>2];K=+g[B+4>>2];J=+g[w+(h*
12|0)+8>>2];w=v+(h*12|0)|0;F=+g[w>>2];C=+g[w+4>>2];E=+g[v+(h*12|0)+8>>2];D=r*F;I=r*C;H=D*D+I*I;if(H>4){I=2/+Q(+H);O=F*I;P=C*I}else{O=F;P=C}C=r*E;if(C*C>2.4674012660980225){if(C>0)R=C;else R=-C;U=E*(1.5707963705062866/R)}else U=E;E=+(L+r*O);L=+(K+r*P);w=t;g[w>>2]=E;g[w+4>>2]=L;g[(c[N>>2]|0)+(h*12|0)+8>>2]=J+r*U;J=+O;L=+P;w=(c[M>>2]|0)+(h*12|0)|0;g[w>>2]=J;g[w+4>>2]=L;v=c[M>>2]|0;g[v+(h*12|0)+8>>2]=U;h=h+1|0}while((h|0)<(c[s>>2]|0))}h=f+16|0;a:do if((c[h>>2]|0)>0){f=d+16|0;v=0;while(1){w=Qi(q)|0;if((c[p>>
2]|0)>0){t=0;B=1;while(1){y=c[(c[f>>2]|0)+(t<<2)>>2]|0;A=B&(nb[c[(c[y>>2]|0)+40>>2]&31](y,o)|0);t=t+1|0;if((t|0)>=(c[p>>2]|0)){V=A;break}else B=A}}else V=1;v=v+1|0;if(w&V){W=0;break a}if((v|0)>=(c[h>>2]|0)){W=1;break}}}else W=1;while(0);if((c[s>>2]|0)>0){h=d+8|0;V=0;do{p=c[(c[h>>2]|0)+(V<<2)>>2]|0;o=(c[N>>2]|0)+(V*12|0)|0;v=c[o>>2]|0;f=c[o+4>>2]|0;o=p+60|0;c[o>>2]=v;c[o+4>>2]=f;U=+g[(c[N>>2]|0)+(V*12|0)+8>>2];g[p+72>>2]=U;o=(c[M>>2]|0)+(V*12|0)|0;B=c[o+4>>2]|0;t=p+80|0;c[t>>2]=c[o>>2];c[t+4>>2]=B;
g[p+88>>2]=+g[(c[M>>2]|0)+(V*12|0)+8>>2];P=+T(+U);g[p+20>>2]=P;O=+S(+U);g[p+24>>2]=O;U=+g[p+44>>2];R=+g[p+48>>2];L=(c[k>>2]=v,+g[k>>2])-(O*U-P*R);J=(c[k>>2]=f,+g[k>>2])-(P*U+O*R);R=+L;L=+J;f=p+12|0;g[f>>2]=R;g[f+4>>2]=L;V=V+1|0}while((V|0)<(c[s>>2]|0))}g[e+20>>2]=+Mm(n);n=c[q+44>>2]|0;e=d+4|0;if((c[e>>2]|0)!=0?(c[u>>2]|0)>0:0){V=m+16|0;M=0;do{N=c[(c[x>>2]|0)+(M<<2)>>2]|0;h=c[n+(M*156|0)+148>>2]|0;c[V>>2]=h;if((h|0)>0){f=0;do{g[m+(f<<2)>>2]=+g[n+(M*156|0)+(f*36|0)+16>>2];g[m+(f<<2)+8>>2]=+g[n+(M*156|
0)+(f*36|0)+20>>2];f=f+1|0}while((f|0)!=(h|0))}h=c[e>>2]|0;ib[c[(c[h>>2]|0)+36>>2]&7](h,N,m);M=M+1|0}while((M|0)<(c[u>>2]|0))}if(!j){Li(q);i=l;return}j=c[s>>2]|0;u=(j|0)>0;if(u){M=c[d+8>>2]|0;m=0;L=3.4028234663852886E38;while(1){e=c[M+(m<<2)>>2]|0;do if((c[e>>2]|0)==0)X=L;else{if((!((b[e+4>>1]&4)==0)?(R=+g[e+88>>2],!(R*R>.001218469929881394)):0)?(R=+g[e+80>>2],J=+g[e+84>>2],!(R*R+J*J>9.999999747378752E-5)):0){n=e+160|0;J=r+ +g[n>>2];g[n>>2]=J;X=L<J?L:J;break}g[e+160>>2]=0;X=0}while(0);m=m+1|0;if((m|
0)>=(j|0)){Y=X;break}else L=X}}else Y=3.4028234663852886E38;if(!(Y>=.5)|W|u^1){Li(q);i=l;return}u=d+8|0;d=0;do{W=c[(c[u>>2]|0)+(d<<2)>>2]|0;j=W+4|0;b[j>>1]=b[j>>1]&65533;g[W+160>>2]=0;j=W+80|0;c[j+0>>2]=0;c[j+4>>2]=0;c[j+8>>2]=0;c[j+12>>2]=0;c[j+16>>2]=0;c[j+20>>2]=0;d=d+1|0}while((d|0)<(c[s>>2]|0));Li(q);i=l;return}function pf(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0;f=i;i=i+128|0;h=f+
104|0;j=f+56|0;k=f;l=a+28|0;if((c[l>>2]|0)>0){m=a+8|0;n=a+20|0;o=a+24|0;p=0;do{q=c[(c[m>>2]|0)+(p<<2)>>2]|0;r=q+60|0;s=c[r+4>>2]|0;t=(c[n>>2]|0)+(p*12|0)|0;c[t>>2]=c[r>>2];c[t+4>>2]=s;g[(c[n>>2]|0)+(p*12|0)+8>>2]=+g[q+72>>2];s=q+80|0;t=c[s+4>>2]|0;r=(c[o>>2]|0)+(p*12|0)|0;c[r>>2]=c[s>>2];c[r+4>>2]=t;t=c[o>>2]|0;g[t+(p*12|0)+8>>2]=+g[q+88>>2];p=p+1|0}while((p|0)<(c[l>>2]|0));u=n;v=t}else{u=a+20|0;v=c[a+24>>2]|0}n=a+12|0;c[j+28>>2]=c[n>>2];p=a+36|0;c[j+32>>2]=c[p>>2];c[j+44>>2]=c[a>>2];c[j+0>>2]=c[b+
0>>2];c[j+4>>2]=c[b+4>>2];c[j+8>>2]=c[b+8>>2];c[j+12>>2]=c[b+12>>2];c[j+16>>2]=c[b+16>>2];c[j+20>>2]=c[b+20>>2];c[j+24>>2]=c[b+24>>2];c[j+36>>2]=c[u>>2];o=a+24|0;c[j+40>>2]=v;Ki(k,j);j=b+16|0;a:do if((c[j>>2]|0)>0){v=0;do{v=v+1|0;if(Si(k,d,e)|0)break a}while((v|0)<(c[j>>2]|0))}while(0);j=a+8|0;v=(c[u>>2]|0)+(d*12|0)|0;m=c[v+4>>2]|0;t=(c[(c[j>>2]|0)+(d<<2)>>2]|0)+52|0;c[t>>2]=c[v>>2];c[t+4>>2]=m;m=c[u>>2]|0;t=c[j>>2]|0;g[(c[t+(d<<2)>>2]|0)+68>>2]=+g[m+(d*12|0)+8>>2];d=m+(e*12|0)|0;m=c[d+4>>2]|0;v=
(c[t+(e<<2)>>2]|0)+52|0;c[v>>2]=c[d>>2];c[v+4>>2]=m;g[(c[(c[j>>2]|0)+(e<<2)>>2]|0)+68>>2]=+g[(c[u>>2]|0)+(e*12|0)+8>>2];Mi(k);e=b+12|0;if((c[e>>2]|0)>0){m=0;do{Oi(k);m=m+1|0}while((m|0)<(c[e>>2]|0))}w=+g[b>>2];if((c[l>>2]|0)>0){b=0;do{e=c[u>>2]|0;m=e+(b*12|0)|0;v=m;x=+g[v>>2];y=+g[v+4>>2];z=+g[e+(b*12|0)+8>>2];e=c[o>>2]|0;v=e+(b*12|0)|0;A=+g[v>>2];B=+g[v+4>>2];C=+g[e+(b*12|0)+8>>2];D=w*A;E=w*B;F=D*D+E*E;if(F>4){E=2/+Q(+F);G=A*E;H=B*E}else{G=A;H=B}B=w*C;if(B*B>2.4674012660980225){if(B>0)I=B;else I=
-B;J=C*(1.5707963705062866/I)}else J=C;C=x+w*G;x=y+w*H;y=z+w*J;z=+C;B=+x;e=m;g[e>>2]=z;g[e+4>>2]=B;g[(c[u>>2]|0)+(b*12|0)+8>>2]=y;A=+G;E=+H;e=(c[o>>2]|0)+(b*12|0)|0;g[e>>2]=A;g[e+4>>2]=E;g[(c[o>>2]|0)+(b*12|0)+8>>2]=J;e=c[(c[j>>2]|0)+(b<<2)>>2]|0;m=e+60|0;g[m>>2]=z;g[m+4>>2]=B;g[e+72>>2]=y;m=e+80|0;g[m>>2]=A;g[m+4>>2]=E;g[e+88>>2]=J;E=+T(+y);g[e+20>>2]=E;A=+S(+y);g[e+24>>2]=A;y=+g[e+44>>2];B=+g[e+48>>2];z=+(C-(A*y-E*B));C=+(x-(E*y+A*B));m=e+12|0;g[m>>2]=z;g[m+4>>2]=C;b=b+1|0}while((b|0)<(c[l>>2]|
0))}l=c[k+44>>2]|0;b=a+4|0;if((c[b>>2]|0)==0){Li(k);i=f;return}if((c[p>>2]|0)<=0){Li(k);i=f;return}a=h+16|0;j=0;do{o=c[(c[n>>2]|0)+(j<<2)>>2]|0;u=c[l+(j*156|0)+148>>2]|0;c[a>>2]=u;if((u|0)>0){m=0;do{g[h+(m<<2)>>2]=+g[l+(j*156|0)+(m*36|0)+16>>2];g[h+(m<<2)+8>>2]=+g[l+(j*156|0)+(m*36|0)+20>>2];m=m+1|0}while((m|0)!=(u|0))}u=c[b>>2]|0;ib[c[(c[u>>2]|0)+36>>2]&7](u,o,h);j=j+1|0}while((j|0)<(c[p>>2]|0));Li(k);i=f;return}function qf(a,c,d){a=a|0;c=c|0;d=d|0;var e=0,f=0;a=i;e=b[c+36>>1]|0;if(!(e<<16>>16==
0?1:e<<16>>16!=(b[d+36>>1]|0))){f=e<<16>>16>0;i=a;return f|0}if((b[d+32>>1]&b[c+34>>1])<<16>>16==0){f=0;i=a;return f|0}f=(b[d+34>>1]&b[c+32>>1])<<16>>16!=0;i=a;return f|0}function rf(a){a=a|0;return}function sf(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function tf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return 1}function uf(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return 1}function vf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0;d=i;vh(a,b);c[a>>2]=904;e=b+20|0;f=c[e>>2]|0;h=c[e+4>>2]|0;e=a+76|0;c[e>>
2]=f;c[e+4>>2]=h;e=c[a+52>>2]|0;j=(c[k>>2]=f,+g[k>>2])-+g[e+12>>2];l=(c[k>>2]=h,+g[k>>2])-+g[e+16>>2];m=+g[e+24>>2];n=+g[e+20>>2];o=+(j*m+l*n);p=+(m*l-j*n);e=a+68|0;g[e>>2]=o;g[e+4>>2]=p;g[a+104>>2]=+g[b+28>>2];g[a+96>>2]=0;g[a+100>>2]=0;g[a+84>>2]=+g[b+32>>2];g[a+88>>2]=+g[b+36>>2];g[a+92>>2]=0;g[a+108>>2]=0;i=d;return}function wf(a,d){a=a|0;d=d|0;var e=0,f=0,h=0,j=0,k=0;e=i;f=c[a+52>>2]|0;h=f+4|0;j=b[h>>1]|0;if((j&2)==0?(k=j&65535,(k&2|0)==0):0){b[h>>1]=k|2;g[f+160>>2]=0}f=d;d=c[f+4>>2]|0;k=a+76|
0;c[k>>2]=c[f>>2];c[k+4>>2]=d;i=e;return}function xf(b,d){b=b|0;d=d|0;var e=0,f=0,h=0,j=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,U=0,V=0;e=i;f=c[b+52>>2]|0;h=c[f+8>>2]|0;j=b+116|0;c[j>>2]=h;l=f+44|0;m=c[l>>2]|0;n=c[l+4>>2]|0;l=b+128|0;c[l>>2]=m;c[l+4>>2]=n;o=+g[f+136>>2];g[b+136>>2]=o;p=+g[f+144>>2];g[b+140>>2]=p;l=c[d+28>>2]|0;q=l+(h*12|0)|0;r=+g[q>>2];s=+g[q+4>>2];t=+g[l+(h*12|0)+8>>2];l=d+32|0;q=c[l>>2]|
0;u=q+(h*12|0)|0;v=+g[u>>2];w=+g[u+4>>2];x=+g[q+(h*12|0)+8>>2];y=+T(+t);z=+S(+t);t=+g[f+132>>2];A=+g[b+84>>2]*6.2831854820251465;B=+g[d>>2];C=B*t*A*A;D=B*(A*t*2*+g[b+88>>2]+C);t=(c[k>>2]=m,+g[k>>2]);A=(c[k>>2]=n,+g[k>>2]);if(D!=0)E=1/D;else E=D;g[b+108>>2]=E;D=C*E;g[b+92>>2]=D;C=+g[b+68>>2]-t;t=+g[b+72>>2]-A;A=z*C-y*t;B=y*C+z*t;t=+A;z=+B;n=b+120|0;g[n>>2]=t;g[n+4>>2]=z;z=E+(o+B*p*B);t=p*A;C=B*t;y=E+(o+A*t);t=z*y-C*C;if(t!=0)F=1/t;else F=t;t=C*F;g[b+144>>2]=y*F;g[b+148>>2]=t;g[b+152>>2]=t;g[b+156>>
2]=z*F;n=b+160|0;F=r+A-+g[b+76>>2];r=s+B-+g[b+80>>2];s=+F;z=+r;m=n;g[m>>2]=s;g[m+4>>2]=z;g[n>>2]=D*F;g[b+164>>2]=D*r;r=x*.9800000190734863;n=b+96|0;if((a[d+24>>0]|0)==0){g[n>>2]=0;g[b+100>>2]=0;G=v;H=w;I=r;J=c[l>>2]|0;K=J+(h*12|0)|0;L=+G;M=+H;N=K;O=N;g[O>>2]=L;P=N+4|0;Q=P;g[Q>>2]=M;R=c[j>>2]|0;U=c[l>>2]|0;V=U+(R*12|0)+8|0;g[V>>2]=I;i=e;return}else{x=+g[d+8>>2];D=x*+g[n>>2];g[n>>2]=D;n=b+100|0;F=x*+g[n>>2];g[n>>2]=F;G=v+o*D;H=w+F*o;I=r+p*(F*A-D*B);J=c[l>>2]|0;K=J+(h*12|0)|0;L=+G;M=+H;N=K;O=N;g[O>>
2]=L;P=N+4|0;Q=P;g[Q>>2]=M;R=c[j>>2]|0;U=c[l>>2]|0;V=U+(R*12|0)+8|0;g[V>>2]=I;i=e;return}}function yf(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0;d=i;e=a+116|0;f=c[e>>2]|0;h=b+32|0;j=c[h>>2]|0;k=j+(f*12|0)|0;l=k;m=+g[l>>2];n=+g[l+4>>2];o=+g[j+(f*12|0)+8>>2];p=+g[a+124>>2];q=+g[a+120>>2];r=+g[a+108>>2];f=a+96|0;s=+g[f>>2];j=a+100|0;t=+g[j>>2];u=-(m-o*p+ +g[a+160>>2]+r*s);v=-(n+o*q+ +g[a+164>>2]+r*t);r=+g[a+148>>2]*u+ +g[a+156>>2]*v;l=
f;w=+g[l>>2];x=+g[l+4>>2];y=s+(+g[a+144>>2]*u+ +g[a+152>>2]*v);g[f>>2]=y;v=r+t;g[j>>2]=v;t=+g[b>>2]*+g[a+104>>2];r=v*v+y*y;if(r>t*t){u=t/+Q(+r);r=y*u;g[f>>2]=r;t=u*v;g[j>>2]=t;z=r;A=t}else{z=y;A=v}v=z-w;w=A-x;x=+g[a+136>>2];A=o+ +g[a+140>>2]*(w*q-v*p);p=+(m+v*x);v=+(n+w*x);a=k;g[a>>2]=p;g[a+4>>2]=v;g[(c[h>>2]|0)+((c[e>>2]|0)*12|0)+8>>2]=A;i=d;return}function zf(a,b){a=a|0;b=b|0;return 1}function Af(a,b){a=a|0;b=b|0;var d=0,e=0;d=b+76|0;b=c[d+4>>2]|0;e=a;c[e>>2]=c[d>>2];c[e+4>>2]=b;return}function Bf(a,
b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,i=0,j=0;d=c[b+52>>2]|0;e=+g[d+24>>2];f=+g[b+68>>2];h=+g[d+20>>2];i=+g[b+72>>2];j=f*h+e*i+ +g[d+16>>2];g[a>>2]=+g[d+12>>2]+(e*f-h*i);g[a+4>>2]=j;return}function Cf(a,b,c){a=a|0;b=b|0;c=+c;var d=0;d=+g[b+100>>2]*c;g[a>>2]=+g[b+96>>2]*c;g[a+4>>2]=d;return}function Df(a,b){a=a|0;b=+b;return+(b*0)}function Ef(a,b){a=a|0;b=b|0;var c=0;c=a+76|0;g[c>>2]=+g[c>>2]-+g[b>>2];c=a+80|0;g[c>>2]=+g[c>>2]-+g[b+4>>2];return}function Ff(a){a=a|0;a=i;i=i+16|0;Rm(1008,a);i=a;return}
function Gf(a){a=a|0;return}function Hf(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function If(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,h=0,j=0,k=0,l=0,m=0,n=0;e=i;c[a+8>>2]=b;c[a+12>>2]=d;f=d+12|0;h=+g[f>>2];j=h-+g[b+12>>2];h=+g[f+4>>2]-+g[b+16>>2];k=+g[b+24>>2];l=+g[b+20>>2];m=+(j*k+h*l);n=+(k*h-j*l);f=a+20|0;g[f>>2]=m;g[f+4>>2]=n;g[a+28>>2]=+g[d+72>>2]-+g[b+72>>2];i=e;return}function cm(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,
B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0;f=i;h=a+4|0;j=c[(c[h>>2]|0)+88>>2]|0;k=c[j+(d<<2)>>2]|c[j+(b<<2)>>2]|c[j+(e<<2)>>2];if((k&16|0)==0){i=f;return}j=c[a+8>>2]|0;if(!(lb[c[(c[j>>2]|0)+16>>2]&7](j,b,d,e)|0)){i=f;return}j=c[h>>2]|0;h=c[j+96>>2]|0;a=h+(b<<3)|0;l=+g[a>>2];m=h+(d<<3)|0;n=+g[m>>2];o=l-n;p=h+(b<<3)+4|0;q=+g[p>>2];r=h+(d<<3)+4|0;s=+g[r>>2];t=q-s;u=h+(e<<3)|0;v=+g[u>>2];w=n-v;x=h+(e<<3)+4|0;n=+g[x>>2];y=s-n;s=v-l;l=n-q;q=+g[j+40>>2]*4;if(o*o+t*t>q){i=f;return}if(w*w+y*y>q){i=f;return}if(s*
s+l*l>q){i=f;return}h=c[j+144>>2]|0;z=c[h+(b<<2)>>2]|0;A=c[h+(d<<2)>>2]|0;B=c[h+(e<<2)>>2]|0;h=j+264|0;C=j+268|0;D=c[C>>2]|0;E=j+272|0;F=c[E>>2]|0;if((D|0)>=(F|0)?(G=(F|0)==0?256:F<<1,(F|0)<(G|0)):0){F=j+276|0;j=Em(c[F>>2]|0,G*60|0)|0;H=c[h>>2]|0;if((H|0)!=0){An(j|0,H|0,(c[C>>2]|0)*60|0)|0;Fm(c[F>>2]|0,c[h>>2]|0,(c[E>>2]|0)*60|0)}c[E>>2]=G;c[h>>2]=j;I=c[C>>2]|0}else I=D;c[C>>2]=I+1;C=c[h>>2]|0;c[C+(I*60|0)>>2]=b;c[C+(I*60|0)+4>>2]=d;c[C+(I*60|0)+8>>2]=e;c[C+(I*60|0)+12>>2]=k;if((z|0)==0)J=1;else J=
+g[z+16>>2];if((A|0)==0)K=1;else K=+g[A+16>>2];q=J<K?J:K;if((B|0)==0)L=1;else L=+g[B+16>>2];g[C+(I*60|0)+16>>2]=q<L?q:L;L=+g[a>>2];q=+g[p>>2];K=(L+ +g[m>>2]+ +g[u>>2])*.3333333432674408;J=(q+ +g[r>>2]+ +g[x>>2])*.3333333432674408;n=+(L-K);L=+(q-J);B=C+(I*60|0)+20|0;g[B>>2]=n;g[B+4>>2]=L;L=+(+g[m>>2]-K);n=+(+g[r>>2]-J);B=C+(I*60|0)+28|0;g[B>>2]=L;g[B+4>>2]=n;n=+(+g[u>>2]-K);K=+(+g[x>>2]-J);B=C+(I*60|0)+36|0;g[B>>2]=n;g[B+4>>2]=K;g[C+(I*60|0)+44>>2]=-(o*s+t*l);g[C+(I*60|0)+48>>2]=-(o*w+t*y);g[C+(I*
60|0)+52>>2]=-(w*s+y*l);l=+g[a>>2];y=+g[r>>2];s=+g[p>>2];w=+g[m>>2];t=+g[x>>2];o=+g[u>>2];g[C+(I*60|0)+56>>2]=s*o-l*t+(l*y-s*w+(w*t-y*o));i=f;return}function dm(a){a=a|0;return}function em(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function fm(a,b){a=a|0;b=b|0;return(c[(c[a+4>>2]|0)+(b<<2)>>2]&4096|0)!=0|0}function gm(a,b,c){a=a|0;b=b|0;c=c|0;return 1}function hm(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return 1}function im(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function jm(a,b){a=a|0;b=b|0;return 1}function km(a){a=
a|0;return}function lm(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function mm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0;e=i;f=c[a+4>>2]|0;a=(f|0)<=(b|0);b=(f|0)>(d|0);if(a|b){i=e;return b&a|0}else{i=e;return 1}return 0}function nm(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=i;g=c[a+4>>2]|0;a=(g|0)>(b|0);b=(g|0)>(d|0);if(a|b|(g|0)>(e|0)){i=f;return(g|0)<=(e|0)|a&b^1|0}else{i=f;return 0}return 0}function om(a){a=a|0;return}function pm(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function qm(a,b){a=a|0;b=b|0;return 0}
function rm(a){a=a|0;return 1}function sm(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0;e=i;f=a+16|0;if((c[f>>2]|0)<=0){g=0;i=e;return g|0}h=a+12|0;a=0;while(1){j=c[(c[h>>2]|0)+(a<<2)>>2]|0;a=a+1|0;if(hb[c[(c[j>>2]|0)+16>>2]&15](j,b,d)|0){g=1;k=5;break}if((a|0)>=(c[f>>2]|0)){g=0;k=5;break}}if((k|0)==5){i=e;return g|0}return 0}function tm(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return}function um(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return 0}function vm(a,b,d,e){a=a|0;b=b|0;d=d|
0;e=e|0;var f=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0;e=i;i=i+16|0;f=e;g[b>>2]=3.4028234663852886E38;h=b+4|0;g[h>>2]=3.4028234663852886E38;g[b+8>>2]=-3.4028234663852886E38;j=b+12|0;g[j>>2]=-3.4028234663852886E38;k=a+16|0;if((c[k>>2]|0)<=0){i=e;return}l=a+12|0;a=f+4|0;m=b+8|0;n=f+8|0;o=f+12|0;p=0;do{q=c[(c[l>>2]|0)+(p<<2)>>2]|0;r=bb[c[(c[q>>2]|0)+12>>2]&7](q)|0;if((r|0)>0){q=0;do{s=c[(c[l>>2]|0)+(p<<2)>>2]|0;pb[c[(c[s>>2]|0)+28>>2]&31](s,f,d,q);t=+g[b>>2];u=+g[f>>2];v=+g[h>>
2];w=+g[a>>2];x=+(t<u?t:u);u=+(v<w?v:w);s=b;g[s>>2]=x;g[s+4>>2]=u;u=+g[m>>2];x=+g[n>>2];w=+g[j>>2];v=+g[o>>2];t=+(u>x?u:x);x=+(w>v?w:v);s=m;g[s>>2]=t;g[s+4>>2]=x;q=q+1|0}while((q|0)!=(r|0))}p=p+1|0}while((p|0)<(c[k>>2]|0));i=e;return}function wm(a,b,c){a=a|0;b=b|0;c=+c;return}function xm(a){a=a|0;return}function ym(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function zm(a,b){a=a|0;b=b|0;return 0}function Am(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0;f=i;g=b+4|0;if((c[g>>2]|0)!=(d|0)){h=0;i=f;return h|
0}j=c[b+8>>2]|0;if(!(hb[c[(c[j>>2]|0)+16>>2]&15](j,b+12|0,(c[d+96>>2]|0)+(e<<3)|0)|0)){h=1;i=f;return h|0}d=c[g>>2]|0;Ak(d,e,c[(c[d+88>>2]|0)+(e<<2)>>2]|((a[b+28>>0]|0)!=0?514:2));e=b+32|0;c[e>>2]=(c[e>>2]|0)+1;h=1;i=f;return h|0}function Bm(a,b){a=a|0;b=b|0;var d=0,e=0;d=b+4|0;c[(c[b>>2]|0)+4>>2]=c[d>>2];c[c[d>>2]>>2]=c[b>>2];c[d>>2]=b;c[b>>2]=b;e=a+12|0;c[d>>2]=c[e>>2];c[b>>2]=a+8;c[c[e>>2]>>2]=b;c[e>>2]=b;return}function Cm(b){b=b|0;var d=0,e=0,f=0,g=0,h=0,j=0;d=i;e=b+68|0;c[b+72>>2]=e;c[e>>2]=
e;e=b+8|0;c[e>>2]=128;c[b+4>>2]=0;f=Pm(1024)|0;c[b>>2]=f;xn(f|0,0,c[e>>2]<<3|0)|0;e=b+12|0;b=e+56|0;do{c[e>>2]=0;e=e+4|0}while((e|0)<(b|0));if((a[8776]|0)==0){g=1;h=0}else{i=d;return}while(1){if((g|0)>(c[8072+(h<<2)>>2]|0)){e=h+1|0;a[8128+g>>0]=e;j=e}else{a[8128+g>>0]=h;j=h}g=g+1|0;if((g|0)==641)break;else h=j}a[8776]=1;i=d;return}function Dm(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0;b=i;d=a+4|0;e=c[a>>2]|0;if((c[d>>2]|0)>0){f=e;g=0;while(1){Qm(c[f+(g<<3)+4>>2]|0);g=g+1|0;h=c[a>>2]|0;if((g|0)>=(c[d>>
2]|0)){j=h;break}else f=h}}else j=e;Qm(j);j=a+68|0;Vm(j);e=a+72|0;c[(c[j>>2]|0)+4>>2]=c[e>>2];c[c[e>>2]>>2]=c[j>>2];c[e>>2]=j;c[j>>2]=j;i=b;return}function Em(a,b){a=a|0;b=b|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0;e=i;if((b|0)==0){f=0;i=e;return f|0}if((b|0)>640){f=Tm(a+68|0,b)|0;i=e;return f|0}g=d[8128+b>>0]|0;b=a+(g<<2)+12|0;h=c[b>>2]|0;if((h|0)!=0){c[b>>2]=c[h>>2];f=h;i=e;return f|0}h=a+4|0;j=c[h>>2]|0;k=a+8|0;if((j|0)==(c[k>>2]|0)){l=c[a>>2]|0;m=j+128|0;c[k>>2]=m;k=Pm(m<<3)|0;c[a>>2]=k;
An(k|0,l|0,c[h>>2]<<3|0)|0;xn((c[a>>2]|0)+(c[h>>2]<<3)|0,0,1024)|0;Qm(l);n=c[h>>2]|0}else n=j;j=c[a>>2]|0;a=Pm(16384)|0;l=j+(n<<3)+4|0;c[l>>2]=a;k=c[8072+(g<<2)>>2]|0;c[j+(n<<3)>>2]=k;n=(16384/(k|0)|0)+-1|0;if((n|0)>0){j=a;g=0;while(1){m=g;g=g+1|0;c[j+(aa(m,k)|0)>>2]=j+(aa(g,k)|0);m=c[l>>2]|0;if((g|0)==(n|0)){o=m;break}else j=m}}else o=a;c[o+(aa(n,k)|0)>>2]=0;c[b>>2]=c[c[l>>2]>>2];c[h>>2]=(c[h>>2]|0)+1;f=c[l>>2]|0;i=e;return f|0}function Fm(a,b,e){a=a|0;b=b|0;e=e|0;var f=0,g=0;f=i;if((e|0)==0){i=
f;return}if((e|0)>640){Um(a+68|0,b);i=f;return}else{g=a+((d[8128+e>>0]|0)<<2)+12|0;c[b>>2]=c[g>>2];c[g>>2]=b;i=f;return}}function Gm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0;d=+g[b+16>>2];e=+g[b+32>>2];f=+g[b+20>>2];h=+g[b+28>>2];i=d*e-f*h;j=+g[b+24>>2];k=+g[b+12>>2];l=f*j-e*k;m=h*k-d*j;n=+g[b>>2];o=+g[b+4>>2];p=+g[b+8>>2];q=i*n+o*l+m*p;if(q!=0)r=1/q;else r=q;q=+g[c>>2];s=+g[c+4>>2];t=+g[c+8>>2];g[a>>2]=r*(i*q+s*l+m*t);g[a+4>>2]=r*((s*e-t*h)*n+o*
(t*j-e*q)+(h*q-s*j)*p);g[a+8>>2]=r*((d*t-f*s)*n+o*(f*q-t*k)+(s*k-d*q)*p);return}function Hm(a,b,c){a=a|0;b=b|0;c=c|0;var d=0,e=0,f=0,h=0,i=0,j=0,k=0;d=+g[b>>2];e=+g[b+12>>2];f=+g[b+4>>2];h=+g[b+16>>2];i=d*h-e*f;if(i!=0)j=1/i;else j=i;i=+g[c>>2];k=+g[c+4>>2];g[a>>2]=j*(h*i-e*k);g[a+4>>2]=j*(d*k-f*i);return}function Im(a,b){a=a|0;b=b|0;var d=0,e=0,f=0,h=0,j=0,k=0,l=0;d=i;e=+g[a>>2];f=+g[a+12>>2];h=+g[a+4>>2];j=+g[a+16>>2];k=e*j-f*h;if(k!=0)l=1/k;else l=k;g[b>>2]=j*l;j=-l;g[b+12>>2]=f*j;g[b+8>>2]=0;
g[b+4>>2]=h*j;g[b+16>>2]=e*l;a=b+20|0;c[a+0>>2]=0;c[a+4>>2]=0;c[a+8>>2]=0;c[a+12>>2]=0;i=d;return}function Jm(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0;c=+g[a+16>>2];d=+g[a+32>>2];e=c*d;f=+g[a+20>>2];h=+g[a+28>>2];i=+g[a+24>>2];j=+g[a+12>>2];k=d*j;l=h*j-c*i;m=+g[a>>2];n=(e-f*h)*m+ +g[a+4>>2]*(f*i-k)+l*+g[a+8>>2];if(n!=0)o=1/n;else o=n;g[b>>2]=o*(e-h*h);e=o*(i*h-k);g[b+4>>2]=e;k=o*l;g[b+8>>2]=k;g[b+12>>2]=e;g[b+16>>2]=o*(m*d-i*i);d=o*(j*i-m*h);g[b+20>>2]=d;g[b+24>>2]=k;g[b+
28>>2]=d;g[b+32>>2]=o*(m*c-j*j);return}function Km(a){a=a|0;return}function Lm(a){a=a|0;return}function Mm(a){a=a|0;return 0}function Nm(a,b){a=a|0;b=b|0;var c=0;b=i;c=on(a)|0;i=b;return c|0}function Om(a,b){a=a|0;b=b|0;b=i;pn(a);i=b;return}function Pm(a){a=a|0;var b=0,d=0;b=i;c[2214]=(c[2214]|0)+1;d=nb[c[2208]&31](a,c[2212]|0)|0;i=b;return d|0}function Qm(a){a=a|0;var b=0;b=i;c[2214]=(c[2214]|0)+-1;gb[c[2210]&63](a,c[2212]|0);i=b;return}function Rm(a,b){a=a|0;b=b|0;return}function Sm(a){a=a|0;return a+
43&-32|0}function Tm(a,b){a=a|0;b=b|0;var d=0,e=0;d=i;e=Pm(b+44|0)|0;c[e>>2]=e;b=e+43&-32;c[b+-4>>2]=e;c[e+4>>2]=a;c[e>>2]=c[a>>2];c[(c[a>>2]|0)+4>>2]=e;c[a>>2]=e;i=d;return b|0}function Um(a,b){a=a|0;b=b|0;var d=0;a=i;d=c[b+-4>>2]|0;b=d+4|0;c[(c[d>>2]|0)+4>>2]=c[b>>2];c[c[b>>2]>>2]=c[d>>2];c[b>>2]=d;c[d>>2]=d;Qm(d);i=a;return}function Vm(a){a=a|0;var b=0,d=0,e=0,f=0;b=i;d=a+4|0;e=c[d>>2]|0;if((e|0)==(a|0)){i=b;return}else f=e;do{e=f+4|0;c[(c[f>>2]|0)+4>>2]=c[e>>2];c[c[e>>2]>>2]=c[f>>2];c[e>>2]=f;
c[f>>2]=f;Qm(f);f=c[d>>2]|0}while((f|0)!=(a|0));i=b;return}function Wm(a){a=a|0;c[a+102400>>2]=0;c[a+102404>>2]=0;c[a+102408>>2]=0;c[a+102796>>2]=0;return}function Xm(a){a=a|0;return}function Ym(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0;e=i;f=d+3&-4;d=b+102796|0;g=c[d>>2]|0;h=b+(g*12|0)+102412|0;c[b+(g*12|0)+102416>>2]=f;j=b+102400|0;k=c[j>>2]|0;if((k+f|0)>102400){c[h>>2]=Pm(f)|0;a[b+(g*12|0)+102420>>0]=1}else{c[h>>2]=b+k;a[b+(g*12|0)+102420>>0]=0;c[j>>2]=(c[j>>2]|0)+f}j=b+102404|0;g=(c[j>>2]|
0)+f|0;c[j>>2]=g;j=b+102408|0;b=c[j>>2]|0;c[j>>2]=(b|0)>(g|0)?b:g;c[d>>2]=(c[d>>2]|0)+1;i=e;return c[h>>2]|0}function Zm(b,d,e){b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0;d=i;f=(c[b+102796>>2]|0)+-1|0;g=b+(f*12|0)+102412|0;h=b+(f*12|0)+102416|0;j=e-(c[h>>2]|0)|0;if((j|0)<=0){k=c[g>>2]|0;i=d;return k|0}l=b+(f*12|0)+102420|0;do if((a[l>>0]|0)==0){f=b+102400|0;m=(c[f>>2]|0)+j|0;if((m|0)>102400){n=Pm(e)|0;An(n|0,c[g>>2]|0,c[h>>2]|0)|0;c[f>>2]=(c[f>>2]|0)-(c[h>>2]|0);c[g>>2]=n;a[l>>0]=1;break}else{c[f>>
2]=m;m=b+102404|0;f=(c[m>>2]|0)+j|0;c[m>>2]=f;m=b+102408|0;n=c[m>>2]|0;c[m>>2]=(n|0)>(f|0)?n:f;break}}else{f=Pm(e)|0;An(f|0,c[g>>2]|0,c[h>>2]|0)|0;Qm(c[g>>2]|0);c[g>>2]=f}while(0);c[h>>2]=e;k=c[g>>2]|0;i=d;return k|0}function _m(b,d){b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0;e=i;f=b+102796|0;g=c[f>>2]|0;h=g+-1|0;if((a[b+(h*12|0)+102420>>0]|0)==0){j=b+(h*12|0)+102416|0;k=b+102400|0;c[k>>2]=(c[k>>2]|0)-(c[j>>2]|0);l=j;m=g}else{Qm(d);l=b+(h*12|0)+102416|0;m=c[f>>2]|0}h=b+102404|0;c[h>>2]=(c[h>>
2]|0)-(c[l>>2]|0);c[f>>2]=m+-1;i=e;return}function $m(a){a=a|0;return}function an(a){a=a|0;return}function bn(a){a=a|0;return}function cn(a){a=a|0;return}function dn(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function en(a){a=a|0;var b=0;b=i;sn(a);i=b;return}function fn(a,b,d){a=a|0;b=b|0;d=d|0;var e=0,f=0,g=0,h=0,j=0;e=i;i=i+64|0;f=e;if((a|0)==(b|0)){g=1;i=e;return g|0}if((b|0)==0){g=0;i=e;return g|0}h=jn(b,8928,8984,0)|0;if((h|0)==0){g=0;i=e;return g|0}b=f+0|0;j=b+56|0;do{c[b>>2]=0;b=b+4|0}while((b|
0)<(j|0));c[f>>2]=h;c[f+8>>2]=a;c[f+12>>2]=-1;c[f+48>>2]=1;pb[c[(c[h>>2]|0)+28>>2]&31](h,f,c[d>>2]|0,1);if((c[f+24>>2]|0)!=1){g=0;i=e;return g|0}c[d>>2]=c[f+16>>2];g=1;i=e;return g|0}function gn(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=i;if((c[d+8>>2]|0)!=(b|0)){i=g;return}b=d+16|0;h=c[b>>2]|0;if((h|0)==0){c[b>>2]=e;c[d+24>>2]=f;c[d+36>>2]=1;i=g;return}if((h|0)!=(e|0)){e=d+36|0;c[e>>2]=(c[e>>2]|0)+1;c[d+24>>2]=2;a[d+54>>0]=1;i=g;return}e=d+24|0;if((c[e>>2]|0)!=2){i=g;return}c[e>>2]=f;i=g;return}
function hn(b,d,e,f){b=b|0;d=d|0;e=e|0;f=f|0;var g=0,h=0;g=i;if((b|0)!=(c[d+8>>2]|0)){h=c[b+8>>2]|0;pb[c[(c[h>>2]|0)+28>>2]&31](h,d,e,f);i=g;return}h=d+16|0;b=c[h>>2]|0;if((b|0)==0){c[h>>2]=e;c[d+24>>2]=f;c[d+36>>2]=1;i=g;return}if((b|0)!=(e|0)){e=d+36|0;c[e>>2]=(c[e>>2]|0)+1;c[d+24>>2]=2;a[d+54>>0]=1;i=g;return}e=d+24|0;if((c[e>>2]|0)!=2){i=g;return}c[e>>2]=f;i=g;return}function jn(d,e,f,g){d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0;h=i;i=i+64|0;j=h;k=c[d>>2]|0;l=d+(c[k+
-8>>2]|0)|0;m=c[k+-4>>2]|0;c[j>>2]=f;c[j+4>>2]=d;c[j+8>>2]=e;c[j+12>>2]=g;g=j+16|0;e=j+20|0;d=j+24|0;k=j+28|0;n=j+32|0;o=j+40|0;p=(m|0)==(f|0);f=g+0|0;q=f+36|0;do{c[f>>2]=0;f=f+4|0}while((f|0)<(q|0));b[g+36>>1]=0;a[g+38>>0]=0;if(p){c[j+48>>2]=1;mb[c[(c[m>>2]|0)+20>>2]&7](m,j,l,l,1,0);r=(c[d>>2]|0)==1?l:0;i=h;return r|0}cb[c[(c[m>>2]|0)+24>>2]&3](m,j,l,1,0);l=c[j+36>>2]|0;if((l|0)==1){if((c[d>>2]|0)!=1){if((c[o>>2]|0)!=0){r=0;i=h;return r|0}if((c[k>>2]|0)!=1){r=0;i=h;return r|0}if((c[n>>2]|0)!=1){r=
0;i=h;return r|0}}r=c[g>>2]|0;i=h;return r|0}else if((l|0)==0){if((c[o>>2]|0)!=1){r=0;i=h;return r|0}if((c[k>>2]|0)!=1){r=0;i=h;return r|0}r=(c[n>>2]|0)==1?c[e>>2]|0:0;i=h;return r|0}else{r=0;i=h;return r|0}return 0}function kn(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0;h=i;if((b|0)==(c[d+8>>2]|0)){if((c[d+4>>2]|0)!=(e|0)){i=h;return}j=d+28|0;if((c[j>>2]|0)==1){i=h;return}c[j>>2]=f;i=h;return}if((b|0)!=(c[d>>2]|0)){j=c[b+8>>2]|0;cb[c[(c[j>>2]|0)+24>>2]&3](j,d,e,f,
g);i=h;return}if((c[d+16>>2]|0)!=(e|0)?(j=d+20|0,(c[j>>2]|0)!=(e|0)):0){c[d+32>>2]=f;k=d+44|0;if((c[k>>2]|0)==4){i=h;return}l=d+52|0;a[l>>0]=0;m=d+53|0;a[m>>0]=0;n=c[b+8>>2]|0;mb[c[(c[n>>2]|0)+20>>2]&7](n,d,e,e,1,g);if((a[m>>0]|0)!=0){if((a[l>>0]|0)==0){o=1;p=13}}else{o=0;p=13}do if((p|0)==13){c[j>>2]=e;l=d+40|0;c[l>>2]=(c[l>>2]|0)+1;if((c[d+36>>2]|0)==1?(c[d+24>>2]|0)==2:0){a[d+54>>0]=1;if(o)break}else p=16;if((p|0)==16?o:0)break;c[k>>2]=4;i=h;return}while(0);c[k>>2]=3;i=h;return}if((f|0)!=1){i=
h;return}c[d+32>>2]=1;i=h;return}function ln(b,d,e,f,g){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;var h=0;g=i;if((c[d+8>>2]|0)==(b|0)){if((c[d+4>>2]|0)!=(e|0)){i=g;return}h=d+28|0;if((c[h>>2]|0)==1){i=g;return}c[h>>2]=f;i=g;return}if((c[d>>2]|0)!=(b|0)){i=g;return}if((c[d+16>>2]|0)!=(e|0)?(b=d+20|0,(c[b>>2]|0)!=(e|0)):0){c[d+32>>2]=f;c[b>>2]=e;e=d+40|0;c[e>>2]=(c[e>>2]|0)+1;if((c[d+36>>2]|0)==1?(c[d+24>>2]|0)==2:0)a[d+54>>0]=1;c[d+44>>2]=4;i=g;return}if((f|0)!=1){i=g;return}c[d+32>>2]=1;i=g;return}function mn(b,
d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0,k=0,l=0;j=i;if((b|0)!=(c[d+8>>2]|0)){k=c[b+8>>2]|0;mb[c[(c[k>>2]|0)+20>>2]&7](k,d,e,f,g,h);i=j;return}a[d+53>>0]=1;if((c[d+4>>2]|0)!=(f|0)){i=j;return}a[d+52>>0]=1;f=d+16|0;h=c[f>>2]|0;if((h|0)==0){c[f>>2]=e;c[d+24>>2]=g;c[d+36>>2]=1;if(!((g|0)==1?(c[d+48>>2]|0)==1:0)){i=j;return}a[d+54>>0]=1;i=j;return}if((h|0)!=(e|0)){e=d+36|0;c[e>>2]=(c[e>>2]|0)+1;a[d+54>>0]=1;i=j;return}e=d+24|0;h=c[e>>2]|0;if((h|0)==2){c[e>>2]=g;l=g}else l=h;if(!((l|0)==
1?(c[d+48>>2]|0)==1:0)){i=j;return}a[d+54>>0]=1;i=j;return}function nn(b,d,e,f,g,h){b=b|0;d=d|0;e=e|0;f=f|0;g=g|0;h=h|0;var j=0;h=i;if((c[d+8>>2]|0)!=(b|0)){i=h;return}a[d+53>>0]=1;if((c[d+4>>2]|0)!=(f|0)){i=h;return}a[d+52>>0]=1;f=d+16|0;b=c[f>>2]|0;if((b|0)==0){c[f>>2]=e;c[d+24>>2]=g;c[d+36>>2]=1;if(!((g|0)==1?(c[d+48>>2]|0)==1:0)){i=h;return}a[d+54>>0]=1;i=h;return}if((b|0)!=(e|0)){e=d+36|0;c[e>>2]=(c[e>>2]|0)+1;a[d+54>>0]=1;i=h;return}e=d+24|0;b=c[e>>2]|0;if((b|0)==2){c[e>>2]=g;j=g}else j=b;if(!((j|
0)==1?(c[d+48>>2]|0)==1:0)){i=h;return}a[d+54>>0]=1;i=h;return}function on(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=0,O=0,P=0,Q=0,R=0,S=0,T=0,U=0,V=0,W=0,X=0,Y=0,Z=0,_=0,$=0,aa=0,ba=0,ca=0,da=0,ea=0,fa=0,ga=0,ha=0,ia=0,ja=0,ka=0,la=0,ma=0,na=0,oa=0,pa=0,qa=0,ra=0,sa=0,ta=0,ua=0,va=0,wa=0,xa=0,ya=0,za=0,Aa=0,Ba=0,Ca=0,Ea=0,Fa=0,Ha=0,Ia=0,Ja=0,Ka=0,La=0;b=i;do if(a>>>0<245){if(a>>>0<
11)d=16;else d=a+11&-8;e=d>>>3;f=c[2284]|0;g=f>>>e;if((g&3|0)!=0){h=(g&1^1)+e|0;j=h<<1;k=9176+(j<<2)|0;l=9176+(j+2<<2)|0;j=c[l>>2]|0;m=j+8|0;n=c[m>>2]|0;do if((k|0)!=(n|0)){if(n>>>0<(c[9152>>2]|0)>>>0)Ua();o=n+12|0;if((c[o>>2]|0)==(j|0)){c[o>>2]=k;c[l>>2]=n;break}else Ua()}else c[2284]=f&~(1<<h);while(0);n=h<<3;c[j+4>>2]=n|3;l=j+(n|4)|0;c[l>>2]=c[l>>2]|1;p=m;i=b;return p|0}if(d>>>0>(c[9144>>2]|0)>>>0){if((g|0)!=0){l=2<<e;n=g<<e&(l|0-l);l=(n&0-n)+-1|0;n=l>>>12&16;k=l>>>n;l=k>>>5&8;o=k>>>l;k=o>>>2&
4;q=o>>>k;o=q>>>1&2;r=q>>>o;q=r>>>1&1;s=(l|n|k|o|q)+(r>>>q)|0;q=s<<1;r=9176+(q<<2)|0;o=9176+(q+2<<2)|0;q=c[o>>2]|0;k=q+8|0;n=c[k>>2]|0;do if((r|0)!=(n|0)){if(n>>>0<(c[9152>>2]|0)>>>0)Ua();l=n+12|0;if((c[l>>2]|0)==(q|0)){c[l>>2]=r;c[o>>2]=n;break}else Ua()}else c[2284]=f&~(1<<s);while(0);f=s<<3;n=f-d|0;c[q+4>>2]=d|3;o=q+d|0;c[q+(d|4)>>2]=n|1;c[q+f>>2]=n;f=c[9144>>2]|0;if((f|0)!=0){r=c[9156>>2]|0;e=f>>>3;f=e<<1;g=9176+(f<<2)|0;m=c[2284]|0;j=1<<e;if((m&j|0)!=0){e=9176+(f+2<<2)|0;h=c[e>>2]|0;if(h>>>0<
(c[9152>>2]|0)>>>0)Ua();else{t=e;u=h}}else{c[2284]=m|j;t=9176+(f+2<<2)|0;u=g}c[t>>2]=r;c[u+12>>2]=r;c[r+8>>2]=u;c[r+12>>2]=g}c[9144>>2]=n;c[9156>>2]=o;p=k;i=b;return p|0}o=c[9140>>2]|0;if((o|0)!=0){n=(o&0-o)+-1|0;o=n>>>12&16;g=n>>>o;n=g>>>5&8;r=g>>>n;g=r>>>2&4;f=r>>>g;r=f>>>1&2;j=f>>>r;f=j>>>1&1;m=c[9440+((n|o|g|r|f)+(j>>>f)<<2)>>2]|0;f=(c[m+4>>2]&-8)-d|0;j=m;r=m;while(1){m=c[j+16>>2]|0;if((m|0)==0){g=c[j+20>>2]|0;if((g|0)==0)break;else v=g}else v=m;m=(c[v+4>>2]&-8)-d|0;g=m>>>0<f>>>0;f=g?m:f;j=v;
r=g?v:r}j=c[9152>>2]|0;if(r>>>0<j>>>0)Ua();k=r+d|0;if(!(r>>>0<k>>>0))Ua();q=c[r+24>>2]|0;s=c[r+12>>2]|0;do if((s|0)==(r|0)){g=r+20|0;m=c[g>>2]|0;if((m|0)==0){o=r+16|0;n=c[o>>2]|0;if((n|0)==0){w=0;break}else{x=n;y=o}}else{x=m;y=g}while(1){g=x+20|0;m=c[g>>2]|0;if((m|0)!=0){x=m;y=g;continue}g=x+16|0;m=c[g>>2]|0;if((m|0)==0)break;else{x=m;y=g}}if(y>>>0<j>>>0)Ua();else{c[y>>2]=0;w=x;break}}else{g=c[r+8>>2]|0;if(g>>>0<j>>>0)Ua();m=g+12|0;if((c[m>>2]|0)!=(r|0))Ua();o=s+8|0;if((c[o>>2]|0)==(r|0)){c[m>>2]=
s;c[o>>2]=g;w=s;break}else Ua()}while(0);do if((q|0)!=0){s=c[r+28>>2]|0;j=9440+(s<<2)|0;if((r|0)==(c[j>>2]|0)){c[j>>2]=w;if((w|0)==0){c[9140>>2]=c[9140>>2]&~(1<<s);break}}else{if(q>>>0<(c[9152>>2]|0)>>>0)Ua();s=q+16|0;if((c[s>>2]|0)==(r|0))c[s>>2]=w;else c[q+20>>2]=w;if((w|0)==0)break}if(w>>>0<(c[9152>>2]|0)>>>0)Ua();c[w+24>>2]=q;s=c[r+16>>2]|0;do if((s|0)!=0)if(s>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[w+16>>2]=s;c[s+24>>2]=w;break}while(0);s=c[r+20>>2]|0;if((s|0)!=0)if(s>>>0<(c[9152>>2]|0)>>>0)Ua();
else{c[w+20>>2]=s;c[s+24>>2]=w;break}}while(0);if(f>>>0<16){q=f+d|0;c[r+4>>2]=q|3;s=r+(q+4)|0;c[s>>2]=c[s>>2]|1}else{c[r+4>>2]=d|3;c[r+(d|4)>>2]=f|1;c[r+(f+d)>>2]=f;s=c[9144>>2]|0;if((s|0)!=0){q=c[9156>>2]|0;j=s>>>3;s=j<<1;g=9176+(s<<2)|0;o=c[2284]|0;m=1<<j;if((o&m|0)!=0){j=9176+(s+2<<2)|0;n=c[j>>2]|0;if(n>>>0<(c[9152>>2]|0)>>>0)Ua();else{z=j;A=n}}else{c[2284]=o|m;z=9176+(s+2<<2)|0;A=g}c[z>>2]=q;c[A+12>>2]=q;c[q+8>>2]=A;c[q+12>>2]=g}c[9144>>2]=f;c[9156>>2]=k}p=r+8|0;i=b;return p|0}else B=d}else B=
d}else if(!(a>>>0>4294967231)){g=a+11|0;q=g&-8;s=c[9140>>2]|0;if((s|0)!=0){m=0-q|0;o=g>>>8;if((o|0)!=0)if(q>>>0>16777215)C=31;else{g=(o+1048320|0)>>>16&8;n=o<<g;o=(n+520192|0)>>>16&4;j=n<<o;n=(j+245760|0)>>>16&2;h=14-(o|g|n)+(j<<n>>>15)|0;C=q>>>(h+7|0)&1|h<<1}else C=0;h=c[9440+(C<<2)>>2]|0;a:do if((h|0)==0){D=m;E=0;F=0}else{if((C|0)==31)G=0;else G=25-(C>>>1)|0;n=m;j=0;g=q<<G;o=h;e=0;while(1){l=c[o+4>>2]&-8;H=l-q|0;if(H>>>0<n>>>0)if((l|0)==(q|0)){D=H;E=o;F=o;break a}else{I=H;J=o}else{I=n;J=e}H=c[o+
20>>2]|0;o=c[o+(g>>>31<<2)+16>>2]|0;l=(H|0)==0|(H|0)==(o|0)?j:H;if((o|0)==0){D=I;E=l;F=J;break}else{n=I;j=l;g=g<<1;e=J}}}while(0);if((E|0)==0&(F|0)==0){h=2<<C;m=s&(h|0-h);if((m|0)==0){B=q;break}h=(m&0-m)+-1|0;m=h>>>12&16;r=h>>>m;h=r>>>5&8;k=r>>>h;r=k>>>2&4;f=k>>>r;k=f>>>1&2;e=f>>>k;f=e>>>1&1;K=c[9440+((h|m|r|k|f)+(e>>>f)<<2)>>2]|0}else K=E;if((K|0)==0){L=D;M=F}else{f=D;e=K;k=F;while(1){r=(c[e+4>>2]&-8)-q|0;m=r>>>0<f>>>0;h=m?r:f;r=m?e:k;m=c[e+16>>2]|0;if((m|0)!=0){f=h;e=m;k=r;continue}e=c[e+20>>2]|
0;if((e|0)==0){L=h;M=r;break}else{f=h;k=r}}}if((M|0)!=0?L>>>0<((c[9144>>2]|0)-q|0)>>>0:0){k=c[9152>>2]|0;if(M>>>0<k>>>0)Ua();f=M+q|0;if(!(M>>>0<f>>>0))Ua();e=c[M+24>>2]|0;s=c[M+12>>2]|0;do if((s|0)==(M|0)){r=M+20|0;h=c[r>>2]|0;if((h|0)==0){m=M+16|0;g=c[m>>2]|0;if((g|0)==0){N=0;break}else{O=g;P=m}}else{O=h;P=r}while(1){r=O+20|0;h=c[r>>2]|0;if((h|0)!=0){O=h;P=r;continue}r=O+16|0;h=c[r>>2]|0;if((h|0)==0)break;else{O=h;P=r}}if(P>>>0<k>>>0)Ua();else{c[P>>2]=0;N=O;break}}else{r=c[M+8>>2]|0;if(r>>>0<k>>>
0)Ua();h=r+12|0;if((c[h>>2]|0)!=(M|0))Ua();m=s+8|0;if((c[m>>2]|0)==(M|0)){c[h>>2]=s;c[m>>2]=r;N=s;break}else Ua()}while(0);do if((e|0)!=0){s=c[M+28>>2]|0;k=9440+(s<<2)|0;if((M|0)==(c[k>>2]|0)){c[k>>2]=N;if((N|0)==0){c[9140>>2]=c[9140>>2]&~(1<<s);break}}else{if(e>>>0<(c[9152>>2]|0)>>>0)Ua();s=e+16|0;if((c[s>>2]|0)==(M|0))c[s>>2]=N;else c[e+20>>2]=N;if((N|0)==0)break}if(N>>>0<(c[9152>>2]|0)>>>0)Ua();c[N+24>>2]=e;s=c[M+16>>2]|0;do if((s|0)!=0)if(s>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[N+16>>2]=s;c[s+24>>
2]=N;break}while(0);s=c[M+20>>2]|0;if((s|0)!=0)if(s>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[N+20>>2]=s;c[s+24>>2]=N;break}}while(0);b:do if(!(L>>>0<16)){c[M+4>>2]=q|3;c[M+(q|4)>>2]=L|1;c[M+(L+q)>>2]=L;e=L>>>3;if(L>>>0<256){s=e<<1;k=9176+(s<<2)|0;r=c[2284]|0;m=1<<e;do if((r&m|0)==0){c[2284]=r|m;Q=9176+(s+2<<2)|0;R=k}else{e=9176+(s+2<<2)|0;h=c[e>>2]|0;if(!(h>>>0<(c[9152>>2]|0)>>>0)){Q=e;R=h;break}Ua()}while(0);c[Q>>2]=f;c[R+12>>2]=f;c[M+(q+8)>>2]=R;c[M+(q+12)>>2]=k;break}s=L>>>8;if((s|0)!=0)if(L>>>0>16777215)S=
31;else{m=(s+1048320|0)>>>16&8;r=s<<m;s=(r+520192|0)>>>16&4;h=r<<s;r=(h+245760|0)>>>16&2;e=14-(s|m|r)+(h<<r>>>15)|0;S=L>>>(e+7|0)&1|e<<1}else S=0;e=9440+(S<<2)|0;c[M+(q+28)>>2]=S;c[M+(q+20)>>2]=0;c[M+(q+16)>>2]=0;r=c[9140>>2]|0;h=1<<S;if((r&h|0)==0){c[9140>>2]=r|h;c[e>>2]=f;c[M+(q+24)>>2]=e;c[M+(q+12)>>2]=f;c[M+(q+8)>>2]=f;break}h=c[e>>2]|0;if((S|0)==31)T=0;else T=25-(S>>>1)|0;c:do if((c[h+4>>2]&-8|0)!=(L|0)){e=L<<T;r=h;while(1){U=r+(e>>>31<<2)+16|0;m=c[U>>2]|0;if((m|0)==0)break;if((c[m+4>>2]&-8|
0)==(L|0)){V=m;break c}else{e=e<<1;r=m}}if(U>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[U>>2]=f;c[M+(q+24)>>2]=r;c[M+(q+12)>>2]=f;c[M+(q+8)>>2]=f;break b}}else V=h;while(0);h=V+8|0;k=c[h>>2]|0;e=c[9152>>2]|0;if(V>>>0<e>>>0)Ua();if(k>>>0<e>>>0)Ua();else{c[k+12>>2]=f;c[h>>2]=f;c[M+(q+8)>>2]=k;c[M+(q+12)>>2]=V;c[M+(q+24)>>2]=0;break}}else{k=L+q|0;c[M+4>>2]=k|3;h=M+(k+4)|0;c[h>>2]=c[h>>2]|1}while(0);p=M+8|0;i=b;return p|0}else B=q}else B=q}else B=-1;while(0);M=c[9144>>2]|0;if(!(B>>>0>M>>>0)){L=M-B|0;V=c[9156>>
2]|0;if(L>>>0>15){c[9156>>2]=V+B;c[9144>>2]=L;c[V+(B+4)>>2]=L|1;c[V+M>>2]=L;c[V+4>>2]=B|3}else{c[9144>>2]=0;c[9156>>2]=0;c[V+4>>2]=M|3;L=V+(M+4)|0;c[L>>2]=c[L>>2]|1}p=V+8|0;i=b;return p|0}V=c[9148>>2]|0;if(B>>>0<V>>>0){L=V-B|0;c[9148>>2]=L;V=c[9160>>2]|0;c[9160>>2]=V+B;c[V+(B+4)>>2]=L|1;c[V+4>>2]=B|3;p=V+8|0;i=b;return p|0}do if((c[2402]|0)==0){V=Ta(30)|0;if((V+-1&V|0)==0){c[9616>>2]=V;c[9612>>2]=V;c[9620>>2]=-1;c[9624>>2]=-1;c[9628>>2]=0;c[9580>>2]=0;c[2402]=(Da(0)|0)&-16^1431655768;break}else Ua()}while(0);
V=B+48|0;L=c[9616>>2]|0;M=B+47|0;U=L+M|0;T=0-L|0;L=U&T;if(!(L>>>0>B>>>0)){p=0;i=b;return p|0}S=c[9576>>2]|0;if((S|0)!=0?(R=c[9568>>2]|0,Q=R+L|0,Q>>>0<=R>>>0|Q>>>0>S>>>0):0){p=0;i=b;return p|0}d:do if((c[9580>>2]&4|0)==0){S=c[9160>>2]|0;e:do if((S|0)!=0){Q=9584|0;while(1){R=c[Q>>2]|0;if(!(R>>>0>S>>>0)?(W=Q+4|0,(R+(c[W>>2]|0)|0)>>>0>S>>>0):0)break;R=c[Q+8>>2]|0;if((R|0)==0){X=182;break e}else Q=R}if((Q|0)!=0){R=U-(c[9148>>2]|0)&T;if(R>>>0<2147483647){N=Ga(R|0)|0;O=(N|0)==((c[Q>>2]|0)+(c[W>>2]|0)|0);
Y=N;Z=R;_=O?N:-1;$=O?R:0;X=191}else aa=0}else X=182}else X=182;while(0);do if((X|0)==182){S=Ga(0)|0;if((S|0)!=(-1|0)){q=S;R=c[9612>>2]|0;O=R+-1|0;if((O&q|0)==0)ba=L;else ba=L-q+(O+q&0-R)|0;R=c[9568>>2]|0;q=R+ba|0;if(ba>>>0>B>>>0&ba>>>0<2147483647){O=c[9576>>2]|0;if((O|0)!=0?q>>>0<=R>>>0|q>>>0>O>>>0:0){aa=0;break}O=Ga(ba|0)|0;q=(O|0)==(S|0);Y=O;Z=ba;_=q?S:-1;$=q?ba:0;X=191}else aa=0}else aa=0}while(0);f:do if((X|0)==191){q=0-Z|0;if((_|0)!=(-1|0)){ca=_;da=$;X=202;break d}do if((Y|0)!=(-1|0)&Z>>>0<2147483647&
Z>>>0<V>>>0?(S=c[9616>>2]|0,O=M-Z+S&0-S,O>>>0<2147483647):0)if((Ga(O|0)|0)==(-1|0)){Ga(q|0)|0;aa=$;break f}else{ea=O+Z|0;break}else ea=Z;while(0);if((Y|0)==(-1|0))aa=$;else{ca=Y;da=ea;X=202;break d}}while(0);c[9580>>2]=c[9580>>2]|4;fa=aa;X=199}else{fa=0;X=199}while(0);if((((X|0)==199?L>>>0<2147483647:0)?(aa=Ga(L|0)|0,L=Ga(0)|0,(L|0)!=(-1|0)&(aa|0)!=(-1|0)&aa>>>0<L>>>0):0)?(ea=L-aa|0,L=ea>>>0>(B+40|0)>>>0,L):0){ca=aa;da=L?ea:fa;X=202}if((X|0)==202){fa=(c[9568>>2]|0)+da|0;c[9568>>2]=fa;if(fa>>>0>(c[9572>>
2]|0)>>>0)c[9572>>2]=fa;fa=c[9160>>2]|0;g:do if((fa|0)!=0){ea=9584|0;while(1){ga=c[ea>>2]|0;ha=ea+4|0;ia=c[ha>>2]|0;if((ca|0)==(ga+ia|0)){X=214;break}L=c[ea+8>>2]|0;if((L|0)==0)break;else ea=L}if(((X|0)==214?(c[ea+12>>2]&8|0)==0:0)?fa>>>0>=ga>>>0&fa>>>0<ca>>>0:0){c[ha>>2]=ia+da;L=(c[9148>>2]|0)+da|0;aa=fa+8|0;if((aa&7|0)==0)ja=0;else ja=0-aa&7;aa=L-ja|0;c[9160>>2]=fa+ja;c[9148>>2]=aa;c[fa+(ja+4)>>2]=aa|1;c[fa+(L+4)>>2]=40;c[9164>>2]=c[9624>>2];break}if(ca>>>0<(c[9152>>2]|0)>>>0)c[9152>>2]=ca;L=ca+
da|0;aa=9584|0;while(1){if((c[aa>>2]|0)==(L|0)){X=224;break}Y=c[aa+8>>2]|0;if((Y|0)==0)break;else aa=Y}if((X|0)==224?(c[aa+12>>2]&8|0)==0:0){c[aa>>2]=ca;L=aa+4|0;c[L>>2]=(c[L>>2]|0)+da;L=ca+8|0;if((L&7|0)==0)ka=0;else ka=0-L&7;L=ca+(da+8)|0;if((L&7|0)==0)la=0;else la=0-L&7;L=ca+(la+da)|0;ea=ka+B|0;Y=ca+ea|0;$=L-(ca+ka)-B|0;c[ca+(ka+4)>>2]=B|3;h:do if((L|0)!=(c[9160>>2]|0)){if((L|0)==(c[9156>>2]|0)){Z=(c[9144>>2]|0)+$|0;c[9144>>2]=Z;c[9156>>2]=Y;c[ca+(ea+4)>>2]=Z|1;c[ca+(Z+ea)>>2]=Z;break}Z=da+4|0;
M=c[ca+(Z+la)>>2]|0;if((M&3|0)==1){V=M&-8;_=M>>>3;i:do if(!(M>>>0<256)){ba=c[ca+((la|24)+da)>>2]|0;W=c[ca+(da+12+la)>>2]|0;do if((W|0)==(L|0)){T=la|16;U=ca+(Z+T)|0;q=c[U>>2]|0;if((q|0)==0){Q=ca+(T+da)|0;T=c[Q>>2]|0;if((T|0)==0){ma=0;break}else{na=T;oa=Q}}else{na=q;oa=U}while(1){U=na+20|0;q=c[U>>2]|0;if((q|0)!=0){na=q;oa=U;continue}U=na+16|0;q=c[U>>2]|0;if((q|0)==0)break;else{na=q;oa=U}}if(oa>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[oa>>2]=0;ma=na;break}}else{U=c[ca+((la|8)+da)>>2]|0;if(U>>>0<(c[9152>>2]|
0)>>>0)Ua();q=U+12|0;if((c[q>>2]|0)!=(L|0))Ua();Q=W+8|0;if((c[Q>>2]|0)==(L|0)){c[q>>2]=W;c[Q>>2]=U;ma=W;break}else Ua()}while(0);if((ba|0)==0)break;W=c[ca+(da+28+la)>>2]|0;r=9440+(W<<2)|0;do if((L|0)!=(c[r>>2]|0)){if(ba>>>0<(c[9152>>2]|0)>>>0)Ua();U=ba+16|0;if((c[U>>2]|0)==(L|0))c[U>>2]=ma;else c[ba+20>>2]=ma;if((ma|0)==0)break i}else{c[r>>2]=ma;if((ma|0)!=0)break;c[9140>>2]=c[9140>>2]&~(1<<W);break i}while(0);if(ma>>>0<(c[9152>>2]|0)>>>0)Ua();c[ma+24>>2]=ba;W=la|16;r=c[ca+(W+da)>>2]|0;do if((r|0)!=
0)if(r>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[ma+16>>2]=r;c[r+24>>2]=ma;break}while(0);r=c[ca+(Z+W)>>2]|0;if((r|0)==0)break;if(r>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[ma+20>>2]=r;c[r+24>>2]=ma;break}}else{r=c[ca+((la|8)+da)>>2]|0;ba=c[ca+(da+12+la)>>2]|0;U=9176+(_<<1<<2)|0;do if((r|0)!=(U|0)){if(r>>>0<(c[9152>>2]|0)>>>0)Ua();if((c[r+12>>2]|0)==(L|0))break;Ua()}while(0);if((ba|0)==(r|0)){c[2284]=c[2284]&~(1<<_);break}do if((ba|0)==(U|0))pa=ba+8|0;else{if(ba>>>0<(c[9152>>2]|0)>>>0)Ua();W=ba+8|0;if((c[W>>2]|
0)==(L|0)){pa=W;break}Ua()}while(0);c[r+12>>2]=ba;c[pa>>2]=r}while(0);qa=ca+((V|la)+da)|0;ra=V+$|0}else{qa=L;ra=$}_=qa+4|0;c[_>>2]=c[_>>2]&-2;c[ca+(ea+4)>>2]=ra|1;c[ca+(ra+ea)>>2]=ra;_=ra>>>3;if(ra>>>0<256){Z=_<<1;M=9176+(Z<<2)|0;U=c[2284]|0;W=1<<_;do if((U&W|0)==0){c[2284]=U|W;sa=9176+(Z+2<<2)|0;ta=M}else{_=9176+(Z+2<<2)|0;Q=c[_>>2]|0;if(!(Q>>>0<(c[9152>>2]|0)>>>0)){sa=_;ta=Q;break}Ua()}while(0);c[sa>>2]=Y;c[ta+12>>2]=Y;c[ca+(ea+8)>>2]=ta;c[ca+(ea+12)>>2]=M;break}Z=ra>>>8;do if((Z|0)==0)ua=0;else{if(ra>>>
0>16777215){ua=31;break}W=(Z+1048320|0)>>>16&8;U=Z<<W;V=(U+520192|0)>>>16&4;Q=U<<V;U=(Q+245760|0)>>>16&2;_=14-(V|W|U)+(Q<<U>>>15)|0;ua=ra>>>(_+7|0)&1|_<<1}while(0);Z=9440+(ua<<2)|0;c[ca+(ea+28)>>2]=ua;c[ca+(ea+20)>>2]=0;c[ca+(ea+16)>>2]=0;M=c[9140>>2]|0;_=1<<ua;if((M&_|0)==0){c[9140>>2]=M|_;c[Z>>2]=Y;c[ca+(ea+24)>>2]=Z;c[ca+(ea+12)>>2]=Y;c[ca+(ea+8)>>2]=Y;break}_=c[Z>>2]|0;if((ua|0)==31)va=0;else va=25-(ua>>>1)|0;j:do if((c[_+4>>2]&-8|0)!=(ra|0)){Z=ra<<va;M=_;while(1){wa=M+(Z>>>31<<2)+16|0;U=c[wa>>
2]|0;if((U|0)==0)break;if((c[U+4>>2]&-8|0)==(ra|0)){xa=U;break j}else{Z=Z<<1;M=U}}if(wa>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[wa>>2]=Y;c[ca+(ea+24)>>2]=M;c[ca+(ea+12)>>2]=Y;c[ca+(ea+8)>>2]=Y;break h}}else xa=_;while(0);_=xa+8|0;Z=c[_>>2]|0;r=c[9152>>2]|0;if(xa>>>0<r>>>0)Ua();if(Z>>>0<r>>>0)Ua();else{c[Z+12>>2]=Y;c[_>>2]=Y;c[ca+(ea+8)>>2]=Z;c[ca+(ea+12)>>2]=xa;c[ca+(ea+24)>>2]=0;break}}else{Z=(c[9148>>2]|0)+$|0;c[9148>>2]=Z;c[9160>>2]=Y;c[ca+(ea+4)>>2]=Z|1}while(0);p=ca+(ka|8)|0;i=b;return p|0}ea=9584|
0;while(1){ya=c[ea>>2]|0;if(!(ya>>>0>fa>>>0)?(za=c[ea+4>>2]|0,Aa=ya+za|0,Aa>>>0>fa>>>0):0)break;ea=c[ea+8>>2]|0}ea=ya+(za+-39)|0;if((ea&7|0)==0)Ba=0;else Ba=0-ea&7;ea=ya+(za+-47+Ba)|0;Y=ea>>>0<(fa+16|0)>>>0?fa:ea;ea=Y+8|0;$=ca+8|0;if(($&7|0)==0)Ca=0;else Ca=0-$&7;$=da+-40-Ca|0;c[9160>>2]=ca+Ca;c[9148>>2]=$;c[ca+(Ca+4)>>2]=$|1;c[ca+(da+-36)>>2]=40;c[9164>>2]=c[9624>>2];c[Y+4>>2]=27;c[ea+0>>2]=c[9584>>2];c[ea+4>>2]=c[9588>>2];c[ea+8>>2]=c[9592>>2];c[ea+12>>2]=c[9596>>2];c[9584>>2]=ca;c[9588>>2]=da;
c[9596>>2]=0;c[9592>>2]=ea;ea=Y+28|0;c[ea>>2]=7;if((Y+32|0)>>>0<Aa>>>0){$=ea;do{ea=$;$=$+4|0;c[$>>2]=7}while((ea+8|0)>>>0<Aa>>>0)}if((Y|0)!=(fa|0)){$=Y-fa|0;ea=fa+($+4)|0;c[ea>>2]=c[ea>>2]&-2;c[fa+4>>2]=$|1;c[fa+$>>2]=$;ea=$>>>3;if($>>>0<256){L=ea<<1;aa=9176+(L<<2)|0;Z=c[2284]|0;_=1<<ea;do if((Z&_|0)==0){c[2284]=Z|_;Ea=9176+(L+2<<2)|0;Fa=aa}else{ea=9176+(L+2<<2)|0;r=c[ea>>2]|0;if(!(r>>>0<(c[9152>>2]|0)>>>0)){Ea=ea;Fa=r;break}Ua()}while(0);c[Ea>>2]=fa;c[Fa+12>>2]=fa;c[fa+8>>2]=Fa;c[fa+12>>2]=aa;break}L=
$>>>8;if((L|0)!=0)if($>>>0>16777215)Ha=31;else{_=(L+1048320|0)>>>16&8;Z=L<<_;L=(Z+520192|0)>>>16&4;Y=Z<<L;Z=(Y+245760|0)>>>16&2;r=14-(L|_|Z)+(Y<<Z>>>15)|0;Ha=$>>>(r+7|0)&1|r<<1}else Ha=0;r=9440+(Ha<<2)|0;c[fa+28>>2]=Ha;c[fa+20>>2]=0;c[fa+16>>2]=0;Z=c[9140>>2]|0;Y=1<<Ha;if((Z&Y|0)==0){c[9140>>2]=Z|Y;c[r>>2]=fa;c[fa+24>>2]=r;c[fa+12>>2]=fa;c[fa+8>>2]=fa;break}Y=c[r>>2]|0;if((Ha|0)==31)Ia=0;else Ia=25-(Ha>>>1)|0;k:do if((c[Y+4>>2]&-8|0)!=($|0)){r=$<<Ia;Z=Y;while(1){Ja=Z+(r>>>31<<2)+16|0;_=c[Ja>>2]|0;
if((_|0)==0)break;if((c[_+4>>2]&-8|0)==($|0)){Ka=_;break k}else{r=r<<1;Z=_}}if(Ja>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[Ja>>2]=fa;c[fa+24>>2]=Z;c[fa+12>>2]=fa;c[fa+8>>2]=fa;break g}}else Ka=Y;while(0);Y=Ka+8|0;$=c[Y>>2]|0;aa=c[9152>>2]|0;if(Ka>>>0<aa>>>0)Ua();if($>>>0<aa>>>0)Ua();else{c[$+12>>2]=fa;c[Y>>2]=fa;c[fa+8>>2]=$;c[fa+12>>2]=Ka;c[fa+24>>2]=0;break}}}else{$=c[9152>>2]|0;if(($|0)==0|ca>>>0<$>>>0)c[9152>>2]=ca;c[9584>>2]=ca;c[9588>>2]=da;c[9596>>2]=0;c[9172>>2]=c[2402];c[9168>>2]=-1;$=0;do{Y=$<<
1;aa=9176+(Y<<2)|0;c[9176+(Y+3<<2)>>2]=aa;c[9176+(Y+2<<2)>>2]=aa;$=$+1|0}while(($|0)!=32);$=ca+8|0;if(($&7|0)==0)La=0;else La=0-$&7;$=da+-40-La|0;c[9160>>2]=ca+La;c[9148>>2]=$;c[ca+(La+4)>>2]=$|1;c[ca+(da+-36)>>2]=40;c[9164>>2]=c[9624>>2]}while(0);da=c[9148>>2]|0;if(da>>>0>B>>>0){ca=da-B|0;c[9148>>2]=ca;da=c[9160>>2]|0;c[9160>>2]=da+B;c[da+(B+4)>>2]=ca|1;c[da+4>>2]=B|3;p=da+8|0;i=b;return p|0}}c[(Qa()|0)>>2]=12;p=0;i=b;return p|0}function pn(a){a=a|0;var b=0,d=0,e=0,f=0,g=0,h=0,j=0,k=0,l=0,m=0,n=
0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0;b=i;if((a|0)==0){i=b;return}d=a+-8|0;e=c[9152>>2]|0;if(d>>>0<e>>>0)Ua();f=c[a+-4>>2]|0;g=f&3;if((g|0)==1)Ua();h=f&-8;j=a+(h+-8)|0;do if((f&1|0)==0){k=c[d>>2]|0;if((g|0)==0){i=b;return}l=-8-k|0;m=a+l|0;n=k+h|0;if(m>>>0<e>>>0)Ua();if((m|0)==(c[9156>>2]|0)){o=a+(h+-4)|0;if((c[o>>2]&3|0)!=3){p=m;q=n;break}c[9144>>2]=n;c[o>>2]=c[o>>2]&-2;c[a+(l+4)>>2]=n|1;c[j>>2]=n;i=b;return}o=k>>>3;if(k>>>0<256){k=c[a+(l+8)>>
2]|0;r=c[a+(l+12)>>2]|0;s=9176+(o<<1<<2)|0;if((k|0)!=(s|0)){if(k>>>0<e>>>0)Ua();if((c[k+12>>2]|0)!=(m|0))Ua()}if((r|0)==(k|0)){c[2284]=c[2284]&~(1<<o);p=m;q=n;break}if((r|0)!=(s|0)){if(r>>>0<e>>>0)Ua();s=r+8|0;if((c[s>>2]|0)==(m|0))t=s;else Ua()}else t=r+8|0;c[k+12>>2]=r;c[t>>2]=k;p=m;q=n;break}k=c[a+(l+24)>>2]|0;r=c[a+(l+12)>>2]|0;do if((r|0)==(m|0)){s=a+(l+20)|0;o=c[s>>2]|0;if((o|0)==0){u=a+(l+16)|0;v=c[u>>2]|0;if((v|0)==0){w=0;break}else{x=v;y=u}}else{x=o;y=s}while(1){s=x+20|0;o=c[s>>2]|0;if((o|
0)!=0){x=o;y=s;continue}s=x+16|0;o=c[s>>2]|0;if((o|0)==0)break;else{x=o;y=s}}if(y>>>0<e>>>0)Ua();else{c[y>>2]=0;w=x;break}}else{s=c[a+(l+8)>>2]|0;if(s>>>0<e>>>0)Ua();o=s+12|0;if((c[o>>2]|0)!=(m|0))Ua();u=r+8|0;if((c[u>>2]|0)==(m|0)){c[o>>2]=r;c[u>>2]=s;w=r;break}else Ua()}while(0);if((k|0)!=0){r=c[a+(l+28)>>2]|0;s=9440+(r<<2)|0;if((m|0)==(c[s>>2]|0)){c[s>>2]=w;if((w|0)==0){c[9140>>2]=c[9140>>2]&~(1<<r);p=m;q=n;break}}else{if(k>>>0<(c[9152>>2]|0)>>>0)Ua();r=k+16|0;if((c[r>>2]|0)==(m|0))c[r>>2]=w;else c[k+
20>>2]=w;if((w|0)==0){p=m;q=n;break}}if(w>>>0<(c[9152>>2]|0)>>>0)Ua();c[w+24>>2]=k;r=c[a+(l+16)>>2]|0;do if((r|0)!=0)if(r>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[w+16>>2]=r;c[r+24>>2]=w;break}while(0);r=c[a+(l+20)>>2]|0;if((r|0)!=0)if(r>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[w+20>>2]=r;c[r+24>>2]=w;p=m;q=n;break}else{p=m;q=n}}else{p=m;q=n}}else{p=d;q=h}while(0);if(!(p>>>0<j>>>0))Ua();d=a+(h+-4)|0;w=c[d>>2]|0;if((w&1|0)==0)Ua();if((w&2|0)==0){if((j|0)==(c[9160>>2]|0)){e=(c[9148>>2]|0)+q|0;c[9148>>2]=e;c[9160>>
2]=p;c[p+4>>2]=e|1;if((p|0)!=(c[9156>>2]|0)){i=b;return}c[9156>>2]=0;c[9144>>2]=0;i=b;return}if((j|0)==(c[9156>>2]|0)){e=(c[9144>>2]|0)+q|0;c[9144>>2]=e;c[9156>>2]=p;c[p+4>>2]=e|1;c[p+e>>2]=e;i=b;return}e=(w&-8)+q|0;x=w>>>3;do if(!(w>>>0<256)){y=c[a+(h+16)>>2]|0;t=c[a+(h|4)>>2]|0;do if((t|0)==(j|0)){g=a+(h+12)|0;f=c[g>>2]|0;if((f|0)==0){r=a+(h+8)|0;k=c[r>>2]|0;if((k|0)==0){z=0;break}else{A=k;B=r}}else{A=f;B=g}while(1){g=A+20|0;f=c[g>>2]|0;if((f|0)!=0){A=f;B=g;continue}g=A+16|0;f=c[g>>2]|0;if((f|0)==
0)break;else{A=f;B=g}}if(B>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[B>>2]=0;z=A;break}}else{g=c[a+h>>2]|0;if(g>>>0<(c[9152>>2]|0)>>>0)Ua();f=g+12|0;if((c[f>>2]|0)!=(j|0))Ua();r=t+8|0;if((c[r>>2]|0)==(j|0)){c[f>>2]=t;c[r>>2]=g;z=t;break}else Ua()}while(0);if((y|0)!=0){t=c[a+(h+20)>>2]|0;n=9440+(t<<2)|0;if((j|0)==(c[n>>2]|0)){c[n>>2]=z;if((z|0)==0){c[9140>>2]=c[9140>>2]&~(1<<t);break}}else{if(y>>>0<(c[9152>>2]|0)>>>0)Ua();t=y+16|0;if((c[t>>2]|0)==(j|0))c[t>>2]=z;else c[y+20>>2]=z;if((z|0)==0)break}if(z>>>
0<(c[9152>>2]|0)>>>0)Ua();c[z+24>>2]=y;t=c[a+(h+8)>>2]|0;do if((t|0)!=0)if(t>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[z+16>>2]=t;c[t+24>>2]=z;break}while(0);t=c[a+(h+12)>>2]|0;if((t|0)!=0)if(t>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[z+20>>2]=t;c[t+24>>2]=z;break}}}else{t=c[a+h>>2]|0;y=c[a+(h|4)>>2]|0;n=9176+(x<<1<<2)|0;if((t|0)!=(n|0)){if(t>>>0<(c[9152>>2]|0)>>>0)Ua();if((c[t+12>>2]|0)!=(j|0))Ua()}if((y|0)==(t|0)){c[2284]=c[2284]&~(1<<x);break}if((y|0)!=(n|0)){if(y>>>0<(c[9152>>2]|0)>>>0)Ua();n=y+8|0;if((c[n>>
2]|0)==(j|0))C=n;else Ua()}else C=y+8|0;c[t+12>>2]=y;c[C>>2]=t}while(0);c[p+4>>2]=e|1;c[p+e>>2]=e;if((p|0)==(c[9156>>2]|0)){c[9144>>2]=e;i=b;return}else D=e}else{c[d>>2]=w&-2;c[p+4>>2]=q|1;c[p+q>>2]=q;D=q}q=D>>>3;if(D>>>0<256){w=q<<1;d=9176+(w<<2)|0;e=c[2284]|0;C=1<<q;if((e&C|0)!=0){q=9176+(w+2<<2)|0;j=c[q>>2]|0;if(j>>>0<(c[9152>>2]|0)>>>0)Ua();else{E=q;F=j}}else{c[2284]=e|C;E=9176+(w+2<<2)|0;F=d}c[E>>2]=p;c[F+12>>2]=p;c[p+8>>2]=F;c[p+12>>2]=d;i=b;return}d=D>>>8;if((d|0)!=0)if(D>>>0>16777215)G=31;
else{F=(d+1048320|0)>>>16&8;E=d<<F;d=(E+520192|0)>>>16&4;w=E<<d;E=(w+245760|0)>>>16&2;C=14-(d|F|E)+(w<<E>>>15)|0;G=D>>>(C+7|0)&1|C<<1}else G=0;C=9440+(G<<2)|0;c[p+28>>2]=G;c[p+20>>2]=0;c[p+16>>2]=0;E=c[9140>>2]|0;w=1<<G;a:do if((E&w|0)!=0){F=c[C>>2]|0;if((G|0)==31)H=0;else H=25-(G>>>1)|0;b:do if((c[F+4>>2]&-8|0)!=(D|0)){d=D<<H;e=F;while(1){I=e+(d>>>31<<2)+16|0;j=c[I>>2]|0;if((j|0)==0)break;if((c[j+4>>2]&-8|0)==(D|0)){J=j;break b}else{d=d<<1;e=j}}if(I>>>0<(c[9152>>2]|0)>>>0)Ua();else{c[I>>2]=p;c[p+
24>>2]=e;c[p+12>>2]=p;c[p+8>>2]=p;break a}}else J=F;while(0);F=J+8|0;d=c[F>>2]|0;j=c[9152>>2]|0;if(J>>>0<j>>>0)Ua();if(d>>>0<j>>>0)Ua();else{c[d+12>>2]=p;c[F>>2]=p;c[p+8>>2]=d;c[p+12>>2]=J;c[p+24>>2]=0;break}}else{c[9140>>2]=E|w;c[C>>2]=p;c[p+24>>2]=C;c[p+12>>2]=p;c[p+8>>2]=p}while(0);p=(c[9168>>2]|0)+-1|0;c[9168>>2]=p;if((p|0)==0)K=9592|0;else{i=b;return}while(1){p=c[K>>2]|0;if((p|0)==0)break;else K=p+8|0}c[9168>>2]=-1;i=b;return}function qn(a){a=a|0;var b=0,d=0,e=0,f=0;b=i;d=(a|0)==0?1:a;while(1){e=
on(d)|0;if((e|0)!=0){f=6;break}a=c[2410]|0;c[2410]=a+0;if((a|0)==0){f=5;break}jb[a&1]()}if((f|0)==5){d=Aa(4)|0;c[d>>2]=9656;Sa(d|0,9704,92)}else if((f|0)==6){i=b;return e|0}return 0}function rn(a,b){a=a|0;b=b|0;var c=0;b=i;c=qn(a)|0;i=b;return c|0}function sn(a){a=a|0;var b=0;b=i;if((a|0)!=0)pn(a);i=b;return}function tn(a){a=a|0;var b=0;b=i;Ra(a|0);sn(a);i=b;return}function un(a){a=a|0;var b=0;b=i;Ra(a|0);i=b;return}function vn(a){a=a|0;return 9672}function wn(){c[2428]=o}function xn(b,d,e){b=b|0;
d=d|0;e=e|0;var f=0,g=0,h=0,i=0;f=b+e|0;if((e|0)>=20){d=d&255;g=b&3;h=d|d<<8|d<<16|d<<24;i=f&~3;if(g){g=b+4-g|0;while((b|0)<(g|0)){a[b>>0]=d;b=b+1|0}}while((b|0)<(i|0)){c[b>>2]=h;b=b+4|0}}while((b|0)<(f|0)){a[b>>0]=d;b=b+1|0}return b-e|0}function yn(b){b=b|0;var c=0;c=b;while(a[c>>0]|0)c=c+1|0;return c-b|0}function zn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=a+c>>>0;return(E=b+d+(e>>>0<a>>>0|0)>>>0,e|0)|0}function An(b,d,e){b=b|0;d=d|0;e=e|0;var f=0;if((e|0)>=4096)return Ma(b|0,d|0,e|0)|0;f=b|0;
if((b&3)==(d&3)){while(b&3){if((e|0)==0)return f|0;a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}while((e|0)>=4){c[b>>2]=c[d>>2];b=b+4|0;d=d+4|0;e=e-4|0}}while((e|0)>0){a[b>>0]=a[d>>0]|0;b=b+1|0;d=d+1|0;e=e-1|0}return f|0}function Bn(b,c,d){b=b|0;c=c|0;d=d|0;var e=0;if((c|0)<(b|0)&(b|0)<(c+d|0)){e=b;c=c+d|0;b=b+d|0;while((d|0)>0){b=b-1|0;c=c-1|0;d=d-1|0;a[b>>0]=a[c>>0]|0}b=e}else An(b,c,d)|0;return b|0}function Cn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=b-d>>>0;e=b-d-(c>>>0>a>>>0|0)>>>0;return(E=e,
a-c>>>0|0)|0}function Dn(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){E=b<<c|(a&(1<<c)-1<<32-c)>>>32-c;return a<<c}E=a<<c-32;return 0}function En(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){E=b>>>c;return a>>>c|(b&(1<<c)-1)<<32-c}E=0;return b>>>c-32|0}function Fn(a,b,c){a=a|0;b=b|0;c=c|0;if((c|0)<32){E=b>>c;return a>>>c|(b&(1<<c)-1)<<32-c}E=(b|0)<0?-1:0;return b>>c-32|0}function Gn(b){b=b|0;var c=0;c=a[n+(b>>>24)>>0]|0;if((c|0)<8)return c|0;c=a[n+(b>>16&255)>>0]|0;if((c|0)<8)return c+8|0;c=a[n+(b>>8&255)>>0]|
0;if((c|0)<8)return c+16|0;return(a[n+(b&255)>>0]|0)+24|0}function Hn(b){b=b|0;var c=0;c=a[m+(b&255)>>0]|0;if((c|0)<8)return c|0;c=a[m+(b>>8&255)>>0]|0;if((c|0)<8)return c+8|0;c=a[m+(b>>16&255)>>0]|0;if((c|0)<8)return c+16|0;return(a[m+(b>>>24)>>0]|0)+24|0}function In(a,b){a=a|0;b=b|0;var c=0,d=0,e=0,f=0;c=a&65535;d=b&65535;e=aa(d,c)|0;f=a>>>16;a=(e>>>16)+(aa(d,f)|0)|0;d=b>>>16;b=aa(d,c)|0;return(E=(a>>>16)+(aa(d,f)|0)+(((a&65535)+b|0)>>>16)|0,a+b<<16|e&65535|0)|0}function Jn(a,b,c,d){a=a|0;b=b|0;
c=c|0;d=d|0;var e=0,f=0,g=0,h=0,i=0;e=b>>31|((b|0)<0?-1:0)<<1;f=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;g=d>>31|((d|0)<0?-1:0)<<1;h=((d|0)<0?-1:0)>>31|((d|0)<0?-1:0)<<1;i=Cn(e^a,f^b,e,f)|0;b=E;a=g^e;e=h^f;f=Cn((On(i,b,Cn(g^c,h^d,g,h)|0,E,0)|0)^a,E^e,a,e)|0;return f|0}function Kn(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0,h=0,j=0,k=0,l=0,m=0;f=i;i=i+8|0;g=f|0;h=b>>31|((b|0)<0?-1:0)<<1;j=((b|0)<0?-1:0)>>31|((b|0)<0?-1:0)<<1;k=e>>31|((e|0)<0?-1:0)<<1;l=((e|0)<0?-1:0)>>31|((e|0)<0?-1:0)<<1;m=Cn(h^a,j^
b,h,j)|0;b=E;On(m,b,Cn(k^d,l^e,k,l)|0,E,g)|0;l=Cn(c[g>>2]^h,c[g+4>>2]^j,h,j)|0;j=E;i=f;return(E=j,l)|0}function Ln(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0,f=0;e=a;a=c;c=In(e,a)|0;f=E;return(E=(aa(b,a)|0)+(aa(d,e)|0)+f|f&0,c|0|0)|0}function Mn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;var e=0;e=On(a,b,c,d,0)|0;return e|0}function Nn(a,b,d,e){a=a|0;b=b|0;d=d|0;e=e|0;var f=0,g=0;f=i;i=i+8|0;g=f|0;On(a,b,d,e,g)|0;i=f;return(E=c[g+4>>2]|0,c[g>>2]|0)|0}function On(a,b,d,e,f){a=a|0;b=b|0;d=d|0;e=e|0;f=f|0;var g=
0,h=0,i=0,j=0,k=0,l=0,m=0,n=0,o=0,p=0,q=0,r=0,s=0,t=0,u=0,v=0,w=0,x=0,y=0,z=0,A=0,B=0,C=0,D=0,F=0,G=0,H=0;g=a;h=b;i=h;j=d;k=e;l=k;if((i|0)==0){m=(f|0)!=0;if((l|0)==0){if(m){c[f>>2]=(g>>>0)%(j>>>0);c[f+4>>2]=0}n=0;o=(g>>>0)/(j>>>0)>>>0;return(E=n,o)|0}else{if(!m){n=0;o=0;return(E=n,o)|0}c[f>>2]=a|0;c[f+4>>2]=b&0;n=0;o=0;return(E=n,o)|0}}m=(l|0)==0;do if((j|0)!=0){if(!m){p=(Gn(l|0)|0)-(Gn(i|0)|0)|0;if(p>>>0<=31){q=p+1|0;r=31-p|0;s=p-31>>31;t=q;u=g>>>(q>>>0)&s|i<<r;v=i>>>(q>>>0)&s;w=0;x=g<<r;break}if((f|
0)==0){n=0;o=0;return(E=n,o)|0}c[f>>2]=a|0;c[f+4>>2]=h|b&0;n=0;o=0;return(E=n,o)|0}r=j-1|0;if((r&j|0)!=0){s=(Gn(j|0)|0)+33-(Gn(i|0)|0)|0;q=64-s|0;p=32-s|0;y=p>>31;z=s-32|0;A=z>>31;t=s;u=p-1>>31&i>>>(z>>>0)|(i<<p|g>>>(s>>>0))&A;v=A&i>>>(s>>>0);w=g<<q&y;x=(i<<q|g>>>(z>>>0))&y|g<<p&s-33>>31;break}if((f|0)!=0){c[f>>2]=r&g;c[f+4>>2]=0}if((j|0)==1){n=h|b&0;o=a|0|0;return(E=n,o)|0}else{r=Hn(j|0)|0;n=i>>>(r>>>0)|0;o=i<<32-r|g>>>(r>>>0)|0;return(E=n,o)|0}}else{if(m){if((f|0)!=0){c[f>>2]=(i>>>0)%(j>>>0);c[f+
4>>2]=0}n=0;o=(i>>>0)/(j>>>0)>>>0;return(E=n,o)|0}if((g|0)==0){if((f|0)!=0){c[f>>2]=0;c[f+4>>2]=(i>>>0)%(l>>>0)}n=0;o=(i>>>0)/(l>>>0)>>>0;return(E=n,o)|0}r=l-1|0;if((r&l|0)==0){if((f|0)!=0){c[f>>2]=a|0;c[f+4>>2]=r&i|b&0}n=0;o=i>>>((Hn(l|0)|0)>>>0);return(E=n,o)|0}r=(Gn(l|0)|0)-(Gn(i|0)|0)|0;if(r>>>0<=30){s=r+1|0;p=31-r|0;t=s;u=i<<p|g>>>(s>>>0);v=i>>>(s>>>0);w=0;x=g<<p;break}if((f|0)==0){n=0;o=0;return(E=n,o)|0}c[f>>2]=a|0;c[f+4>>2]=h|b&0;n=0;o=0;return(E=n,o)|0}while(0);if((t|0)==0){B=x;C=w;D=v;F=
u;G=0;H=0}else{b=d|0|0;d=k|e&0;e=zn(b,d,-1,-1)|0;k=E;h=x;x=w;w=v;v=u;u=t;t=0;do{a=h;h=x>>>31|h<<1;x=t|x<<1;g=v<<1|a>>>31|0;a=v>>>31|w<<1|0;Cn(e,k,g,a)|0;i=E;l=i>>31|((i|0)<0?-1:0)<<1;t=l&1;v=Cn(g,a,l&b,(((i|0)<0?-1:0)>>31|((i|0)<0?-1:0)<<1)&d)|0;w=E;u=u-1|0}while((u|0)!=0);B=h;C=x;D=w;F=v;G=0;H=t}t=C;C=0;if((f|0)!=0){c[f>>2]=F;c[f+4>>2]=D}n=(t|0)>>>31|(B|C)<<1|(C<<1|t>>>31)&0|G;o=(t<<1|0>>>31)&-2|H;return(E=n,o)|0}function Pn(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=+g;return+ab[a&1](b|
0,c|0,d|0,e|0,f|0,+g)}function Qn(a,b){a=a|0;b=b|0;return bb[a&7](b|0)|0}function Rn(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;cb[a&3](b|0,c|0,d|0,e|0,f|0)}function Sn(a,b,c){a=a|0;b=b|0;c=+c;return+db[a&15](b|0,+c)}function Tn(a,b){a=a|0;b=b|0;eb[a&127](b|0)}function Un(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=+f;return+fb[a&1](b|0,c|0,d|0,e|0,+f)}function Vn(a,b,c){a=a|0;b=b|0;c=c|0;gb[a&63](b|0,c|0)}function Wn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;return hb[a&15](b|0,c|0,d|0)|0}function Xn(a,
b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;ib[a&7](b|0,c|0,d|0)}function Yn(a){a=a|0;jb[a&1]()}function Zn(a,b,c,d){a=a|0;b=b|0;c=c|0;d=+d;kb[a&31](b|0,c|0,+d)}function _n(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;return lb[a&7](b|0,c|0,d|0,e|0)|0}function $n(a,b,c,d,e,f,g){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;g=g|0;mb[a&7](b|0,c|0,d|0,e|0,f|0,g|0)}function ao(a,b,c){a=a|0;b=b|0;c=c|0;return nb[a&31](b|0,c|0)|0}function bo(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;return ob[a&15](b|0,c|0,d|0,e|0,f|0)|0}
function co(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;pb[a&31](b|0,c|0,d|0,e|0)}function eo(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=+f;ba(0);return 0}function fo(a){a=a|0;ba(1);return 0}function go(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;ba(2)}function ho(a,b){a=a|0;b=+b;ba(3);return 0}function io(a){a=a|0;ba(4)}function jo(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=+e;ba(5);return 0}function ko(a,b){a=a|0;b=b|0;ba(6)}function lo(a,b,c){a=a|0;b=b|0;c=c|0;ba(7);return 0}function mo(a,b,c){a=a|0;b=b|
0;c=c|0;ba(8)}function no(){ba(9)}function oo(){_a()}function po(a,b,c){a=a|0;b=b|0;c=+c;ba(10)}function qo(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;ba(11);return 0}function ro(a,b,c,d,e,f){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;f=f|0;ba(12)}function so(a,b){a=a|0;b=b|0;ba(13);return 0}function to(a,b,c,d,e){a=a|0;b=b|0;c=c|0;d=d|0;e=e|0;ba(14);return 0}function uo(a,b,c,d){a=a|0;b=b|0;c=c|0;d=d|0;ba(15)}var ab=[eo,Gd];var bb=[fo,ge,ne,ve,Fe,rm,vn,fo];var cb=[go,ln,kn,go];var db=[ho,Df,Qf,dg,pg,Bg,Mg,Zg,ph,Hh,Zh,
ki,ho,ho,ho,ho];var eb=[io,pc,Ed,oc,Id,nc,Md,Gb,Wd,Ib,Vd,Cb,Xd,Ce,Be,rf,sf,Ff,Gf,Hf,Tf,Vf,Wf,eg,fg,gg,qg,rg,sg,Cg,Dg,Eg,Og,Pg,Qg,fh,gh,hh,qh,rh,sh,wh,xh,yh,Oh,Ph,Qh,$h,ai,bi,li,ni,oi,si,ti,yi,zi,Di,Ei,Ii,Ji,Wi,Xi,$i,aj,ej,fj,jj,kj,Rj,ck,Ul,Vl,Zl,_l,am,bm,dm,em,Jk,im,km,lm,om,pm,xm,ym,an,dn,bn,cn,en,un,tn,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io,io];var fb=[jo,Fd];var gb=[ko,Nd,Od,Af,Bf,Ef,xf,yf,Nf,Of,Uf,Kf,Lf,ag,bg,Zf,_f,mg,ng,jg,kg,yg,zg,
vg,wg,Jg,Kg,Gg,Hg,Wg,Xg,Tg,Ug,mh,nh,jh,kh,Eh,Fh,Bh,Ch,Wh,Xh,Th,Uh,hi,ii,mi,ei,fi,dk,ek,Om,Gi,Bi,hj,Ui,cj,Zi,qi,ko,ko,ko,ko];var hb=[lo,Kd,he,pe,we,Ie,qf,gm,mm,sm,Am,fn,lo,lo,lo,lo];var ib=[mo,Pd,Rd,Td,Ud,fk,gk,mo];var jb=[no,oo];var kb=[po,le,te,Ae,Le,Cf,Pf,cg,og,Ag,Lg,Yg,oh,Gh,Yh,ji,wm,po,po,po,po,po,po,po,po,po,po,po,po,po,po,po];var lb=[qo,tf,uf,hm,nm,qo,qo,qo];var mb=[ro,ie,qe,xe,He,tm,nn,mn];var nb=[so,Hd,Jd,Ld,fe,me,ue,Ee,zf,Mf,$f,lg,xg,Ig,Vg,lh,Dh,Vh,gi,Wl,Xl,fm,jm,qm,zm,Nm,Zj,Kk,Lk,Wk,Vk,
_k];var ob=[to,je,re,ye,Je,um,Fi,Ai,gj,Ti,bj,Yi,pi,to,to,to];var pb=[uo,Qd,Sd,ke,se,ze,Ke,ri,Ci,Hi,Vi,_i,dj,ij,Yl,$l,cm,vm,gn,hn,uo,uo,uo,uo,uo,uo,uo,uo,uo,uo,uo,uo];return{_b2PrismaticJoint_IsMotorEnabled:Yc,_b2Body_GetWorldVector:fc,_strlen:yn,_b2Body_GetLocalVector:_b,_b2PrismaticJoint_GetMotorSpeed:Vc,_b2RopeJointDef_Create:kd,_b2World_CreateParticleSystem:sc,_b2ParticleSystem_SetRadius:Dd,_b2FrictionJointDef_Create:Gc,_b2World_RayCast:yc,_b2MotorJointDef_InitializeAndCreate:Pc,_b2GearJoint_GetRatio:Ic,
_b2Body_GetLocalPoint:Zb,_memcpy:An,_b2RevoluteJoint_EnableLimit:cd,_b2Body_DestroyFixture:Ub,_b2World_Create:qc,_b2PolygonShape_CreateFixture_3:Hb,_b2PolygonShape_CreateFixture_6:Lb,_b2PolygonShape_CreateFixture_7:Mb,_b2PolygonShape_CreateFixture_4:Jb,_b2PolygonShape_CreateFixture_5:Kb,_b2Body_SetAwake:gc,_b2Body_GetWorldCenter:dc,_b2ParticleGroup_DestroyParticles:td,_b2PrismaticJoint_EnableLimit:Sc,_b2Fixture_TestPoint:mc,_b2MotorJoint_SetLinearOffset:Nc,_free:pn,_b2ParticleSystem_CreateParticle:wd,
_b2Body_SetLinearVelocity:ic,_b2CircleShape_CreateParticleGroup:Db,_b2WeldJointDef_Create:ld,_b2Body_GetAngularVelocity:Wb,_b2Body_ApplyForceToCenter:Sb,_b2DistanceJointDef_InitializeAndCreate:Fc,_b2Body_ApplyForce:Rb,_b2RevoluteJoint_SetMotorSpeed:jd,_b2Body_GetPosition:ac,_b2World_CreateBody:rc,_b2Body_GetLinearVelocity:Yb,_b2Body_SetMassData:jc,_b2MouseJointDef_Create:Rc,_b2ParticleSystem_GetColorBuffer:xd,_b2DistanceJointDef_Create:Ec,_b2ParticleSystem_GetPositionBuffer:zd,_b2CircleShape_DestroyParticlesInShape:Eb,
_b2World_QueryAABB:xc,_b2PolygonShape_DestroyParticlesInShape_4:Pb,_b2RevoluteJointDef_InitializeAndCreate:id,_b2GearJointDef_Create:Jc,_b2PrismaticJoint_IsLimitEnabled:Xc,_b2Contact_GetWorldManifold:Dc,_b2WheelJoint_SetSpringFrequencyHz:od,_b2Body_ApplyTorque:Tb,_b2ParticleGroup_ApplyLinearImpulse:sd,_b2PrismaticJointDef_InitializeAndCreate:$c,_memset:xn,_b2MotorJointDef_Create:Oc,_b2World_DestroyBody:uc,_b2RevoluteJointDef_Create:hd,_b2ParticleGroup_GetParticleCount:vd,_b2World_SetGravity:Ac,_b2PrismaticJoint_EnableMotor:Tc,
_b2PolygonShape_CreateParticleGroup_4:Ob,_b2PolygonShape_CreateFixture_8:Nb,_b2Body_SetAngularVelocity:hc,_b2Body_GetWorldPoint:ec,_b2WheelJoint_SetMotorSpeed:nd,_b2FrictionJointDef_InitializeAndCreate:Hc,_b2World_SetContactListener:zc,_b2ParticleSystem_SetDamping:Bd,_b2Body_SetType:lc,_b2Body_SetTransform:kc,_b2CircleShape_CreateFixture:Bb,_b2RevoluteJoint_GetJointAngle:ed,_b2ParticleGroup_ApplyForce:rd,_malloc:on,_b2Contact_GetManifold:Cc,_b2RevoluteJoint_IsMotorEnabled:gd,_b2ParticleSystem_GetVelocityBuffer:Ad,
_b2RevoluteJoint_IsLimitEnabled:fd,_b2World_DestroyParticleSystem:wc,_b2RevoluteJoint_EnableMotor:dd,_b2Body_GetTransform:bc,_b2WeldJointDef_InitializeAndCreate:md,_b2EdgeShape_CreateFixture:Fb,_b2Body_GetType:cc,_b2Manifold_GetPointCount:yb,_b2ParticleSystem_SetDensity:Cd,_b2PrismaticJoint_GetMotorForce:Wc,_b2Joint_GetBodyA:Kc,_b2PulleyJointDef_InitializeAndCreate:bd,_b2Joint_GetBodyB:Lc,_b2ParticleSystem_GetParticleCount:yd,_b2MouseJoint_SetTarget:Qc,_b2Body_ApplyAngularImpulse:Qb,_b2ChainShape_CreateFixture:zb,
_b2World_DestroyJoint:vc,_b2MotorJoint_SetAngularOffset:Mc,_b2World_Delete:tc,_b2PrismaticJoint_GetJointTranslation:Uc,_i64Add:zn,_b2Body_GetMass:$b,_b2Body_GetAngle:Vb,_b2ParticleGroup_GetBufferIndex:ud,_b2WheelJointDef_InitializeAndCreate:qd,_b2World_Step:Bc,_b2PrismaticJointDef_Create:_c,_b2WheelJointDef_Create:pd,_b2PulleyJointDef_Create:ad,_b2Body_GetInertia:Xb,_memmove:Bn,_b2PrismaticJoint_SetMotorSpeed:Zc,__GLOBAL__I_a:Yd,runPostSets:wn,stackAlloc:qb,stackSave:rb,stackRestore:sb,setThrew:tb,
setTempRet0:wb,getTempRet0:xb,dynCall_diiiiid:Pn,dynCall_ii:Qn,dynCall_viiiii:Rn,dynCall_did:Sn,dynCall_vi:Tn,dynCall_diiiid:Un,dynCall_vii:Vn,dynCall_iiii:Wn,dynCall_viii:Xn,dynCall_v:Yn,dynCall_viid:Zn,dynCall_iiiii:_n,dynCall_viiiiii:$n,dynCall_iii:ao,dynCall_iiiiii:bo,dynCall_viiii:co}}({"Math":Math,"Int8Array":Int8Array,"Int16Array":Int16Array,"Int32Array":Int32Array,"Uint8Array":Uint8Array,"Uint16Array":Uint16Array,"Uint32Array":Uint32Array,"Float32Array":Float32Array,"Float64Array":Float64Array},
{"abort":abort,"assert":assert,"asmPrintInt":asmPrintInt,"asmPrintFloat":asmPrintFloat,"min":Math_min,"invoke_diiiiid":invoke_diiiiid,"invoke_ii":invoke_ii,"invoke_viiiii":invoke_viiiii,"invoke_did":invoke_did,"invoke_vi":invoke_vi,"invoke_diiiid":invoke_diiiid,"invoke_vii":invoke_vii,"invoke_iiii":invoke_iiii,"invoke_viii":invoke_viii,"invoke_v":invoke_v,"invoke_viid":invoke_viid,"invoke_iiiii":invoke_iiiii,"invoke_viiiiii":invoke_viiiiii,"invoke_iii":invoke_iii,"invoke_iiiiii":invoke_iiiiii,"invoke_viiii":invoke_viiii,
"_cosf":_cosf,"__ZSt9terminatev":__ZSt9terminatev,"_b2WorldPreSolve":_b2WorldPreSolve,"___cxa_is_number_type":___cxa_is_number_type,"___cxa_allocate_exception":___cxa_allocate_exception,"___cxa_find_matching_catch":___cxa_find_matching_catch,"_fflush":_fflush,"_time":_time,"__exit":__exit,"___setErrNo":___setErrNo,"_sbrk":_sbrk,"___cxa_begin_catch":___cxa_begin_catch,"_sinf":_sinf,"___resumeException":___resumeException,"__ZSt18uncaught_exceptionv":__ZSt18uncaught_exceptionv,"_b2WorldRayCastCallback":_b2WorldRayCastCallback,
"_emscripten_memcpy_big":_emscripten_memcpy_big,"_floorf":_floorf,"_sqrtf":_sqrtf,"_b2WorldBeginContactBody":_b2WorldBeginContactBody,"___errno_location":___errno_location,"__ZNSt9exceptionD2Ev":__ZNSt9exceptionD2Ev,"___cxa_throw":___cxa_throw,"_sysconf":_sysconf,"_abort":_abort,"___cxa_does_inherit":___cxa_does_inherit,"_b2WorldEndContactBody":_b2WorldEndContactBody,"_b2WorldQueryAABB":_b2WorldQueryAABB,"_b2WorldPostSolve":_b2WorldPostSolve,"_exit":_exit,"___cxa_pure_virtual":___cxa_pure_virtual,
"STACKTOP":STACKTOP,"STACK_MAX":STACK_MAX,"tempDoublePtr":tempDoublePtr,"ABORT":ABORT,"cttz_i8":cttz_i8,"ctlz_i8":ctlz_i8,"NaN":NaN,"Infinity":Infinity,"__ZTISt9exception":__ZTISt9exception},buffer);var _b2PrismaticJoint_IsMotorEnabled=Module["_b2PrismaticJoint_IsMotorEnabled"]=asm["_b2PrismaticJoint_IsMotorEnabled"];var _b2Body_GetWorldVector=Module["_b2Body_GetWorldVector"]=asm["_b2Body_GetWorldVector"];var _strlen=Module["_strlen"]=asm["_strlen"];
var _b2Body_GetLocalVector=Module["_b2Body_GetLocalVector"]=asm["_b2Body_GetLocalVector"];var _b2PrismaticJoint_GetMotorSpeed=Module["_b2PrismaticJoint_GetMotorSpeed"]=asm["_b2PrismaticJoint_GetMotorSpeed"];var _b2RopeJointDef_Create=Module["_b2RopeJointDef_Create"]=asm["_b2RopeJointDef_Create"];var _b2World_CreateParticleSystem=Module["_b2World_CreateParticleSystem"]=asm["_b2World_CreateParticleSystem"];var _b2ParticleSystem_SetRadius=Module["_b2ParticleSystem_SetRadius"]=asm["_b2ParticleSystem_SetRadius"];
var _b2FrictionJointDef_Create=Module["_b2FrictionJointDef_Create"]=asm["_b2FrictionJointDef_Create"];var _b2World_RayCast=Module["_b2World_RayCast"]=asm["_b2World_RayCast"];var _b2MotorJointDef_InitializeAndCreate=Module["_b2MotorJointDef_InitializeAndCreate"]=asm["_b2MotorJointDef_InitializeAndCreate"];var _b2GearJoint_GetRatio=Module["_b2GearJoint_GetRatio"]=asm["_b2GearJoint_GetRatio"];var _b2Body_GetLocalPoint=Module["_b2Body_GetLocalPoint"]=asm["_b2Body_GetLocalPoint"];
var _memcpy=Module["_memcpy"]=asm["_memcpy"];var _b2RevoluteJoint_EnableLimit=Module["_b2RevoluteJoint_EnableLimit"]=asm["_b2RevoluteJoint_EnableLimit"];var _b2Body_DestroyFixture=Module["_b2Body_DestroyFixture"]=asm["_b2Body_DestroyFixture"];var _b2World_Create=Module["_b2World_Create"]=asm["_b2World_Create"];var _b2PolygonShape_CreateFixture_3=Module["_b2PolygonShape_CreateFixture_3"]=asm["_b2PolygonShape_CreateFixture_3"];
var _b2PolygonShape_CreateFixture_6=Module["_b2PolygonShape_CreateFixture_6"]=asm["_b2PolygonShape_CreateFixture_6"];var _b2PolygonShape_CreateFixture_7=Module["_b2PolygonShape_CreateFixture_7"]=asm["_b2PolygonShape_CreateFixture_7"];var _b2PolygonShape_CreateFixture_4=Module["_b2PolygonShape_CreateFixture_4"]=asm["_b2PolygonShape_CreateFixture_4"];var _b2PolygonShape_CreateFixture_5=Module["_b2PolygonShape_CreateFixture_5"]=asm["_b2PolygonShape_CreateFixture_5"];
var _b2Body_SetAwake=Module["_b2Body_SetAwake"]=asm["_b2Body_SetAwake"];var _b2Body_GetWorldCenter=Module["_b2Body_GetWorldCenter"]=asm["_b2Body_GetWorldCenter"];var _b2ParticleGroup_DestroyParticles=Module["_b2ParticleGroup_DestroyParticles"]=asm["_b2ParticleGroup_DestroyParticles"];var _b2PrismaticJoint_EnableLimit=Module["_b2PrismaticJoint_EnableLimit"]=asm["_b2PrismaticJoint_EnableLimit"];var _b2Fixture_TestPoint=Module["_b2Fixture_TestPoint"]=asm["_b2Fixture_TestPoint"];
var _b2MotorJoint_SetLinearOffset=Module["_b2MotorJoint_SetLinearOffset"]=asm["_b2MotorJoint_SetLinearOffset"];var _free=Module["_free"]=asm["_free"];var _b2ParticleSystem_CreateParticle=Module["_b2ParticleSystem_CreateParticle"]=asm["_b2ParticleSystem_CreateParticle"];var _b2Body_SetLinearVelocity=Module["_b2Body_SetLinearVelocity"]=asm["_b2Body_SetLinearVelocity"];var _b2CircleShape_CreateParticleGroup=Module["_b2CircleShape_CreateParticleGroup"]=asm["_b2CircleShape_CreateParticleGroup"];
var _b2WeldJointDef_Create=Module["_b2WeldJointDef_Create"]=asm["_b2WeldJointDef_Create"];var _b2Body_GetAngularVelocity=Module["_b2Body_GetAngularVelocity"]=asm["_b2Body_GetAngularVelocity"];var _b2Body_ApplyForceToCenter=Module["_b2Body_ApplyForceToCenter"]=asm["_b2Body_ApplyForceToCenter"];var _b2DistanceJointDef_InitializeAndCreate=Module["_b2DistanceJointDef_InitializeAndCreate"]=asm["_b2DistanceJointDef_InitializeAndCreate"];var _b2Body_ApplyForce=Module["_b2Body_ApplyForce"]=asm["_b2Body_ApplyForce"];
var _b2RevoluteJoint_SetMotorSpeed=Module["_b2RevoluteJoint_SetMotorSpeed"]=asm["_b2RevoluteJoint_SetMotorSpeed"];var _b2Body_GetPosition=Module["_b2Body_GetPosition"]=asm["_b2Body_GetPosition"];var _b2World_CreateBody=Module["_b2World_CreateBody"]=asm["_b2World_CreateBody"];var _b2Body_GetLinearVelocity=Module["_b2Body_GetLinearVelocity"]=asm["_b2Body_GetLinearVelocity"];var _b2Body_SetMassData=Module["_b2Body_SetMassData"]=asm["_b2Body_SetMassData"];
var _b2MouseJointDef_Create=Module["_b2MouseJointDef_Create"]=asm["_b2MouseJointDef_Create"];var _b2ParticleSystem_GetColorBuffer=Module["_b2ParticleSystem_GetColorBuffer"]=asm["_b2ParticleSystem_GetColorBuffer"];var _b2DistanceJointDef_Create=Module["_b2DistanceJointDef_Create"]=asm["_b2DistanceJointDef_Create"];var _b2ParticleSystem_GetPositionBuffer=Module["_b2ParticleSystem_GetPositionBuffer"]=asm["_b2ParticleSystem_GetPositionBuffer"];
var _b2CircleShape_DestroyParticlesInShape=Module["_b2CircleShape_DestroyParticlesInShape"]=asm["_b2CircleShape_DestroyParticlesInShape"];var _b2World_QueryAABB=Module["_b2World_QueryAABB"]=asm["_b2World_QueryAABB"];var _b2PolygonShape_DestroyParticlesInShape_4=Module["_b2PolygonShape_DestroyParticlesInShape_4"]=asm["_b2PolygonShape_DestroyParticlesInShape_4"];var _b2RevoluteJointDef_InitializeAndCreate=Module["_b2RevoluteJointDef_InitializeAndCreate"]=asm["_b2RevoluteJointDef_InitializeAndCreate"];
var _b2GearJointDef_Create=Module["_b2GearJointDef_Create"]=asm["_b2GearJointDef_Create"];var _b2PrismaticJoint_IsLimitEnabled=Module["_b2PrismaticJoint_IsLimitEnabled"]=asm["_b2PrismaticJoint_IsLimitEnabled"];var _b2Contact_GetWorldManifold=Module["_b2Contact_GetWorldManifold"]=asm["_b2Contact_GetWorldManifold"];var _b2WheelJoint_SetSpringFrequencyHz=Module["_b2WheelJoint_SetSpringFrequencyHz"]=asm["_b2WheelJoint_SetSpringFrequencyHz"];var _b2Body_ApplyTorque=Module["_b2Body_ApplyTorque"]=asm["_b2Body_ApplyTorque"];
var _b2ParticleGroup_ApplyLinearImpulse=Module["_b2ParticleGroup_ApplyLinearImpulse"]=asm["_b2ParticleGroup_ApplyLinearImpulse"];var _b2PrismaticJointDef_InitializeAndCreate=Module["_b2PrismaticJointDef_InitializeAndCreate"]=asm["_b2PrismaticJointDef_InitializeAndCreate"];var _memset=Module["_memset"]=asm["_memset"];var _b2MotorJointDef_Create=Module["_b2MotorJointDef_Create"]=asm["_b2MotorJointDef_Create"];var _b2World_DestroyBody=Module["_b2World_DestroyBody"]=asm["_b2World_DestroyBody"];
var _b2RevoluteJointDef_Create=Module["_b2RevoluteJointDef_Create"]=asm["_b2RevoluteJointDef_Create"];var _b2ParticleGroup_GetParticleCount=Module["_b2ParticleGroup_GetParticleCount"]=asm["_b2ParticleGroup_GetParticleCount"];var _b2World_SetGravity=Module["_b2World_SetGravity"]=asm["_b2World_SetGravity"];var _b2PrismaticJoint_EnableMotor=Module["_b2PrismaticJoint_EnableMotor"]=asm["_b2PrismaticJoint_EnableMotor"];
var _b2PolygonShape_CreateParticleGroup_4=Module["_b2PolygonShape_CreateParticleGroup_4"]=asm["_b2PolygonShape_CreateParticleGroup_4"];var _b2PolygonShape_CreateFixture_8=Module["_b2PolygonShape_CreateFixture_8"]=asm["_b2PolygonShape_CreateFixture_8"];var _b2Body_SetAngularVelocity=Module["_b2Body_SetAngularVelocity"]=asm["_b2Body_SetAngularVelocity"];var _b2Body_GetWorldPoint=Module["_b2Body_GetWorldPoint"]=asm["_b2Body_GetWorldPoint"];
var _b2WheelJoint_SetMotorSpeed=Module["_b2WheelJoint_SetMotorSpeed"]=asm["_b2WheelJoint_SetMotorSpeed"];var _b2FrictionJointDef_InitializeAndCreate=Module["_b2FrictionJointDef_InitializeAndCreate"]=asm["_b2FrictionJointDef_InitializeAndCreate"];var _b2World_SetContactListener=Module["_b2World_SetContactListener"]=asm["_b2World_SetContactListener"];var _b2ParticleSystem_SetDamping=Module["_b2ParticleSystem_SetDamping"]=asm["_b2ParticleSystem_SetDamping"];
var _b2Body_SetType=Module["_b2Body_SetType"]=asm["_b2Body_SetType"];var _b2Body_SetTransform=Module["_b2Body_SetTransform"]=asm["_b2Body_SetTransform"];var _b2CircleShape_CreateFixture=Module["_b2CircleShape_CreateFixture"]=asm["_b2CircleShape_CreateFixture"];var _b2RevoluteJoint_GetJointAngle=Module["_b2RevoluteJoint_GetJointAngle"]=asm["_b2RevoluteJoint_GetJointAngle"];var _b2ParticleGroup_ApplyForce=Module["_b2ParticleGroup_ApplyForce"]=asm["_b2ParticleGroup_ApplyForce"];
var _malloc=Module["_malloc"]=asm["_malloc"];var _b2Contact_GetManifold=Module["_b2Contact_GetManifold"]=asm["_b2Contact_GetManifold"];var _b2RevoluteJoint_IsMotorEnabled=Module["_b2RevoluteJoint_IsMotorEnabled"]=asm["_b2RevoluteJoint_IsMotorEnabled"];var _b2ParticleSystem_GetVelocityBuffer=Module["_b2ParticleSystem_GetVelocityBuffer"]=asm["_b2ParticleSystem_GetVelocityBuffer"];var _b2RevoluteJoint_IsLimitEnabled=Module["_b2RevoluteJoint_IsLimitEnabled"]=asm["_b2RevoluteJoint_IsLimitEnabled"];
var _b2World_DestroyParticleSystem=Module["_b2World_DestroyParticleSystem"]=asm["_b2World_DestroyParticleSystem"];var _b2RevoluteJoint_EnableMotor=Module["_b2RevoluteJoint_EnableMotor"]=asm["_b2RevoluteJoint_EnableMotor"];var _b2Body_GetTransform=Module["_b2Body_GetTransform"]=asm["_b2Body_GetTransform"];var _b2WeldJointDef_InitializeAndCreate=Module["_b2WeldJointDef_InitializeAndCreate"]=asm["_b2WeldJointDef_InitializeAndCreate"];
var _b2EdgeShape_CreateFixture=Module["_b2EdgeShape_CreateFixture"]=asm["_b2EdgeShape_CreateFixture"];var _b2Body_GetType=Module["_b2Body_GetType"]=asm["_b2Body_GetType"];var _b2Manifold_GetPointCount=Module["_b2Manifold_GetPointCount"]=asm["_b2Manifold_GetPointCount"];var _b2ParticleSystem_SetDensity=Module["_b2ParticleSystem_SetDensity"]=asm["_b2ParticleSystem_SetDensity"];var _b2PrismaticJoint_GetMotorForce=Module["_b2PrismaticJoint_GetMotorForce"]=asm["_b2PrismaticJoint_GetMotorForce"];
var _b2Joint_GetBodyA=Module["_b2Joint_GetBodyA"]=asm["_b2Joint_GetBodyA"];var _b2PulleyJointDef_InitializeAndCreate=Module["_b2PulleyJointDef_InitializeAndCreate"]=asm["_b2PulleyJointDef_InitializeAndCreate"];var _b2Joint_GetBodyB=Module["_b2Joint_GetBodyB"]=asm["_b2Joint_GetBodyB"];var _b2ParticleSystem_GetParticleCount=Module["_b2ParticleSystem_GetParticleCount"]=asm["_b2ParticleSystem_GetParticleCount"];var _b2MouseJoint_SetTarget=Module["_b2MouseJoint_SetTarget"]=asm["_b2MouseJoint_SetTarget"];
var _b2Body_ApplyAngularImpulse=Module["_b2Body_ApplyAngularImpulse"]=asm["_b2Body_ApplyAngularImpulse"];var _b2ChainShape_CreateFixture=Module["_b2ChainShape_CreateFixture"]=asm["_b2ChainShape_CreateFixture"];var _b2World_DestroyJoint=Module["_b2World_DestroyJoint"]=asm["_b2World_DestroyJoint"];var _b2MotorJoint_SetAngularOffset=Module["_b2MotorJoint_SetAngularOffset"]=asm["_b2MotorJoint_SetAngularOffset"];var _b2World_Delete=Module["_b2World_Delete"]=asm["_b2World_Delete"];
var _b2PrismaticJoint_GetJointTranslation=Module["_b2PrismaticJoint_GetJointTranslation"]=asm["_b2PrismaticJoint_GetJointTranslation"];var _i64Add=Module["_i64Add"]=asm["_i64Add"];var _b2Body_GetMass=Module["_b2Body_GetMass"]=asm["_b2Body_GetMass"];var _b2Body_GetAngle=Module["_b2Body_GetAngle"]=asm["_b2Body_GetAngle"];var _b2ParticleGroup_GetBufferIndex=Module["_b2ParticleGroup_GetBufferIndex"]=asm["_b2ParticleGroup_GetBufferIndex"];
var _b2WheelJointDef_InitializeAndCreate=Module["_b2WheelJointDef_InitializeAndCreate"]=asm["_b2WheelJointDef_InitializeAndCreate"];var _b2World_Step=Module["_b2World_Step"]=asm["_b2World_Step"];var _b2PrismaticJointDef_Create=Module["_b2PrismaticJointDef_Create"]=asm["_b2PrismaticJointDef_Create"];var _b2WheelJointDef_Create=Module["_b2WheelJointDef_Create"]=asm["_b2WheelJointDef_Create"];var _b2PulleyJointDef_Create=Module["_b2PulleyJointDef_Create"]=asm["_b2PulleyJointDef_Create"];
var _b2Body_GetInertia=Module["_b2Body_GetInertia"]=asm["_b2Body_GetInertia"];var _memmove=Module["_memmove"]=asm["_memmove"];var _b2PrismaticJoint_SetMotorSpeed=Module["_b2PrismaticJoint_SetMotorSpeed"]=asm["_b2PrismaticJoint_SetMotorSpeed"];var __GLOBAL__I_a=Module["__GLOBAL__I_a"]=asm["__GLOBAL__I_a"];var runPostSets=Module["runPostSets"]=asm["runPostSets"];var dynCall_diiiiid=Module["dynCall_diiiiid"]=asm["dynCall_diiiiid"];var dynCall_ii=Module["dynCall_ii"]=asm["dynCall_ii"];
var dynCall_viiiii=Module["dynCall_viiiii"]=asm["dynCall_viiiii"];var dynCall_did=Module["dynCall_did"]=asm["dynCall_did"];var dynCall_vi=Module["dynCall_vi"]=asm["dynCall_vi"];var dynCall_diiiid=Module["dynCall_diiiid"]=asm["dynCall_diiiid"];var dynCall_vii=Module["dynCall_vii"]=asm["dynCall_vii"];var dynCall_iiii=Module["dynCall_iiii"]=asm["dynCall_iiii"];var dynCall_viii=Module["dynCall_viii"]=asm["dynCall_viii"];var dynCall_v=Module["dynCall_v"]=asm["dynCall_v"];
var dynCall_viid=Module["dynCall_viid"]=asm["dynCall_viid"];var dynCall_iiiii=Module["dynCall_iiiii"]=asm["dynCall_iiiii"];var dynCall_viiiiii=Module["dynCall_viiiiii"]=asm["dynCall_viiiiii"];var dynCall_iii=Module["dynCall_iii"]=asm["dynCall_iii"];var dynCall_iiiiii=Module["dynCall_iiiiii"]=asm["dynCall_iiiiii"];var dynCall_viiii=Module["dynCall_viiii"]=asm["dynCall_viiii"];Runtime.stackAlloc=asm["stackAlloc"];Runtime.stackSave=asm["stackSave"];Runtime.stackRestore=asm["stackRestore"];
Runtime.setTempRet0=asm["setTempRet0"];Runtime.getTempRet0=asm["getTempRet0"];
var i64Math=function(){var goog={math:{}};goog.math.Long=function(low,high){this.low_=low|0;this.high_=high|0};goog.math.Long.IntCache_={};goog.math.Long.fromInt=function(value){if(-128<=value&&value<128){var cachedObj=goog.math.Long.IntCache_[value];if(cachedObj)return cachedObj}var obj=new goog.math.Long(value|0,value<0?-1:0);if(-128<=value&&value<128)goog.math.Long.IntCache_[value]=obj;return obj};goog.math.Long.fromNumber=function(value){if(isNaN(value)||!isFinite(value))return goog.math.Long.ZERO;
else if(value<=-goog.math.Long.TWO_PWR_63_DBL_)return goog.math.Long.MIN_VALUE;else if(value+1>=goog.math.Long.TWO_PWR_63_DBL_)return goog.math.Long.MAX_VALUE;else if(value<0)return goog.math.Long.fromNumber(-value).negate();else return new goog.math.Long(value%goog.math.Long.TWO_PWR_32_DBL_|0,value/goog.math.Long.TWO_PWR_32_DBL_|0)};goog.math.Long.fromBits=function(lowBits,highBits){return new goog.math.Long(lowBits,highBits)};goog.math.Long.fromString=function(str,opt_radix){if(str.length==0)throw Error("number format error: empty string");
var radix=opt_radix||10;if(radix<2||36<radix)throw Error("radix out of range: "+radix);if(str.charAt(0)=="-")return goog.math.Long.fromString(str.substring(1),radix).negate();else if(str.indexOf("-")>=0)throw Error('number format error: interior "-" character: '+str);var radixToPower=goog.math.Long.fromNumber(Math.pow(radix,8));var result=goog.math.Long.ZERO;for(var i=0;i<str.length;i+=8){var size=Math.min(8,str.length-i);var value=parseInt(str.substring(i,i+size),radix);if(size<8){var power=goog.math.Long.fromNumber(Math.pow(radix,
size));result=result.multiply(power).add(goog.math.Long.fromNumber(value))}else{result=result.multiply(radixToPower);result=result.add(goog.math.Long.fromNumber(value))}}return result};goog.math.Long.TWO_PWR_16_DBL_=1<<16;goog.math.Long.TWO_PWR_24_DBL_=1<<24;goog.math.Long.TWO_PWR_32_DBL_=goog.math.Long.TWO_PWR_16_DBL_*goog.math.Long.TWO_PWR_16_DBL_;goog.math.Long.TWO_PWR_31_DBL_=goog.math.Long.TWO_PWR_32_DBL_/2;goog.math.Long.TWO_PWR_48_DBL_=goog.math.Long.TWO_PWR_32_DBL_*goog.math.Long.TWO_PWR_16_DBL_;
goog.math.Long.TWO_PWR_64_DBL_=goog.math.Long.TWO_PWR_32_DBL_*goog.math.Long.TWO_PWR_32_DBL_;goog.math.Long.TWO_PWR_63_DBL_=goog.math.Long.TWO_PWR_64_DBL_/2;goog.math.Long.ZERO=goog.math.Long.fromInt(0);goog.math.Long.ONE=goog.math.Long.fromInt(1);goog.math.Long.NEG_ONE=goog.math.Long.fromInt(-1);goog.math.Long.MAX_VALUE=goog.math.Long.fromBits(4294967295|0,2147483647|0);goog.math.Long.MIN_VALUE=goog.math.Long.fromBits(0,2147483648|0);goog.math.Long.TWO_PWR_24_=goog.math.Long.fromInt(1<<24);goog.math.Long.prototype.toInt=
function(){return this.low_};goog.math.Long.prototype.toNumber=function(){return this.high_*goog.math.Long.TWO_PWR_32_DBL_+this.getLowBitsUnsigned()};goog.math.Long.prototype.toString=function(opt_radix){var radix=opt_radix||10;if(radix<2||36<radix)throw Error("radix out of range: "+radix);if(this.isZero())return"0";if(this.isNegative())if(this.equals(goog.math.Long.MIN_VALUE)){var radixLong=goog.math.Long.fromNumber(radix);var div=this.div(radixLong);var rem=div.multiply(radixLong).subtract(this);
return div.toString(radix)+rem.toInt().toString(radix)}else return"-"+this.negate().toString(radix);var radixToPower=goog.math.Long.fromNumber(Math.pow(radix,6));var rem=this;var result="";while(true){var remDiv=rem.div(radixToPower);var intval=rem.subtract(remDiv.multiply(radixToPower)).toInt();var digits=intval.toString(radix);rem=remDiv;if(rem.isZero())return digits+result;else{while(digits.length<6)digits="0"+digits;result=""+digits+result}}};goog.math.Long.prototype.getHighBits=function(){return this.high_};
goog.math.Long.prototype.getLowBits=function(){return this.low_};goog.math.Long.prototype.getLowBitsUnsigned=function(){return this.low_>=0?this.low_:goog.math.Long.TWO_PWR_32_DBL_+this.low_};goog.math.Long.prototype.getNumBitsAbs=function(){if(this.isNegative())if(this.equals(goog.math.Long.MIN_VALUE))return 64;else return this.negate().getNumBitsAbs();else{var val=this.high_!=0?this.high_:this.low_;for(var bit=31;bit>0;bit--)if((val&1<<bit)!=0)break;return this.high_!=0?bit+33:bit+1}};goog.math.Long.prototype.isZero=
function(){return this.high_==0&&this.low_==0};goog.math.Long.prototype.isNegative=function(){return this.high_<0};goog.math.Long.prototype.isOdd=function(){return(this.low_&1)==1};goog.math.Long.prototype.equals=function(other){return this.high_==other.high_&&this.low_==other.low_};goog.math.Long.prototype.notEquals=function(other){return this.high_!=other.high_||this.low_!=other.low_};goog.math.Long.prototype.lessThan=function(other){return this.compare(other)<0};goog.math.Long.prototype.lessThanOrEqual=
function(other){return this.compare(other)<=0};goog.math.Long.prototype.greaterThan=function(other){return this.compare(other)>0};goog.math.Long.prototype.greaterThanOrEqual=function(other){return this.compare(other)>=0};goog.math.Long.prototype.compare=function(other){if(this.equals(other))return 0;var thisNeg=this.isNegative();var otherNeg=other.isNegative();if(thisNeg&&!otherNeg)return-1;if(!thisNeg&&otherNeg)return 1;if(this.subtract(other).isNegative())return-1;else return 1};goog.math.Long.prototype.negate=
function(){if(this.equals(goog.math.Long.MIN_VALUE))return goog.math.Long.MIN_VALUE;else return this.not().add(goog.math.Long.ONE)};goog.math.Long.prototype.add=function(other){var a48=this.high_>>>16;var a32=this.high_&65535;var a16=this.low_>>>16;var a00=this.low_&65535;var b48=other.high_>>>16;var b32=other.high_&65535;var b16=other.low_>>>16;var b00=other.low_&65535;var c48=0,c32=0,c16=0,c00=0;c00+=a00+b00;c16+=c00>>>16;c00&=65535;c16+=a16+b16;c32+=c16>>>16;c16&=65535;c32+=a32+b32;c48+=c32>>>
16;c32&=65535;c48+=a48+b48;c48&=65535;return goog.math.Long.fromBits(c16<<16|c00,c48<<16|c32)};goog.math.Long.prototype.subtract=function(other){return this.add(other.negate())};goog.math.Long.prototype.multiply=function(other){if(this.isZero())return goog.math.Long.ZERO;else if(other.isZero())return goog.math.Long.ZERO;if(this.equals(goog.math.Long.MIN_VALUE))return other.isOdd()?goog.math.Long.MIN_VALUE:goog.math.Long.ZERO;else if(other.equals(goog.math.Long.MIN_VALUE))return this.isOdd()?goog.math.Long.MIN_VALUE:
goog.math.Long.ZERO;if(this.isNegative())if(other.isNegative())return this.negate().multiply(other.negate());else return this.negate().multiply(other).negate();else if(other.isNegative())return this.multiply(other.negate()).negate();if(this.lessThan(goog.math.Long.TWO_PWR_24_)&&other.lessThan(goog.math.Long.TWO_PWR_24_))return goog.math.Long.fromNumber(this.toNumber()*other.toNumber());var a48=this.high_>>>16;var a32=this.high_&65535;var a16=this.low_>>>16;var a00=this.low_&65535;var b48=other.high_>>>
16;var b32=other.high_&65535;var b16=other.low_>>>16;var b00=other.low_&65535;var c48=0,c32=0,c16=0,c00=0;c00+=a00*b00;c16+=c00>>>16;c00&=65535;c16+=a16*b00;c32+=c16>>>16;c16&=65535;c16+=a00*b16;c32+=c16>>>16;c16&=65535;c32+=a32*b00;c48+=c32>>>16;c32&=65535;c32+=a16*b16;c48+=c32>>>16;c32&=65535;c32+=a00*b32;c48+=c32>>>16;c32&=65535;c48+=a48*b00+a32*b16+a16*b32+a00*b48;c48&=65535;return goog.math.Long.fromBits(c16<<16|c00,c48<<16|c32)};goog.math.Long.prototype.div=function(other){if(other.isZero())throw Error("division by zero");
else if(this.isZero())return goog.math.Long.ZERO;if(this.equals(goog.math.Long.MIN_VALUE))if(other.equals(goog.math.Long.ONE)||other.equals(goog.math.Long.NEG_ONE))return goog.math.Long.MIN_VALUE;else if(other.equals(goog.math.Long.MIN_VALUE))return goog.math.Long.ONE;else{var halfThis=this.shiftRight(1);var approx=halfThis.div(other).shiftLeft(1);if(approx.equals(goog.math.Long.ZERO))return other.isNegative()?goog.math.Long.ONE:goog.math.Long.NEG_ONE;else{var rem=this.subtract(other.multiply(approx));
var result=approx.add(rem.div(other));return result}}else if(other.equals(goog.math.Long.MIN_VALUE))return goog.math.Long.ZERO;if(this.isNegative())if(other.isNegative())return this.negate().div(other.negate());else return this.negate().div(other).negate();else if(other.isNegative())return this.div(other.negate()).negate();var res=goog.math.Long.ZERO;var rem=this;while(rem.greaterThanOrEqual(other)){var approx=Math.max(1,Math.floor(rem.toNumber()/other.toNumber()));var log2=Math.ceil(Math.log(approx)/
Math.LN2);var delta=log2<=48?1:Math.pow(2,log2-48);var approxRes=goog.math.Long.fromNumber(approx);var approxRem=approxRes.multiply(other);while(approxRem.isNegative()||approxRem.greaterThan(rem)){approx-=delta;approxRes=goog.math.Long.fromNumber(approx);approxRem=approxRes.multiply(other)}if(approxRes.isZero())approxRes=goog.math.Long.ONE;res=res.add(approxRes);rem=rem.subtract(approxRem)}return res};goog.math.Long.prototype.modulo=function(other){return this.subtract(this.div(other).multiply(other))};
goog.math.Long.prototype.not=function(){return goog.math.Long.fromBits(~this.low_,~this.high_)};goog.math.Long.prototype.and=function(other){return goog.math.Long.fromBits(this.low_&other.low_,this.high_&other.high_)};goog.math.Long.prototype.or=function(other){return goog.math.Long.fromBits(this.low_|other.low_,this.high_|other.high_)};goog.math.Long.prototype.xor=function(other){return goog.math.Long.fromBits(this.low_^other.low_,this.high_^other.high_)};goog.math.Long.prototype.shiftLeft=function(numBits){numBits&=
63;if(numBits==0)return this;else{var low=this.low_;if(numBits<32){var high=this.high_;return goog.math.Long.fromBits(low<<numBits,high<<numBits|low>>>32-numBits)}else return goog.math.Long.fromBits(0,low<<numBits-32)}};goog.math.Long.prototype.shiftRight=function(numBits){numBits&=63;if(numBits==0)return this;else{var high=this.high_;if(numBits<32){var low=this.low_;return goog.math.Long.fromBits(low>>>numBits|high<<32-numBits,high>>numBits)}else return goog.math.Long.fromBits(high>>numBits-32,high>=
0?0:-1)}};goog.math.Long.prototype.shiftRightUnsigned=function(numBits){numBits&=63;if(numBits==0)return this;else{var high=this.high_;if(numBits<32){var low=this.low_;return goog.math.Long.fromBits(low>>>numBits|high<<32-numBits,high>>>numBits)}else if(numBits==32)return goog.math.Long.fromBits(high,0);else return goog.math.Long.fromBits(high>>>numBits-32,0)}};var navigator={appName:"Modern Browser"};var dbits;var canary=0xdeadbeefcafe;var j_lm=(canary&16777215)==15715070;function BigInteger(a,b,
c){if(a!=null)if("number"==typeof a)this.fromNumber(a,b,c);else if(b==null&&"string"!=typeof a)this.fromString(a,256);else this.fromString(a,b)}function nbi(){return new BigInteger(null)}function am1(i,x,w,j,c,n){while(--n>=0){var v=x*this[i++]+w[j]+c;c=Math.floor(v/67108864);w[j++]=v&67108863}return c}function am2(i,x,w,j,c,n){var xl=x&32767,xh=x>>15;while(--n>=0){var l=this[i]&32767;var h=this[i++]>>15;var m=xh*l+h*xl;l=xl*l+((m&32767)<<15)+w[j]+(c&1073741823);c=(l>>>30)+(m>>>15)+xh*h+(c>>>30);
w[j++]=l&1073741823}return c}function am3(i,x,w,j,c,n){var xl=x&16383,xh=x>>14;while(--n>=0){var l=this[i]&16383;var h=this[i++]>>14;var m=xh*l+h*xl;l=xl*l+((m&16383)<<14)+w[j]+c;c=(l>>28)+(m>>14)+xh*h;w[j++]=l&268435455}return c}if(j_lm&&navigator.appName=="Microsoft Internet Explorer"){BigInteger.prototype.am=am2;dbits=30}else if(j_lm&&navigator.appName!="Netscape"){BigInteger.prototype.am=am1;dbits=26}else{BigInteger.prototype.am=am3;dbits=28}BigInteger.prototype.DB=dbits;BigInteger.prototype.DM=
(1<<dbits)-1;BigInteger.prototype.DV=1<<dbits;var BI_FP=52;BigInteger.prototype.FV=Math.pow(2,BI_FP);BigInteger.prototype.F1=BI_FP-dbits;BigInteger.prototype.F2=2*dbits-BI_FP;var BI_RM="0123456789abcdefghijklmnopqrstuvwxyz";var BI_RC=new Array;var rr,vv;rr="0".charCodeAt(0);for(vv=0;vv<=9;++vv)BI_RC[rr++]=vv;rr="a".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;rr="A".charCodeAt(0);for(vv=10;vv<36;++vv)BI_RC[rr++]=vv;function int2char(n){return BI_RM.charAt(n)}function intAt(s,i){var c=BI_RC[s.charCodeAt(i)];
return c==null?-1:c}function bnpCopyTo(r){for(var i=this.t-1;i>=0;--i)r[i]=this[i];r.t=this.t;r.s=this.s}function bnpFromInt(x){this.t=1;this.s=x<0?-1:0;if(x>0)this[0]=x;else if(x<-1)this[0]=x+DV;else this.t=0}function nbv(i){var r=nbi();r.fromInt(i);return r}function bnpFromString(s,b){var k;if(b==16)k=4;else if(b==8)k=3;else if(b==256)k=8;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else{this.fromRadix(s,b);return}this.t=0;this.s=0;var i=s.length,mi=false,sh=0;while(--i>=0){var x=k==8?s[i]&
255:intAt(s,i);if(x<0){if(s.charAt(i)=="-")mi=true;continue}mi=false;if(sh==0)this[this.t++]=x;else if(sh+k>this.DB){this[this.t-1]|=(x&(1<<this.DB-sh)-1)<<sh;this[this.t++]=x>>this.DB-sh}else this[this.t-1]|=x<<sh;sh+=k;if(sh>=this.DB)sh-=this.DB}if(k==8&&(s[0]&128)!=0){this.s=-1;if(sh>0)this[this.t-1]|=(1<<this.DB-sh)-1<<sh}this.clamp();if(mi)BigInteger.ZERO.subTo(this,this)}function bnpClamp(){var c=this.s&this.DM;while(this.t>0&&this[this.t-1]==c)--this.t}function bnToString(b){if(this.s<0)return"-"+
this.negate().toString(b);var k;if(b==16)k=4;else if(b==8)k=3;else if(b==2)k=1;else if(b==32)k=5;else if(b==4)k=2;else return this.toRadix(b);var km=(1<<k)-1,d,m=false,r="",i=this.t;var p=this.DB-i*this.DB%k;if(i-- >0){if(p<this.DB&&(d=this[i]>>p)>0){m=true;r=int2char(d)}while(i>=0){if(p<k){d=(this[i]&(1<<p)-1)<<k-p;d|=this[--i]>>(p+=this.DB-k)}else{d=this[i]>>(p-=k)&km;if(p<=0){p+=this.DB;--i}}if(d>0)m=true;if(m)r+=int2char(d)}}return m?r:"0"}function bnNegate(){var r=nbi();BigInteger.ZERO.subTo(this,
r);return r}function bnAbs(){return this.s<0?this.negate():this}function bnCompareTo(a){var r=this.s-a.s;if(r!=0)return r;var i=this.t;r=i-a.t;if(r!=0)return this.s<0?-r:r;while(--i>=0)if((r=this[i]-a[i])!=0)return r;return 0}function nbits(x){var r=1,t;if((t=x>>>16)!=0){x=t;r+=16}if((t=x>>8)!=0){x=t;r+=8}if((t=x>>4)!=0){x=t;r+=4}if((t=x>>2)!=0){x=t;r+=2}if((t=x>>1)!=0){x=t;r+=1}return r}function bnBitLength(){if(this.t<=0)return 0;return this.DB*(this.t-1)+nbits(this[this.t-1]^this.s&this.DM)}function bnpDLShiftTo(n,
r){var i;for(i=this.t-1;i>=0;--i)r[i+n]=this[i];for(i=n-1;i>=0;--i)r[i]=0;r.t=this.t+n;r.s=this.s}function bnpDRShiftTo(n,r){for(var i=n;i<this.t;++i)r[i-n]=this[i];r.t=Math.max(this.t-n,0);r.s=this.s}function bnpLShiftTo(n,r){var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<cbs)-1;var ds=Math.floor(n/this.DB),c=this.s<<bs&this.DM,i;for(i=this.t-1;i>=0;--i){r[i+ds+1]=this[i]>>cbs|c;c=(this[i]&bm)<<bs}for(i=ds-1;i>=0;--i)r[i]=0;r[ds]=c;r.t=this.t+ds+1;r.s=this.s;r.clamp()}function bnpRShiftTo(n,r){r.s=
this.s;var ds=Math.floor(n/this.DB);if(ds>=this.t){r.t=0;return}var bs=n%this.DB;var cbs=this.DB-bs;var bm=(1<<bs)-1;r[0]=this[ds]>>bs;for(var i=ds+1;i<this.t;++i){r[i-ds-1]|=(this[i]&bm)<<cbs;r[i-ds]=this[i]>>bs}if(bs>0)r[this.t-ds-1]|=(this.s&bm)<<cbs;r.t=this.t-ds;r.clamp()}function bnpSubTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this[i]-a[i];r[i++]=c&this.DM;c>>=this.DB}if(a.t<this.t){c-=a.s;while(i<this.t){c+=this[i];r[i++]=c&this.DM;c>>=this.DB}c+=this.s}else{c+=this.s;while(i<
a.t){c-=a[i];r[i++]=c&this.DM;c>>=this.DB}c-=a.s}r.s=c<0?-1:0;if(c<-1)r[i++]=this.DV+c;else if(c>0)r[i++]=c;r.t=i;r.clamp()}function bnpMultiplyTo(a,r){var x=this.abs(),y=a.abs();var i=x.t;r.t=i+y.t;while(--i>=0)r[i]=0;for(i=0;i<y.t;++i)r[i+x.t]=x.am(0,y[i],r,i,0,x.t);r.s=0;r.clamp();if(this.s!=a.s)BigInteger.ZERO.subTo(r,r)}function bnpSquareTo(r){var x=this.abs();var i=r.t=2*x.t;while(--i>=0)r[i]=0;for(i=0;i<x.t-1;++i){var c=x.am(i,x[i],r,2*i,0,1);if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1))>=
x.DV){r[i+x.t]-=x.DV;r[i+x.t+1]=1}}if(r.t>0)r[r.t-1]+=x.am(i,x[i],r,2*i,0,1);r.s=0;r.clamp()}function bnpDivRemTo(m,q,r){var pm=m.abs();if(pm.t<=0)return;var pt=this.abs();if(pt.t<pm.t){if(q!=null)q.fromInt(0);if(r!=null)this.copyTo(r);return}if(r==null)r=nbi();var y=nbi(),ts=this.s,ms=m.s;var nsh=this.DB-nbits(pm[pm.t-1]);if(nsh>0){pm.lShiftTo(nsh,y);pt.lShiftTo(nsh,r)}else{pm.copyTo(y);pt.copyTo(r)}var ys=y.t;var y0=y[ys-1];if(y0==0)return;var yt=y0*(1<<this.F1)+(ys>1?y[ys-2]>>this.F2:0);var d1=
this.FV/yt,d2=(1<<this.F1)/yt,e=1<<this.F2;var i=r.t,j=i-ys,t=q==null?nbi():q;y.dlShiftTo(j,t);if(r.compareTo(t)>=0){r[r.t++]=1;r.subTo(t,r)}BigInteger.ONE.dlShiftTo(ys,t);t.subTo(y,y);while(y.t<ys)y[y.t++]=0;while(--j>=0){var qd=r[--i]==y0?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);if((r[i]+=y.am(0,qd,r,j,0,ys))<qd){y.dlShiftTo(j,t);r.subTo(t,r);while(r[i]<--qd)r.subTo(t,r)}}if(q!=null){r.drShiftTo(ys,q);if(ts!=ms)BigInteger.ZERO.subTo(q,q)}r.t=ys;r.clamp();if(nsh>0)r.rShiftTo(nsh,r);if(ts<0)BigInteger.ZERO.subTo(r,
r)}function bnMod(a){var r=nbi();this.abs().divRemTo(a,null,r);if(this.s<0&&r.compareTo(BigInteger.ZERO)>0)a.subTo(r,r);return r}function Classic(m){this.m=m}function cConvert(x){if(x.s<0||x.compareTo(this.m)>=0)return x.mod(this.m);else return x}function cRevert(x){return x}function cReduce(x){x.divRemTo(this.m,null,x)}function cMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}function cSqrTo(x,r){x.squareTo(r);this.reduce(r)}Classic.prototype.convert=cConvert;Classic.prototype.revert=cRevert;Classic.prototype.reduce=
cReduce;Classic.prototype.mulTo=cMulTo;Classic.prototype.sqrTo=cSqrTo;function bnpInvDigit(){if(this.t<1)return 0;var x=this[0];if((x&1)==0)return 0;var y=x&3;y=y*(2-(x&15)*y)&15;y=y*(2-(x&255)*y)&255;y=y*(2-((x&65535)*y&65535))&65535;y=y*(2-x*y%this.DV)%this.DV;return y>0?this.DV-y:-y}function Montgomery(m){this.m=m;this.mp=m.invDigit();this.mpl=this.mp&32767;this.mph=this.mp>>15;this.um=(1<<m.DB-15)-1;this.mt2=2*m.t}function montConvert(x){var r=nbi();x.abs().dlShiftTo(this.m.t,r);r.divRemTo(this.m,
null,r);if(x.s<0&&r.compareTo(BigInteger.ZERO)>0)this.m.subTo(r,r);return r}function montRevert(x){var r=nbi();x.copyTo(r);this.reduce(r);return r}function montReduce(x){while(x.t<=this.mt2)x[x.t++]=0;for(var i=0;i<this.m.t;++i){var j=x[i]&32767;var u0=j*this.mpl+((j*this.mph+(x[i]>>15)*this.mpl&this.um)<<15)&x.DM;j=i+this.m.t;x[j]+=this.m.am(0,u0,x,i,0,this.m.t);while(x[j]>=x.DV){x[j]-=x.DV;x[++j]++}}x.clamp();x.drShiftTo(this.m.t,x);if(x.compareTo(this.m)>=0)x.subTo(this.m,x)}function montSqrTo(x,
r){x.squareTo(r);this.reduce(r)}function montMulTo(x,y,r){x.multiplyTo(y,r);this.reduce(r)}Montgomery.prototype.convert=montConvert;Montgomery.prototype.revert=montRevert;Montgomery.prototype.reduce=montReduce;Montgomery.prototype.mulTo=montMulTo;Montgomery.prototype.sqrTo=montSqrTo;function bnpIsEven(){return(this.t>0?this[0]&1:this.s)==0}function bnpExp(e,z){if(e>4294967295||e<1)return BigInteger.ONE;var r=nbi(),r2=nbi(),g=z.convert(this),i=nbits(e)-1;g.copyTo(r);while(--i>=0){z.sqrTo(r,r2);if((e&
1<<i)>0)z.mulTo(r2,g,r);else{var t=r;r=r2;r2=t}}return z.revert(r)}function bnModPowInt(e,m){var z;if(e<256||m.isEven())z=new Classic(m);else z=new Montgomery(m);return this.exp(e,z)}BigInteger.prototype.copyTo=bnpCopyTo;BigInteger.prototype.fromInt=bnpFromInt;BigInteger.prototype.fromString=bnpFromString;BigInteger.prototype.clamp=bnpClamp;BigInteger.prototype.dlShiftTo=bnpDLShiftTo;BigInteger.prototype.drShiftTo=bnpDRShiftTo;BigInteger.prototype.lShiftTo=bnpLShiftTo;BigInteger.prototype.rShiftTo=
bnpRShiftTo;BigInteger.prototype.subTo=bnpSubTo;BigInteger.prototype.multiplyTo=bnpMultiplyTo;BigInteger.prototype.squareTo=bnpSquareTo;BigInteger.prototype.divRemTo=bnpDivRemTo;BigInteger.prototype.invDigit=bnpInvDigit;BigInteger.prototype.isEven=bnpIsEven;BigInteger.prototype.exp=bnpExp;BigInteger.prototype.toString=bnToString;BigInteger.prototype.negate=bnNegate;BigInteger.prototype.abs=bnAbs;BigInteger.prototype.compareTo=bnCompareTo;BigInteger.prototype.bitLength=bnBitLength;BigInteger.prototype.mod=
bnMod;BigInteger.prototype.modPowInt=bnModPowInt;BigInteger.ZERO=nbv(0);BigInteger.ONE=nbv(1);function bnpFromRadix(s,b){this.fromInt(0);if(b==null)b=10;var cs=this.chunkSize(b);var d=Math.pow(b,cs),mi=false,j=0,w=0;for(var i=0;i<s.length;++i){var x=intAt(s,i);if(x<0){if(s.charAt(i)=="-"&&this.signum()==0)mi=true;continue}w=b*w+x;if(++j>=cs){this.dMultiply(d);this.dAddOffset(w,0);j=0;w=0}}if(j>0){this.dMultiply(Math.pow(b,j));this.dAddOffset(w,0)}if(mi)BigInteger.ZERO.subTo(this,this)}function bnpChunkSize(r){return Math.floor(Math.LN2*
this.DB/Math.log(r))}function bnSigNum(){if(this.s<0)return-1;else if(this.t<=0||this.t==1&&this[0]<=0)return 0;else return 1}function bnpDMultiply(n){this[this.t]=this.am(0,n-1,this,0,0,this.t);++this.t;this.clamp()}function bnpDAddOffset(n,w){if(n==0)return;while(this.t<=w)this[this.t++]=0;this[w]+=n;while(this[w]>=this.DV){this[w]-=this.DV;if(++w>=this.t)this[this.t++]=0;++this[w]}}function bnpToRadix(b){if(b==null)b=10;if(this.signum()==0||b<2||b>36)return"0";var cs=this.chunkSize(b);var a=Math.pow(b,
cs);var d=nbv(a),y=nbi(),z=nbi(),r="";this.divRemTo(d,y,z);while(y.signum()>0){r=(a+z.intValue()).toString(b).substr(1)+r;y.divRemTo(d,y,z)}return z.intValue().toString(b)+r}function bnIntValue(){if(this.s<0)if(this.t==1)return this[0]-this.DV;else{if(this.t==0)return-1}else if(this.t==1)return this[0];else if(this.t==0)return 0;return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]}function bnpAddTo(a,r){var i=0,c=0,m=Math.min(a.t,this.t);while(i<m){c+=this[i]+a[i];r[i++]=c&this.DM;c>>=this.DB}if(a.t<
this.t){c+=a.s;while(i<this.t){c+=this[i];r[i++]=c&this.DM;c>>=this.DB}c+=this.s}else{c+=this.s;while(i<a.t){c+=a[i];r[i++]=c&this.DM;c>>=this.DB}c+=a.s}r.s=c<0?-1:0;if(c>0)r[i++]=c;else if(c<-1)r[i++]=this.DV+c;r.t=i;r.clamp()}BigInteger.prototype.fromRadix=bnpFromRadix;BigInteger.prototype.chunkSize=bnpChunkSize;BigInteger.prototype.signum=bnSigNum;BigInteger.prototype.dMultiply=bnpDMultiply;BigInteger.prototype.dAddOffset=bnpDAddOffset;BigInteger.prototype.toRadix=bnpToRadix;BigInteger.prototype.intValue=
bnIntValue;BigInteger.prototype.addTo=bnpAddTo;var Wrapper={abs:function(l,h){var x=new goog.math.Long(l,h);var ret;if(x.isNegative())ret=x.negate();else ret=x;HEAP32[tempDoublePtr>>2]=ret.low_;HEAP32[tempDoublePtr+4>>2]=ret.high_},ensureTemps:function(){if(Wrapper.ensuredTemps)return;Wrapper.ensuredTemps=true;Wrapper.two32=new BigInteger;Wrapper.two32.fromString("4294967296",10);Wrapper.two64=new BigInteger;Wrapper.two64.fromString("18446744073709551616",10);Wrapper.temp1=new BigInteger;Wrapper.temp2=
new BigInteger},lh2bignum:function(l,h){var a=new BigInteger;a.fromString(h.toString(),10);var b=new BigInteger;a.multiplyTo(Wrapper.two32,b);var c=new BigInteger;c.fromString(l.toString(),10);var d=new BigInteger;c.addTo(b,d);return d},stringify:function(l,h,unsigned){var ret=(new goog.math.Long(l,h)).toString();if(unsigned&&ret[0]=="-"){Wrapper.ensureTemps();var bignum=new BigInteger;bignum.fromString(ret,10);ret=new BigInteger;Wrapper.two64.addTo(bignum,ret);ret=ret.toString(10)}return ret},fromString:function(str,
base,min,max,unsigned){Wrapper.ensureTemps();var bignum=new BigInteger;bignum.fromString(str,base);var bigmin=new BigInteger;bigmin.fromString(min,10);var bigmax=new BigInteger;bigmax.fromString(max,10);if(unsigned&&bignum.compareTo(BigInteger.ZERO)<0){var temp=new BigInteger;bignum.addTo(Wrapper.two64,temp);bignum=temp}var error=false;if(bignum.compareTo(bigmin)<0){bignum=bigmin;error=true}else if(bignum.compareTo(bigmax)>0){bignum=bigmax;error=true}var ret=goog.math.Long.fromString(bignum.toString());
HEAP32[tempDoublePtr>>2]=ret.low_;HEAP32[tempDoublePtr+4>>2]=ret.high_;if(error)throw"range error";}};return Wrapper}();
if(memoryInitializer)if(ENVIRONMENT_IS_NODE||ENVIRONMENT_IS_SHELL){var data=Module["readBinary"](memoryInitializer);HEAPU8.set(data,STATIC_BASE)}else{addRunDependency("memory initializer");Browser.asyncLoad(memoryInitializer,function(data){HEAPU8.set(data,STATIC_BASE);removeRunDependency("memory initializer")},function(data){throw"could not load memory initializer "+memoryInitializer;})}
function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}ExitStatus.prototype=new Error;ExitStatus.prototype.constructor=ExitStatus;var initialStackTop;var preloadStartTime=null;var calledMain=false;dependenciesFulfilled=function runCaller(){if(!Module["calledRun"]&&shouldRunNow)run();if(!Module["calledRun"])dependenciesFulfilled=runCaller};
Module["callMain"]=Module.callMain=function callMain(args){assert(runDependencies==0,"cannot call main when async dependencies remain! (listen on __ATMAIN__)");assert(__ATPRERUN__.length==0,"cannot call main when preRun functions remain to be called");args=args||[];ensureInitRuntime();var argc=args.length+1;function pad(){for(var i=0;i<4-1;i++)argv.push(0)}var argv=[allocate(intArrayFromString("/bin/this.program"),"i8",ALLOC_NORMAL)];pad();for(var i=0;i<argc-1;i=i+1){argv.push(allocate(intArrayFromString(args[i]),
"i8",ALLOC_NORMAL));pad()}argv.push(0);argv=allocate(argv,"i32",ALLOC_NORMAL);initialStackTop=STACKTOP;try{var ret=Module["_main"](argc,argv,0);if(!Module["noExitRuntime"])exit(ret)}catch(e){if(e instanceof ExitStatus)return;else if(e=="SimulateInfiniteLoop"){Module["noExitRuntime"]=true;return}else{if(e&&typeof e==="object"&&e.stack)Module.printErr("exception thrown: "+[e,e.stack]);throw e;}}finally{calledMain=true}};
function run(args){args=args||Module["arguments"];if(preloadStartTime===null)preloadStartTime=Date.now();if(runDependencies>0){Module.printErr("run() called, but dependencies remain, so not running");return}preRun();if(runDependencies>0)return;if(Module["calledRun"])return;function doRun(){if(Module["calledRun"])return;Module["calledRun"]=true;ensureInitRuntime();preMain();if(ENVIRONMENT_IS_WEB&&preloadStartTime!==null)Module.printErr("pre-main prep time: "+(Date.now()-preloadStartTime)+" ms");if(Module["_main"]&&
shouldRunNow)Module["callMain"](args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);if(!ABORT)doRun()},1)}else doRun()}Module["run"]=Module.run=run;function exit(status){ABORT=true;EXITSTATUS=status;STACKTOP=initialStackTop;exitRuntime();throw new ExitStatus(status);}Module["exit"]=Module.exit=exit;
function abort(text){if(text){Module.print(text);Module.printErr(text)}ABORT=true;EXITSTATUS=1;var extra="\nIf this abort() is unexpected, build with -s ASSERTIONS=1 which can give more information.";throw"abort() at "+stackTrace()+extra;}Module["abort"]=Module.abort=abort;if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0)Module["preInit"].pop()()}var shouldRunNow=true;if(Module["noInitialRun"])shouldRunNow=false;run();var Offsets={b2Body:{type:0,islandIndex:8,xf:12,xf0:28,sweep:44,linearVelocity:80,angularVelocity:88,force:92,torque:100,world:104,prev:108,next:112,fixtureList:116,fixtureCount:120,jointList:124,contactList:128,mass:132,invMass:136,I:140,invI:144,linearDamping:148,angularDamping:152,gravityScale:156,sleepTime:160,userData:164},b2Contact:{flags:4,prev:8,next:12,nodeA:16,nodeB:32,fixtureA:48,fixtureB:52,indexA:56,indexB:60,manifold:64,toiCount:128,toi:132,friction:136,restitution:140,tangentSpeed:144},
b2Fixture:{density:0,next:4,body:8,shape:12,friction:16,restitution:20,proxies:24,proxyCount:28,filter:32,isSensor:38,userData:40},b2ParticleGroup:{system:0,firstIndex:4,lastIndex:8,groupFlags:12,strength:16,prev:20,next:24,timestamp:28,mass:32,inertia:36,center:40,linearVelocity:48,angularVelocity:56,transform:60,userData:76},b2WorldManifold:{normal:0,points:8,separations:24},b2World:{bodyList:102960}};var FLT_EPSILON=1.1920929E-7;function b2Max(a,b){return new b2Vec2(Math.max(a.x,b.x),Math.max(a.y,b.y))}function b2Min(a,b){return new b2Vec2(Math.min(a.x,b.x),Math.min(a.y,b.y))}function b2Clamp(a,low,high){return b2Max(low,b2Min(a,high))}function b2Vec2(x,y){if(x===undefined)x=0;if(y===undefined)y=0;this.x=x;this.y=y}b2Vec2.Add=function(out,a,b){out.x=a.x+b.x;out.y=a.y+b.y};b2Vec2.CrossScalar=function(output,input,scalar){output.x=-scalar*input.y;output.y=scalar*input.x};
b2Vec2.Cross=function(a,b){return a.x*b.y-a.y*b.x};b2Vec2.MulScalar=function(out,input,scalar){out.x=input.x*scalar;out.y=input.y*scalar};b2Vec2.Mul=function(out,T,v){var Tp=T.p;var Tqc=T.q.c;var Tqs=T.q.s;var x=v.x;var y=v.y;out.x=Tqc*x-Tqs*y+Tp.x;out.y=Tqs*x+Tqc*y+Tp.y};b2Vec2.Normalize=function(out,input){var length=input.Length();if(length<FLT_EPSILON){out.x=0;out.y=0;return}var invLength=1/length;out.x=input.x*invLength;out.y=input.y*invLength};
b2Vec2.Sub=function(out,input,subtract){out.x=input.x-subtract.x;out.y=input.y-subtract.y};b2Vec2.prototype.Clone=function(){return new b2Vec2(this.x,this.y)};b2Vec2.prototype.Set=function(x,y){this.x=x;this.y=y};b2Vec2.prototype.Length=function(){var x=this.x;var y=this.y;return Math.sqrt(x*x+y*y)};b2Vec2.prototype.LengthSquared=function(){var x=this.x;var y=this.y;return x*x+y*y};function b2Rot(radians){if(radians===undefined)radians=0;this.s=Math.sin(radians);this.c=Math.cos(radians)}
b2Rot.prototype.Set=function(radians){this.s=Math.sin(radians);this.c=Math.cos(radians)};b2Rot.prototype.SetIdentity=function(){this.s=0;this.c=1};b2Rot.prototype.GetXAxis=function(){return new b2Vec2(this.c,this.s)};function b2Transform(position,rotation){if(position===undefined)position=new b2Vec2;if(rotation===undefined)rotation=new b2Rot;this.p=position;this.q=rotation}b2Transform.prototype.FromFloat64Array=function(arr){var p=this.p;var q=this.q;p.x=arr[0];p.y=arr[1];q.s=arr[2];q.c=arr[3]};
b2Transform.prototype.SetIdentity=function(){this.p.Set(0,0);this.q.SetIdentity()};function b2AABB(){this.lowerBound=new b2Vec2;this.upperBound=new b2Vec2}b2AABB.prototype.GetCenter=function(){var sum=new b2Vec2;b2Vec2.Add(sum,this.lowerBound,this.upperBound);b2Vec2.MulScalar(sum,sum,.5)};var b2Manifold_GetPointCount=Module.cwrap("b2Manifold_GetPointCount","number",["number"]);function b2Manifold(ptr){this.ptr=ptr}b2Manifold.prototype.GetPointCount=function(){return b2Manifold_GetPointCount(this.ptr)};var b2WorldManifold_points_offset=Offsets.b2WorldManifold.points;
function b2WorldManifold(ptr){this.buffer=new DataView(Module.HEAPU8.buffer,ptr);this.ptr=ptr}b2WorldManifold.prototype.GetPoint=function(i){var point=new b2Vec2;point.x=this.buffer.getFloat32(i*2+b2WorldManifold_points_offset,true);point.y=this.buffer.getFloat32(i*2+4+b2WorldManifold_points_offset,true);return point};var b2EdgeShape_CreateFixture=Module.cwrap("b2EdgeShape_CreateFixture","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);function b2EdgeShape(){this.hasVertex0=false;this.hasVertex3=false;this.vertex0=new b2Vec2;this.vertex1=new b2Vec2;this.vertex2=new b2Vec2;this.vertex3=new b2Vec2;this.type=b2Shape_Type_e_edge}
b2EdgeShape.prototype.Set=function(v1,v2){this.vertex1=v1;this.vertex2=v2;this.hasVertex0=false;this.hasVertex3=false};
b2EdgeShape.prototype._CreateFixture=function(body,fixtureDef){return b2EdgeShape_CreateFixture(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,this.hasVertex0,this.hasVertex3,this.vertex0.x,this.vertex0.y,this.vertex1.x,this.vertex1.y,this.vertex2.x,this.vertex2.y,this.vertex3.x,this.vertex3.y)};var b2PolygonShape_CreateFixture_3=Module.cwrap("b2PolygonShape_CreateFixture_3","number",["number","number","number","number","number","number","number","number","number","number","number","number"]);var b2PolygonShape_CreateFixture_4=Module.cwrap("b2PolygonShape_CreateFixture_4","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PolygonShape_CreateFixture_5=Module.cwrap("b2PolygonShape_CreateFixture_5","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);var b2PolygonShape_CreateFixture_6=Module.cwrap("b2PolygonShape_CreateFixture_6","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PolygonShape_CreateFixture_7=Module.cwrap("b2PolygonShape_CreateFixture_7","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PolygonShape_CreateFixture_8=Module.cwrap("b2PolygonShape_CreateFixture_8","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PolygonShape_CreateParticleGroup_4=Module.cwrap("b2PolygonShape_CreateParticleGroup_4","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PolygonShape_DestroyParticlesInShape_4=Module.cwrap("b2PolygonShape_DestroyParticlesInShape_4","number",["number","number","number","number","number","number","number","number","number","number","number","number","number"]);function b2PolygonShape(){this.position=new b2Vec2;this.vertices=[];this.type=b2Shape_Type_e_polygon}
b2PolygonShape.prototype.SetAsBoxXY=function(hx,hy){this.vertices[0]=new b2Vec2(-hx,-hy);this.vertices[1]=new b2Vec2(hx,-hy);this.vertices[2]=new b2Vec2(hx,hy);this.vertices[3]=new b2Vec2(-hx,hy)};
b2PolygonShape.prototype.SetAsBoxXYCenterAngle=function(hx,hy,center,angle){this.vertices[0]=new b2Vec2(-hx,-hy);this.vertices[1]=new b2Vec2(hx,-hy);this.vertices[2]=new b2Vec2(hx,hy);this.vertices[3]=new b2Vec2(-hx,hy);var xf=new b2Transform;xf.p=center;xf.q.Set(angle);for(var i=0;i<4;i++)b2Vec2.Mul(this.vertices[i],xf,this.vertices[i])};
b2PolygonShape.prototype._CreateFixture=function(body,fixtureDef){var vertices=this.vertices;switch(vertices.length){case 3:var v0=vertices[0];var v1=vertices[1];var v2=vertices[2];return b2PolygonShape_CreateFixture_3(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,v0.y,v1.x,v1.y,v2.x,v2.y);break;case 4:var v0=vertices[0];var v1=vertices[1];var v2=
vertices[2];var v3=vertices[3];return b2PolygonShape_CreateFixture_4(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,v0.y,v1.x,v1.y,v2.x,v2.y,v3.x,v3.y);break;case 5:var v0=vertices[0];var v1=vertices[1];var v2=vertices[2];var v3=vertices[3];var v4=vertices[4];return b2PolygonShape_CreateFixture_5(body.ptr,fixtureDef.density,fixtureDef.friction,
fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,v0.y,v1.x,v1.y,v2.x,v2.y,v3.x,v3.y,v4.x,v4.y);break;case 6:var v0=vertices[0];var v1=vertices[1];var v2=vertices[2];var v3=vertices[3];var v4=vertices[4];var v5=vertices[5];return b2PolygonShape_CreateFixture_6(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,
fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,v0.y,v1.x,v1.y,v2.x,v2.y,v3.x,v3.y,v4.x,v4.y,v5.x,v5.y);break;case 7:var v0=vertices[0];var v1=vertices[1];var v2=vertices[2];var v3=vertices[3];var v4=vertices[4];var v5=vertices[5];var v6=vertices[6];return b2PolygonShape_CreateFixture_7(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,
v0.y,v1.x,v1.y,v2.x,v2.y,v3.x,v3.y,v4.x,v4.y,v5.x,v5.y,v6.x,v6.y);break;case 8:var v0=vertices[0];var v1=vertices[1];var v2=vertices[2];var v3=vertices[3];var v4=vertices[4];var v5=vertices[5];var v6=vertices[6];var v7=vertices[7];return b2PolygonShape_CreateFixture_8(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,v0.x,v0.y,v1.x,v1.y,v2.x,v2.y,v3.x,
v3.y,v4.x,v4.y,v5.x,v5.y,v6.x,v6.y,v6.x,v7.y);break}};
b2PolygonShape.prototype._CreateParticleGroup=function(particleSystem,pgd){var v=this.vertices;switch(v.length){case 3:break;case 4:return b2PolygonShape_CreateParticleGroup_4(particleSystem.ptr,pgd.angle,pgd.angularVelocity,pgd.color.r,pgd.color.g,pgd.color.b,pgd.color.a,pgd.flags,pgd.group.ptr,pgd.groupFlags,pgd.lifetime,pgd.linearVelocity.x,pgd.linearVelocity.y,pgd.position.x,pgd.position.y,pgd.positionData,pgd.particleCount,pgd.strength,pgd.stride,pgd.userData,v[0].x,v[0].y,v[1].x,v[1].y,v[2].x,
v[2].y,v[3].x,v[3].y);break}};b2PolygonShape.prototype._DestroyParticlesInShape=function(ps,xf){var v=this.vertices;switch(v.length){case 3:break;case 4:return b2PolygonShape_DestroyParticlesInShape_4(ps.ptr,v[0].x,v[0].y,v[1].x,v[1].y,v[2].x,v[2].y,v[3].x,v[3].y,xf.p.x,xf.p.y,xf.q.s,xf.q.c);break}};
b2PolygonShape.prototype.Validate=function(){for(var i=0,max=this.vertices.length;i<max;++i){var i1=i;var i2=i<max-1?i1+1:0;var p=this.vertices[i1];var e=this.vertices[i2];var eSubP=new b2Vec2;b2Vec2.Sub(eSubP,e,p);for(var j=0;j<max;++j){if(j==i1||j==i2)continue;var v=new b2Vec2;b2Vec2.Sub(v,this.vertices[j],p);var c=b2Vec2.Cross(eSubP,v);if(c<0)return false}}return true};var b2Shape_Type_e_circle=0;var b2Shape_Type_e_edge=1;var b2Shape_Type_e_polygon=2;var b2Shape_Type_e_chain=3;var b2Shape_Type_e_typeCount=4;var b2_linearSlop=.005;var b2_polygonRadius=2*b2_linearSlop;var b2_maxPolygonVertices=8;function b2MassData(mass,center,I){this.mass=mass;this.center=center;this.I=I};var b2ChainShape_CreateFixture=Module.cwrap("b2ChainShape_CreateFixture","number",["number","number","number","number","number","number","number","number"]);function b2ChainShape(){this.radius=b2_polygonRadius;this.vertices=[];this.type=b2Shape_Type_e_chain}b2ChainShape.prototype.CreateLoop=function(){this.vertices.push(this.vertices[0])};
b2ChainShape.prototype._CreateFixture=function(body,fixtureDef){var vertices=this.vertices;var chainLength=vertices.length;var dataLength=chainLength*2;var data=new Float32Array(dataLength);for(var i=0,j=0;i<dataLength;i+=2,j++){data[i]=vertices[j].x;data[i+1]=vertices[j].y}var nDataBytes=data.length*data.BYTES_PER_ELEMENT;var dataPtr=Module._malloc(nDataBytes);var dataHeap=new Uint8Array(Module.HEAPU8.buffer,dataPtr,nDataBytes);dataHeap.set(new Uint8Array(data.buffer));var fixture=b2ChainShape_CreateFixture(body.ptr,
fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,dataHeap.byteOffset,data.length);Module._free(dataHeap.byteOffset);return fixture};var b2CircleShape_CreateFixture=Module.cwrap("b2CircleShape_CreateFixture","number",["number","number","number","number","number","number","number","number","number"]);var b2CircleShape_CreateParticleGroup=Module.cwrap("b2CircleShape_CreateParticleGroup","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2CircleShape_DestroyParticlesInShape=Module.cwrap("b2CircleShape_DestroyParticlesInShape","number",["number","number","number","number","number","number","number","number"]);function b2CircleShape(){this.position=new b2Vec2;this.radius=0;this.type=b2Shape_Type_e_circle}
b2CircleShape.prototype._CreateFixture=function(body,fixtureDef){return b2CircleShape_CreateFixture(body.ptr,fixtureDef.density,fixtureDef.friction,fixtureDef.isSensor,fixtureDef.restitution,fixtureDef.userData,fixtureDef.filter.categoryBits,fixtureDef.filter.groupIndex,fixtureDef.filter.maskBits,this.position.x,this.position.y,this.radius)};
b2CircleShape.prototype._CreateParticleGroup=function(particleSystem,pgd){return b2CircleShape_CreateParticleGroup(particleSystem.ptr,pgd.angle,pgd.angularVelocity,pgd.color.r,pgd.color.g,pgd.color.b,pgd.color.a,pgd.flags,pgd.group.ptr,pgd.groupFlags,pgd.lifetime,pgd.linearVelocity.x,pgd.linearVelocity.y,pgd.position.x,pgd.position.y,pgd.positionData,pgd.particleCount,pgd.strength,pgd.stride,pgd.userData,this.position.x,this.position.y,this.radius)};
b2CircleShape.prototype._DestroyParticlesInShape=function(ps,xf){return b2CircleShape_DestroyParticlesInShape(ps.ptr,this.position.x,this.position.y,this.radius,xf.p.x,xf.p.y,xf.q.s,xf.q.c)};var b2Body_ApplyAngularImpulse=Module.cwrap("b2Body_ApplyAngularImpulse","null",["number","number","number"]);var b2Body_ApplyForce=Module.cwrap("b2Body_ApplyForce","number",["number","number","number","number","number","number"]);var b2Body_ApplyForceToCenter=Module.cwrap("b2Body_ApplyForceToCenter","number",["number","number","number","number"]);var b2Body_ApplyTorque=Module.cwrap("b2Body_ApplyTorque","number",["number","number","number"]);
var b2Body_DestroyFixture=Module.cwrap("b2Body_DestroyFixture","null",["number","number"]);var b2Body_GetAngle=Module.cwrap("b2Body_GetAngle","number",["number"]);var b2Body_GetAngularVelocity=Module.cwrap("b2Body_GetAngularVelocity","number",["number"]);var b2Body_GetInertia=Module.cwrap("b2Body_GetInertia","number",["number"]);var b2Body_GetLinearVelocity=Module.cwrap("b2Body_GetLinearVelocity","null",["number","number"]);
var b2Body_GetLocalPoint=Module.cwrap("b2Body_GetLocalPoint","null",["number","number","number","number"]);var b2Body_GetLocalVector=Module.cwrap("b2Body_GetLocalVector","null",["number","number","number","number"]);var b2Body_GetMass=Module.cwrap("b2Body_GetMass","number",["number"]);var b2Body_GetPosition=Module.cwrap("b2Body_GetPosition","null",["number","number"]);var b2Body_GetTransform=Module.cwrap("b2Body_GetTransform","null",["number","number"]);
var b2Body_GetType=Module.cwrap("b2Body_GetType","number",["number"]);var b2Body_GetWorldCenter=Module.cwrap("b2Body_GetWorldCenter","null",["number","number"]);var b2Body_GetWorldPoint=Module.cwrap("b2Body_GetWorldPoint","null",["number","number","number","number"]);var b2Body_GetWorldVector=Module.cwrap("b2Body_GetWorldVector","null",["number","number","number","number"]);var b2Body_SetAngularVelocity=Module.cwrap("b2Body_SetAngularVelocity","null",["number","number"]);
var b2Body_SetAwake=Module.cwrap("b2Body_SetAwake","number",["number","number"]);var b2Body_SetLinearVelocity=Module.cwrap("b2Body_SetLinearVelocity","null",["number","number","number"]);var b2Body_SetMassData=Module.cwrap("b2Body_SetMassData","null",["number","number","number","number","number"]);var b2Body_SetTransform=Module.cwrap("b2Body_SetTransform","null",["number","number","number"]);var b2Body_SetType=Module.cwrap("b2Body_SetType","null",["number","number"]);var b2Body_xf_offset=Offsets.b2Body.xf;
var b2Body_userData_offset=Offsets.b2Body.userData;function b2Body(ptr){this.buffer=new DataView(Module.HEAPU8.buffer,ptr);this.ptr=ptr;this.fixtures=[]}b2Body.prototype.ApplyAngularImpulse=function(force,wake){b2Body_ApplyAngularImpulse(this.ptr,force,wake)};b2Body.prototype.ApplyForce=function(force,point,wake){b2Body_ApplyForce(this.ptr,force.x,force.y,point.x,point.y,wake)};b2Body.prototype.ApplyForceToCenter=function(force,wake){b2Body_ApplyForceToCenter(this.ptr,force.x,force.y,wake)};
b2Body.prototype.ApplyTorque=function(force,wake){b2Body_ApplyTorque(this.ptr,force,wake)};b2Body.prototype.CreateFixtureFromDef=function(fixtureDef){var fixture=new b2Fixture;fixture.FromFixtureDef(fixtureDef);fixture._SetPtr(fixtureDef.shape._CreateFixture(this,fixtureDef));fixture.body=this;b2World._Push(fixture,this.fixtures);world.fixturesLookup[fixture.ptr]=fixture;return fixture};
b2Body.prototype.CreateFixtureFromShape=function(shape,density){var fixtureDef=new b2FixtureDef;fixtureDef.shape=shape;fixtureDef.density=density;return this.CreateFixtureFromDef(fixtureDef)};b2Body.prototype.DestroyFixture=function(fixture){b2Body_DestroyFixture(this.ptr,fixture.ptr);b2World._RemoveItem(fixture,this.fixtures)};b2Body.prototype.GetAngle=function(){return b2Body_GetAngle(this.ptr)};b2Body.prototype.GetAngularVelocity=function(){return b2Body_GetAngularVelocity(this.ptr)};
b2Body.prototype.GetInertia=function(){return b2Body_GetInertia(this.ptr)};b2Body.prototype.GetMass=function(){return b2Body_GetMass(this.ptr)};b2Body.prototype.GetLinearVelocity=function(){b2Body_GetLinearVelocity(this.ptr,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};
b2Body.prototype.GetLocalPoint=function(vec){b2Body_GetLocalPoint(this.ptr,vec.x,vec.y,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};b2Body.prototype.GetLocalVector=function(vec){b2Body_GetLocalVector(this.ptr,vec.x,vec.y,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};
b2Body.prototype.GetPosition=function(){b2Body_GetPosition(this.ptr,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};
b2Body.prototype.GetTransform=function(){var transform=new b2Transform;transform.p.x=this.buffer.getFloat32(b2Body_xf_offset,true);transform.p.y=this.buffer.getFloat32(b2Body_xf_offset+4,true);transform.q.s=this.buffer.getFloat32(b2Body_xf_offset+8,true);transform.q.c=this.buffer.getFloat32(b2Body_xf_offset+12,true);return transform};b2Body.prototype.GetType=function(){return b2Body_GetType(this.ptr)};b2Body.prototype.GetUserData=function(){return this.buffer.getUint32(b2Body_userData_offset,true)};
b2Body.prototype.GetWorldCenter=function(){b2Body_GetWorldCenter(this.ptr,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};b2Body.prototype.GetWorldPoint=function(vec){b2Body_GetWorldPoint(this.ptr,vec.x,vec.y,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};
b2Body.prototype.GetWorldVector=function(vec){b2Body_GetWorldVector(this.ptr,vec.x,vec.y,_vec2Buf.byteOffset);var result=new Float32Array(_vec2Buf.buffer,_vec2Buf.byteOffset,_vec2Buf.length);return new b2Vec2(result[0],result[1])};b2Body.prototype.SetAngularVelocity=function(angle){b2Body_SetAngularVelocity(this.ptr,angle)};b2Body.prototype.SetAwake=function(flag){b2Body_SetAwake(this.ptr,flag)};b2Body.prototype.SetLinearVelocity=function(v){b2Body_SetLinearVelocity(this.ptr,v.x,v.y)};
b2Body.prototype.SetMassData=function(massData){b2Body_SetMassData(this.ptr,massData.mass,massData.center.x,massData.center.y,massData.I)};b2Body.prototype.SetTransform=function(v,angle){b2Body_SetTransform(this.ptr,v.x,v.y,angle)};b2Body.prototype.SetType=function(type){b2Body_SetType(this.ptr,type)};var b2_staticBody=0;var b2_kinematicBody=1;var b2_dynamicBody=2;
function b2BodyDef(){this.active=true;this.allowSleep=true;this.angle=0;this.angularVelocity=0;this.angularDamping=0;this.awake=true;this.bullet=false;this.fixedRotation=false;this.gravityScale=1;this.linearDamping=0;this.linearVelocity=new b2Vec2;this.position=new b2Vec2;this.type=b2_staticBody;this.userData=null};b2World.BeginContactBody=function(contactPtr){if(world.listener.BeginContactBody===undefined)return;var contact=new b2Contact(contactPtr);world.listener.BeginContactBody(contact)};b2World.EndContactBody=function(contactPtr){if(world.listener.EndContactBody===undefined)return;var contact=new b2Contact(contactPtr);world.listener.EndContactBody(contact)};
b2World.PreSolve=function(contactPtr,oldManifoldPtr){if(world.listener.PreSolve===undefined)return;world.listener.PreSolve(new b2Contact(contactPtr),new b2Manifold(oldManifoldPtr))};b2World.PostSolve=function(contactPtr,impulsePtr){if(world.listener.PostSolve===undefined)return;world.listener.PostSolve(new b2Contact(contactPtr),new b2ContactImpulse(impulsePtr))};b2World.QueryAABB=function(fixturePtr){return world.queryAABBCallback.ReportFixture(world.fixturesLookup[fixturePtr])};
b2World.RayCast=function(fixturePtr,pointX,pointY,normalX,normalY,fraction){return world.rayCastCallback.ReportFixture(world.fixturesLookup[fixturePtr],new b2Vec2(pointX,pointY),new b2Vec2(normalX,normalY),fraction)};var b2World_Create=Module.cwrap("b2World_Create","number",["number","number"]);
var b2World_CreateBody=Module.cwrap("b2World_CreateBody","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);var b2World_CreateParticleSystem=Module.cwrap("b2World_CreateParticleSystem","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2World_DestroyBody=Module.cwrap("b2World_DestroyBody","null",["number","number"]);var b2World_DestroyJoint=Module.cwrap("b2World_DestroyJoint","null",["number","number"]);var b2World_DestroyParticleSystem=Module.cwrap("b2World_DestroyParticleSystem","null",["number","number"]);var b2World_QueryAABB=Module.cwrap("b2World_QueryAABB","null",["number","number","number","number","number"]);var b2World_RayCast=Module.cwrap("b2World_RayCast","null",["number","number","number","number","number"]);
var b2World_SetContactListener=Module.cwrap("b2World_SetContactListener","null",["number"]);var b2World_SetGravity=Module.cwrap("b2World_SetGravity","null",["number","number","number"]);var b2World_Step=Module.cwrap("b2World_Step","null",["number","number","number"]);var _transBuf=null;var _vec2Buf=null;
function b2World(gravity){this.bodies=[];this.bodiesLookup={};this.fixturesLookup={};this.joints=[];this.listener=null;this.particleSystems=[];this.ptr=b2World_Create(gravity.x,gravity.y);this.queryAABBCallback=null;this.rayCastCallback=null;this.buffer=new DataView(Module.HEAPU8.buffer,this.ptr);var nDataBytes=4*Float32Array.BYTES_PER_ELEMENT;var dataPtr=Module._malloc(nDataBytes);_transBuf=new Uint8Array(Module.HEAPU8.buffer,dataPtr,nDataBytes);nDataBytes=2*Float32Array.BYTES_PER_ELEMENT;dataPtr=
Module._malloc(nDataBytes);_vec2Buf=new Uint8Array(Module.HEAPU8.buffer,dataPtr,nDataBytes)}b2World._Push=function(item,list){item.lindex=list.length;list.push(item)};b2World._RemoveItem=function(item,list){var length=list.length;var lindex=item.lindex;if(length>1){list[lindex]=list[length-1];list[lindex].lindex=lindex}list.pop()};
b2World.prototype.CreateBody=function(bodyDef){var body=new b2Body(b2World_CreateBody(this.ptr,bodyDef.active,bodyDef.allowSleep,bodyDef.angle,bodyDef.angularVelocity,bodyDef.angularDamping,bodyDef.awake,bodyDef.bullet,bodyDef.fixedRotation,bodyDef.gravityScale,bodyDef.linearDamping,bodyDef.linearVelocity.x,bodyDef.linearVelocity.y,bodyDef.position.x,bodyDef.position.y,bodyDef.type,bodyDef.userData));b2World._Push(body,this.bodies);this.bodiesLookup[body.ptr]=body;return body};
b2World.prototype.CreateJoint=function(jointDef){var joint=jointDef.Create(this);b2World._Push(joint,this.joints);return joint};
b2World.prototype.CreateParticleSystem=function(psd){var ps=new b2ParticleSystem(b2World_CreateParticleSystem(this.ptr,psd.colorMixingStrength,psd.dampingStrength,psd.destroyByAge,psd.ejectionStrength,psd.elasticStrength,psd.lifetimeGranularity,psd.powderStrength,psd.pressureStrength,psd.radius,psd.repulsiveStrength,psd.springStrength,psd.staticPressureIterations,psd.staticPressureRelaxation,psd.staticPressureStrength,psd.surfaceTensionNormalStrength,psd.surfaceTensionPressureStrength,psd.viscousStrength));
b2World._Push(ps,this.particleSystems);ps.dampingStrength=psd.dampingStrength;ps.radius=psd.radius;return ps};b2World.prototype.DestroyBody=function(body){b2World_DestroyBody(this.ptr,body.ptr);b2World._RemoveItem(body,this.bodies)};b2World.prototype.DestroyJoint=function(joint){b2World_DestroyJoint(this.ptr,joint.ptr);b2World._RemoveItem(joint,this.joints)};
b2World.prototype.DestroyParticleSystem=function(particleSystem){b2World_DestroyParticleSystem(this.ptr,particleSystem.ptr);b2World._RemoveItem(particleSystem,this.particleSystems)};b2World.prototype.QueryAABB=function(callback,aabb){this.queryAABBCallback=callback;b2World_QueryAABB(this.ptr,aabb.lowerBound.x,aabb.lowerBound.y,aabb.upperBound.x,aabb.upperBound.y)};
b2World.prototype.RayCast=function(callback,point1,point2){this.rayCastCallback=callback;b2World_RayCast(this.ptr,point1.x,point1.y,point2.x,point2.y)};b2World.prototype.SetContactListener=function(listener){this.listener=listener;b2World_SetContactListener(this.ptr)};b2World.prototype.SetGravity=function(gravity){b2World_SetGravity(this.ptr,gravity.x,gravity.y)};b2World.prototype.Step=function(steps,vIterations,pIterations){b2World_Step(this.ptr,steps,vIterations,pIterations)};var b2WheelJoint_SetMotorSpeed=Module.cwrap("b2WheelJoint_SetMotorSpeed","null",["number","number"]);var b2WheelJoint_SetSpringFrequencyHz=Module.cwrap("b2WheelJoint_SetSpringFrequencyHz","null",["number","number"]);function b2WheelJoint(def){this.next=null;this.ptr=null}b2WheelJoint.prototype.SetMotorSpeed=function(speed){b2WheelJoint_SetMotorSpeed(this.ptr,speed)};b2WheelJoint.prototype.SetSpringFrequencyHz=function(hz){b2WheelJoint_SetSpringFrequencyHz(this.ptr,hz)};
var b2WheelJointDef_Create=Module.cwrap("b2WheelJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);var b2WheelJointDef_InitializeAndCreate=Module.cwrap("b2WheelJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number","number","number","number","number","number"]);
function b2WheelJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.dampingRatio=.7;this.enableMotor=false;this.frequencyHz=2;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.localAxisA=new b2Vec2(1,0);this.maxMotorTorque=0;this.motorSpeed=0}
b2WheelJointDef.prototype.Create=function(world){var wheelJoint=new b2WheelJoint(this);wheelJoint.ptr=b2WheelJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.dampingRatio,this.enableMotor,this.frequencyHz,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.localAxisA.x,this.localAxisA.y,this.maxMotorTorque,this.motorSpeed);return wheelJoint};
b2WheelJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchor,axis){this.bodyA=bodyA;this.bodyB=bodyB;var wheelJoint=new b2WheelJoint(this);wheelJoint.ptr=b2WheelJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchor.x,anchor.y,axis.x,axis.y,this.collideConnected,this.dampingRatio,this.enableMotor,this.frequencyHz,this.maxMotorTorque,this.motorSpeed);b2World._Push(wheelJoint,world.joints);return wheelJoint};var b2WeldJointDef_Create=Module.cwrap("b2WeldJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number"]);var b2WeldJointDef_InitializeAndCreate=Module.cwrap("b2WeldJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number"]);
function b2WeldJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.dampingRatio=0;this.frequencyHz=0;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.referenceAngle=0}
b2WeldJointDef.prototype.Create=function(world){var weldJoint=new b2WeldJoint(this);weldJoint.ptr=b2WeldJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.dampingRatio,this.frequencyHz,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.referenceAngle);return weldJoint};
b2WeldJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchor){this.bodyA=bodyA;this.bodyB=bodyB;var weldJoint=new b2WeldJoint(this);weldJoint.ptr=b2WeldJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchor.x,anchor.y,this.collideConnected,this.dampingRatio,this.frequencyHz);b2World._Push(weldJoint,world.joints);return weldJoint};function b2WeldJoint(def){this.bodyA=def.bodyA;this.bodyB=def.bodyB;this.next=null;this.ptr=null};var b2GearJoint_GetRatio=Module.cwrap("b2GearJoint_GetRatio","number",["number"]);function b2GearJoint(def){this.ptr=null;this.next=null}b2GearJoint.prototype.GetRatio=function(){return b2GearJoint_GetRatio(this.ptr)};var b2GearJointDef_Create=Module.cwrap("b2GearJointDef_Create","number",["number","number","number","number","number","number","number"]);function b2GearJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.joint1=null;this.joint2=null;this.ratio=0}
b2GearJointDef.prototype.Create=function(world){var gearJoint=new b2GearJoint(this);gearJoint.ptr=b2GearJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.joint1.ptr,this.joint2.ptr,this.ratio);return gearJoint};var e_unknownJoint=0;var e_revoluteJoint=1;var e_prismaticJoint=2;var e_distanceJoint=3;var e_pulleyJoint=4;var e_mouseJoint=5;var e_gearJoint=6;var e_wheelJoint=7;var e_weldJoint=8;var e_frictionJoint=9;var e_ropeJoint=10;var e_motorJoint=11;var b2Joint_GetBodyA=Module.cwrap("b2Joint_GetBodyA","number",["number"]);var b2Joint_GetBodyB=Module.cwrap("b2Joint_GetBodyB","number",["number"]);function b2Joint(){}b2Joint.prototype.GetBodyA=function(){return world.bodiesLookup[b2Joint_GetBodyA(this.ptr)]};
b2Joint.prototype.GetBodyB=function(){return world.bodiesLookup[b2Joint_GetBodyB(this.ptr)]};var b2FrictionJointDef_Create=Module.cwrap("b2FrictionJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number"]);var b2FrictionJointDef_InitializeAndCreate=Module.cwrap("b2FrictionJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number"]);
function b2FrictionJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.maxForce=0;this.maxTorque=0;this.userData=null}
b2FrictionJointDef.prototype.Create=function(world){var frictionJoint=new b2FrictionJoint(this);frictionJoint.ptr=b2FrictionJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.maxForce,this.maxTorque);return frictionJoint};
b2FrictionJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchor){this.bodyA=bodyA;this.bodyB=bodyB;var frictionJoint=new b2FrictionJoint(this);frictionJoint.ptr=b2FrictionJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchor.x,anchor.y,this.collideConnected,this.maxForce,this.maxTorque);b2World._Push(frictionJoint,world.joints);return frictionJoint};function b2FrictionJoint(def){this.bodyA=def.bodyA;this.bodyB=def.bodyB;this.ptr=null;this.next=null};var b2RevoluteJoint_EnableLimit=Module.cwrap("b2RevoluteJoint_EnableLimit","number",["number","number"]);var b2RevoluteJoint_EnableMotor=Module.cwrap("b2RevoluteJoint_EnableMotor","number",["number","number"]);var b2RevoluteJoint_GetJointAngle=Module.cwrap("b2RevoluteJoint_GetJointAngle","number",["number"]);var b2RevoluteJoint_IsLimitEnabled=Module.cwrap("b2RevoluteJoint_IsLimitEnabled","number",["number"]);
var b2RevoluteJoint_IsMotorEnabled=Module.cwrap("b2RevoluteJoint_IsMotorEnabled","number",["number"]);var b2RevoluteJoint_SetMotorSpeed=Module.cwrap("b2RevoluteJoint_SetMotorSpeed","number",["number","number"]);
function b2RevoluteJoint(revoluteJointDef){this.collideConnected=revoluteJointDef.collideConnected;this.enableLimit=revoluteJointDef.enableLimit;this.enableMotor=revoluteJointDef.enableMotor;this.lowerAngle=revoluteJointDef.lowerAngle;this.maxMotorTorque=revoluteJointDef.maxMotorTorque;this.motorSpeed=revoluteJointDef.motorSpeed;this.next=null;this.ptr=null;this.upperAngle=revoluteJointDef.upperAngle;this.userData=revoluteJointDef.userData}b2RevoluteJoint.prototype=new b2Joint;
b2RevoluteJoint.prototype.EnableLimit=function(flag){b2RevoluteJoint_EnableLimit(this.ptr,flag)};b2RevoluteJoint.prototype.EnableMotor=function(flag){b2RevoluteJoint_EnableMotor(this.ptr,flag)};b2RevoluteJoint.prototype.GetJointAngle=function(flag){return b2RevoluteJoint_GetJointAngle(this.ptr)};b2RevoluteJoint.prototype.IsLimitEnabled=function(){return b2RevoluteJoint_IsLimitEnabled(this.ptr)};b2RevoluteJoint.prototype.IsMotorEnabled=function(){return b2RevoluteJoint_IsMotorEnabled(this.ptr)};
b2RevoluteJoint.prototype.SetMotorSpeed=function(speed){b2RevoluteJoint_SetMotorSpeed(this.ptr,speed);this.motorSpeed=speed};var b2RevoluteJointDef_Create=Module.cwrap("b2RevoluteJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2RevoluteJointDef_InitializeAndCreate=Module.cwrap("b2RevoluteJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number","number","number","number","number"]);function b2RevoluteJointDef(){this.collideConnected=false;this.enableLimit=false;this.enableMotor=false;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.lowerAngle=0;this.maxMotorTorque=0;this.motorSpeed=0;this.referenceAngle=0;this.upperAngle=0;this.userData=null}
b2RevoluteJointDef.prototype.Create=function(world){var revoluteJoint=new b2RevoluteJoint(this);revoluteJoint.ptr=b2RevoluteJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.enableLimit,this.enableMotor,this.lowerAngle,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.maxMotorTorque,this.motorSpeed,this.referenceAngle,this.upperAngle);return revoluteJoint};
b2RevoluteJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchor){this.bodyA=bodyA;this.bodyB=bodyB;var revoluteJoint=new b2RevoluteJoint(this);revoluteJoint.ptr=b2RevoluteJointDef_InitializeAndCreate(world.ptr,bodyA.ptr,bodyB.ptr,anchor.x,anchor.y,this.collideConnected,this.enableLimit,this.enableMotor,this.lowerAngle,this.maxMotorTorque,this.motorSpeed,this.upperAngle);b2World._Push(revoluteJoint,world.joints);return revoluteJoint};var b2MotorJoint_SetAngularOffset=Module.cwrap("b2MotorJoint_SetAngularOffset","null",["number","number"]);var b2MotorJoint_SetLinearOffset=Module.cwrap("b2MotorJoint_SetLinearOffset","null",["number","number","number"]);function b2MotorJoint(def){this.bodyA=def.bodyA;this.bodyB=def.bodyB;this.ptr=null;this.next=null}b2MotorJoint.prototype.SetAngularOffset=function(angle){b2MotorJoint_SetAngularOffset(this.ptr,angle)};
b2MotorJoint.prototype.SetLinearOffset=function(v){b2MotorJoint_SetLinearOffset(this.ptr,v.x,v.y)};var b2MotorJointDef_Create=Module.cwrap("b2MotorJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number"]);var b2MotorJointDef_InitializeAndCreate=Module.cwrap("b2MotorJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number"]);
function b2MotorJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.angularOffset=0;this.correctionFactor=.3;this.linearOffset=new b2Vec2;this.maxForce=0;this.maxTorque=0}b2MotorJointDef.prototype.Create=function(world){var motorJoint=new b2MotorJoint(this);motorJoint.ptr=b2MotorJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.angularOffset,this.correctionFactor,this.linearOffset.x,this.linearOffset.y,this.maxForce,this.maxTorque);return motorJoint};
b2MotorJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB){this.bodyA=bodyA;this.bodyB=bodyB;var motorJoint=new b2MotorJoint(this);motorJoint.ptr=b2MotorJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.correctionFactor,this.maxForce,this.maxTorque);b2World._Push(motorJoint,world.joints);return motorJoint};function b2PulleyJoint(def){this.ptr=null;this.next=null}var b2PulleyJointDef_Create=Module.cwrap("b2PulleyJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);var b2PulleyJointDef_InitializeAndCreate=Module.cwrap("b2PulleyJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
function b2PulleyJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=true;this.groundAnchorA=new b2Vec2;this.groundAnchorB=new b2Vec2;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.lengthA=0;this.lengthB=0;this.ratio=1}
b2PulleyJointDef.prototype.Create=function(world){var pulleyJoint=new b2PulleyJoint(this);pulleyJoint.ptr=b2PulleyJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.groundAnchorA.x,this.groundAnchorA.y,this.groundAnchorB.x,this.groundAnchorB.y,this.lengthA,this.lengthB,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.ratio);return pulleyJoint};
b2PulleyJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,groundAnchorA,groundAnchorB,anchorA,anchorB,ratio){this.bodyA=bodyA;this.bodyB=bodyB;var pulleyJoint=new b2PulleyJoint(this);pulleyJoint.ptr=b2PulleyJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchorA.x,anchorA.y,anchorB.x,anchorB.y,groundAnchorA.x,groundAnchorA.y,groundAnchorB.x,groundAnchorB.y,ratio,this.collideConnected);b2World._Push(pulleyJoint,world.joints);return pulleyJoint};function b2DistanceJoint(def){this.bodyA=def.bodyA;this.bodyB=def.bodyB;this.ptr=null;this.next=null}var b2DistanceJointDef_Create=Module.cwrap("b2DistanceJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number","number"]);var b2DistanceJointDef_InitializeAndCreate=Module.cwrap("b2DistanceJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number","number","number"]);
function b2DistanceJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.dampingRatio=0;this.length=1;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.frequencyHz=0}
b2DistanceJointDef.prototype.Create=function(world){var distanceJoint=new b2DistanceJoint(this);distanceJoint.ptr=b2DistanceJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.dampingRatio,this.frequencyHz,this.length,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y);return distanceJoint};
b2DistanceJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchorA,anchorB){this.bodyA=bodyA;this.bodyB=bodyB;var distanceJoint=new b2DistanceJoint(this);distanceJoint.ptr=b2DistanceJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchorA.x,anchorA.y,anchorB.x,anchorB.y,this.collideConnected,this.dampingRatio,this.frequencyHz);b2World._Push(distanceJoint,world.joints);return distanceJoint};var b2PrismaticJoint_EnableLimit=Module.cwrap("b2PrismaticJoint_EnableLimit","number",["number","number"]);var b2PrismaticJoint_EnableMotor=Module.cwrap("b2PrismaticJoint_EnableMotor","number",["number","number"]);var b2PrismaticJoint_GetJointTranslation=Module.cwrap("b2PrismaticJoint_GetJointTranslation","number",["number"]);var b2PrismaticJoint_GetMotorSpeed=Module.cwrap("b2PrismaticJoint_GetMotorSpeed","number",["number"]);
var b2PrismaticJoint_GetMotorForce=Module.cwrap("b2PrismaticJoint_GetMotorForce","number",["number","number"]);var b2PrismaticJoint_IsLimitEnabled=Module.cwrap("b2PrismaticJoint_IsLimitEnabled","number",["number"]);var b2PrismaticJoint_IsMotorEnabled=Module.cwrap("b2PrismaticJoint_IsMotorEnabled","number",["number"]);var b2PrismaticJoint_SetMotorSpeed=Module.cwrap("b2PrismaticJoint_SetMotorSpeed","number",["number","number"]);function b2PrismaticJoint(def){this.ptr=null;this.next=null}
b2PrismaticJoint.prototype=new b2Joint;b2PrismaticJoint.prototype.EnableLimit=function(flag){return b2PrismaticJoint_EnableLimit(this.ptr,flag)};b2PrismaticJoint.prototype.EnableMotor=function(flag){return b2PrismaticJoint_EnableMotor(this.ptr,flag)};b2PrismaticJoint.prototype.GetJointTranslation=function(){return b2PrismaticJoint_GetJointTranslation(this.ptr)};b2PrismaticJoint.prototype.GetMotorSpeed=function(){return b2PrismaticJoint_GetMotorSpeed(this.ptr)};
b2PrismaticJoint.prototype.GetMotorForce=function(hz){return b2PrismaticJoint_GetMotorForce(this.ptr,hz)};b2PrismaticJoint.prototype.IsLimitEnabled=function(){return b2PrismaticJoint_IsLimitEnabled(this.ptr)};b2PrismaticJoint.prototype.IsMotorEnabled=function(){return b2PrismaticJoint_IsMotorEnabled(this.ptr)};b2PrismaticJoint.prototype.GetMotorEnabled=function(){return b2PrismaticJoint_IsMotorEnabled(this.ptr)};
b2PrismaticJoint.prototype.SetMotorSpeed=function(speed){return b2PrismaticJoint_SetMotorSpeed(this.ptr,speed)};var b2PrismaticJointDef_Create=Module.cwrap("b2PrismaticJointDef_Create","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
var b2PrismaticJointDef_InitializeAndCreate=Module.cwrap("b2PrismaticJointDef_InitializeAndCreate","number",["number","number","number","number","number","number","number","number","number","number","number","number","number","number"]);
function b2PrismaticJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.enableLimit=false;this.enableMotor=false;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.localAxisA=new b2Vec2(1,0);this.lowerTranslation=0;this.maxMotorForce=0;this.motorSpeed=0;this.referenceAngle=0;this.upperTranslation=0}
b2PrismaticJointDef.prototype.Create=function(world){var prismaticJoint=new b2PrismaticJoint(this);prismaticJoint.ptr=b2PrismaticJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.enableLimit,this.enableMotor,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.localAxisA.x,this.localAxisA.y,this.lowerTranslation,this.maxMotorForce,this.motorSpeed,this.referenceAngle,this.upperTranslation);return prismaticJoint};
b2PrismaticJointDef.prototype.InitializeAndCreate=function(bodyA,bodyB,anchor,axis){this.bodyA=bodyA;this.bodyB=bodyB;var prismaticJoint=new b2PrismaticJoint(this);prismaticJoint.ptr=b2PrismaticJointDef_InitializeAndCreate(world.ptr,this.bodyA.ptr,this.bodyB.ptr,anchor.x,anchor.y,axis.x,axis.y,this.collideConnected,this.enableLimit,this.enableMotor,this.lowerTranslation,this.maxMotorForce,this.motorSpeed,this.upperTranslation);b2World._Push(prismaticJoint,world.joints);return prismaticJoint};function b2RopeJoint(def){this.next=null;this.ptr=null}var b2RopeJointDef_Create=Module.cwrap("b2RopeJointDef_Create","number",["number","number","number","number","number","number","number","number","number"]);function b2RopeJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.localAnchorA=new b2Vec2;this.localAnchorB=new b2Vec2;this.maxLength=0}
b2RopeJointDef.prototype.Create=function(world){var ropeJoint=new b2RopeJoint(this);ropeJoint.ptr=b2RopeJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.localAnchorA.x,this.localAnchorA.y,this.localAnchorB.x,this.localAnchorB.y,this.maxLength);return ropeJoint};var b2MouseJoint_SetTarget=Module.cwrap("b2MouseJoint_SetTarget","null",["number","number","number"]);function b2MouseJoint(def){this.ptr=null;this.next=null}b2MouseJoint.prototype.SetTarget=function(p){b2MouseJoint_SetTarget(this.ptr,p.x,p.y)};var b2MouseJointDef_Create=Module.cwrap("b2MouseJointDef_Create","number",["number","number","number","number","number","number","number","number","number"]);
function b2MouseJointDef(){this.bodyA=null;this.bodyB=null;this.collideConnected=false;this.dampingRatio=.7;this.frequencyHz=5;this.maxForce=0;this.target=new b2Vec2}b2MouseJointDef.prototype.Create=function(world){var mouseJoint=new b2MouseJoint(this);mouseJoint.ptr=b2MouseJointDef_Create(world.ptr,this.bodyA.ptr,this.bodyB.ptr,this.collideConnected,this.dampingRatio,this.frequencyHz,this.maxForce,this.target.x,this.target.y);return mouseJoint};var b2Contact_fixtureA_offset=Offsets.b2Contact.fixtureA;var b2Contact_fixtureB_offset=Offsets.b2Contact.fixtureB;var b2Contact_tangentSpeed_offset=Offsets.b2Contact.tangentSpeed;var b2Contact_GetManifold=Module.cwrap("b2Contact_GetManifold","number",["number"]);var b2Contact_GetWorldManifold=Module.cwrap("b2Contact_GetWorldManifold","number",["number"]);function b2Contact(ptr){this.buffer=new DataView(Module.HEAPU8.buffer,ptr);this.ptr=ptr}
b2Contact.prototype.GetFixtureA=function(){var fixAPtr=this.buffer.getUint32(b2Contact_fixtureA_offset,true);return world.fixturesLookup[fixAPtr]};b2Contact.prototype.GetFixtureB=function(){var fixBPtr=this.buffer.getUint32(b2Contact_fixtureB_offset,true);return world.fixturesLookup[fixBPtr]};b2Contact.prototype.GetManifold=function(){return new b2Manifold(b2Contact_GetManifold(this.ptr))};b2Contact.prototype.GetWorldManifold=function(){return new b2WorldManifold(b2Contact_GetWorldManifold(this.ptr))};
b2Contact.prototype.SetTangentSpeed=function(speed){this.buffer.setFloat32(b2Contact_tangentSpeed_offset,speed,true)};function b2Filter(){this.categoryBits=1;this.groupIndex=0;this.maskBits=65535}var b2Fixture_isSensor_offset=Offsets.b2Fixture.isSensor;var b2Fixture_userData_offset=Offsets.b2Fixture.userData;function b2Fixture(){this.body=null;this.buffer=null;this.ptr=null;this.shape=null}var b2Fixture_TestPoint=Module.cwrap("b2Fixture_TestPoint","number",["number","number","number"]);b2Fixture.prototype._SetPtr=function(ptr){this.ptr=ptr;this.buffer=new DataView(Module.HEAPU8.buffer,ptr)};
b2Fixture.prototype.FromFixtureDef=function(fixtureDef){this.density=fixtureDef.density;this.friction=fixtureDef.friction;this.isSensor=fixtureDef.isSensor;this.restitution=fixtureDef.restitution;this.shape=fixtureDef.shape;this.userData=fixtureDef.userData;this.vertices=[]};b2Fixture.prototype.GetUserData=function(){return this.buffer.getUint32(b2Fixture_userData_offset,true)};b2Fixture.prototype.SetSensor=function(flag){this.buffer.setUint32(b2Fixture_isSensor_offset,flag,true)};
b2Fixture.prototype.TestPoint=function(p){return b2Fixture_TestPoint(this.ptr,p.x,p.y)};function b2FixtureDef(){this.density=0;this.friction=.2;this.isSensor=false;this.restitution=0;this.shape=null;this.userData=null;this.filter=new b2Filter};function b2ContactImpulse(ptr){this.ptr=ptr;this.buffer=new DataView(Module.HEAPU8.buffer,ptr)}b2ContactImpulse.prototype.GetNormalImpulse=function(i){return this.buffer.getFloat32(i*4,true)};b2ContactImpulse.prototype.GetTangentImpulse=function(i){return this.buffer.getFloat32(i*4+8,true)};b2ContactImpulse.prototype.GetCount=function(i){console.log(this.buffer.getInt32(16,true))};function b2ParticleSystemDef(){this.colorMixingStrength=.5;this.dampingStrength=1;this.destroyByAge=true;this.ejectionStrength=.5;this.elasticStrength=.25;this.lifetimeGranularity=1/60;this.powderStrength=.5;this.pressureStrength=.05;this.radius=1;this.repulsiveStrength=1;this.springStrength=.25;this.staticPressureIterations=8;this.staticPressureRelaxation=.2;this.staticPressureStrength=.2;this.surfaceTensionNormalStrength=.2;this.surfaceTensionPressureStrength=.2;this.viscousStrength=.25}
var b2ParticleSystem_CreateParticle=Module.cwrap("b2ParticleSystem_CreateParticle","number",["number","number","number","number","number","number","number","number","number","number","number","number","number"]);var b2ParticleSystem_GetColorBuffer=Module.cwrap("b2ParticleSystem_GetColorBuffer","number",["number"]);var b2ParticleSystem_GetParticleCount=Module.cwrap("b2ParticleSystem_GetParticleCount","number",["number"]);
var b2ParticleSystem_GetPositionBuffer=Module.cwrap("b2ParticleSystem_GetPositionBuffer","number",["number"]);var b2ParticleSystem_GetVelocityBuffer=Module.cwrap("b2ParticleSystem_GetVelocityBuffer","number",["number"]);var b2ParticleSystem_SetDamping=Module.cwrap("b2ParticleSystem_SetDamping","null",["number","number"]);var b2ParticleSystem_SetDensity=Module.cwrap("b2ParticleSystem_SetDensity","null",["number","number"]);
var b2ParticleSystem_SetRadius=Module.cwrap("b2ParticleSystem_SetRadius","null",["number","number"]);function b2ParticleSystem(ptr){this.dampingStrength=1;this.density=1;this.ptr=ptr;this.particleGroups=[];this.radius=1}b2ParticleSystem.prototype.CreateParticle=function(pd){return b2ParticleSystem_CreateParticle(this.ptr,pd.color.r,pd.color.g,pd.color.b,pd.color.a,pd.flags,pd.group,pd.lifetime,pd.position.x,pd.position.y,pd.userData,pd.velocity.x,pd.velocity.y)};
b2ParticleSystem.prototype.CreateParticleGroup=function(pgd){var particleGroup=new b2ParticleGroup(pgd.shape._CreateParticleGroup(this,pgd));this.particleGroups.push(particleGroup);return particleGroup};b2ParticleSystem.prototype.DestroyParticlesInShape=function(shape,xf){return shape._DestroyParticlesInShape(this,xf)};
b2ParticleSystem.prototype.GetColorBuffer=function(){var count=b2ParticleSystem_GetParticleCount(this.ptr)*4;var offset=b2ParticleSystem_GetColorBuffer(this.ptr);return new Uint8Array(Module.HEAPU8.buffer,offset,count)};b2ParticleSystem.prototype.GetParticleCount=function(){return b2ParticleSystem_GetParticleCount(this.ptr)*2};
b2ParticleSystem.prototype.GetPositionBuffer=function(){var count=b2ParticleSystem_GetParticleCount(this.ptr)*2;var offset=b2ParticleSystem_GetPositionBuffer(this.ptr);return new Float32Array(Module.HEAPU8.buffer,offset,count)};b2ParticleSystem.prototype.GetVelocityBuffer=function(){var count=b2ParticleSystem_GetParticleCount(this.ptr)*2;var offset=b2ParticleSystem_GetVelocityBuffer(this.ptr);return new Float32Array(Module.HEAPU8.buffer,offset,count)};
b2ParticleSystem.prototype.SetDamping=function(damping){this.dampingStrength=damping;b2ParticleSystem_SetDamping(this.ptr,damping)};b2ParticleSystem.prototype.SetDensity=function(density){this.density=density;b2ParticleSystem_SetDensity(this.ptr,density)};b2ParticleSystem.prototype.SetRadius=function(radius){this.radius=radius;b2ParticleSystem_SetRadius(this.ptr,radius)};var b2_solidParticleGroup=1<<0;var b2_rigidParticleGroup=1<<1;var b2_particleGroupCanBeEmpty=1<<2;var b2_particleGroupWillBeDestroyed=1<<3;var b2_particleGroupNeedsUpdateDepth=1<<4;var b2_particleGroupInternalMask=b2_particleGroupWillBeDestroyed|b2_particleGroupNeedsUpdateDepth;var b2ParticleGroup_ApplyForce=Module.cwrap("b2ParticleGroup_ApplyForce","null",["number","number","number"]);
var b2ParticleGroup_ApplyLinearImpulse=Module.cwrap("b2ParticleGroup_ApplyLinearImpulse","null",["number","number","number"]);var b2ParticleGroup_DestroyParticles=Module.cwrap("b2ParticleGroup_DestroyParticles","null",["number","number"]);var b2ParticleGroup_GetBufferIndex=Module.cwrap("b2ParticleGroup_GetBufferIndex","number",["number"]);var b2ParticleGroup_GetParticleCount=Module.cwrap("b2ParticleGroup_GetParticleCount","number",["number"]);var b2ParticleGroup_groupFlags_offset=Offsets.b2ParticleGroup.groupFlags;
function b2ParticleGroup(ptr){this.buffer=new DataView(Module.HEAPU8.buffer,ptr);this.ptr=ptr}b2ParticleGroup.prototype.ApplyForce=function(force){b2ParticleGroup_ApplyForce(this.ptr,force.x,force.y)};b2ParticleGroup.prototype.ApplyLinearImpulse=function(impulse){b2ParticleGroup_ApplyLinearImpulse(this.ptr,impulse.x,impulse.y)};b2ParticleGroup.prototype.DestroyParticles=function(flag){b2ParticleGroup_DestroyParticles(this.ptr,flag)};b2ParticleGroup.prototype.GetBufferIndex=function(){return b2ParticleGroup_GetBufferIndex(this.ptr)};
b2ParticleGroup.prototype.GetGroupFlags=function(){return this.buffer.getUint32(b2ParticleGroup_groupFlags_offset,true)};b2ParticleGroup.prototype.GetParticleCount=function(){return b2ParticleGroup_GetParticleCount(this.ptr)};b2ParticleGroup.prototype.SetGroupFlags=function(flags){this.buffer.setUint32(b2ParticleGroup_groupFlags_offset,flags,true)};
function b2ParticleGroupDef(){this.angle=0;this.angularVelocity=0;this.color=new b2ParticleColor(0,0,0,0);this.flags=0;this.group=new b2ParticleGroup(null);this.groupFlags=0;this.lifetime=0;this.linearVelocity=new b2Vec2;this.position=new b2Vec2;this.positionData=null;this.particleCount=0;this.shape=null;this.strength=1;this.stride=0;this.userData=null};var b2_waterParticle=0;var b2_zombieParticle=1<<1;var b2_wallParticle=1<<2;var b2_springParticle=1<<3;var b2_elasticParticle=1<<4;var b2_viscousParticle=1<<5;var b2_powderParticle=1<<6;var b2_tensileParticle=1<<7;var b2_colorMixingParticle=1<<8;var b2_destructionListenerParticle=1<<9;var b2_barrierParticle=1<<10;var b2_staticPressureParticle=1<<11;var b2_reactiveParticle=1<<12;var b2_repulsiveParticle=1<<13;var b2_fixtureContactListenerParticle=1<<14;var b2_particleContactListenerParticle=1<<15;
var b2_fixtureContactFilterParticle=1<<16;var b2_particleContactFilterParticle=1<<17;function b2ParticleColor(r,g,b,a){if(r===undefined)r=0;if(g===undefined)g=0;if(b===undefined)b=0;if(a===undefined)a=0;this.r=r;this.g=g;this.b=b;this.a=a}b2ParticleColor.prototype.Set=function(r,g,b,a){this.r=r;this.g=g;this.b=b;this.a=a};function b2ParticleDef(){this.color=new b2Vec2;this.flags=0;this.group=0;this.lifetime=0;this.position=new b2Vec2;this.userData=0;this.velocity=new b2Vec2};
;/**
 * @author mrdoob / http://mrdoob.com/
 * @author Larry Battle / http://bateru.com/news
 * @author bhouston / http://exocortex.com
 */

var THREE = { REVISION: '66' };

self.console = self.console || {

	info: function () {},
	log: function () {},
	debug: function () {},
	warn: function () {},
	error: function () {}

};

// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

// requestAnimationFrame polyfill by Erik Möller
// fixes from Paul Irish and Tino Zijdel
// using 'self' instead of 'window' for compatibility with both NodeJS and IE10.
( function () {

	var lastTime = 0;
	var vendors = [ 'ms', 'moz', 'webkit', 'o' ];

	for ( var x = 0; x < vendors.length && !self.requestAnimationFrame; ++ x ) {

		self.requestAnimationFrame = self[ vendors[ x ] + 'RequestAnimationFrame' ];
		self.cancelAnimationFrame = self[ vendors[ x ] + 'CancelAnimationFrame' ] || self[ vendors[ x ] + 'CancelRequestAnimationFrame' ];

	}

	if ( self.requestAnimationFrame === undefined && self['setTimeout'] !== undefined ) {

		self.requestAnimationFrame = function ( callback ) {

			var currTime = Date.now(), timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
			var id = self.setTimeout( function() { callback( currTime + timeToCall ); }, timeToCall );
			lastTime = currTime + timeToCall;
			return id;

		};

	}

	if( self.cancelAnimationFrame === undefined && self['clearTimeout'] !== undefined ) {

		self.cancelAnimationFrame = function ( id ) { self.clearTimeout( id ) };

	}

}() );

// GL STATE CONSTANTS

THREE.CullFaceNone = 0;
THREE.CullFaceBack = 1;
THREE.CullFaceFront = 2;
THREE.CullFaceFrontBack = 3;

THREE.FrontFaceDirectionCW = 0;
THREE.FrontFaceDirectionCCW = 1;

// SHADOWING TYPES

THREE.BasicShadowMap = 0;
THREE.PCFShadowMap = 1;
THREE.PCFSoftShadowMap = 2;

// MATERIAL CONSTANTS

// side

THREE.FrontSide = 0;
THREE.BackSide = 1;
THREE.DoubleSide = 2;

// shading

THREE.NoShading = 0;
THREE.FlatShading = 1;
THREE.SmoothShading = 2;

// colors

THREE.NoColors = 0;
THREE.FaceColors = 1;
THREE.VertexColors = 2;

// blending modes

THREE.NoBlending = 0;
THREE.NormalBlending = 1;
THREE.AdditiveBlending = 2;
THREE.SubtractiveBlending = 3;
THREE.MultiplyBlending = 4;
THREE.CustomBlending = 5;

// custom blending equations
// (numbers start from 100 not to clash with other
//  mappings to OpenGL constants defined in Texture.js)

THREE.AddEquation = 100;
THREE.SubtractEquation = 101;
THREE.ReverseSubtractEquation = 102;

// custom blending destination factors

THREE.ZeroFactor = 200;
THREE.OneFactor = 201;
THREE.SrcColorFactor = 202;
THREE.OneMinusSrcColorFactor = 203;
THREE.SrcAlphaFactor = 204;
THREE.OneMinusSrcAlphaFactor = 205;
THREE.DstAlphaFactor = 206;
THREE.OneMinusDstAlphaFactor = 207;

// custom blending source factors

//THREE.ZeroFactor = 200;
//THREE.OneFactor = 201;
//THREE.SrcAlphaFactor = 204;
//THREE.OneMinusSrcAlphaFactor = 205;
//THREE.DstAlphaFactor = 206;
//THREE.OneMinusDstAlphaFactor = 207;
THREE.DstColorFactor = 208;
THREE.OneMinusDstColorFactor = 209;
THREE.SrcAlphaSaturateFactor = 210;


// TEXTURE CONSTANTS

THREE.MultiplyOperation = 0;
THREE.MixOperation = 1;
THREE.AddOperation = 2;

// Mapping modes

THREE.UVMapping = function () {};

THREE.CubeReflectionMapping = function () {};
THREE.CubeRefractionMapping = function () {};

THREE.SphericalReflectionMapping = function () {};
THREE.SphericalRefractionMapping = function () {};

// Wrapping modes

THREE.RepeatWrapping = 1000;
THREE.ClampToEdgeWrapping = 1001;
THREE.MirroredRepeatWrapping = 1002;

// Filters

THREE.NearestFilter = 1003;
THREE.NearestMipMapNearestFilter = 1004;
THREE.NearestMipMapLinearFilter = 1005;
THREE.LinearFilter = 1006;
THREE.LinearMipMapNearestFilter = 1007;
THREE.LinearMipMapLinearFilter = 1008;

// Data types

THREE.UnsignedByteType = 1009;
THREE.ByteType = 1010;
THREE.ShortType = 1011;
THREE.UnsignedShortType = 1012;
THREE.IntType = 1013;
THREE.UnsignedIntType = 1014;
THREE.FloatType = 1015;

// Pixel types

//THREE.UnsignedByteType = 1009;
THREE.UnsignedShort4444Type = 1016;
THREE.UnsignedShort5551Type = 1017;
THREE.UnsignedShort565Type = 1018;

// Pixel formats

THREE.AlphaFormat = 1019;
THREE.RGBFormat = 1020;
THREE.RGBAFormat = 1021;
THREE.LuminanceFormat = 1022;
THREE.LuminanceAlphaFormat = 1023;

// Compressed texture formats

THREE.RGB_S3TC_DXT1_Format = 2001;
THREE.RGBA_S3TC_DXT1_Format = 2002;
THREE.RGBA_S3TC_DXT3_Format = 2003;
THREE.RGBA_S3TC_DXT5_Format = 2004;

/*
// Potential future PVRTC compressed texture formats
THREE.RGB_PVRTC_4BPPV1_Format = 2100;
THREE.RGB_PVRTC_2BPPV1_Format = 2101;
THREE.RGBA_PVRTC_4BPPV1_Format = 2102;
THREE.RGBA_PVRTC_2BPPV1_Format = 2103;
*/

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Color = function ( color ) {

	if ( arguments.length === 3 ) {

		return this.setRGB( arguments[ 0 ], arguments[ 1 ], arguments[ 2 ] );

	}

	return this.set( color )

};

THREE.Color.prototype = {

	constructor: THREE.Color,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value instanceof THREE.Color ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function ( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			var hue2rgb = function ( p, q, t ) {

				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;

			};

			var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			var q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	},

	setStyle: function ( style ) {

		// rgb(255,0,0)

		if ( /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.test( style ) ) {

			var color = /^rgb\((\d+), ?(\d+), ?(\d+)\)$/i.exec( style );

			this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
			this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
			this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

			return this;

		}

		// rgb(100%,0%,0%)

		if ( /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.test( style ) ) {

			var color = /^rgb\((\d+)\%, ?(\d+)\%, ?(\d+)\%\)$/i.exec( style );

			this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
			this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
			this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

			return this;

		}

		// #ff0000

		if ( /^\#([0-9a-f]{6})$/i.test( style ) ) {

			var color = /^\#([0-9a-f]{6})$/i.exec( style );

			this.setHex( parseInt( color[ 1 ], 16 ) );

			return this;

		}

		// #f00

		if ( /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.test( style ) ) {

			var color = /^\#([0-9a-f])([0-9a-f])([0-9a-f])$/i.exec( style );

			this.setHex( parseInt( color[ 1 ] + color[ 1 ] + color[ 2 ] + color[ 2 ] + color[ 3 ] + color[ 3 ], 16 ) );

			return this;

		}

		// red

		if ( /^(\w+)$/i.test( style ) ) {

			this.setHex( THREE.ColorKeywords[ style ] );

			return this;

		}


	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color ) {

		this.r = color.r * color.r;
		this.g = color.g * color.g;
		this.b = color.b * color.b;

		return this;

	},

	copyLinearToGamma: function ( color ) {

		this.r = Math.sqrt( color.r );
		this.g = Math.sqrt( color.g );
		this.b = Math.sqrt( color.b );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array ) {

		this.r = array[ 0 ];
		this.g = array[ 1 ];
		this.b = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.r, this.g, this.b ];

	},

	clone: function () {

		return new THREE.Color().setRGB( this.r, this.g, this.b );

	}

};

THREE.ColorKeywords = { "aliceblue": 0xF0F8FF, "antiquewhite": 0xFAEBD7, "aqua": 0x00FFFF, "aquamarine": 0x7FFFD4, "azure": 0xF0FFFF,
"beige": 0xF5F5DC, "bisque": 0xFFE4C4, "black": 0x000000, "blanchedalmond": 0xFFEBCD, "blue": 0x0000FF, "blueviolet": 0x8A2BE2,
"brown": 0xA52A2A, "burlywood": 0xDEB887, "cadetblue": 0x5F9EA0, "chartreuse": 0x7FFF00, "chocolate": 0xD2691E, "coral": 0xFF7F50,
"cornflowerblue": 0x6495ED, "cornsilk": 0xFFF8DC, "crimson": 0xDC143C, "cyan": 0x00FFFF, "darkblue": 0x00008B, "darkcyan": 0x008B8B,
"darkgoldenrod": 0xB8860B, "darkgray": 0xA9A9A9, "darkgreen": 0x006400, "darkgrey": 0xA9A9A9, "darkkhaki": 0xBDB76B, "darkmagenta": 0x8B008B,
"darkolivegreen": 0x556B2F, "darkorange": 0xFF8C00, "darkorchid": 0x9932CC, "darkred": 0x8B0000, "darksalmon": 0xE9967A, "darkseagreen": 0x8FBC8F,
"darkslateblue": 0x483D8B, "darkslategray": 0x2F4F4F, "darkslategrey": 0x2F4F4F, "darkturquoise": 0x00CED1, "darkviolet": 0x9400D3,
"deeppink": 0xFF1493, "deepskyblue": 0x00BFFF, "dimgray": 0x696969, "dimgrey": 0x696969, "dodgerblue": 0x1E90FF, "firebrick": 0xB22222,
"floralwhite": 0xFFFAF0, "forestgreen": 0x228B22, "fuchsia": 0xFF00FF, "gainsboro": 0xDCDCDC, "ghostwhite": 0xF8F8FF, "gold": 0xFFD700,
"goldenrod": 0xDAA520, "gray": 0x808080, "green": 0x008000, "greenyellow": 0xADFF2F, "grey": 0x808080, "honeydew": 0xF0FFF0, "hotpink": 0xFF69B4,
"indianred": 0xCD5C5C, "indigo": 0x4B0082, "ivory": 0xFFFFF0, "khaki": 0xF0E68C, "lavender": 0xE6E6FA, "lavenderblush": 0xFFF0F5, "lawngreen": 0x7CFC00,
"lemonchiffon": 0xFFFACD, "lightblue": 0xADD8E6, "lightcoral": 0xF08080, "lightcyan": 0xE0FFFF, "lightgoldenrodyellow": 0xFAFAD2, "lightgray": 0xD3D3D3,
"lightgreen": 0x90EE90, "lightgrey": 0xD3D3D3, "lightpink": 0xFFB6C1, "lightsalmon": 0xFFA07A, "lightseagreen": 0x20B2AA, "lightskyblue": 0x87CEFA,
"lightslategray": 0x778899, "lightslategrey": 0x778899, "lightsteelblue": 0xB0C4DE, "lightyellow": 0xFFFFE0, "lime": 0x00FF00, "limegreen": 0x32CD32,
"linen": 0xFAF0E6, "magenta": 0xFF00FF, "maroon": 0x800000, "mediumaquamarine": 0x66CDAA, "mediumblue": 0x0000CD, "mediumorchid": 0xBA55D3,
"mediumpurple": 0x9370DB, "mediumseagreen": 0x3CB371, "mediumslateblue": 0x7B68EE, "mediumspringgreen": 0x00FA9A, "mediumturquoise": 0x48D1CC,
"mediumvioletred": 0xC71585, "midnightblue": 0x191970, "mintcream": 0xF5FFFA, "mistyrose": 0xFFE4E1, "moccasin": 0xFFE4B5, "navajowhite": 0xFFDEAD,
"navy": 0x000080, "oldlace": 0xFDF5E6, "olive": 0x808000, "olivedrab": 0x6B8E23, "orange": 0xFFA500, "orangered": 0xFF4500, "orchid": 0xDA70D6,
"palegoldenrod": 0xEEE8AA, "palegreen": 0x98FB98, "paleturquoise": 0xAFEEEE, "palevioletred": 0xDB7093, "papayawhip": 0xFFEFD5, "peachpuff": 0xFFDAB9,
"peru": 0xCD853F, "pink": 0xFFC0CB, "plum": 0xDDA0DD, "powderblue": 0xB0E0E6, "purple": 0x800080, "red": 0xFF0000, "rosybrown": 0xBC8F8F,
"royalblue": 0x4169E1, "saddlebrown": 0x8B4513, "salmon": 0xFA8072, "sandybrown": 0xF4A460, "seagreen": 0x2E8B57, "seashell": 0xFFF5EE,
"sienna": 0xA0522D, "silver": 0xC0C0C0, "skyblue": 0x87CEEB, "slateblue": 0x6A5ACD, "slategray": 0x708090, "slategrey": 0x708090, "snow": 0xFFFAFA,
"springgreen": 0x00FF7F, "steelblue": 0x4682B4, "tan": 0xD2B48C, "teal": 0x008080, "thistle": 0xD8BFD8, "tomato": 0xFF6347, "turquoise": 0x40E0D0,
"violet": 0xEE82EE, "wheat": 0xF5DEB3, "white": 0xFFFFFF, "whitesmoke": 0xF5F5F5, "yellow": 0xFFFF00, "yellowgreen": 0x9ACD32 };

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Quaternion = function ( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

};

THREE.Quaternion.prototype = {

	constructor: THREE.Quaternion,

	_x: 0,_y: 0, _z: 0, _w: 0,

	_euler: undefined,

	_updateEuler: function ( callback ) {

		if ( this._euler !== undefined ) {

			this._euler.setFromQuaternion( this, undefined, false );

		}

	},

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this._updateEuler();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this._updateEuler();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this._updateEuler();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this._updateEuler();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._updateEuler();

		return this;

	},

	copy: function ( quaternion ) {

		this._x = quaternion._x;
		this._y = quaternion._y;
		this._z = quaternion._z;
		this._w = quaternion._w;

		this._updateEuler();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( euler instanceof THREE.Euler === false ) {

			throw new Error( 'ERROR: Quaternion\'s .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );
		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		if ( euler.order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( euler.order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( euler.order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this._updateEuler();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// from http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
		// axis have to be normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._updateEuler();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[0], m12 = te[4], m13 = te[8],
			m21 = te[1], m22 = te[5], m23 = te[9],
			m31 = te[2], m32 = te[6], m33 = te[10],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = (m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = (m12 + m21 ) / s;
			this._z = (m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = (m13 - m31 ) / s;
			this._x = (m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = (m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._updateEuler();

		return this;

	},

	inverse: function () {

		this.conjugate().normalize();

		return this;

	},

	conjugate: function () {

		this._x *= -1;
		this._y *= -1;
		this._z *= -1;

		this._updateEuler();

		return this;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'DEPRECATED: Quaternion\'s .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._updateEuler();

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Quaternion\'s .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	},

	slerp: function ( qb, t ) {

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = -qb._w;
			this._x = -qb._x;
			this._y = -qb._y;
			this._z = -qb._z;

			cosHalfTheta = -cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var halfTheta = Math.acos( cosHalfTheta );
		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._updateEuler();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		this._w = array[ 3 ];

		this._updateEuler();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._w ];

	},

	clone: function () {

		return new THREE.Quaternion( this._x, this._y, this._z, this._w );

	}

};

THREE.Quaternion.slerp = function ( qa, qb, qm, t ) {

	return qm.copy( qa ).slerp( qb, t );

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.Vector2 = function ( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

};

THREE.Vector2.prototype = {

	constructor: THREE.Vector2,

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},


	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector2\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector2\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.x *= s;
		this.y *= s;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		return this;
	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector2();
				max = new THREE.Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};
		
	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		return this.multiplyScalar( - 1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	equals: function( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y ];

	},

	clone: function () {

		return new THREE.Vector2( this.x, this.y );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector3 = function ( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

};

THREE.Vector3.prototype = {

	constructor: THREE.Vector3,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function ( euler ) {

			if ( euler instanceof THREE.Euler === false ) {

				console.error( 'ERROR: Vector3\'s .applyEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );

			}

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromEuler( euler ) );

			return this;

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function ( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new THREE.Quaternion();

			this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

			return this;

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[3] * y + e[6] * z;
		this.y = e[1] * x + e[4] * y + e[7] * z;
		this.z = e[2] * x + e[5] * y + e[8] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8]  * z + e[12];
		this.y = e[1] * x + e[5] * y + e[9]  * z + e[13];
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;
		var d = 1 / ( e[3] * x + e[7] * y + e[11] * z + e[15] ); // perspective divide

		this.x = ( e[0] * x + e[4] * y + e[8]  * z + e[12] ) * d;
		this.y = ( e[1] * x + e[5] * y + e[9]  * z + e[13] ) * d;
		this.z = ( e[2] * x + e[6] * y + e[10] * z + e[14] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;

		var qx = q.x;
		var qy = q.y;
		var qz = q.z;
		var qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = -qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

		return this;

	},

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8]  * z;
		this.y = e[1] * x + e[5] * y + e[9]  * z;
		this.z = e[2] * x + e[6] * y + e[10] * z;

		this.normalize();

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector3();
				max = new THREE.Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		return this.multiplyScalar( - 1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength  ) {

			this.multiplyScalar( l / oldLength );
		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector3\'s .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function () {

		var v1, dot;

		return function ( vector ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( vector ).normalize();

			dot = this.dot( v1 );

			return this.copy( v1 ).multiplyScalar( dot );

		};

	}(),

	projectOnPlane: function () {

		var v1;

		return function ( planeNormal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		}

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function ( normal ) {

			if ( v1 === undefined ) v1 = new THREE.Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		}

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( this.length() * v.length() );

		// clamp, to handle numerical problems

		return Math.acos( THREE.Math.clamp( theta, -1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x;
		var dy = this.y - v.y;
		var dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	setEulerFromRotationMatrix: function ( m, order ) {

		console.error( "REMOVED: Vector3\'s setEulerFromRotationMatrix has been removed in favor of Euler.setFromRotationMatrix(), please update your code.");

	},

	setEulerFromQuaternion: function ( q, order ) {

		console.error( "REMOVED: Vector3\'s setEulerFromQuaternion: has been removed in favor of Euler.setFromQuaternion(), please update your code.");

	},

	getPositionFromMatrix: function ( m ) {

		console.warn( "DEPRECATED: Vector3\'s .getPositionFromMatrix() has been renamed to .setFromMatrixPosition(). Please update your code." );

		return this.setFromMatrixPosition( m );

	},

	getScaleFromMatrix: function ( m ) {

		console.warn( "DEPRECATED: Vector3\'s .getScaleFromMatrix() has been renamed to .setFromMatrixScale(). Please update your code." );

		return this.setFromMatrixScale( m );
	},

	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( "DEPRECATED: Vector3\'s .getColumnFromMatrix() has been renamed to .setFromMatrixColumn(). Please update your code." );

		return this.setFromMatrixColumn( index, matrix );

	},

	setFromMatrixPosition: function ( m ) {

		this.x = m.elements[ 12 ];
		this.y = m.elements[ 13 ];
		this.z = m.elements[ 14 ];

		return this;

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.set( m.elements[ 0 ], m.elements[ 1 ], m.elements[  2 ] ).length();
		var sy = this.set( m.elements[ 4 ], m.elements[ 5 ], m.elements[  6 ] ).length();
		var sz = this.set( m.elements[ 8 ], m.elements[ 9 ], m.elements[ 10 ] ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;
	},

	setFromMatrixColumn: function ( index, matrix ) {

		var offset = index * 4;

		var me = matrix.elements;

		this.x = me[ offset ];
		this.y = me[ offset + 1 ];
		this.z = me[ offset + 2 ];

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];
		this.z = array[ 2 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y, this.z ];

	},

	clone: function () {

		return new THREE.Vector3( this.x, this.y, this.z );

	}

};
/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Vector4 = function ( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

};

THREE.Vector4.prototype = {

	constructor: THREE.Vector4,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( "index is out of range: " + index );

		}

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector4\'s .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'DEPRECATED: Vector4\'s .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x;
		var y = this.y;
		var z = this.z;
		var w = this.w;

		var e = m.elements;

		this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
		this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
		this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
		this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		if ( scalar !== 0 ) {

			var invScalar = 1 / scalar;

			this.x *= invScalar;
			this.y *= invScalar;
			this.z *= invScalar;
			this.w *= invScalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 1;

		}

		return this;

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[0], m12 = te[4], m13 = te[8],
			m21 = te[1], m22 = te[5], m23 = te[9],
			m31 = te[2], m32 = te[6], m33 = te[10];

		if ( ( Math.abs( m12 - m21 ) < epsilon )
		  && ( Math.abs( m13 - m31 ) < epsilon )
		  && ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 )
			  && ( Math.abs( m13 + m31 ) < epsilon2 )
			  && ( Math.abs( m23 + m32 ) < epsilon2 )
			  && ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) { // m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) { // m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else { // m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 )
						 + ( m13 - m31 ) * ( m13 - m31 )
						 + ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		if ( this.x > v.x ) {

			this.x = v.x;

		}

		if ( this.y > v.y ) {

			this.y = v.y;

		}

		if ( this.z > v.z ) {

			this.z = v.z;

		}

		if ( this.w > v.w ) {

			this.w = v.w;

		}

		return this;

	},

	max: function ( v ) {

		if ( this.x < v.x ) {

			this.x = v.x;

		}

		if ( this.y < v.y ) {

			this.y = v.y;

		}

		if ( this.z < v.z ) {

			this.z = v.z;

		}

		if ( this.w < v.w ) {

			this.w = v.w;

		}

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		if ( this.x < min.x ) {

			this.x = min.x;

		} else if ( this.x > max.x ) {

			this.x = max.x;

		}

		if ( this.y < min.y ) {

			this.y = min.y;

		} else if ( this.y > max.y ) {

			this.y = max.y;

		}

		if ( this.z < min.z ) {

			this.z = min.z;

		} else if ( this.z > max.z ) {

			this.z = max.z;

		}

		if ( this.w < min.w ) {

			this.w = min.w;

		} else if ( this.w > max.w ) {

			this.w = max.w;

		}

		return this;

	},

	clampScalar: ( function () {

		var min, max;

		return function ( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new THREE.Vector4();
				max = new THREE.Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	} )(),

    floor: function () {

        this.x = Math.floor( this.x );
        this.y = Math.floor( this.y );
        this.z = Math.floor( this.z );
        this.w = Math.floor( this.w );

        return this;

    },

    ceil: function () {

        this.x = Math.ceil( this.x );
        this.y = Math.ceil( this.y );
        this.z = Math.ceil( this.z );
        this.w = Math.ceil( this.w );

        return this;

    },

    round: function () {

        this.x = Math.round( this.x );
        this.y = Math.round( this.y );
        this.z = Math.round( this.z );
        this.w = Math.round( this.w );

        return this;

    },

    roundToZero: function () {

        this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
        this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
        this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
        this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

        return this;

    },

	negate: function () {

		return this.multiplyScalar( -1 );

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( l ) {

		var oldLength = this.length();

		if ( oldLength !== 0 && l !== oldLength ) {

			this.multiplyScalar( l / oldLength );

		}

		return this;

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array ) {

		this.x = array[ 0 ];
		this.y = array[ 1 ];
		this.z = array[ 2 ];
		this.w = array[ 3 ];

		return this;

	},

	toArray: function () {

		return [ this.x, this.y, this.z, this.w ];

	},

	clone: function () {

		return new THREE.Vector4( this.x, this.y, this.z, this.w );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Euler = function ( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || THREE.Euler.DefaultOrder;

};

THREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

THREE.Euler.DefaultOrder = 'XYZ';

THREE.Euler.prototype = {

	constructor: THREE.Euler,

	_x: 0, _y: 0, _z: 0, _order: THREE.Euler.DefaultOrder,

	_quaternion: undefined,

	_updateQuaternion: function () {

		if ( this._quaternion !== undefined ) {

			this._quaternion.setFromEuler( this, false );

		}

	},

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this._updateQuaternion();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this._updateQuaternion();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this._updateQuaternion();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this._updateQuaternion();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._updateQuaternion();

		return this;

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._updateQuaternion();

		return this;

	},

	setFromRotationMatrix: function ( m, order ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		// clamp, to handle numerical problems

		function clamp( x ) {

			return Math.min( Math.max( x, -1 ), 1 );

		}

		var te = m.elements;
		var m11 = te[0], m12 = te[4], m13 = te[8];
		var m21 = te[1], m22 = te[5], m23 = te[9];
		var m31 = te[2], m32 = te[6], m33 = te[10];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'WARNING: Euler.setFromRotationMatrix() given unsupported order: ' + order )

		}

		this._order = order;

		this._updateQuaternion();

		return this;

	},

	setFromQuaternion: function ( q, order, update ) {

		// q is assumed to be normalized

		// clamp, to handle numerical problems

		function clamp( x ) {

			return Math.min( Math.max( x, -1 ), 1 );

		}

		// http://www.mathworks.com/matlabcentral/fileexchange/20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m

		var sqx = q.x * q.x;
		var sqy = q.y * q.y;
		var sqz = q.z * q.z;
		var sqw = q.w * q.w;

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.y * q.z ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.x * q.z + q.y * q.w ) ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order ===  'YXZ' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w - q.y * q.z ) ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin(  clamp( 2 * ( q.x * q.w + q.y * q.z ) ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.z * q.x ), ( sqw - sqx - sqy + sqz ) );
			this._z = Math.atan2( 2 * ( q.z * q.w - q.x * q.y ), ( sqw - sqx + sqy - sqz ) );

		} else if ( order === 'ZYX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.z * q.y ), ( sqw - sqx - sqy + sqz ) );
			this._y = Math.asin(  clamp( 2 * ( q.y * q.w - q.x * q.z ) ) );
			this._z = Math.atan2( 2 * ( q.x * q.y + q.z * q.w ), ( sqw + sqx - sqy - sqz ) );

		} else if ( order === 'YZX' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w - q.z * q.y ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.y * q.w - q.x * q.z ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.x * q.y + q.z * q.w ) ) );

		} else if ( order === 'XZY' ) {

			this._x = Math.atan2( 2 * ( q.x * q.w + q.y * q.z ), ( sqw - sqx + sqy - sqz ) );
			this._y = Math.atan2( 2 * ( q.x * q.z + q.y * q.w ), ( sqw + sqx - sqy - sqz ) );
			this._z = Math.asin(  clamp( 2 * ( q.z * q.w - q.x * q.y ) ) );

		} else {

			console.warn( 'WARNING: Euler.setFromQuaternion() given unsupported order: ' + order )

		}

		this._order = order;

		if ( update !== false ) this._updateQuaternion();

		return this;

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new THREE.Quaternion();

		return function ( newOrder ) {

			q.setFromEuler( this );
			this.setFromQuaternion( q, newOrder );

		};


	}(),

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._updateQuaternion();

		return this;

	},

	toArray: function () {

		return [ this._x, this._y, this._z, this._order ];

	},

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	clone: function () {

		return new THREE.Euler( this._x, this._y, this._z, this._order );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Line3 = function ( start, end ) {

	this.start = ( start !== undefined ) ? start : new THREE.Vector3();
	this.end = ( end !== undefined ) ? end : new THREE.Vector3();

};

THREE.Line3.prototype = {

	constructor: THREE.Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function() {

		var startP = new THREE.Vector3();
		var startEnd = new THREE.Vector3();

		return function ( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = THREE.Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new THREE.Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	},

	clone: function () {

		return new THREE.Line3().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Box2 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector2( Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector2( -Infinity, -Infinity );

};

THREE.Box2.prototype = {

	constructor: THREE.Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		if ( points.length > 0 ) {

			var point = points[ 0 ];

			this.min.copy( point );
			this.max.copy( point );

			for ( var i = 1, il = points.length; i < il; i ++ ) {

				point = points[ i ];

				if ( point.x < this.min.x ) {

					this.min.x = point.x;

				} else if ( point.x > this.max.x ) {

					this.max.x = point.x;

				}

				if ( point.y < this.min.y ) {

					this.min.y = point.y;

				} else if ( point.y > this.max.y ) {

					this.max.y = point.y;

				}

			}

		} else {

			this.makeEmpty();

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new THREE.Vector2();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = Infinity;
		this.max.x = this.max.y = -Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;
	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;
	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( -scalar );
		this.max.addScalar( scalar );

		return this;
	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
		     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector2();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box2().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Box3 = function ( min, max ) {

	this.min = ( min !== undefined ) ? min : new THREE.Vector3( Infinity, Infinity, Infinity );
	this.max = ( max !== undefined ) ? max : new THREE.Vector3( -Infinity, -Infinity, -Infinity );

};

THREE.Box3.prototype = {

	constructor: THREE.Box3,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	addPoint: function ( point ) {

		if ( point.x < this.min.x ) {

			this.min.x = point.x;

		} else if ( point.x > this.max.x ) {

			this.max.x = point.x;

		}

		if ( point.y < this.min.y ) {

			this.min.y = point.y;

		} else if ( point.y > this.max.y ) {

			this.max.y = point.y;

		}

		if ( point.z < this.min.z ) {

			this.min.z = point.z;

		} else if ( point.z > this.max.z ) {

			this.max.z = point.z;

		}

	},

	setFromPoints: function ( points ) {

		if ( points.length > 0 ) {

			var point = points[ 0 ];

			this.min.copy( point );
			this.max.copy( point );

			for ( var i = 1, il = points.length; i < il; i ++ ) {

				this.addPoint( points[ i ] )

			}

		} else {

			this.makeEmpty();

		}

		return this;

	},

	setFromCenterAndSize: function() {

		var v1 = new THREE.Vector3();

		return function ( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function() {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and childrens', world transforms

		var v1 = new THREE.Vector3();

		return function( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				if ( node.geometry !== undefined && node.geometry.vertices !== undefined ) {

					var vertices = node.geometry.vertices;

					for ( var i = 0, il = vertices.length; i < il; i++ ) {

						v1.copy( vertices[ i ] );

						v1.applyMatrix4( node.matrixWorld );

						scope.expandByPoint( v1 );

					}

				}

			} );

			return this;

		};

	}(),

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = Infinity;
		this.max.x = this.max.y = this.max.z = -Infinity;

		return this;

	},

	empty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	center: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	size: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( -scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		if ( point.x < this.min.x || point.x > this.max.x ||
		     point.y < this.min.y || point.y > this.max.y ||
		     point.z < this.min.z || point.z > this.max.z ) {

			return false;

		}

		return true;

	},

	containsBox: function ( box ) {

		if ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&
			 ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&
			 ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {

			return true;

		}

		return false;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new THREE.Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	isIntersectionBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.

		if ( box.max.x < this.min.x || box.min.x > this.max.x ||
		     box.max.y < this.min.y || box.min.y > this.max.y ||
		     box.max.z < this.min.z || box.min.z > this.max.z ) {

			return false;

		}

		return true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function() {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function() {

		var v1 = new THREE.Vector3();

		return function ( optionalTarget ) {

			var result = optionalTarget || new THREE.Sphere();

			result.center = this.center();
			result.radius = this.size( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function() {

		var points = [
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3(),
			new THREE.Vector3()
		];

		return function ( matrix ) {

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[0].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[1].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[2].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[3].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[4].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[5].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[6].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[7].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );  // 111

			this.makeEmpty();
			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	},

	clone: function () {

		return new THREE.Box3().copy( this );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://exocortex.com
 */

THREE.Matrix3 = function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

	this.elements = new Float32Array(9);

	this.set(

		( n11 !== undefined ) ? n11 : 1, n12 || 0, n13 || 0,
		n21 || 0, ( n22 !== undefined ) ? n22 : 1, n23 || 0,
		n31 || 0, n32 || 0, ( n33 !== undefined ) ? n33 : 1

	);
};

THREE.Matrix3.prototype = {

	constructor: THREE.Matrix3,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[0] = n11; te[3] = n12; te[6] = n13;
		te[1] = n21; te[4] = n22; te[7] = n23;
		te[2] = n31; te[5] = n32; te[8] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[0], me[3], me[6],
			me[1], me[4], me[7],
			me[2], me[5], me[8]

		);

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix3\'s .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},

	multiplyVector3Array: function() {

		var v1 = new THREE.Vector3();

		return function ( a ) {

			for ( var i = 0, il = a.length; i < il; i += 3 ) {

				v1.x = a[ i ];
				v1.y = a[ i + 1 ];
				v1.z = a[ i + 2 ];

				v1.applyMatrix3(this);

				a[ i ]     = v1.x;
				a[ i + 1 ] = v1.y;
				a[ i + 2 ] = v1.z;

			}

			return a;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[0] *= s; te[3] *= s; te[6] *= s;
		te[1] *= s; te[4] *= s; te[7] *= s;
		te[2] *= s; te[5] *= s; te[8] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[0], b = te[1], c = te[2],
			d = te[3], e = te[4], f = te[5],
			g = te[6], h = te[7], i = te[8];

		return a*e*i - a*f*h - b*d*i + b*f*g + c*d*h - c*e*g;

	},

	getInverse: function ( matrix, throwOnInvertible ) {

		// input: THREE.Matrix4
		// ( based on http://code.google.com/p/webgl-mjs/ )

		var me = matrix.elements;
		var te = this.elements;

		te[ 0 ] =   me[10] * me[5] - me[6] * me[9];
		te[ 1 ] = - me[10] * me[1] + me[2] * me[9];
		te[ 2 ] =   me[6] * me[1] - me[2] * me[5];
		te[ 3 ] = - me[10] * me[4] + me[6] * me[8];
		te[ 4 ] =   me[10] * me[0] - me[2] * me[8];
		te[ 5 ] = - me[6] * me[0] + me[2] * me[4];
		te[ 6 ] =   me[9] * me[4] - me[5] * me[8];
		te[ 7 ] = - me[9] * me[0] + me[1] * me[8];
		te[ 8 ] =   me[5] * me[0] - me[1] * me[4];

		var det = me[ 0 ] * te[ 0 ] + me[ 1 ] * te[ 3 ] + me[ 2 ] * te[ 6 ];

		// no inverse

		if ( det === 0 ) {

			var msg = "Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;

		}

		this.multiplyScalar( 1.0 / det );

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[1]; m[1] = m[3]; m[3] = tmp;
		tmp = m[2]; m[2] = m[6]; m[6] = tmp;
		tmp = m[5]; m[5] = m[7]; m[7] = tmp;

		return this;

	},

	getNormalMatrix: function ( m ) {

		// input: THREE.Matrix4

		this.getInverse( m ).transpose();

		return this;

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ],
			te[ 3 ], te[ 4 ], te[ 5 ],
			te[ 6 ], te[ 7 ], te[ 8 ]
		];

	},

	clone: function () {

		var te = this.elements;

		return new THREE.Matrix3(

			te[0], te[3], te[6],
			te[1], te[4], te[7],
			te[2], te[5], te[8]

		);

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://exocortex.com
 * @author WestLangley / http://github.com/WestLangley
 */


THREE.Matrix4 = function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

	this.elements = new Float32Array( 16 );

	// TODO: if n11 is undefined, then just set to identity, otherwise copy all other values into matrix
	//   we should not support semi specification of Matrix4, it is just weird.

	var te = this.elements;

	te[0] = ( n11 !== undefined ) ? n11 : 1; te[4] = n12 || 0; te[8] = n13 || 0; te[12] = n14 || 0;
	te[1] = n21 || 0; te[5] = ( n22 !== undefined ) ? n22 : 1; te[9] = n23 || 0; te[13] = n24 || 0;
	te[2] = n31 || 0; te[6] = n32 || 0; te[10] = ( n33 !== undefined ) ? n33 : 1; te[14] = n34 || 0;
	te[3] = n41 || 0; te[7] = n42 || 0; te[11] = n43 || 0; te[15] = ( n44 !== undefined ) ? n44 : 1;

};

THREE.Matrix4.prototype = {

	constructor: THREE.Matrix4,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[0] = n11; te[4] = n12; te[8] = n13; te[12] = n14;
		te[1] = n21; te[5] = n22; te[9] = n23; te[13] = n24;
		te[2] = n31; te[6] = n32; te[10] = n33; te[14] = n34;
		te[3] = n41; te[7] = n42; te[11] = n43; te[15] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	extractPosition: function ( m ) {

		console.warn( 'DEPRECATED: Matrix4\'s .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[12] = me[12];
		te[13] = me[13];
		te[14] = me[14];

		return this;

	},

	extractRotation: function () {

		var v1 = new THREE.Vector3();

		return function ( m ) {

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.set( me[0], me[1], me[2] ).length();
			var scaleY = 1 / v1.set( me[4], me[5], me[6] ).length();
			var scaleZ = 1 / v1.set( me[8], me[9], me[10] ).length();

			te[0] = me[0] * scaleX;
			te[1] = me[1] * scaleX;
			te[2] = me[2] * scaleX;

			te[4] = me[4] * scaleY;
			te[5] = me[5] * scaleY;
			te[6] = me[6] * scaleY;

			te[8] = me[8] * scaleZ;
			te[9] = me[9] * scaleZ;
			te[10] = me[10] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( euler instanceof THREE.Euler === false ) {

			console.error( 'ERROR: Matrix\'s .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.  Please update your code.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[0] = c * e;
			te[4] = - c * f;
			te[8] = d;

			te[1] = af + be * d;
			te[5] = ae - bf * d;
			te[9] = - b * c;

			te[2] = bf - ae * d;
			te[6] = be + af * d;
			te[10] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[0] = ce + df * b;
			te[4] = de * b - cf;
			te[8] = a * d;

			te[1] = a * f;
			te[5] = a * e;
			te[9] = - b;

			te[2] = cf * b - de;
			te[6] = df + ce * b;
			te[10] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[0] = ce - df * b;
			te[4] = - a * f;
			te[8] = de + cf * b;

			te[1] = cf + de * b;
			te[5] = a * e;
			te[9] = df - ce * b;

			te[2] = - a * d;
			te[6] = b;
			te[10] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[0] = c * e;
			te[4] = be * d - af;
			te[8] = ae * d + bf;

			te[1] = c * f;
			te[5] = bf * d + ae;
			te[9] = af * d - be;

			te[2] = - d;
			te[6] = b * c;
			te[10] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[0] = c * e;
			te[4] = bd - ac * f;
			te[8] = bc * f + ad;

			te[1] = f;
			te[5] = a * e;
			te[9] = - b * e;

			te[2] = - d * e;
			te[6] = ad * f + bc;
			te[10] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[0] = c * e;
			te[4] = - f;
			te[8] = d * e;

			te[1] = ac * f + bd;
			te[5] = a * e;
			te[9] = ad * f - bc;

			te[2] = bc * f - ad;
			te[6] = b * e;
			te[10] = bd * f + ac;

		}

		// last column
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;

		// bottom row
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;

		return this;

	},

	setRotationFromQuaternion: function ( q ) {

		console.warn( 'DEPRECATED: Matrix4\'s .setRotationFromQuaternion() has been deprecated in favor of makeRotationFromQuaternion.  Please update your code.' );

		return this.makeRotationFromQuaternion( q );

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[0] = 1 - ( yy + zz );
		te[4] = xy - wz;
		te[8] = xz + wy;

		te[1] = xy + wz;
		te[5] = 1 - ( xx + zz );
		te[9] = yz - wx;

		te[2] = xz - wy;
		te[6] = yz + wx;
		te[10] = 1 - ( xx + yy );

		// last column
		te[3] = 0;
		te[7] = 0;
		te[11] = 0;

		// bottom row
		te[12] = 0;
		te[13] = 0;
		te[14] = 0;
		te[15] = 1;

		return this;

	},

	lookAt: function() {

		var x = new THREE.Vector3();
		var y = new THREE.Vector3();
		var z = new THREE.Vector3();

		return function ( eye, target, up ) {

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.length() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.length() === 0 ) {

				z.x += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[0] = x.x; te[4] = y.x; te[8] = z.x;
			te[1] = x.y; te[5] = y.y; te[9] = z.y;
			te[2] = x.z; te[6] = y.z; te[10] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'DEPRECATED: Matrix4\'s .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
		var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
		var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
		var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];

		var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
		var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
		var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
		var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];

		te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[0]; r[ 1 ] = te[1]; r[ 2 ] = te[2]; r[ 3 ] = te[3];
		r[ 4 ] = te[4]; r[ 5 ] = te[5]; r[ 6 ] = te[6]; r[ 7 ] = te[7];
		r[ 8 ]  = te[8]; r[ 9 ]  = te[9]; r[ 10 ] = te[10]; r[ 11 ] = te[11];
		r[ 12 ] = te[12]; r[ 13 ] = te[13]; r[ 14 ] = te[14]; r[ 15 ] = te[15];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[0] *= s; te[4] *= s; te[8] *= s; te[12] *= s;
		te[1] *= s; te[5] *= s; te[9] *= s; te[13] *= s;
		te[2] *= s; te[6] *= s; te[10] *= s; te[14] *= s;
		te[3] *= s; te[7] *= s; te[11] *= s; te[15] *= s;

		return this;

	},

	multiplyVector3: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},

	multiplyVector4: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix4\'s .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	multiplyVector3Array: function() {

		var v1 = new THREE.Vector3();

		return function ( a ) {

			for ( var i = 0, il = a.length; i < il; i += 3 ) {

				v1.x = a[ i ];
				v1.y = a[ i + 1 ];
				v1.z = a[ i + 2 ];

				v1.applyProjection( this );

				a[ i ]     = v1.x;
				a[ i + 1 ] = v1.y;
				a[ i + 2 ] = v1.z;

			}

			return a;

		};

	}(),

	rotateAxis: function ( v ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );

		v.transformDirection( this );

	},

	crossVector: function ( vector ) {

		console.warn( 'DEPRECATED: Matrix4\'s .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},

	determinant: function () {

		var te = this.elements;

		var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
		var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
		var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
		var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+n14 * n23 * n32
				-n13 * n24 * n32
				-n14 * n22 * n33
				+n12 * n24 * n33
				+n13 * n22 * n34
				-n12 * n23 * n34
			) +
			n42 * (
				+n11 * n23 * n34
				-n11 * n24 * n33
				+n14 * n21 * n33
				-n13 * n21 * n34
				+n13 * n24 * n31
				-n14 * n23 * n31
			) +
			n43 * (
				+n11 * n24 * n32
				-n11 * n22 * n34
				-n14 * n21 * n32
				+n12 * n21 * n34
				+n14 * n22 * n31
				-n12 * n24 * n31
			) +
			n44 * (
				-n13 * n22 * n31
				-n11 * n23 * n32
				+n11 * n22 * n33
				+n13 * n21 * n32
				-n12 * n21 * n33
				+n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[1]; te[1] = te[4]; te[4] = tmp;
		tmp = te[2]; te[2] = te[8]; te[8] = tmp;
		tmp = te[6]; te[6] = te[9]; te[9] = tmp;

		tmp = te[3]; te[3] = te[12]; te[12] = tmp;
		tmp = te[7]; te[7] = te[13]; te[13] = tmp;
		tmp = te[11]; te[11] = te[14]; te[14] = tmp;

		return this;

	},

	flattenToArray: function ( flat ) {

		var te = this.elements;
		flat[ 0 ] = te[0]; flat[ 1 ] = te[1]; flat[ 2 ] = te[2]; flat[ 3 ] = te[3];
		flat[ 4 ] = te[4]; flat[ 5 ] = te[5]; flat[ 6 ] = te[6]; flat[ 7 ] = te[7];
		flat[ 8 ] = te[8]; flat[ 9 ] = te[9]; flat[ 10 ] = te[10]; flat[ 11 ] = te[11];
		flat[ 12 ] = te[12]; flat[ 13 ] = te[13]; flat[ 14 ] = te[14]; flat[ 15 ] = te[15];

		return flat;

	},

	flattenToArrayOffset: function( flat, offset ) {

		var te = this.elements;
		flat[ offset ] = te[0];
		flat[ offset + 1 ] = te[1];
		flat[ offset + 2 ] = te[2];
		flat[ offset + 3 ] = te[3];

		flat[ offset + 4 ] = te[4];
		flat[ offset + 5 ] = te[5];
		flat[ offset + 6 ] = te[6];
		flat[ offset + 7 ] = te[7];

		flat[ offset + 8 ]  = te[8];
		flat[ offset + 9 ]  = te[9];
		flat[ offset + 10 ] = te[10];
		flat[ offset + 11 ] = te[11];

		flat[ offset + 12 ] = te[12];
		flat[ offset + 13 ] = te[13];
		flat[ offset + 14 ] = te[14];
		flat[ offset + 15 ] = te[15];

		return flat;

	},

	getPosition: function() {

		var v1 = new THREE.Vector3();

		return function () {

			console.warn( 'DEPRECATED: Matrix4\'s .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );

			var te = this.elements;
			return v1.set( te[12], te[13], te[14] );

		};

	}(),

	setPosition: function ( v ) {

		var te = this.elements;

		te[12] = v.x;
		te[13] = v.y;
		te[14] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnInvertible ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements;
		var me = m.elements;

		var n11 = me[0], n12 = me[4], n13 = me[8], n14 = me[12];
		var n21 = me[1], n22 = me[5], n23 = me[9], n24 = me[13];
		var n31 = me[2], n32 = me[6], n33 = me[10], n34 = me[14];
		var n41 = me[3], n42 = me[7], n43 = me[11], n44 = me[15];

		te[0] = n23*n34*n42 - n24*n33*n42 + n24*n32*n43 - n22*n34*n43 - n23*n32*n44 + n22*n33*n44;
		te[4] = n14*n33*n42 - n13*n34*n42 - n14*n32*n43 + n12*n34*n43 + n13*n32*n44 - n12*n33*n44;
		te[8] = n13*n24*n42 - n14*n23*n42 + n14*n22*n43 - n12*n24*n43 - n13*n22*n44 + n12*n23*n44;
		te[12] = n14*n23*n32 - n13*n24*n32 - n14*n22*n33 + n12*n24*n33 + n13*n22*n34 - n12*n23*n34;
		te[1] = n24*n33*n41 - n23*n34*n41 - n24*n31*n43 + n21*n34*n43 + n23*n31*n44 - n21*n33*n44;
		te[5] = n13*n34*n41 - n14*n33*n41 + n14*n31*n43 - n11*n34*n43 - n13*n31*n44 + n11*n33*n44;
		te[9] = n14*n23*n41 - n13*n24*n41 - n14*n21*n43 + n11*n24*n43 + n13*n21*n44 - n11*n23*n44;
		te[13] = n13*n24*n31 - n14*n23*n31 + n14*n21*n33 - n11*n24*n33 - n13*n21*n34 + n11*n23*n34;
		te[2] = n22*n34*n41 - n24*n32*n41 + n24*n31*n42 - n21*n34*n42 - n22*n31*n44 + n21*n32*n44;
		te[6] = n14*n32*n41 - n12*n34*n41 - n14*n31*n42 + n11*n34*n42 + n12*n31*n44 - n11*n32*n44;
		te[10] = n12*n24*n41 - n14*n22*n41 + n14*n21*n42 - n11*n24*n42 - n12*n21*n44 + n11*n22*n44;
		te[14] = n14*n22*n31 - n12*n24*n31 - n14*n21*n32 + n11*n24*n32 + n12*n21*n34 - n11*n22*n34;
		te[3] = n23*n32*n41 - n22*n33*n41 - n23*n31*n42 + n21*n33*n42 + n22*n31*n43 - n21*n32*n43;
		te[7] = n12*n33*n41 - n13*n32*n41 + n13*n31*n42 - n11*n33*n42 - n12*n31*n43 + n11*n32*n43;
		te[11] = n13*n22*n41 - n12*n23*n41 - n13*n21*n42 + n11*n23*n42 + n12*n21*n43 - n11*n22*n43;
		te[15] = n12*n23*n31 - n13*n22*n31 + n13*n21*n32 - n11*n23*n32 - n12*n21*n33 + n11*n22*n33;

		var det = n11 * te[ 0 ] + n21 * te[ 4 ] + n31 * te[ 8 ] + n41 * te[ 12 ];

		if ( det == 0 ) {

			var msg = "Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnInvertible || false ) {

				throw new Error( msg ); 

			} else {

				console.warn( msg );

			}

			this.identity();

			return this;
		}

		this.multiplyScalar( 1 / det );

		return this;

	},

	translate: function ( v ) {

		console.warn( 'DEPRECATED: Matrix4\'s .translate() has been removed.');

	},

	rotateX: function ( angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateX() has been removed.');

	},

	rotateY: function ( angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateY() has been removed.');

	},

	rotateZ: function ( angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateZ() has been removed.');

	},

	rotateByAxis: function ( axis, angle ) {

		console.warn( 'DEPRECATED: Matrix4\'s .rotateByAxis() has been removed.');

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[0] *= x; te[4] *= y; te[8] *= z;
		te[1] *= x; te[5] *= y; te[9] *= z;
		te[2] *= x; te[6] *= y; te[10] *= z;
		te[3] *= x; te[7] *= y; te[11] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
		var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
		var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];

		return Math.sqrt( Math.max( scaleXSq, Math.max( scaleYSq, scaleZSq ) ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, -s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			-s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, -s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector = new THREE.Vector3();
		var matrix = new THREE.Matrix4();

		return function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = vector.set( te[0], te[1], te[2] ).length();
			var sy = vector.set( te[4], te[5], te[6] ).length();
			var sz = vector.set( te[8], te[9], te[10] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if( det < 0 ) {
				sx = -sx;
			}

			position.x = te[12];
			position.y = te[13];
			position.z = te[14];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[0] *= invSX;
			matrix.elements[1] *= invSX;
			matrix.elements[2] *= invSX;

			matrix.elements[4] *= invSY;
			matrix.elements[5] *= invSY;
			matrix.elements[6] *= invSY;

			matrix.elements[8] *= invSZ;
			matrix.elements[9] *= invSZ;
			matrix.elements[10] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[0] = x;	te[4] = 0;	te[8] = a;	te[12] = 0;
		te[1] = 0;	te[5] = y;	te[9] = b;	te[13] = 0;
		te[2] = 0;	te[6] = 0;	te[10] = c;	te[14] = d;
		te[3] = 0;	te[7] = 0;	te[11] = - 1;	te[15] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( THREE.Math.degToRad( fov * 0.5 ) );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = right - left;
		var h = top - bottom;
		var p = far - near;

		var x = ( right + left ) / w;
		var y = ( top + bottom ) / h;
		var z = ( far + near ) / p;

		te[0] = 2 / w;	te[4] = 0;	te[8] = 0;	te[12] = -x;
		te[1] = 0;	te[5] = 2 / h;	te[9] = 0;	te[13] = -y;
		te[2] = 0;	te[6] = 0;	te[10] = -2/p;	te[14] = -z;
		te[3] = 0;	te[7] = 0;	te[11] = 0;	te[15] = 1;

		return this;

	},

	fromArray: function ( array ) {

		this.elements.set( array );

		return this;

	},

	toArray: function () {

		var te = this.elements;

		return [
			te[ 0 ], te[ 1 ], te[ 2 ], te[ 3 ],
			te[ 4 ], te[ 5 ], te[ 6 ], te[ 7 ],
			te[ 8 ], te[ 9 ], te[ 10 ], te[ 11 ],
			te[ 12 ], te[ 13 ], te[ 14 ], te[ 15 ]
		];

	},

	clone: function () {

		var te = this.elements;

		return new THREE.Matrix4(

			te[0], te[4], te[8], te[12],
			te[1], te[5], te[9], te[13],
			te[2], te[6], te[10], te[14],
			te[3], te[7], te[11], te[15]

		);

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Ray = function ( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();
	this.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();

};

THREE.Ray.prototype = {

	constructor: THREE.Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	recast: function () {

		var v1 = new THREE.Vector3();

		return function ( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function () {

		var v1 = new THREE.Vector3();

		return function ( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceTo( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceTo( point );

		};

	}(),

	distanceSqToSegment: function( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/LibMathematics/Distance/Wm5DistRay3Segment3.cpp
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		var segCenter = v0.clone().add( v1 ).multiplyScalar( 0.5 );
		var segDir = v1.clone().sub( v0 ).normalize();
		var segExtent = v0.distanceTo( v1 ) * 0.5;
		var diff = this.origin.clone().sub( segCenter );
		var a01 = - this.direction.dot( segDir );
		var b0 = diff.dot( this.direction );
		var b1 = - diff.dot( segDir );
		var c = diff.lengthSq();
		var det = Math.abs( 1 - a01 * a01 );
		var s0, s1, sqrDist, extDet;

		if ( det >= 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						var invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction.clone().multiplyScalar( s0 ).add( this.origin ) );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( segDir.clone().multiplyScalar( s1 ).add( segCenter ) );

		}

		return sqrDist;

	},

	isIntersectionSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	isIntersectionPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );
		if ( denominator == 0 ) {

			// line is coplanar, return origin
			if( plane.distanceToPoint( this.origin ) == 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;
		}

		return this.at( t, optionalTarget );

	},

	isIntersectionBox: function () {
		
		var v = new THREE.Vector3();

		return function ( box ) {

			return this.intersectBox( box, v ) !== null;

		}

	}(),

	intersectBox: function ( box , optionalTarget ) {

		// http://www.scratchapixel.com/lessons/3d-basic-lessons/lesson-7-intersecting-simple-shapes/ray-box-intersection/

		var tmin,tmax,tymin,tymax,tzmin,tzmax;

		var invdirx = 1/this.direction.x,
			invdiry = 1/this.direction.y,
			invdirz = 1/this.direction.z;

		var origin = this.origin;

		if (invdirx >= 0) {
				
			tmin = (box.min.x - origin.x) * invdirx;
			tmax = (box.max.x - origin.x) * invdirx;

		} else { 

			tmin = (box.max.x - origin.x) * invdirx;
			tmax = (box.min.x - origin.x) * invdirx;
		}			

		if (invdiry >= 0) {
		
			tymin = (box.min.y - origin.y) * invdiry;
			tymax = (box.max.y - origin.y) * invdiry;

		} else {

			tymin = (box.max.y - origin.y) * invdiry;
			tymax = (box.min.y - origin.y) * invdiry;
		}

		if ((tmin > tymax) || (tymin > tmax)) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN
		
		if (tymin > tmin || tmin !== tmin ) tmin = tymin;

		if (tymax < tmax || tmax !== tmax ) tmax = tymax;

		if (invdirz >= 0) {
		
			tzmin = (box.min.z - origin.z) * invdirz;
			tzmax = (box.max.z - origin.z) * invdirz;

		} else {

			tzmin = (box.max.z - origin.z) * invdirz;
			tzmax = (box.min.z - origin.z) * invdirz;
		}

		if ((tmin > tzmax) || (tzmin > tmax)) return null;

		if (tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if (tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectTriangle: function() {

		// Compute the offset origin, edges, and normal.
		var diff = new THREE.Vector3();
		var edge1 = new THREE.Vector3();
		var edge2 = new THREE.Vector3();
		var normal = new THREE.Vector3();

		return function ( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/LibMathematics/Intersection/Wm5IntrRay3Triangle3.cpp

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );
	
		}
	
	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;
	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	},

	clone: function () {

		return new THREE.Ray().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Sphere = function ( center, radius ) {

	this.center = ( center !== undefined ) ? center : new THREE.Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

};

THREE.Sphere.prototype = {

	constructor: THREE.Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;
	},


	setFromPoints: function () {

		var box = new THREE.Box3();

		return function ( points, optionalCenter )  {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).center( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;			
 		
 		};

	}(),

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new THREE.Vector3();
		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new THREE.Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	},

	clone: function () {

		return new THREE.Sphere().copy( this );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://exocortex.com
 */

THREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new THREE.Plane(),
		( p1 !== undefined ) ? p1 : new THREE.Plane(),
		( p2 !== undefined ) ? p2 : new THREE.Plane(),
		( p3 !== undefined ) ? p3 : new THREE.Plane(),
		( p4 !== undefined ) ? p4 : new THREE.Plane(),
		( p5 !== undefined ) ? p5 : new THREE.Plane()

	];

};

THREE.Frustum.prototype = {

	constructor: THREE.Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[0].copy( p0 );
		planes[1].copy( p1 );
		planes[2].copy( p2 );
		planes[3].copy( p3 );
		planes[4].copy( p4 );
		planes[5].copy( p5 );

		return this;

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for( var i = 0; i < 6; i ++ ) {

			planes[i].copy( frustum.planes[i] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];
		var me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];
		var me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];
		var me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new THREE.Sphere();

		return function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = -sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox : function() {

		var p1 = new THREE.Vector3(),
			p2 = new THREE.Vector3();

		return function( box ) {

			var planes = this.planes;
			
			for ( var i = 0; i < 6 ; i ++ ) {
			
				var plane = planes[i];
				
				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );
				
				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {
					
					return false;
		
				}
			}

			return true;
		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	},

	clone: function () {

		return new THREE.Frustum().copy( this );

	}

};

/**
 * @author bhouston / http://exocortex.com
 */

THREE.Plane = function ( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

};

THREE.Plane.prototype = {

	constructor: THREE.Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function() {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();

		return function ( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),


	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= -1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	isIntersectionLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectLine: function() {

		var v1 = new THREE.Vector3();

		return function ( line, optionalTarget ) {

			var result = optionalTarget || new THREE.Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator == 0 ) {

				// line is coplanar, return origin
				if( this.distanceToPoint( line.start ) == 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),


	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function() {

		var v1 = new THREE.Vector3();
		var v2 = new THREE.Vector3();
		var m1 = new THREE.Matrix3();

		return function ( matrix, optionalNormalMatrix ) {

			// compute new normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var newNormal = v1.copy( this.normal ).applyMatrix3( normalMatrix );
			
			var newCoplanarPoint = this.coplanarPoint( v2 );
			newCoplanarPoint.applyMatrix4( matrix );

			this.setFromNormalAndCoplanarPoint( newNormal, newCoplanarPoint );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant == this.constant );

	},

	clone: function () {

		return new THREE.Plane().copy( this );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Math = {

	PI2: Math.PI * 2,

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm
		
		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');
		var uuid = new Array(36);
		var rnd = 0, r;

		return function () {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i == 8 || i == 13 || i == 18 || i == 23 ) {
			
					uuid[ i ] = '-';
			
				} else if ( i == 14 ) {
			
					uuid[ i ] = '4';
			
				} else {
			
					if (rnd <= 0x02) rnd = 0x2000000 + (Math.random()*0x1000000)|0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[i] = chars[(i == 19) ? (r & 0x3) | 0x8 : r];

				}
			}
			
			return uuid.join('');

		};

	}(),

	// Clamp value to range <a, b>

	clamp: function ( x, a, b ) {

		return ( x < a ) ? a : ( ( x > b ) ? b : x );

	},

	// Clamp value to range <a, inf)

	clampBottom: function ( x, a ) {

		return x < a ? a : x;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min )/( max - min );

		return x*x*(3 - 2*x);

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min )/( max - min );

		return x*x*x*(x*(x*6 - 15) + 10);

	},

	// Random float from <0, 1> with 16 bits of randomness
	// (standard Math.random() creates repetitive patterns when applied over larger space)

	random16: function () {

		return ( 65280 * Math.random() + 255 * Math.random() ) / 65535;

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	sign: function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : 0;

	},

	degToRad: function() {

		var degreeToRadiansFactor = Math.PI / 180;

		return function ( degrees ) {

			return degrees * degreeToRadiansFactor;

		};

	}(),

	radToDeg: function() {

		var radianToDegreesFactor = 180 / Math.PI;

		return function ( radians ) {

			return radians * radianToDegreesFactor;

		};

	}(),

	isPowerOfTwo: function ( value ) {
		return ( value & ( value - 1 ) ) === 0 && value !== 0;
	}

};

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Spline = function ( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new THREE.Vector3(),
			tmpVec = new THREE.Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( !nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint != oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			linearDistance, realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new THREE.Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	};

};

/**
 * @author bhouston / http://exocortex.com
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Triangle = function ( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new THREE.Vector3();
	this.b = ( b !== undefined ) ? b : new THREE.Vector3();
	this.c = ( c !== undefined ) ? c : new THREE.Vector3();

};

THREE.Triangle.normal = function() {

	var v0 = new THREE.Vector3();

	return function ( a, b, c, optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycoordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
THREE.Triangle.barycoordFromPoint = function() {

	var v0 = new THREE.Vector3();
	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new THREE.Vector3();

		// colinear or singular triangle
		if( denom == 0 ) {
			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( -2, -1, -1 );
		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycoordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

THREE.Triangle.containsPoint = function() {

	var v1 = new THREE.Vector3();

	return function ( point, a, b, c ) {

		var result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

THREE.Triangle.prototype = {

	constructor: THREE.Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[i0] );
		this.b.copy( points[i1] );
		this.c.copy( points[i2] );

		return this;

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function() {

		var v0 = new THREE.Vector3();
		var v1 = new THREE.Vector3();

		return function () {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new THREE.Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return THREE.Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	},

	clone: function () {

		return new THREE.Triangle().copy( this );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Vertex = function ( v ) {

	console.warn( 'THREE.Vertex has been DEPRECATED. Use THREE.Vector3 instead.')
	return v;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.UV = function ( u, v ) {

	console.warn( 'THREE.UV has been DEPRECATED. Use THREE.Vector2 instead.')
	return new THREE.Vector2( u, v );

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

THREE.Clock.prototype = {

	constructor: THREE.Clock,

	start: function () {

		this.startTime = self.performance !== undefined && self.performance.now !== undefined
					? self.performance.now()
					: Date.now();

		this.oldTime = this.startTime;
		this.running = true;
	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance !== undefined && self.performance.now !== undefined
					? self.performance.now()
					: Date.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

THREE.EventDispatcher = function () {}

THREE.EventDispatcher.prototype = {

	constructor: THREE.EventDispatcher,

	apply: function ( object ) {

		object.addEventListener = THREE.EventDispatcher.prototype.addEventListener;
		object.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener;
		object.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener;
		object.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent;

	},

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		if ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {

			return true;

		}

		return false;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function () {

		var array = [];

		return function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var length = listenerArray.length;

				for ( var i = 0; i < length; i ++ ) {

					array[ i ] = listenerArray[ i ];

				}

				for ( var i = 0; i < length; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		};

	}()

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://exocortex.com/
 * @author stephomi / http://stephaneginier.com/
 */

( function ( THREE ) {

	THREE.Raycaster = function ( origin, direction, near, far ) {

		this.ray = new THREE.Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

		this.near = near || 0;
		this.far = far || Infinity;

	};

	var sphere = new THREE.Sphere();
	var localRay = new THREE.Ray();
	var facePlane = new THREE.Plane();
	var intersectPoint = new THREE.Vector3();
	var matrixPosition = new THREE.Vector3();

	var inverseMatrix = new THREE.Matrix4();

	var descSort = function ( a, b ) {

		return a.distance - b.distance;

	};

	var vA = new THREE.Vector3();
	var vB = new THREE.Vector3();
	var vC = new THREE.Vector3();

	var intersectObject = function ( object, raycaster, intersects ) {

		if ( object instanceof THREE.Sprite ) {

			matrixPosition.setFromMatrixPosition( object.matrixWorld );
			
			var distance = raycaster.ray.distanceToPoint( matrixPosition );

			if ( distance > object.scale.x ) {

				return intersects;

			}

			intersects.push( {

				distance: distance,
				point: object.position,
				face: null,
				object: object

			} );

		} else if ( object instanceof THREE.LOD ) {

			matrixPosition.setFromMatrixPosition( object.matrixWorld );
			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			intersectObject( object.getObjectForDistance( distance ), raycaster, intersects );

		} else if ( object instanceof THREE.Mesh ) {

			var geometry = object.geometry;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );

			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return intersects;

			}

			// Check boundingBox before continuing
			
			inverseMatrix.getInverse( object.matrixWorld );  
			localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			if ( geometry.boundingBox !== null ) {

				if ( localRay.isIntersectionBox( geometry.boundingBox ) === false )  {

					return intersects;

				}

			} 

			if ( geometry instanceof THREE.BufferGeometry ) {

				var material = object.material;

				if ( material === undefined ) return intersects;

				var attributes = geometry.attributes;

				var a, b, c;
				var precision = raycaster.precision;

				if ( attributes.index !== undefined ) {

					var offsets = geometry.offsets;
					var indices = attributes.index.array;
					var positions = attributes.position.array;

					for ( var oi = 0, ol = offsets.length; oi < ol; ++oi ) {

						var start = offsets[ oi ].start;
						var count = offsets[ oi ].count;
						var index = offsets[ oi ].index;

						for ( var i = start, il = start + count; i < il; i += 3 ) {

							a = index + indices[ i ];
							b = index + indices[ i + 1 ]; 
							c = index + indices[ i + 2 ];

							vA.set(
								positions[ a * 3 ],
								positions[ a * 3 + 1 ],
								positions[ a * 3 + 2 ]
							);
							vB.set(
								positions[ b * 3 ],
								positions[ b * 3 + 1 ],
								positions[ b * 3 + 2 ]
							);
							vC.set(
								positions[ c * 3 ],
								positions[ c * 3 + 1 ],
								positions[ c * 3 + 2 ]
							);

							
							if ( material.side === THREE.BackSide ) {
							
								var intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); 

							} else {

								var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

							}

							if ( intersectionPoint === null ) continue;

							intersectionPoint.applyMatrix4( object.matrixWorld );

							var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

							if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

							intersects.push( {

								distance: distance,
								point: intersectionPoint,
								indices: [a, b, c],
								face: null,
								faceIndex: null,
								object: object

							} );

						}

					}

				} else {

					var offsets = geometry.offsets;
					var positions = attributes.position.array;

					for ( var i = 0, il = attributes.position.array.length; i < il; i += 3 ) {

						a = i;
						b = i + 1;
						c = i + 2;

						vA.set(
							positions[ a * 3 ],
							positions[ a * 3 + 1 ],
							positions[ a * 3 + 2 ]
						);
						vB.set(
							positions[ b * 3 ],
							positions[ b * 3 + 1 ],
							positions[ b * 3 + 2 ]
						);
						vC.set(
							positions[ c * 3 ],
							positions[ c * 3 + 1 ],
							positions[ c * 3 + 2 ]
						);

						
						if ( material.side === THREE.BackSide ) {
							
							var intersectionPoint = localRay.intersectTriangle( vC, vB, vA, true ); 

						} else {

							var intersectionPoint = localRay.intersectTriangle( vA, vB, vC, material.side !== THREE.DoubleSide );

						}

						if ( intersectionPoint === null ) continue;

						intersectionPoint.applyMatrix4( object.matrixWorld );

						var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

						if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							point: intersectionPoint,
							indices: [a, b, c],
							face: null,
							faceIndex: null,
							object: object

						} );

					}

				}

			} else if ( geometry instanceof THREE.Geometry ) {

				var isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
				var objectMaterials = isFaceMaterial === true ? object.material.materials : null;

				var a, b, c, d;
				var precision = raycaster.precision;

				var vertices = geometry.vertices;

				for ( var f = 0, fl = geometry.faces.length; f < fl; f ++ ) {

					var face = geometry.faces[ f ];

					var material = isFaceMaterial === true ? objectMaterials[ face.materialIndex ] : object.material;

					if ( material === undefined ) continue;

					a = vertices[ face.a ];
					b = vertices[ face.b ];
					c = vertices[ face.c ];

					if ( material.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = object.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.x += ( targets[ face.a ].x - a.x ) * influence;
							vA.y += ( targets[ face.a ].y - a.y ) * influence;
							vA.z += ( targets[ face.a ].z - a.z ) * influence;

							vB.x += ( targets[ face.b ].x - b.x ) * influence;
							vB.y += ( targets[ face.b ].y - b.y ) * influence;
							vB.z += ( targets[ face.b ].z - b.z ) * influence;

							vC.x += ( targets[ face.c ].x - c.x ) * influence;
							vC.y += ( targets[ face.c ].y - c.y ) * influence;
							vC.z += ( targets[ face.c ].z - c.z ) * influence;

						}

						vA.add( a );
						vB.add( b );
						vC.add( c );

						a = vA;
						b = vB;
						c = vC;

					}

					if ( material.side === THREE.BackSide ) {
							
						var intersectionPoint = localRay.intersectTriangle( c, b, a, true );

					} else {
								
						var intersectionPoint = localRay.intersectTriangle( a, b, c, material.side !== THREE.DoubleSide );

					}

					if ( intersectionPoint === null ) continue;

					intersectionPoint.applyMatrix4( object.matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectionPoint );

					if ( distance < precision || distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						point: intersectionPoint,
						face: face,
						faceIndex: f,
						object: object

					} );

				}

			}

		} else if ( object instanceof THREE.Line ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			// Checking boundingSphere distance to ray

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( object.matrixWorld );
			
			if ( raycaster.ray.isIntersectionSphere( sphere ) === false ) {

				return intersects;

			}
			
			inverseMatrix.getInverse( object.matrixWorld );
			localRay.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			/* if ( geometry instanceof THREE.BufferGeometry ) {

			} else */ if ( geometry instanceof THREE.Geometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;
				var interSegment = new THREE.Vector3();
				var interRay = new THREE.Vector3();
				var step = object.type === THREE.LineStrip ? 1 : 2;

				for ( var i = 0; i < nbVertices - 1; i = i + step ) {

					var distSq = localRay.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					var distance = localRay.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( object.matrixWorld ),
						face: null,
						faceIndex: null,
						object: object

					} );

				}

			}

		}

	};

	var intersectDescendants = function ( object, raycaster, intersects ) {

		var descendants = object.getDescendants();

		for ( var i = 0, l = descendants.length; i < l; i ++ ) {

			intersectObject( descendants[ i ], raycaster, intersects );

		}
	};

	//

	THREE.Raycaster.prototype.precision = 0.0001;
	THREE.Raycaster.prototype.linePrecision = 1;

	THREE.Raycaster.prototype.set = function ( origin, direction ) {

		this.ray.set( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)

	};

	THREE.Raycaster.prototype.intersectObject = function ( object, recursive ) {

		var intersects = [];

		if ( recursive === true ) {

			intersectDescendants( object, this, intersects );

		}

		intersectObject( object, this, intersects );

		intersects.sort( descSort );

		return intersects;

	};

	THREE.Raycaster.prototype.intersectObjects = function ( objects, recursive ) {

		var intersects = [];

		for ( var i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects );

			if ( recursive === true ) {

				intersectDescendants( objects[ i ], this, intersects );

			}

		}

		intersects.sort( descSort );

		return intersects;

	};

}( THREE ) );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.Object3D = function () {

	this.id = THREE.Object3DIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.parent = undefined;
	this.children = [];

	this.up = new THREE.Vector3( 0, 1, 0 );

	this.position = new THREE.Vector3();
	this._rotation = new THREE.Euler();
	this._quaternion = new THREE.Quaternion();
	this.scale = new THREE.Vector3( 1, 1, 1 );

	// keep rotation and quaternion in sync

	this._rotation._quaternion = this.quaternion;
	this._quaternion._euler = this.rotation;

	this.renderDepth = null;

	this.rotationAutoUpdate = true;

	this.matrix = new THREE.Matrix4();
	this.matrixWorld = new THREE.Matrix4();

	this.matrixAutoUpdate = true;
	this.matrixWorldNeedsUpdate = true;

	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;

	this.userData = {};

};


THREE.Object3D.prototype = {

	constructor: THREE.Object3D,
	
	get rotation () { 
		return this._rotation; 
	},

	set rotation ( value ) {
		
		this._rotation = value;
		this._rotation._quaternion = this._quaternion;
		this._quaternion._euler = this._rotation;
		this._rotation._updateQuaternion();
		
	},

	get quaternion () { 
		return this._quaternion; 
	},
	
	set quaternion ( value ) {
		
		this._quaternion = value;
		this._quaternion._euler = this._rotation;
		this._rotation._quaternion = this._quaternion;
		this._quaternion._updateEuler();
		
	},

	get eulerOrder () {

		console.warn( 'DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.' );

		return this.rotation.order;

	},

	set eulerOrder ( value ) {

		console.warn( 'DEPRECATED: Object3D\'s .eulerOrder has been moved to Object3D\'s .rotation.order.' );

		this.rotation.order = value;

	},

	get useQuaternion () {

		console.warn( 'DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	set useQuaternion ( value ) {

		console.warn( 'DEPRECATED: Object3D\'s .useQuaternion has been removed. The library now uses quaternions by default.' );

	},

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function() {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new THREE.Quaternion();

		return function ( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		}

	}(),

	rotateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new THREE.Vector3();

		return function ( axis, distance ) {

			v1.copy( axis );

			v1.applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		}

	}(),

	translate: function ( distance, axis ) {

		console.warn( 'DEPRECATED: Object3D\'s .translate() has been removed. Use .translateOnAxis( axis, distance ) instead. Note args have been changed.' );
		return this.translateOnAxis( axis, distance );

	},

	translateX: function () {

		var v1 = new THREE.Vector3( 1, 0, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new THREE.Vector3( 0, 1, 0 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new THREE.Vector3( 0, 0, 1 );

		return function ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new THREE.Matrix4();

		return function ( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( object === this ) {

			console.warn( 'THREE.Object3D.add: An object can\'t be added as a child of itself.' );
			return;

		}

		if ( object instanceof THREE.Object3D ) {

			if ( object.parent !== undefined ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

			// add to scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene )  {

				scene.__addObject( object );

			}

		}

	},

	remove: function ( object ) {

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = undefined;
			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

			// remove from scene

			var scene = this;

			while ( scene.parent !== undefined ) {

				scene = scene.parent;

			}

			if ( scene !== undefined && scene instanceof THREE.Scene ) {

				scene.__removeObject( object );

			}

		}

	},

	traverse: function ( callback ) {

		callback( this );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].traverse( callback );

		}

	},

	getObjectById: function ( id, recursive ) {

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child.id === id ) {

				return child;

			}

			if ( recursive === true ) {

				child = child.getObjectById( id, recursive );

				if ( child !== undefined ) {

					return child;

				}

			}

		}

		return undefined;

	},

	getObjectByName: function ( name, recursive ) {

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child.name === name ) {

				return child;

			}

			if ( recursive === true ) {

				child = child.getObjectByName( name, recursive );

				if ( child !== undefined ) {

					return child;

				}

			}

		}

		return undefined;

	},

	getChildByName: function ( name, recursive ) {

		console.warn( 'DEPRECATED: Object3D\'s .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name, recursive );

	},

	getDescendants: function ( array ) {

		if ( array === undefined ) array = [];

		Array.prototype.push.apply( array, this.children );

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].getDescendants( array );

		}

		return array;

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === undefined ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			this.children[ i ].updateMatrixWorld( force );

		}

	},

	clone: function ( object, recursive ) {

		if ( object === undefined ) object = new THREE.Object3D();
		if ( recursive === undefined ) recursive = true;

		object.name = this.name;

		object.up.copy( this.up );

		object.position.copy( this.position );
		object.quaternion.copy( this.quaternion );
		object.scale.copy( this.scale );

		object.renderDepth = this.renderDepth;

		object.rotationAutoUpdate = this.rotationAutoUpdate;

		object.matrix.copy( this.matrix );
		object.matrixWorld.copy( this.matrixWorld );

		object.matrixAutoUpdate = this.matrixAutoUpdate;
		object.matrixWorldNeedsUpdate = this.matrixWorldNeedsUpdate;

		object.visible = this.visible;

		object.castShadow = this.castShadow;
		object.receiveShadow = this.receiveShadow;

		object.frustumCulled = this.frustumCulled;

		object.userData = JSON.parse( JSON.stringify( this.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < this.children.length; i ++ ) {

				var child = this.children[ i ];
				object.add( child.clone() );

			}

		}

		return object;

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Object3D.prototype );

THREE.Object3DIdCount = 0;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author julianwa / https://github.com/julianwa
 */

THREE.Projector = function () {

	var _object, _objectCount, _objectPool = [], _objectPoolLength = 0,
	_vertex, _vertexCount, _vertexPool = [], _vertexPoolLength = 0,
	_face, _faceCount, _facePool = [], _facePoolLength = 0,
	_line, _lineCount, _linePool = [], _linePoolLength = 0,
	_sprite, _spriteCount, _spritePool = [], _spritePoolLength = 0,

	_renderData = { objects: [], lights: [], elements: [] },

	_vA = new THREE.Vector3(),
	_vB = new THREE.Vector3(),
	_vC = new THREE.Vector3(),

	_vector3 = new THREE.Vector3(),
	_vector4 = new THREE.Vector4(),

	_clipBox = new THREE.Box3( new THREE.Vector3( -1, -1, -1 ), new THREE.Vector3( 1, 1, 1 ) ),
	_boundingBox = new THREE.Box3(),
	_points3 = new Array( 3 ),
	_points4 = new Array( 4 ),

	_viewMatrix = new THREE.Matrix4(),
	_viewProjectionMatrix = new THREE.Matrix4(),

	_modelMatrix,
	_modelViewProjectionMatrix = new THREE.Matrix4(),

	_normalMatrix = new THREE.Matrix3(),

	_frustum = new THREE.Frustum(),

	_clippedVertex1PositionScreen = new THREE.Vector4(),
	_clippedVertex2PositionScreen = new THREE.Vector4();

	this.projectVector = function ( vector, camera ) {

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );

		return vector.applyProjection( _viewProjectionMatrix );

	};

	this.unprojectVector = function () {

		var projectionMatrixInverse = new THREE.Matrix4();

		return function ( vector, camera ) {

			projectionMatrixInverse.getInverse( camera.projectionMatrix );
			_viewProjectionMatrix.multiplyMatrices( camera.matrixWorld, projectionMatrixInverse );

			return vector.applyProjection( _viewProjectionMatrix );

		};

	}();

	this.pickingRay = function ( vector, camera ) {

		// set two vectors with opposing z values
		vector.z = -1.0;
		var end = new THREE.Vector3( vector.x, vector.y, 1.0 );

		this.unprojectVector( vector, camera );
		this.unprojectVector( end, camera );

		// find direction from vector to end
		end.sub( vector ).normalize();

		return new THREE.Raycaster( vector, end );

	};

	var projectObject = function ( object ) {

		if ( object.visible === false ) return;

		if ( object instanceof THREE.Light ) {

			_renderData.lights.push( object );

		} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Sprite ) {

			if ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) {

				_object = getNextObjectInPool();
				_object.id = object.id;
				_object.object = object;

				if ( object.renderDepth !== null ) {

					_object.z = object.renderDepth;

				} else {

					_vector3.setFromMatrixPosition( object.matrixWorld );
					_vector3.applyProjection( _viewProjectionMatrix );
					_object.z = _vector3.z;

				}

				_renderData.objects.push( _object );

			}

		}

		for ( var i = 0, l = object.children.length; i < l; i ++ ) {

			projectObject( object.children[ i ] );

		}

	};

	var projectGraph = function ( root, sortObjects ) {

		_objectCount = 0;

		_renderData.objects.length = 0;
		_renderData.lights.length = 0;

		projectObject( root );

		if ( sortObjects === true ) {

			_renderData.objects.sort( painterSort );

		}

	};

	var RenderList = function () {

		var normals = [];

		var object = null;
		var normalMatrix = new THREE.Matrix3();

		var setObject = function ( value ) {

			object = value;
			normalMatrix.getNormalMatrix( object.matrixWorld );

			normals.length = 0;

		};

		var projectVertex = function ( vertex ) {

			var position = vertex.position;
			var positionWorld = vertex.positionWorld;
			var positionScreen = vertex.positionScreen;

			positionWorld.copy( position ).applyMatrix4( _modelMatrix );
			positionScreen.copy( positionWorld ).applyMatrix4( _viewProjectionMatrix );

			var invW = 1 / positionScreen.w;

			positionScreen.x *= invW;
			positionScreen.y *= invW;
			positionScreen.z *= invW;

			vertex.visible = positionScreen.x >= -1 && positionScreen.x <= 1 &&
					 positionScreen.y >= -1 && positionScreen.y <= 1 &&
					 positionScreen.z >= -1 && positionScreen.z <= 1;

		};

		var pushVertex = function ( x, y, z ) {

			_vertex = getNextVertexInPool();
			_vertex.position.set( x, y, z );

			projectVertex( _vertex );

		};

		var pushNormal = function ( x, y, z ) {

			normals.push( x, y, z );

		};

		var checkTriangleVisibility = function ( v1, v2, v3 ) {

			_points3[ 0 ] = v1.positionScreen;
			_points3[ 1 ] = v2.positionScreen;
			_points3[ 2 ] = v3.positionScreen;

			if ( v1.visible === true || v2.visible === true || v3.visible === true ||
				_clipBox.isIntersectionBox( _boundingBox.setFromPoints( _points3 ) ) ) {

				return ( ( v3.positionScreen.x - v1.positionScreen.x ) *
					    ( v2.positionScreen.y - v1.positionScreen.y ) -
					    ( v3.positionScreen.y - v1.positionScreen.y ) *
					    ( v2.positionScreen.x - v1.positionScreen.x ) ) < 0;

			}

			return false;

		};

		var pushLine = function ( a, b ) {

			var v1 = _vertexPool[ a ];
			var v2 = _vertexPool[ b ];

			_line = getNextLineInPool();

			_line.id = object.id;
			_line.v1.copy( v1 );
			_line.v2.copy( v2 );
			_line.z = ( v1.positionScreen.z + v2.positionScreen.z ) / 2;

			_line.material = object.material;

			_renderData.elements.push( _line );

		};

		var pushTriangle = function ( a, b, c ) {

			var v1 = _vertexPool[ a ];
			var v2 = _vertexPool[ b ];
			var v3 = _vertexPool[ c ];

			if ( checkTriangleVisibility( v1, v2, v3 ) === true ) {

				_face = getNextFaceInPool();

				_face.id = object.id;
				_face.v1.copy( v1 );
				_face.v2.copy( v2 );
				_face.v3.copy( v3 );
				_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;

				for ( var i = 0; i < 3; i ++ ) {

					var offset = arguments[ i ] * 3;
					var normal = _face.vertexNormalsModel[ i ];

					normal.set( normals[ offset + 0 ], normals[ offset + 1 ], normals[ offset + 2 ] );
					normal.applyMatrix3( normalMatrix ).normalize();

				}

				_face.vertexNormalsLength = 3;

				_face.material = object.material;

				_renderData.elements.push( _face );

			}

		};

		return {
			setObject: setObject,
			projectVertex: projectVertex,
			checkTriangleVisibility: checkTriangleVisibility,
			pushVertex: pushVertex,
			pushNormal: pushNormal,
			pushLine: pushLine,
			pushTriangle: pushTriangle
		}

	};

	var renderList = new RenderList();

	this.projectScene = function ( scene, camera, sortObjects, sortElements ) {

		var object, geometry, vertices, faces, face, faceVertexNormals, faceVertexUvs, uvs,
		isFaceMaterial, objectMaterials;

		_faceCount = 0;
		_lineCount = 0;
		_spriteCount = 0;

		_renderData.elements.length = 0;

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		_viewMatrix.copy( camera.matrixWorldInverse.getInverse( camera.matrixWorld ) );
		_viewProjectionMatrix.multiplyMatrices( camera.projectionMatrix, _viewMatrix );

		_frustum.setFromMatrix( _viewProjectionMatrix );

		projectGraph( scene, sortObjects );

		for ( var o = 0, ol = _renderData.objects.length; o < ol; o ++ ) {

			object = _renderData.objects[ o ].object;
			geometry = object.geometry;

			renderList.setObject( object );

			_modelMatrix = object.matrixWorld;

			_vertexCount = 0;

			if ( object instanceof THREE.Mesh ) {

				if ( geometry instanceof THREE.BufferGeometry ) {

					var attributes = geometry.attributes;
					var offsets = geometry.offsets;

					if ( attributes.position === undefined ) continue;

					var positions = attributes.position.array;

					for ( var i = 0, l = positions.length; i < l; i += 3 ) {

						renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

					}

					var normals = attributes.normal.array;

					for ( var i = 0, l = normals.length; i < l; i += 3 ) {

						renderList.pushNormal( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] );

					}

					if ( attributes.index !== undefined ) {

						var indices = attributes.index.array;

						if ( offsets.length > 0 ) {

							for ( var o = 0; o < offsets.length; o ++ ) {

								var offset = offsets[ o ];
								var index = offset.index;

								for ( var i = offset.start, l = offset.start + offset.count; i < l; i += 3 ) {

									renderList.pushTriangle( indices[ i ] + index, indices[ i + 1 ] + index, indices[ i + 2 ] + index );

								}

							}

						} else {

							for ( var i = 0, l = indices.length; i < l; i += 3 ) {

								renderList.pushTriangle( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

							}

						}

					} else {

						for ( var i = 0, l = positions.length / 3; i < l; i += 3 ) {

							renderList.pushTriangle( i, i + 1, i + 2 );

						}

					}

				} else if ( geometry instanceof THREE.Geometry ) {

					vertices = geometry.vertices;
					faces = geometry.faces;
					faceVertexUvs = geometry.faceVertexUvs;

					_normalMatrix.getNormalMatrix( _modelMatrix );

					isFaceMaterial = object.material instanceof THREE.MeshFaceMaterial;
					objectMaterials = isFaceMaterial === true ? object.material : null;

					for ( var v = 0, vl = vertices.length; v < vl; v ++ ) {

						var vertex = vertices[ v ];
						renderList.pushVertex( vertex.x, vertex.y, vertex.z );

					}

					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

						face = faces[ f ];

						var material = isFaceMaterial === true
							? objectMaterials.materials[ face.materialIndex ]
							: object.material;

						if ( material === undefined ) continue;

						var side = material.side;

						var v1 = _vertexPool[ face.a ];
						var v2 = _vertexPool[ face.b ];
						var v3 = _vertexPool[ face.c ];

						if ( material.morphTargets === true ) {

							var morphTargets = geometry.morphTargets;
							var morphInfluences = object.morphTargetInfluences;

							var v1p = v1.position;
							var v2p = v2.position;
							var v3p = v3.position;

							_vA.set( 0, 0, 0 );
							_vB.set( 0, 0, 0 );
							_vC.set( 0, 0, 0 );

							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

								var influence = morphInfluences[ t ];

								if ( influence === 0 ) continue;

								var targets = morphTargets[ t ].vertices;

								_vA.x += ( targets[ face.a ].x - v1p.x ) * influence;
								_vA.y += ( targets[ face.a ].y - v1p.y ) * influence;
								_vA.z += ( targets[ face.a ].z - v1p.z ) * influence;

								_vB.x += ( targets[ face.b ].x - v2p.x ) * influence;
								_vB.y += ( targets[ face.b ].y - v2p.y ) * influence;
								_vB.z += ( targets[ face.b ].z - v2p.z ) * influence;

								_vC.x += ( targets[ face.c ].x - v3p.x ) * influence;
								_vC.y += ( targets[ face.c ].y - v3p.y ) * influence;
								_vC.z += ( targets[ face.c ].z - v3p.z ) * influence;

							}

							v1.position.add( _vA );
							v2.position.add( _vB );
							v3.position.add( _vC );

							renderList.projectVertex( v1 );
							renderList.projectVertex( v2 );
							renderList.projectVertex( v3 );

						}

						var visible = renderList.checkTriangleVisibility( v1, v2, v3 );

						if ( ( visible === false && side === THREE.FrontSide ) ||
							 ( visible === true && side === THREE.BackSide ) ) continue;

						_face = getNextFaceInPool();

						_face.id = object.id;
						_face.v1.copy( v1 );
						_face.v2.copy( v2 );
						_face.v3.copy( v3 );

						_face.normalModel.copy( face.normal );

						if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

							_face.normalModel.negate();

						}

						_face.normalModel.applyMatrix3( _normalMatrix ).normalize();

						_face.centroidModel.copy( face.centroid ).applyMatrix4( _modelMatrix );

						faceVertexNormals = face.vertexNormals;

						for ( var n = 0, nl = Math.min( faceVertexNormals.length, 3 ); n < nl; n ++ ) {

							var normalModel = _face.vertexNormalsModel[ n ];
							normalModel.copy( faceVertexNormals[ n ] );

							if ( visible === false && ( side === THREE.BackSide || side === THREE.DoubleSide ) ) {

								normalModel.negate();

							}

							normalModel.applyMatrix3( _normalMatrix ).normalize();

						}

						_face.vertexNormalsLength = faceVertexNormals.length;

						for ( var c = 0, cl = Math.min( faceVertexUvs.length, 3 ); c < cl; c ++ ) {

							uvs = faceVertexUvs[ c ][ f ];

							if ( uvs === undefined ) continue;

							for ( var u = 0, ul = uvs.length; u < ul; u ++ ) {

								_face.uvs[ c ][ u ] = uvs[ u ];

							}

						}

						_face.color = face.color;
						_face.material = material;

						_face.z = ( v1.positionScreen.z + v2.positionScreen.z + v3.positionScreen.z ) / 3;

						_renderData.elements.push( _face );

					}

				}

			} else if ( object instanceof THREE.Line ) {

				if ( geometry instanceof THREE.BufferGeometry ) {

					var attributes = geometry.attributes;

					if ( attributes.position !== undefined ) {

						var positions = attributes.position.array;

						for ( var i = 0, l = positions.length; i < l; i += 3 ) {

							renderList.pushVertex( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );

						}

						if ( attributes.index !== undefined ) {

							var indices = attributes.index.array;

							for ( var i = 0, l = indices.length; i < l; i += 2 ) {

								renderList.pushLine( indices[ i ], indices[ i + 1 ] );

							}

						} else {

							for ( var i = 0, l = ( positions.length / 3 ) - 1; i < l; i ++ ) {

								renderList.pushLine( i, i + 1 );

							}

						}

					}

				} else if ( geometry instanceof THREE.Geometry ) {

					_modelViewProjectionMatrix.multiplyMatrices( _viewProjectionMatrix, _modelMatrix );

					vertices = object.geometry.vertices;

					if ( vertices.length === 0 ) continue;

					v1 = getNextVertexInPool();
					v1.positionScreen.copy( vertices[ 0 ] ).applyMatrix4( _modelViewProjectionMatrix );

					// Handle LineStrip and LinePieces
					var step = object.type === THREE.LinePieces ? 2 : 1;

					for ( var v = 1, vl = vertices.length; v < vl; v ++ ) {

						v1 = getNextVertexInPool();
						v1.positionScreen.copy( vertices[ v ] ).applyMatrix4( _modelViewProjectionMatrix );

						if ( ( v + 1 ) % step > 0 ) continue;

						v2 = _vertexPool[ _vertexCount - 2 ];

						_clippedVertex1PositionScreen.copy( v1.positionScreen );
						_clippedVertex2PositionScreen.copy( v2.positionScreen );

						if ( clipLine( _clippedVertex1PositionScreen, _clippedVertex2PositionScreen ) === true ) {

							// Perform the perspective divide
							_clippedVertex1PositionScreen.multiplyScalar( 1 / _clippedVertex1PositionScreen.w );
							_clippedVertex2PositionScreen.multiplyScalar( 1 / _clippedVertex2PositionScreen.w );

							_line = getNextLineInPool();

							_line.id = object.id;
							_line.v1.positionScreen.copy( _clippedVertex1PositionScreen );
							_line.v2.positionScreen.copy( _clippedVertex2PositionScreen );

							_line.z = Math.max( _clippedVertex1PositionScreen.z, _clippedVertex2PositionScreen.z );

							_line.material = object.material;

							if ( object.material.vertexColors === THREE.VertexColors ) {

								_line.vertexColors[ 0 ].copy( object.geometry.colors[ v ] );
								_line.vertexColors[ 1 ].copy( object.geometry.colors[ v - 1 ] );

							}

							_renderData.elements.push( _line );

						}

					}

				}

			} else if ( object instanceof THREE.Sprite ) {

				_vector4.set( _modelMatrix.elements[12], _modelMatrix.elements[13], _modelMatrix.elements[14], 1 );
				_vector4.applyMatrix4( _viewProjectionMatrix );

				var invW = 1 / _vector4.w;

				_vector4.z *= invW;

				if ( _vector4.z >= -1 && _vector4.z <= 1 ) {

					_sprite = getNextSpriteInPool();
					_sprite.id = object.id;
					_sprite.x = _vector4.x * invW;
					_sprite.y = _vector4.y * invW;
					_sprite.z = _vector4.z;
					_sprite.object = object;

					_sprite.rotation = object.rotation;

					_sprite.scale.x = object.scale.x * Math.abs( _sprite.x - ( _vector4.x + camera.projectionMatrix.elements[0] ) / ( _vector4.w + camera.projectionMatrix.elements[12] ) );
					_sprite.scale.y = object.scale.y * Math.abs( _sprite.y - ( _vector4.y + camera.projectionMatrix.elements[5] ) / ( _vector4.w + camera.projectionMatrix.elements[13] ) );

					_sprite.material = object.material;

					_renderData.elements.push( _sprite );

				}

			}

		}

		if ( sortElements === true ) _renderData.elements.sort( painterSort );

		return _renderData;

	};

	// Pools

	function getNextObjectInPool() {

		if ( _objectCount === _objectPoolLength ) {

			var object = new THREE.RenderableObject();
			_objectPool.push( object );
			_objectPoolLength ++;
			_objectCount ++;
			return object;

		}

		return _objectPool[ _objectCount ++ ];

	}

	function getNextVertexInPool() {

		if ( _vertexCount === _vertexPoolLength ) {

			var vertex = new THREE.RenderableVertex();
			_vertexPool.push( vertex );
			_vertexPoolLength ++;
			_vertexCount ++;
			return vertex;

		}

		return _vertexPool[ _vertexCount ++ ];

	}

	function getNextFaceInPool() {

		if ( _faceCount === _facePoolLength ) {

			var face = new THREE.RenderableFace();
			_facePool.push( face );
			_facePoolLength ++;
			_faceCount ++;
			return face;

		}

		return _facePool[ _faceCount ++ ];


	}

	function getNextLineInPool() {

		if ( _lineCount === _linePoolLength ) {

			var line = new THREE.RenderableLine();
			_linePool.push( line );
			_linePoolLength ++;
			_lineCount ++
			return line;

		}

		return _linePool[ _lineCount ++ ];

	}

	function getNextSpriteInPool() {

		if ( _spriteCount === _spritePoolLength ) {

			var sprite = new THREE.RenderableSprite();
			_spritePool.push( sprite );
			_spritePoolLength ++;
			_spriteCount ++
			return sprite;

		}

		return _spritePool[ _spriteCount ++ ];

	}

	//

	function painterSort( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else if ( a.id !== b.id ) {

			return a.id - b.id;

		} else {

			return 0;

		}

	}

	function clipLine( s1, s2 ) {

		var alpha1 = 0, alpha2 = 1,

		// Calculate the boundary coordinate of each vertex for the near and far clip planes,
		// Z = -1 and Z = +1, respectively.
		bc1near =  s1.z + s1.w,
		bc2near =  s2.z + s2.w,
		bc1far =  - s1.z + s1.w,
		bc2far =  - s2.z + s2.w;

		if ( bc1near >= 0 && bc2near >= 0 && bc1far >= 0 && bc2far >= 0 ) {

			// Both vertices lie entirely within all clip planes.
			return true;

		} else if ( ( bc1near < 0 && bc2near < 0) || (bc1far < 0 && bc2far < 0 ) ) {

			// Both vertices lie entirely outside one of the clip planes.
			return false;

		} else {

			// The line segment spans at least one clip plane.

			if ( bc1near < 0 ) {

				// v1 lies outside the near plane, v2 inside
				alpha1 = Math.max( alpha1, bc1near / ( bc1near - bc2near ) );

			} else if ( bc2near < 0 ) {

				// v2 lies outside the near plane, v1 inside
				alpha2 = Math.min( alpha2, bc1near / ( bc1near - bc2near ) );

			}

			if ( bc1far < 0 ) {

				// v1 lies outside the far plane, v2 inside
				alpha1 = Math.max( alpha1, bc1far / ( bc1far - bc2far ) );

			} else if ( bc2far < 0 ) {

				// v2 lies outside the far plane, v2 inside
				alpha2 = Math.min( alpha2, bc1far / ( bc1far - bc2far ) );

			}

			if ( alpha2 < alpha1 ) {

				// The line segment spans two boundaries, but is outside both of them.
				// (This can't happen when we're only clipping against just near/far but good
				//  to leave the check here for future usage if other clip planes are added.)
				return false;

			} else {

				// Update the s1 and s2 vertices to match the clipped line segment.
				s1.lerp( s2, alpha1 );
				s2.lerp( s1, 1 - alpha2 );

				return true;

			}

		}

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();
	this.vertexNormals = normal instanceof Array ? normal : [ ];

	this.color = color instanceof THREE.Color ? color : new THREE.Color();
	this.vertexColors = color instanceof Array ? color : [];

	this.vertexTangents = [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	this.centroid = new THREE.Vector3();

};

THREE.Face3.prototype = {

	constructor: THREE.Face3,

	clone: function () {

		var face = new THREE.Face3( this.a, this.b, this.c );

		face.normal.copy( this.normal );
		face.color.copy( this.color );
		face.centroid.copy( this.centroid );

		face.materialIndex = this.materialIndex;

		var i, il;
		for ( i = 0, il = this.vertexNormals.length; i < il; i ++ ) face.vertexNormals[ i ] = this.vertexNormals[ i ].clone();
		for ( i = 0, il = this.vertexColors.length; i < il; i ++ ) face.vertexColors[ i ] = this.vertexColors[ i ].clone();
		for ( i = 0, il = this.vertexTangents.length; i < il; i ++ ) face.vertexTangents[ i ] = this.vertexTangents[ i ].clone();

		return face;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Face4 = function ( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.')

	return new THREE.Face3( a, b, c, normal, color, materialIndex );

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.BufferGeometry = function () {

	this.id = THREE.GeometryIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	// attributes

	this.attributes = {};

	// offsets for chunks when using indexed elements

	this.offsets = [];

	// boundings

	this.boundingBox = null;
	this.boundingSphere = null;

};

THREE.BufferGeometry.prototype = {

	constructor: THREE.BufferGeometry,

	addAttribute: function ( name, type, numItems, itemSize ) {

		this.attributes[ name ] = {

			array: new type( numItems * itemSize ),
			itemSize: itemSize

		};

		return this.attributes[ name ];

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.multiplyVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

			normalMatrix.multiplyVector3Array( normal.array );
			normal.needsUpdate = true;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		var positions = this.attributes[ "position" ].array;

		if ( positions ) {

			var bb = this.boundingBox;

			if( positions.length >= 3 ) {
				bb.min.x = bb.max.x = positions[ 0 ];
				bb.min.y = bb.max.y = positions[ 1 ];
				bb.min.z = bb.max.z = positions[ 2 ];
			}

			for ( var i = 3, il = positions.length; i < il; i += 3 ) {

				var x = positions[ i ];
				var y = positions[ i + 1 ];
				var z = positions[ i + 2 ];

				// bounding box

				if ( x < bb.min.x ) {

					bb.min.x = x;

				} else if ( x > bb.max.x ) {

					bb.max.x = x;

				}

				if ( y < bb.min.y ) {

					bb.min.y = y;

				} else if ( y > bb.max.y ) {

					bb.max.y = y;

				}

				if ( z < bb.min.z ) {

					bb.min.z = z;

				} else if ( z > bb.max.z ) {

					bb.max.z = z;

				}

			}

		}

		if ( positions === undefined || positions.length === 0 ) {

			this.boundingBox.min.set( 0, 0, 0 );
			this.boundingBox.max.set( 0, 0, 0 );

		}

	},

	computeBoundingSphere: function () {

		var box = new THREE.Box3();
		var vector = new THREE.Vector3();

		return function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new THREE.Sphere();

			}

			var positions = this.attributes[ "position" ].array;

			if ( positions ) {

				box.makeEmpty();

				var center = this.boundingSphere.center;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					box.addPoint( vector );

				}

				box.center( center );

				var maxRadiusSq = 0;

				for ( var i = 0, il = positions.length; i < il; i += 3 ) {

					vector.set( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			}

		}

	}(),

	computeVertexNormals: function () {

		if ( this.attributes[ "position" ] ) {

			var i, il;
			var j, jl;

			var nVertexElements = this.attributes[ "position" ].array.length;

			if ( this.attributes[ "normal" ] === undefined ) {

				this.attributes[ "normal" ] = {

					itemSize: 3,
					array: new Float32Array( nVertexElements )

				};

			} else {

				// reset existing normals to zero

				for ( i = 0, il = this.attributes[ "normal" ].array.length; i < il; i ++ ) {

					this.attributes[ "normal" ].array[ i ] = 0;

				}

			}

			var positions = this.attributes[ "position" ].array;
			var normals = this.attributes[ "normal" ].array;

			var vA, vB, vC, x, y, z,

			pA = new THREE.Vector3(),
			pB = new THREE.Vector3(),
			pC = new THREE.Vector3(),

			cb = new THREE.Vector3(),
			ab = new THREE.Vector3();

			// indexed elements

			if ( this.attributes[ "index" ] ) {

				var indices = this.attributes[ "index" ].array;

				var offsets = this.offsets;

				for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

					var start = offsets[ j ].start;
					var count = offsets[ j ].count;
					var index = offsets[ j ].index;

					for ( i = start, il = start + count; i < il; i += 3 ) {

						vA = index + indices[ i ];
						vB = index + indices[ i + 1 ];
						vC = index + indices[ i + 2 ];

						x = positions[ vA * 3 ];
						y = positions[ vA * 3 + 1 ];
						z = positions[ vA * 3 + 2 ];
						pA.set( x, y, z );

						x = positions[ vB * 3 ];
						y = positions[ vB * 3 + 1 ];
						z = positions[ vB * 3 + 2 ];
						pB.set( x, y, z );

						x = positions[ vC * 3 ];
						y = positions[ vC * 3 + 1 ];
						z = positions[ vC * 3 + 2 ];
						pC.set( x, y, z );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA * 3     ] += cb.x;
						normals[ vA * 3 + 1 ] += cb.y;
						normals[ vA * 3 + 2 ] += cb.z;

						normals[ vB * 3     ] += cb.x;
						normals[ vB * 3 + 1 ] += cb.y;
						normals[ vB * 3 + 2 ] += cb.z;

						normals[ vC * 3     ] += cb.x;
						normals[ vC * 3 + 1 ] += cb.y;
						normals[ vC * 3 + 2 ] += cb.z;

					}

				}

			// non-indexed elements (unconnected triangle soup)

			} else {

				for ( i = 0, il = positions.length; i < il; i += 9 ) {

					x = positions[ i ];
					y = positions[ i + 1 ];
					z = positions[ i + 2 ];
					pA.set( x, y, z );

					x = positions[ i + 3 ];
					y = positions[ i + 4 ];
					z = positions[ i + 5 ];
					pB.set( x, y, z );

					x = positions[ i + 6 ];
					y = positions[ i + 7 ];
					z = positions[ i + 8 ];
					pC.set( x, y, z );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i     ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			this.normalsNeedUpdate = true;

		}

	},

	normalizeNormals: function () {

		var normals = this.attributes[ "normal" ].array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i     ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( this.attributes[ "index" ] === undefined ||
			 this.attributes[ "position" ] === undefined ||
			 this.attributes[ "normal" ] === undefined ||
			 this.attributes[ "uv" ] === undefined ) {

			console.warn( "Missing required attributes (index, position, normal or uv) in BufferGeometry.computeTangents()" );
			return;

		}

		var indices = this.attributes[ "index" ].array;
		var positions = this.attributes[ "position" ].array;
		var normals = this.attributes[ "normal" ].array;
		var uvs = this.attributes[ "uv" ].array;

		var nVertices = positions.length / 3;

		if ( this.attributes[ "tangent" ] === undefined ) {

			var nTangentElements = 4 * nVertices;

			this.attributes[ "tangent" ] = {

				itemSize: 4,
				array: new Float32Array( nTangentElements )

			};

		}

		var tangents = this.attributes[ "tangent" ].array;

		var tan1 = [], tan2 = [];

		for ( var k = 0; k < nVertices; k ++ ) {

			tan1[ k ] = new THREE.Vector3();
			tan2[ k ] = new THREE.Vector3();

		}

		var xA, yA, zA,
			xB, yB, zB,
			xC, yC, zC,

			uA, vA,
			uB, vB,
			uC, vC,

			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r;

		var sdir = new THREE.Vector3(), tdir = new THREE.Vector3();

		function handleTriangle( a, b, c ) {

			xA = positions[ a * 3 ];
			yA = positions[ a * 3 + 1 ];
			zA = positions[ a * 3 + 2 ];

			xB = positions[ b * 3 ];
			yB = positions[ b * 3 + 1 ];
			zB = positions[ b * 3 + 2 ];

			xC = positions[ c * 3 ];
			yC = positions[ c * 3 + 1 ];
			zC = positions[ c * 3 + 2 ];

			uA = uvs[ a * 2 ];
			vA = uvs[ a * 2 + 1 ];

			uB = uvs[ b * 2 ];
			vB = uvs[ b * 2 + 1 ];

			uC = uvs[ c * 2 ];
			vC = uvs[ c * 2 + 1 ];

			x1 = xB - xA;
			x2 = xC - xA;

			y1 = yB - yA;
			y2 = yC - yA;

			z1 = zB - zA;
			z2 = zC - zA;

			s1 = uB - uA;
			s2 = uC - uA;

			t1 = vB - vA;
			t2 = vC - vA;

			r = 1.0 / ( s1 * t2 - s2 * t1 );

			sdir.set(
				( t2 * x1 - t1 * x2 ) * r,
				( t2 * y1 - t1 * y2 ) * r,
				( t2 * z1 - t1 * z2 ) * r
			);

			tdir.set(
				( s1 * x2 - s2 * x1 ) * r,
				( s1 * y2 - s2 * y1 ) * r,
				( s1 * z2 - s2 * z1 ) * r
			);

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		var i, il;
		var j, jl;
		var iA, iB, iC;

		var offsets = this.offsets;

		for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

			var start = offsets[ j ].start;
			var count = offsets[ j ].count;
			var index = offsets[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleTriangle( iA, iB, iC );

			}

		}

		var tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3();
		var n = new THREE.Vector3(), n2 = new THREE.Vector3();
		var w, t, test;

		function handleVertex( v ) {

			n.x = normals[ v * 3 ];
			n.y = normals[ v * 3 + 1 ];
			n.z = normals[ v * 3 + 2 ];

			n2.copy( n );

			t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			test = tmp2.dot( tan2[ v ] );
			w = ( test < 0.0 ) ? -1.0 : 1.0;

			tangents[ v * 4     ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( j = 0, jl = offsets.length; j < jl; ++ j ) {

			var start = offsets[ j ].start;
			var count = offsets[ j ].count;
			var index = offsets[ j ].index;

			for ( i = start, il = start + count; i < il; i += 3 ) {

				iA = index + indices[ i ];
				iB = index + indices[ i + 1 ];
				iC = index + indices[ i + 2 ];

				handleVertex( iA );
				handleVertex( iB );
				handleVertex( iC );

			}

		}

	},

	/*
		computeOffsets
		Compute the draw offset for large models by chunking the index buffer into chunks of 65k addressable vertices.
		This method will effectively rewrite the index buffer and remap all attributes to match the new indices.
		WARNING: This method will also expand the vertex count to prevent sprawled triangles across draw offsets.
		indexBufferSize - Defaults to 65535, but allows for larger or smaller chunks.
	*/
	computeOffsets: function(indexBufferSize) {

		var size = indexBufferSize;
		if(indexBufferSize === undefined)
			size = 65535; //WebGL limits type of index buffer values to 16-bit.

		var s = Date.now();

		var indices = this.attributes['index'].array;
		var vertices = this.attributes['position'].array;

		var verticesCount = (vertices.length/3);
		var facesCount = (indices.length/3);

		/*
		console.log("Computing buffers in offsets of "+size+" -> indices:"+indices.length+" vertices:"+vertices.length);
		console.log("Faces to process: "+(indices.length/3));
		console.log("Reordering "+verticesCount+" vertices.");
		*/

		var sortedIndices = new Uint16Array( indices.length ); //16-bit buffers
		var indexPtr = 0;
		var vertexPtr = 0;

		var offsets = [ { start:0, count:0, index:0 } ];
		var offset = offsets[0];

		var duplicatedVertices = 0;
		var newVerticeMaps = 0;
		var faceVertices = new Int32Array(6);
		var vertexMap = new Int32Array( vertices.length );
		var revVertexMap = new Int32Array( vertices.length );
		for(var j = 0; j < vertices.length; j++) { vertexMap[j] = -1; revVertexMap[j] = -1; }

		/*
			Traverse every face and reorder vertices in the proper offsets of 65k.
			We can have more than 65k entries in the index buffer per offset, but only reference 65k values.
		*/
		for(var findex = 0; findex < facesCount; findex++) {
			newVerticeMaps = 0;

			for(var vo = 0; vo < 3; vo++) {
				var vid = indices[ findex*3 + vo ];
				if(vertexMap[vid] == -1) {
					//Unmapped vertice
					faceVertices[vo*2] = vid;
					faceVertices[vo*2+1] = -1;
					newVerticeMaps++;
				} else if(vertexMap[vid] < offset.index) {
					//Reused vertices from previous block (duplicate)
					faceVertices[vo*2] = vid;
					faceVertices[vo*2+1] = -1;
					duplicatedVertices++;
				} else {
					//Reused vertice in the current block
					faceVertices[vo*2] = vid;
					faceVertices[vo*2+1] = vertexMap[vid];
				}
			}

			var faceMax = vertexPtr + newVerticeMaps;
			if(faceMax > (offset.index + size)) {
				var new_offset = { start:indexPtr, count:0, index:vertexPtr };
				offsets.push(new_offset);
				offset = new_offset;

				//Re-evaluate reused vertices in light of new offset.
				for(var v = 0; v < 6; v+=2) {
					var new_vid = faceVertices[v+1];
					if(new_vid > -1 && new_vid < offset.index)
						faceVertices[v+1] = -1;
				}
			}

			//Reindex the face.
			for(var v = 0; v < 6; v+=2) {
				var vid = faceVertices[v];
				var new_vid = faceVertices[v+1];

				if(new_vid === -1)
					new_vid = vertexPtr++;

				vertexMap[vid] = new_vid;
				revVertexMap[new_vid] = vid;
				sortedIndices[indexPtr++] = new_vid - offset.index; //XXX overflows at 16bit
				offset.count++;
			}
		}

		/* Move all attribute values to map to the new computed indices , also expand the vertice stack to match our new vertexPtr. */
		this.reorderBuffers(sortedIndices, revVertexMap, vertexPtr);
		this.offsets = offsets;

		/*
		var orderTime = Date.now();
		console.log("Reorder time: "+(orderTime-s)+"ms");
		console.log("Duplicated "+duplicatedVertices+" vertices.");
		console.log("Compute Buffers time: "+(Date.now()-s)+"ms");
		console.log("Draw offsets: "+offsets.length);
		*/

		return offsets;
	},

	/*
		reoderBuffers:
		Reorder attributes based on a new indexBuffer and indexMap.
		indexBuffer - Uint16Array of the new ordered indices.
		indexMap - Int32Array where the position is the new vertex ID and the value the old vertex ID for each vertex.
		vertexCount - Amount of total vertices considered in this reordering (in case you want to grow the vertice stack).
	*/
	reorderBuffers: function(indexBuffer, indexMap, vertexCount) {

		/* Create a copy of all attributes for reordering. */
		var sortedAttributes = {};
		var types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];
		for( var attr in this.attributes ) {
			if(attr == 'index')
				continue;
			var sourceArray = this.attributes[attr].array;
			for ( var i = 0, il = types.length; i < il; i++ ) {
				var type = types[i];
				if (sourceArray instanceof type) {
					sortedAttributes[attr] = new type( this.attributes[attr].itemSize * vertexCount );
					break;
				}
			}
		}

		/* Move attribute positions based on the new index map */
		for(var new_vid = 0; new_vid < vertexCount; new_vid++) {
			var vid = indexMap[new_vid];
			for ( var attr in this.attributes ) {
				if(attr == 'index')
					continue;
				var attrArray = this.attributes[attr].array;
				var attrSize = this.attributes[attr].itemSize;
				var sortedAttr = sortedAttributes[attr];
				for(var k = 0; k < attrSize; k++)
					sortedAttr[ new_vid * attrSize + k ] = attrArray[ vid * attrSize + k ];
			}
		}

		/* Carry the new sorted buffers locally */
		this.attributes['index'].array = indexBuffer;
		for ( var attr in this.attributes ) {
			if(attr == 'index')
				continue;
			this.attributes[attr].array = sortedAttributes[attr];
			this.attributes[attr].numItems = this.attributes[attr].itemSize * vertexCount;
		}
	},

	clone: function () {

		var geometry = new THREE.BufferGeometry();

		var types = [ Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array ];

		for ( var attr in this.attributes ) {

			var sourceAttr = this.attributes[ attr ];
			var sourceArray = sourceAttr.array;

			var attribute = {

				itemSize: sourceAttr.itemSize,
				array: null

			};

			for ( var i = 0, il = types.length; i < il; i ++ ) {

				var type = types[ i ];

				if ( sourceArray instanceof type ) {

					attribute.array = new type( sourceArray );
					break;

				}

			}

			geometry.attributes[ attr ] = attribute;

		}

		for ( var i = 0, il = this.offsets.length; i < il; i ++ ) {

			var offset = this.offsets[ i ];

			geometry.offsets.push( {

				start: offset.start,
				index: offset.index,
				count: offset.count

			} );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.BufferGeometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://exocortex.com
 */

THREE.Geometry = function () {

	this.id = THREE.GeometryIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.vertices = [];
	this.colors = [];  // one-to-one vertex colors, used in ParticleSystem and Line

	this.faces = [];

	this.faceVertexUvs = [[]];

	this.morphTargets = [];
	this.morphColors = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.hasTangents = false;

	this.dynamic = true; // the intermediate typed arrays will be deleted when set to false

	// update flags

	this.verticesNeedUpdate = false;
	this.elementsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.tangentsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;

	this.buffersNeedUpdate = false;

};

THREE.Geometry.prototype = {

	constructor: THREE.Geometry,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

			face.centroid.applyMatrix4( matrix );

		}

		if ( this.boundingBox instanceof THREE.Box3 ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere instanceof THREE.Sphere ) {

			this.computeBoundingSphere();

		}

	},

	computeCentroids: function () {

		var f, fl, face;

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			face.centroid.set( 0, 0, 0 );

			face.centroid.add( this.vertices[ face.a ] );
			face.centroid.add( this.vertices[ face.b ] );
			face.centroid.add( this.vertices[ face.c ] );
			face.centroid.divideScalar( 3 );

		}

	},

	computeFaceNormals: function () {

		var cb = new THREE.Vector3(), ab = new THREE.Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new THREE.Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC, vD;
			var cb = new THREE.Vector3(), ab = new THREE.Vector3(),
				db = new THREE.Vector3(), dc = new THREE.Vector3(), bc = new THREE.Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.vertexNormals[ 0 ] = vertices[ face.a ].clone();
			face.vertexNormals[ 1 ] = vertices[ face.b ].clone();
			face.vertexNormals[ 2 ] = vertices[ face.c ].clone();

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new THREE.Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = new THREE.Vector3();
					vertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeTangents: function () {

		// based on http://www.terathon.com/code/tangent.html
		// tangents go to vertices

		var f, fl, v, vl, i, il, vertexIndex,
			face, uv, vA, vB, vC, uvA, uvB, uvC,
			x1, x2, y1, y2, z1, z2,
			s1, s2, t1, t2, r, t, test,
			tan1 = [], tan2 = [],
			sdir = new THREE.Vector3(), tdir = new THREE.Vector3(),
			tmp = new THREE.Vector3(), tmp2 = new THREE.Vector3(),
			n = new THREE.Vector3(), w;

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			tan1[ v ] = new THREE.Vector3();
			tan2[ v ] = new THREE.Vector3();

		}

		function handleTriangle( context, a, b, c, ua, ub, uc ) {

			vA = context.vertices[ a ];
			vB = context.vertices[ b ];
			vC = context.vertices[ c ];

			uvA = uv[ ua ];
			uvB = uv[ ub ];
			uvC = uv[ uc ];

			x1 = vB.x - vA.x;
			x2 = vC.x - vA.x;
			y1 = vB.y - vA.y;
			y2 = vC.y - vA.y;
			z1 = vB.z - vA.z;
			z2 = vC.z - vA.z;

			s1 = uvB.x - uvA.x;
			s2 = uvC.x - uvA.x;
			t1 = uvB.y - uvA.y;
			t2 = uvC.y - uvA.y;

			r = 1.0 / ( s1 * t2 - s2 * t1 );
			sdir.set( ( t2 * x1 - t1 * x2 ) * r,
					  ( t2 * y1 - t1 * y2 ) * r,
					  ( t2 * z1 - t1 * z2 ) * r );
			tdir.set( ( s1 * x2 - s2 * x1 ) * r,
					  ( s1 * y2 - s2 * y1 ) * r,
					  ( s1 * z2 - s2 * z1 ) * r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];
			uv = this.faceVertexUvs[ 0 ][ f ]; // use UV layer 0 for tangents

			handleTriangle( this, face.a, face.b, face.c, 0, 1, 2 );

		}

		var faceIndex = [ 'a', 'b', 'c', 'd' ];

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			for ( i = 0; i < Math.min( face.vertexNormals.length, 3 ); i++ ) {

				n.copy( face.vertexNormals[ i ] );

				vertexIndex = face[ faceIndex[ i ] ];

				t = tan1[ vertexIndex ];

				// Gram-Schmidt orthogonalize

				tmp.copy( t );
				tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

				// Calculate handedness

				tmp2.crossVectors( face.vertexNormals[ i ], t );
				test = tmp2.dot( tan2[ vertexIndex ] );
				w = (test < 0.0) ? -1.0 : 1.0;

				face.vertexTangents[ i ] = new THREE.Vector4( tmp.x, tmp.y, tmp.z, w );

			}

		}

		this.hasTangents = true;

	},

	computeLineDistances: function ( ) {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new THREE.Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new THREE.Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertice by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, eg. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i,il, face;
		var indices, k, j, jl, u;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		};


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = -1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {
				if ( indices[ n ] == indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}
			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	// Geometry splitting

	makeGroups: ( function () {

		var geometryGroupCounter = 0;
		
		return function ( usesFaceMaterial ) {

			var f, fl, face, materialIndex,
				groupHash, hash_map = {};

			var numMorphTargets = this.morphTargets.length;
			var numMorphNormals = this.morphNormals.length;

			this.geometryGroups = {};

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];
				materialIndex = usesFaceMaterial ? face.materialIndex : 0;

				if ( ! ( materialIndex in hash_map ) ) {

					hash_map[ materialIndex ] = { 'hash': materialIndex, 'counter': 0 };

				}

				groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

				if ( ! ( groupHash in this.geometryGroups ) ) {

					this.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };

				}

				if ( this.geometryGroups[ groupHash ].vertices + 3 > 65535 ) {

					hash_map[ materialIndex ].counter += 1;
					groupHash = hash_map[ materialIndex ].hash + '_' + hash_map[ materialIndex ].counter;

					if ( ! ( groupHash in this.geometryGroups ) ) {

						this.geometryGroups[ groupHash ] = { 'faces3': [], 'materialIndex': materialIndex, 'vertices': 0, 'numMorphTargets': numMorphTargets, 'numMorphNormals': numMorphNormals };

					}

				}

				this.geometryGroups[ groupHash ].faces3.push( f );
				this.geometryGroups[ groupHash ].vertices += 3;

			}

			this.geometryGroupsList = [];

			for ( var g in this.geometryGroups ) {

				this.geometryGroups[ g ].id = geometryGroupCounter ++;

				this.geometryGroupsList.push( this.geometryGroups[ g ] );

			}

		};
		
	} )(),

	clone: function () {

		var geometry = new THREE.Geometry();

		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			geometry.vertices.push( vertices[ i ].clone() );

		}

		var faces = this.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			geometry.faces.push( faces[ i ].clone() );

		}

		var uvs = this.faceVertexUvs[ 0 ];

		for ( var i = 0, il = uvs.length; i < il; i ++ ) {

			var uv = uvs[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			geometry.faceVertexUvs[ 0 ].push( uvCopy );

		}

		return geometry;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Geometry.prototype );

THREE.GeometryIdCount = 0;

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Geometry2 = function ( size ) {

	THREE.BufferGeometry.call( this );

	this.vertices = this.addAttribute( 'position', Float32Array, size, 3 ).array;
	this.normals = this.addAttribute( 'normal', Float32Array, size, 3 ).array;
	this.uvs = this.addAttribute( 'uv', Float32Array, size, 2 ).array;

	this.boundingBox = null;
	this.boundingSphere = null;

};

THREE.Geometry2.prototype = Object.create( THREE.BufferGeometry.prototype );
/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.Camera = function () {

	THREE.Object3D.call( this );

	this.matrixWorldInverse = new THREE.Matrix4();
	this.projectionMatrix = new THREE.Matrix4();

};

THREE.Camera.prototype = Object.create( THREE.Object3D.prototype );

THREE.Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new THREE.Matrix4();

	return function ( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

THREE.Camera.prototype.clone = function (camera) {

	if ( camera === undefined ) camera = new THREE.Camera();

	THREE.Object3D.prototype.clone.call( this, camera );

	camera.matrixWorldInverse.copy( this.matrixWorldInverse );
	camera.projectionMatrix.copy( this.projectionMatrix );

	return camera;
};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {

	THREE.Camera.call( this );

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.OrthographicCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.OrthographicCamera.prototype.updateProjectionMatrix = function () {

	this.projectionMatrix.makeOrthographic( this.left, this.right, this.top, this.bottom, this.near, this.far );

};

THREE.OrthographicCamera.prototype.clone = function () {

	var camera = new THREE.OrthographicCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.left = this.left;
	camera.right = this.right;
	camera.top = this.top;
	camera.bottom = this.bottom;
	
	camera.near = this.near;
	camera.far = this.far;

	return camera;
};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

THREE.PerspectiveCamera = function ( fov, aspect, near, far ) {

	THREE.Camera.call( this );

	this.fov = fov !== undefined ? fov : 50;
	this.aspect = aspect !== undefined ? aspect : 1;
	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;

	this.updateProjectionMatrix();

};

THREE.PerspectiveCamera.prototype = Object.create( THREE.Camera.prototype );


/**
 * Uses Focal Length (in mm) to estimate and set FOV
 * 35mm (fullframe) camera is used if frame size is not specified;
 * Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
 */

THREE.PerspectiveCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	this.fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );
	this.updateProjectionMatrix();

}


/**
 * Sets an offset in a larger frustum. This is useful for multi-window or
 * multi-monitor/multi-machine setups.
 *
 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
 * the monitors are in grid like this
 *
 *   +---+---+---+
 *   | A | B | C |
 *   +---+---+---+
 *   | D | E | F |
 *   +---+---+---+
 *
 * then for each monitor you would call it like this
 *
 *   var w = 1920;
 *   var h = 1080;
 *   var fullWidth = w * 3;
 *   var fullHeight = h * 2;
 *
 *   --A--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
 *   --B--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
 *   --C--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
 *   --D--
 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
 *   --E--
 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
 *   --F--
 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
 *
 *   Note there is no reason monitors have to be the same size or in a grid.
 */

THREE.PerspectiveCamera.prototype.setViewOffset = function ( fullWidth, fullHeight, x, y, width, height ) {

	this.fullWidth = fullWidth;
	this.fullHeight = fullHeight;
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;

	this.updateProjectionMatrix();

};


THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function () {

	if ( this.fullWidth ) {

		var aspect = this.fullWidth / this.fullHeight;
		var top = Math.tan( THREE.Math.degToRad( this.fov * 0.5 ) ) * this.near;
		var bottom = -top;
		var left = aspect * bottom;
		var right = aspect * top;
		var width = Math.abs( right - left );
		var height = Math.abs( top - bottom );

		this.projectionMatrix.makeFrustum(
			left + this.x * width / this.fullWidth,
			left + ( this.x + this.width ) * width / this.fullWidth,
			top - ( this.y + this.height ) * height / this.fullHeight,
			top - this.y * height / this.fullHeight,
			this.near,
			this.far
		);

	} else {

		this.projectionMatrix.makePerspective( this.fov, this.aspect, this.near, this.far );

	}

};

THREE.PerspectiveCamera.prototype.clone = function () {

	var camera = new THREE.PerspectiveCamera();

	THREE.Camera.prototype.clone.call( this, camera );

	camera.fov = this.fov;
	camera.aspect = this.aspect;
	camera.near = this.near;
	camera.far = this.far;

	return camera;
};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */
 
THREE.Light = function ( color ) {

	THREE.Object3D.call( this );

	this.color = new THREE.Color( color );

};

THREE.Light.prototype = Object.create( THREE.Object3D.prototype );

THREE.Light.prototype.clone = function ( light ) {

	if ( light === undefined ) light = new THREE.Light();

	THREE.Object3D.prototype.clone.call( this, light );

	light.color.copy( this.color );

	return light;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AmbientLight = function ( color ) {

	THREE.Light.call( this, color );

};

THREE.AmbientLight.prototype = Object.create( THREE.Light.prototype );

THREE.AmbientLight.prototype.clone = function () {

	var light = new THREE.AmbientLight();

	THREE.Light.prototype.clone.call( this, light );

	return light;

};

/**
 * @author MPanknin / http://www.redplant.de/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.AreaLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.normal = new THREE.Vector3( 0, -1, 0 );
	this.right = new THREE.Vector3( 1, 0, 0 );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.width = 1.0;
	this.height = 1.0;

	this.constantAttenuation = 1.5;
	this.linearAttenuation = 0.5;
	this.quadraticAttenuation = 0.1;

};

THREE.AreaLight.prototype = Object.create( THREE.Light.prototype );


/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DirectionalLight = function ( color, intensity ) {

	THREE.Light.call( this, color );

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;

	this.shadowCameraLeft = -500;
	this.shadowCameraRight = 500;
	this.shadowCameraTop = 500;
	this.shadowCameraBottom = -500;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowCascade = false;

	this.shadowCascadeOffset = new THREE.Vector3( 0, 0, -1000 );
	this.shadowCascadeCount = 2;

	this.shadowCascadeBias = [ 0, 0, 0 ];
	this.shadowCascadeWidth = [ 512, 512, 512 ];
	this.shadowCascadeHeight = [ 512, 512, 512 ];

	this.shadowCascadeNearZ = [ -1.000, 0.990, 0.998 ];
	this.shadowCascadeFarZ  = [  0.990, 0.998, 1.000 ];

	this.shadowCascadeArray = [];

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.DirectionalLight.prototype = Object.create( THREE.Light.prototype );

THREE.DirectionalLight.prototype.clone = function () {

	var light = new THREE.DirectionalLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {

	THREE.Light.call( this, skyColor );

	this.position.set( 0, 100, 0 );

	this.groundColor = new THREE.Color( groundColor );
	this.intensity = ( intensity !== undefined ) ? intensity : 1;

};

THREE.HemisphereLight.prototype = Object.create( THREE.Light.prototype );

THREE.HemisphereLight.prototype.clone = function () {

	var light = new THREE.HemisphereLight();

	THREE.Light.prototype.clone.call( this, light );

	light.groundColor.copy( this.groundColor );
	light.intensity = this.intensity;

	return light;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLight = function ( color, intensity, distance ) {

	THREE.Light.call( this, color );

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;

};

THREE.PointLight.prototype = Object.create( THREE.Light.prototype );

THREE.PointLight.prototype.clone = function () {

	var light = new THREE.PointLight();

	THREE.Light.prototype.clone.call( this, light );

	light.intensity = this.intensity;
	light.distance = this.distance;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpotLight = function ( color, intensity, distance, angle, exponent ) {

	THREE.Light.call( this, color );

	this.position.set( 0, 1, 0 );
	this.target = new THREE.Object3D();

	this.intensity = ( intensity !== undefined ) ? intensity : 1;
	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.exponent = ( exponent !== undefined ) ? exponent : 10;

	this.castShadow = false;
	this.onlyShadow = false;

	//

	this.shadowCameraNear = 50;
	this.shadowCameraFar = 5000;
	this.shadowCameraFov = 50;

	this.shadowCameraVisible = false;

	this.shadowBias = 0;
	this.shadowDarkness = 0.5;

	this.shadowMapWidth = 512;
	this.shadowMapHeight = 512;

	//

	this.shadowMap = null;
	this.shadowMapSize = null;
	this.shadowCamera = null;
	this.shadowMatrix = null;

};

THREE.SpotLight.prototype = Object.create( THREE.Light.prototype );

THREE.SpotLight.prototype.clone = function () {

	var light = new THREE.SpotLight();

	THREE.Light.prototype.clone.call( this, light );

	light.target = this.target.clone();

	light.intensity = this.intensity;
	light.distance = this.distance;
	light.angle = this.angle;
	light.exponent = this.exponent;

	light.castShadow = this.castShadow;
	light.onlyShadow = this.onlyShadow;

	return light;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Loader = function ( showStatus ) {

	this.showStatus = showStatus;
	this.statusDomElement = showStatus ? THREE.Loader.prototype.addStatusElement() : null;

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

};

THREE.Loader.prototype = {

	constructor: THREE.Loader,

	crossOrigin: undefined,

	addStatusElement: function () {

		var e = document.createElement( "div" );

		e.style.position = "absolute";
		e.style.right = "0px";
		e.style.top = "0px";
		e.style.fontSize = "0.8em";
		e.style.textAlign = "left";
		e.style.background = "rgba(0,0,0,0.25)";
		e.style.color = "#fff";
		e.style.width = "120px";
		e.style.padding = "0.5em 0.5em 0.5em 0.5em";
		e.style.zIndex = 1000;

		e.innerHTML = "Loading ...";

		return e;

	},

	updateProgress: function ( progress ) {

		var message = "Loaded ";

		if ( progress.total ) {

			message += ( 100 * progress.loaded / progress.total ).toFixed(0) + "%";


		} else {

			message += ( progress.loaded / 1000 ).toFixed(2) + " KB";

		}

		this.statusDomElement.innerHTML = message;

	},

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = THREE.Loader.prototype.createMaterial( materials[ i ], texturePath );

		}

		return array;

	},

	needsTangents: function ( materials ) {

		for( var i = 0, il = materials.length; i < il; i ++ ) {

			var m = materials[ i ];

			if ( m instanceof THREE.ShaderMaterial ) return true;

		}

		return false;

	},

	createMaterial: function ( m, texturePath ) {

		var _this = this;

		function is_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.floor( l ) == l;

		}

		function nearest_pow2( n ) {

			var l = Math.log( n ) / Math.LN2;
			return Math.pow( 2, Math.round(  l ) );

		}

		function load_image( where, url ) {

			var image = new Image();

			image.onload = function () {

				if ( !is_pow2( this.width ) || !is_pow2( this.height ) ) {

					var width = nearest_pow2( this.width );
					var height = nearest_pow2( this.height );

					where.image.width = width;
					where.image.height = height;
					where.image.getContext( '2d' ).drawImage( this, 0, 0, width, height );

				} else {

					where.image = this;

				}

				where.needsUpdate = true;

			};

			if ( _this.crossOrigin !== undefined ) image.crossOrigin = _this.crossOrigin;
			image.src = url;

		}

		function create_texture( where, name, sourceFile, repeat, offset, wrap, anisotropy ) {

			var isCompressed = /\.dds$/i.test( sourceFile );

			var fullPath = texturePath + sourceFile;

			if ( isCompressed ) {

				var texture = THREE.ImageUtils.loadCompressedTexture( fullPath );

				where[ name ] = texture;

			} else {

				var texture = document.createElement( 'canvas' );

				where[ name ] = new THREE.Texture( texture );

			}

			where[ name ].sourceFile = sourceFile;

			if( repeat ) {

				where[ name ].repeat.set( repeat[ 0 ], repeat[ 1 ] );

				if ( repeat[ 0 ] !== 1 ) where[ name ].wrapS = THREE.RepeatWrapping;
				if ( repeat[ 1 ] !== 1 ) where[ name ].wrapT = THREE.RepeatWrapping;

			}

			if ( offset ) {

				where[ name ].offset.set( offset[ 0 ], offset[ 1 ] );

			}

			if ( wrap ) {

				var wrapMap = {
					"repeat": THREE.RepeatWrapping,
					"mirror": THREE.MirroredRepeatWrapping
				}

				if ( wrapMap[ wrap[ 0 ] ] !== undefined ) where[ name ].wrapS = wrapMap[ wrap[ 0 ] ];
				if ( wrapMap[ wrap[ 1 ] ] !== undefined ) where[ name ].wrapT = wrapMap[ wrap[ 1 ] ];

			}

			if ( anisotropy ) {

				where[ name ].anisotropy = anisotropy;

			}

			if ( ! isCompressed ) {

				load_image( where[ name ], fullPath );

			}

		}

		function rgb2hex( rgb ) {

			return ( rgb[ 0 ] * 255 << 16 ) + ( rgb[ 1 ] * 255 << 8 ) + rgb[ 2 ] * 255;

		}

		// defaults

		var mtype = "MeshLambertMaterial";
		var mpars = { color: 0xeeeeee, opacity: 1.0, map: null, lightMap: null, normalMap: null, bumpMap: null, wireframe: false };

		// parameters from model file

		if ( m.shading ) {

			var shading = m.shading.toLowerCase();

			if ( shading === "phong" ) mtype = "MeshPhongMaterial";
			else if ( shading === "basic" ) mtype = "MeshBasicMaterial";

		}

		if ( m.blending !== undefined && THREE[ m.blending ] !== undefined ) {

			mpars.blending = THREE[ m.blending ];

		}

		if ( m.transparent !== undefined || m.opacity < 1.0 ) {

			mpars.transparent = m.transparent;

		}

		if ( m.depthTest !== undefined ) {

			mpars.depthTest = m.depthTest;

		}

		if ( m.depthWrite !== undefined ) {

			mpars.depthWrite = m.depthWrite;

		}

		if ( m.visible !== undefined ) {

			mpars.visible = m.visible;

		}

		if ( m.flipSided !== undefined ) {

			mpars.side = THREE.BackSide;

		}

		if ( m.doubleSided !== undefined ) {

			mpars.side = THREE.DoubleSide;

		}

		if ( m.wireframe !== undefined ) {

			mpars.wireframe = m.wireframe;

		}

		if ( m.vertexColors !== undefined ) {

			if ( m.vertexColors === "face" ) {

				mpars.vertexColors = THREE.FaceColors;

			} else if ( m.vertexColors ) {

				mpars.vertexColors = THREE.VertexColors;

			}

		}

		// colors

		if ( m.colorDiffuse ) {

			mpars.color = rgb2hex( m.colorDiffuse );

		} else if ( m.DbgColor ) {

			mpars.color = m.DbgColor;

		}

		if ( m.colorSpecular ) {

			mpars.specular = rgb2hex( m.colorSpecular );

		}

		if ( m.colorAmbient ) {

			mpars.ambient = rgb2hex( m.colorAmbient );

		}

		// modifiers

		if ( m.transparency ) {

			mpars.opacity = m.transparency;

		}

		if ( m.specularCoef ) {

			mpars.shininess = m.specularCoef;

		}

		// textures

		if ( m.mapDiffuse && texturePath ) {

			create_texture( mpars, "map", m.mapDiffuse, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );

		}

		if ( m.mapLight && texturePath ) {

			create_texture( mpars, "lightMap", m.mapLight, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );

		}

		if ( m.mapBump && texturePath ) {

			create_texture( mpars, "bumpMap", m.mapBump, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );

		}

		if ( m.mapNormal && texturePath ) {

			create_texture( mpars, "normalMap", m.mapNormal, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );

		}

		if ( m.mapSpecular && texturePath ) {

			create_texture( mpars, "specularMap", m.mapSpecular, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );

		}

		//

		if ( m.mapBumpScale ) {

			mpars.bumpScale = m.mapBumpScale;

		}

		// special case for normal mapped material

		if ( m.mapNormal ) {

			var shader = THREE.ShaderLib[ "normalmap" ];
			var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

			uniforms[ "tNormal" ].value = mpars.normalMap;

			if ( m.mapNormalFactor ) {

				uniforms[ "uNormalScale" ].value.set( m.mapNormalFactor, m.mapNormalFactor );

			}

			if ( mpars.map ) {

				uniforms[ "tDiffuse" ].value = mpars.map;
				uniforms[ "enableDiffuse" ].value = true;

			}

			if ( mpars.specularMap ) {

				uniforms[ "tSpecular" ].value = mpars.specularMap;
				uniforms[ "enableSpecular" ].value = true;

			}

			if ( mpars.lightMap ) {

				uniforms[ "tAO" ].value = mpars.lightMap;
				uniforms[ "enableAO" ].value = true;

			}

			// for the moment don't handle displacement texture

			uniforms[ "diffuse" ].value.setHex( mpars.color );
			uniforms[ "specular" ].value.setHex( mpars.specular );
			uniforms[ "ambient" ].value.setHex( mpars.ambient );

			uniforms[ "shininess" ].value = mpars.shininess;

			if ( mpars.opacity !== undefined ) {

				uniforms[ "opacity" ].value = mpars.opacity;

			}

			var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };
			var material = new THREE.ShaderMaterial( parameters );

			if ( mpars.transparent ) {

				material.transparent = true;

			}

		} else {

			var material = new THREE[ mtype ]( mpars );

		}

		if ( m.DbgName !== undefined ) material.name = m.DbgName;

		return material;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.XHRLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.XHRLoader.prototype = {

	constructor: THREE.XHRLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;
		var request = new XMLHttpRequest();

		if ( onLoad !== undefined ) {

			request.addEventListener( 'load', function ( event ) {

				onLoad( event.target.responseText );
				scope.manager.itemEnd( url );

			}, false );

		}

		if ( onProgress !== undefined ) {

			request.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			request.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) request.crossOrigin = this.crossOrigin;

		request.open( 'GET', url, true );
		request.send( null );

		scope.manager.itemStart( url );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ImageLoader.prototype = {

	constructor: THREE.ImageLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;
		var image = document.createElement( 'img' );

		if ( onLoad !== undefined ) {

			image.addEventListener( 'load', function ( event ) {

				scope.manager.itemEnd( url );
				onLoad( this );

			}, false );

		}

		if ( onProgress !== undefined ) {

			image.addEventListener( 'progress', function ( event ) {

				onProgress( event );

			}, false );

		}

		if ( onError !== undefined ) {

			image.addEventListener( 'error', function ( event ) {

				onError( event );

			}, false );

		}

		if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		image.src = url;

		scope.manager.itemStart( url );

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.JSONLoader = function ( showStatus ) {

	THREE.Loader.call( this, showStatus );

	this.withCredentials = false;

};

THREE.JSONLoader.prototype = Object.create( THREE.Loader.prototype );

THREE.JSONLoader.prototype.load = function ( url, callback, texturePath ) {

	var scope = this;

	// todo: unify load API to for easier SceneLoader use

	texturePath = texturePath && ( typeof texturePath === "string" ) ? texturePath : this.extractUrlBase( url );

	this.onLoadStart();
	this.loadAjaxJSON( this, url, callback, texturePath );

};

THREE.JSONLoader.prototype.loadAjaxJSON = function ( context, url, callback, texturePath, callbackProgress ) {

	var xhr = new XMLHttpRequest();

	var length = 0;

	xhr.onreadystatechange = function () {

		if ( xhr.readyState === xhr.DONE ) {

			if ( xhr.status === 200 || xhr.status === 0 ) {

				if ( xhr.responseText ) {

					var json = JSON.parse( xhr.responseText );

					if ( json.metadata.type === 'scene' ) {

						console.error( 'THREE.JSONLoader: "' + url + '" seems to be a Scene. Use THREE.SceneLoader instead.' );
						return;

					}

					var result = context.parse( json, texturePath );
					callback( result.geometry, result.materials );

				} else {

					console.error( 'THREE.JSONLoader: "' + url + '" seems to be unreachable or the file is empty.' );

				}

				// in context of more complex asset initialization
				// do not block on single failed file
				// maybe should go even one more level up

				context.onLoadComplete();

			} else {

				console.error( 'THREE.JSONLoader: Couldn\'t load "' + url + '" (' + xhr.status + ')' );

			}

		} else if ( xhr.readyState === xhr.LOADING ) {

			if ( callbackProgress ) {

				if ( length === 0 ) {

					length = xhr.getResponseHeader( 'Content-Length' );

				}

				callbackProgress( { total: length, loaded: xhr.responseText.length } );

			}

		} else if ( xhr.readyState === xhr.HEADERS_RECEIVED ) {

			if ( callbackProgress !== undefined ) {

				length = xhr.getResponseHeader( "Content-Length" );

			}

		}

	};

	xhr.open( "GET", url, true );
	xhr.withCredentials = this.withCredentials;
	xhr.send( null );

};

THREE.JSONLoader.prototype.parse = function ( json, texturePath ) {

	var scope = this,
	geometry = new THREE.Geometry(),
	scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

	parseModel( scale );

	parseSkin();
	parseMorphing( scale );

	geometry.computeCentroids();
	geometry.computeFaceNormals();
	geometry.computeBoundingSphere();

	function parseModel( scale ) {

		function isBitSet( value, position ) {

			return value & ( 1 << position );

		}

		var i, j, fi,

		offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

		type,
		isQuad,
		hasMaterial,
		hasFaceVertexUv,
		hasFaceNormal, hasFaceVertexNormal,
		hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, color, hex, normal,

		uvLayer, uv, u, v,

		faces = json.faces,
		vertices = json.vertices,
		normals = json.normals,
		colors = json.colors,

		nUvLayers = 0;

		if ( json.uvs !== undefined ) {

			// disregard empty arrays

			for ( i = 0; i < json.uvs.length; i++ ) {

				if ( json.uvs[ i ].length ) nUvLayers ++;

			}

			for ( i = 0; i < nUvLayers; i++ ) {

				geometry.faceVertexUvs[ i ] = [];

			}

		}

		offset = 0;
		zLength = vertices.length;

		while ( offset < zLength ) {

			vertex = new THREE.Vector3();

			vertex.x = vertices[ offset ++ ] * scale;
			vertex.y = vertices[ offset ++ ] * scale;
			vertex.z = vertices[ offset ++ ] * scale;

			geometry.vertices.push( vertex );

		}

		offset = 0;
		zLength = faces.length;

		while ( offset < zLength ) {

			type = faces[ offset ++ ];


			isQuad              = isBitSet( type, 0 );
			hasMaterial         = isBitSet( type, 1 );
			hasFaceVertexUv     = isBitSet( type, 3 );
			hasFaceNormal       = isBitSet( type, 4 );
			hasFaceVertexNormal = isBitSet( type, 5 );
			hasFaceColor	    = isBitSet( type, 6 );
			hasFaceVertexColor  = isBitSet( type, 7 );

			// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

			if ( isQuad ) {

				faceA = new THREE.Face3();
				faceA.a = faces[ offset ];
				faceA.b = faces[ offset + 1 ];
				faceA.c = faces[ offset + 3 ];

				faceB = new THREE.Face3();
				faceB.a = faces[ offset + 1 ];
				faceB.b = faces[ offset + 2 ];
				faceB.c = faces[ offset + 3 ];

				offset += 4;

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					faceA.materialIndex = materialIndex;
					faceB.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];
						geometry.faceVertexUvs[ i ][ fi + 1 ] = []

						for ( j = 0; j < 4; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
							if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					faceA.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

					faceB.normal.copy( faceA.normal );

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 4; i++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);


						if ( i !== 2 ) faceA.vertexNormals.push( normal );
						if ( i !== 0 ) faceB.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					hex = colors[ colorIndex ];

					faceA.color.setHex( hex );
					faceB.color.setHex( hex );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 4; i++ ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						if ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );
						if ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );

					}

				}

				geometry.faces.push( faceA );
				geometry.faces.push( faceB );

			} else {

				face = new THREE.Face3();
				face.a = faces[ offset ++ ];
				face.b = faces[ offset ++ ];
				face.c = faces[ offset ++ ];

				if ( hasMaterial ) {

					materialIndex = faces[ offset ++ ];
					face.materialIndex = materialIndex;

				}

				// to get face <=> uv index correspondence

				fi = geometry.faces.length;

				if ( hasFaceVertexUv ) {

					for ( i = 0; i < nUvLayers; i++ ) {

						uvLayer = json.uvs[ i ];

						geometry.faceVertexUvs[ i ][ fi ] = [];

						for ( j = 0; j < 3; j ++ ) {

							uvIndex = faces[ offset ++ ];

							u = uvLayer[ uvIndex * 2 ];
							v = uvLayer[ uvIndex * 2 + 1 ];

							uv = new THREE.Vector2( u, v );

							geometry.faceVertexUvs[ i ][ fi ].push( uv );

						}

					}

				}

				if ( hasFaceNormal ) {

					normalIndex = faces[ offset ++ ] * 3;

					face.normal.set(
						normals[ normalIndex ++ ],
						normals[ normalIndex ++ ],
						normals[ normalIndex ]
					);

				}

				if ( hasFaceVertexNormal ) {

					for ( i = 0; i < 3; i++ ) {

						normalIndex = faces[ offset ++ ] * 3;

						normal = new THREE.Vector3(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						face.vertexNormals.push( normal );

					}

				}


				if ( hasFaceColor ) {

					colorIndex = faces[ offset ++ ];
					face.color.setHex( colors[ colorIndex ] );

				}


				if ( hasFaceVertexColor ) {

					for ( i = 0; i < 3; i++ ) {

						colorIndex = faces[ offset ++ ];
						face.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );

					}

				}

				geometry.faces.push( face );

			}

		}

	};

	function parseSkin() {

		if ( json.skinWeights ) {

			for ( var i = 0, l = json.skinWeights.length; i < l; i += 2 ) {

				var x = json.skinWeights[ i     ];
				var y = json.skinWeights[ i + 1 ];
				var z = 0;
				var w = 0;

				geometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );

			}

		}

		if ( json.skinIndices ) {

			for ( var i = 0, l = json.skinIndices.length; i < l; i += 2 ) {

				var a = json.skinIndices[ i     ];
				var b = json.skinIndices[ i + 1 ];
				var c = 0;
				var d = 0;

				geometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );

			}

		}

		geometry.bones = json.bones;

		if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

		}


		// could change this to json.animations[0] or remove completely
		
		geometry.animation = json.animation;
		geometry.animations = json.animations;

	};

	function parseMorphing( scale ) {

		if ( json.morphTargets !== undefined ) {

			var i, l, v, vl, dstVertices, srcVertices;

			for ( i = 0, l = json.morphTargets.length; i < l; i ++ ) {

				geometry.morphTargets[ i ] = {};
				geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
				geometry.morphTargets[ i ].vertices = [];

				dstVertices = geometry.morphTargets[ i ].vertices;
				srcVertices = json.morphTargets [ i ].vertices;

				for( v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

					var vertex = new THREE.Vector3();
					vertex.x = srcVertices[ v ] * scale;
					vertex.y = srcVertices[ v + 1 ] * scale;
					vertex.z = srcVertices[ v + 2 ] * scale;

					dstVertices.push( vertex );

				}

			}

		}

		if ( json.morphColors !== undefined ) {

			var i, l, c, cl, dstColors, srcColors, color;

			for ( i = 0, l = json.morphColors.length; i < l; i++ ) {

				geometry.morphColors[ i ] = {};
				geometry.morphColors[ i ].name = json.morphColors[ i ].name;
				geometry.morphColors[ i ].colors = [];

				dstColors = geometry.morphColors[ i ].colors;
				srcColors = json.morphColors [ i ].colors;

				for ( c = 0, cl = srcColors.length; c < cl; c += 3 ) {

					color = new THREE.Color( 0xffaa00 );
					color.setRGB( srcColors[ c ], srcColors[ c + 1 ], srcColors[ c + 2 ] );
					dstColors.push( color );

				}

			}

		}

	};

	if ( json.materials === undefined ) {

		return { geometry: geometry };

	} else {

		var materials = this.initMaterials( json.materials, texturePath );

		if ( this.needsTangents( materials ) ) {

			geometry.computeTangents();

		}

		return { geometry: geometry, materials: materials };

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LoadingManager = function ( onLoad, onProgress, onError ) {

	var scope = this;

	var loaded = 0, total = 0;

	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		total ++;

	};

	this.itemEnd = function ( url ) {

		loaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, loaded, total );

		}

		if ( loaded === total && scope.onLoad !== undefined ) {

			scope.onLoad();

		}

	};

};

THREE.DefaultLoadingManager = new THREE.LoadingManager();

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BufferGeometryLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.BufferGeometryLoader.prototype = {

	constructor: THREE.BufferGeometryLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.BufferGeometry();

		var attributes = json.attributes;
		var offsets = json.offsets;
		var boundingSphere = json.boundingSphere;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			geometry.attributes[ key ] = {
				itemSize: attribute.itemSize,
				array: new self[ attribute.type ]( attribute.array )
			}

		}

		if ( offsets !== undefined ) {

			geometry.offsets = JSON.parse( JSON.stringify( offsets ) );

		}

		if ( boundingSphere !== undefined ) {

			geometry.boundingSphere = new THREE.Sphere(
				new THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),
				boundingSphere.radius
			);

		}

		return geometry;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Geometry2Loader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.Geometry2Loader.prototype = {

	constructor: THREE.Geometry2Loader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometry = new THREE.Geometry2( json.vertices.length / 3 );

		var attributes = [ 'vertices', 'normals', 'uvs' ];
		var boundingSphere = json.boundingSphere;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			geometry[ attribute ].set( json[ attribute ] );

		}

		if ( boundingSphere !== undefined ) {

			geometry.boundingSphere = new THREE.Sphere(
				new THREE.Vector3().fromArray( boundingSphere.center !== undefined ? boundingSphere.center : [ 0, 0, 0 ] ),
				boundingSphere.radius
			);

		}

		return geometry;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MaterialLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.MaterialLoader.prototype = {

	constructor: THREE.MaterialLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader();
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var material = new THREE[ json.type ];

		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.ambient !== undefined ) material.ambient.setHex( json.ambient );
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ObjectLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.ObjectLoader.prototype = {

	constructor: THREE.ObjectLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json ) {

		var geometries = this.parseGeometries( json.geometries );
		var materials = this.parseMaterials( json.materials );
		var object = this.parseObject( json.object, geometries, materials );

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new THREE.JSONLoader();
			var geometry2Loader = new THREE.Geometry2Loader();
			var bufferGeometryLoader = new THREE.BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':

						geometry = new THREE.PlaneGeometry(
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'CubeGeometry': // DEPRECATED

						geometry = new THREE.BoxGeometry(
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':

						geometry = new THREE.CircleGeometry(
							data.radius,
							data.segments
						);

						break;

					case 'CylinderGeometry':

						geometry = new THREE.CylinderGeometry(
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded
						);

						break;

					case 'SphereGeometry':

						geometry = new THREE.SphereGeometry(
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'IcosahedronGeometry':

						geometry = new THREE.IcosahedronGeometry(
							data.radius,
							data.detail
						);

						break;

					case 'TorusGeometry':

						geometry = new THREE.TorusGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':

						geometry = new THREE.TorusKnotGeometry(
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.p,
							data.q,
							data.heightScale
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data.data );

						break;

					case 'Geometry2':

						geometry = geometry2Loader.parse( data.data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data ).geometry;

						break;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new THREE.MaterialLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];
				var material = loader.parse( data );

				material.uuid = data.uuid;

				if ( data.name !== undefined ) material.name = data.name;

				materials[ data.uuid ] = material;

			}

		}

		return materials;

	},

	parseObject: function () {

		var matrix = new THREE.Matrix4();

		return function ( data, geometries, materials ) {

			var object;

			switch ( data.type ) {

				case 'Scene':

					object = new THREE.Scene();

					break;

				case 'PerspectiveCamera':

					object = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					break;

				case 'OrthographicCamera':

					object = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new THREE.AmbientLight( data.color );

					break;

				case 'DirectionalLight':

					object = new THREE.DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new THREE.PointLight( data.color, data.intensity, data.distance );

					break;

				case 'SpotLight':

					object = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.exponent );

					break;

				case 'HemisphereLight':

					object = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					var geometry = geometries[ data.geometry ];
					var material = materials[ data.material ];

					if ( geometry === undefined ) {

						console.error( 'THREE.ObjectLoader: Undefined geometry ' + data.geometry );

					}

					if ( material === undefined ) {

						console.error( 'THREE.ObjectLoader: Undefined material ' + data.material );

					}

					object = new THREE.Mesh( geometry, material );

					break;

				case 'Sprite':

					var material = materials[ data.material ];

					if ( material === undefined ) {

						console.error( 'THREE.ObjectLoader: Undefined material ' + data.material );

					}

					object = new THREE.Sprite( material );

					break;

				default:

					object = new THREE.Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			return object;

		}

	}()

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneLoader = function () {

	this.onLoadStart = function () {};
	this.onLoadProgress = function() {};
	this.onLoadComplete = function () {};

	this.callbackSync = function () {};
	this.callbackProgress = function () {};

	this.geometryHandlers = {};
	this.hierarchyHandlers = {};

	this.addGeometryHandler( "ascii", THREE.JSONLoader );

};

THREE.SceneLoader.prototype = {

	constructor: THREE.SceneLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.XHRLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( text ) {

			scope.parse( JSON.parse( text ), onLoad, url );

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	addGeometryHandler: function ( typeID, loaderClass ) {

		this.geometryHandlers[ typeID ] = { "loaderClass": loaderClass };

	},

	addHierarchyHandler: function ( typeID, loaderClass ) {

		this.hierarchyHandlers[ typeID ] = { "loaderClass": loaderClass };

	},

	parse: function ( json, callbackFinished, url ) {

		var scope = this;

		var urlBase = THREE.Loader.prototype.extractUrlBase( url );

		var geometry, material, camera, fog,
			texture, images, color,
			light, hex, intensity,
			counter_models, counter_textures,
			total_models, total_textures,
			result;

		var target_array = [];

		var data = json;

		// async geometry loaders

		for ( var typeID in this.geometryHandlers ) {

			var loaderClass = this.geometryHandlers[ typeID ][ "loaderClass" ];
			this.geometryHandlers[ typeID ][ "loaderObject" ] = new loaderClass();

		}

		// async hierachy loaders

		for ( var typeID in this.hierarchyHandlers ) {

			var loaderClass = this.hierarchyHandlers[ typeID ][ "loaderClass" ];
			this.hierarchyHandlers[ typeID ][ "loaderObject" ] = new loaderClass();

		}

		counter_models = 0;
		counter_textures = 0;

		result = {

			scene: new THREE.Scene(),
			geometries: {},
			face_materials: {},
			materials: {},
			textures: {},
			objects: {},
			cameras: {},
			lights: {},
			fogs: {},
			empties: {},
			groups: {}

		};

		if ( data.transform ) {

			var position = data.transform.position,
				rotation = data.transform.rotation,
				scale = data.transform.scale;

			if ( position ) {

				result.scene.position.fromArray( position );

			}

			if ( rotation ) {

				result.scene.rotation.fromArray( rotation );

			}

			if ( scale ) {

				result.scene.scale.fromArray( scale );

			}

			if ( position || rotation || scale ) {

				result.scene.updateMatrix();
				result.scene.updateMatrixWorld();

			}

		}

		function get_url( source_url, url_type ) {

			if ( url_type == "relativeToHTML" ) {

				return source_url;

			} else {

				return urlBase + source_url;

			}

		};

		// toplevel loader function, delegates to handle_children

		function handle_objects() {

			handle_children( result.scene, data.objects );

		}

		// handle all the children from the loaded json and attach them to given parent

		function handle_children( parent, children ) {

			var mat, dst, pos, rot, scl, quat;

			for ( var objID in children ) {

				// check by id if child has already been handled,
				// if not, create new object

				var object = result.objects[ objID ];
				var objJSON = children[ objID ];

				if ( object === undefined ) {

					// meshes

					if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {

						if ( objJSON.loading === undefined ) {

							var reservedTypes = {
								"type": 1, "url": 1, "material": 1,
								"position": 1, "rotation": 1, "scale" : 1,
								"visible": 1, "children": 1, "userData": 1,
								"skin": 1, "morph": 1, "mirroredLoop": 1, "duration": 1
							};

							var loaderParameters = {};

							for ( var parType in objJSON ) {

								if ( ! ( parType in reservedTypes ) ) {

									loaderParameters[ parType ] = objJSON[ parType ];

								}

							}

							material = result.materials[ objJSON.material ];

							objJSON.loading = true;

							var loader = scope.hierarchyHandlers[ objJSON.type ][ "loaderObject" ];

							// ColladaLoader

							if ( loader.options ) {

								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ) );

							// UTF8Loader
							// OBJLoader

							} else {

								loader.load( get_url( objJSON.url, data.urlBaseType ), create_callback_hierachy( objID, parent, material, objJSON ), loaderParameters );

							}

						}

					} else if ( objJSON.geometry !== undefined ) {

						geometry = result.geometries[ objJSON.geometry ];

						// geometry already loaded

						if ( geometry ) {

							var needsTangents = false;

							material = result.materials[ objJSON.material ];
							needsTangents = material instanceof THREE.ShaderMaterial;

							pos = objJSON.position;
							rot = objJSON.rotation;
							scl = objJSON.scale;
							mat = objJSON.matrix;
							quat = objJSON.quaternion;

							// use materials from the model file
							// if there is no material specified in the object

							if ( ! objJSON.material ) {

								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

							}

							// use materials from the model file
							// if there is just empty face material
							// (must create new material as each model has its own face material)

							if ( ( material instanceof THREE.MeshFaceMaterial ) && material.materials.length === 0 ) {

								material = new THREE.MeshFaceMaterial( result.face_materials[ objJSON.geometry ] );

							}

							if ( material instanceof THREE.MeshFaceMaterial ) {

								for ( var i = 0; i < material.materials.length; i ++ ) {

									needsTangents = needsTangents || ( material.materials[ i ] instanceof THREE.ShaderMaterial );

								}

							}

							if ( needsTangents ) {

								geometry.computeTangents();

							}

							if ( objJSON.skin ) {

								object = new THREE.SkinnedMesh( geometry, material );

							} else if ( objJSON.morph ) {

								object = new THREE.MorphAnimMesh( geometry, material );

								if ( objJSON.duration !== undefined ) {

									object.duration = objJSON.duration;

								}

								if ( objJSON.time !== undefined ) {

									object.time = objJSON.time;

								}

								if ( objJSON.mirroredLoop !== undefined ) {

									object.mirroredLoop = objJSON.mirroredLoop;

								}

								if ( material.morphNormals ) {

									geometry.computeMorphNormals();

								}

							} else {

								object = new THREE.Mesh( geometry, material );

							}

							object.name = objID;

							if ( mat ) {

								object.matrixAutoUpdate = false;
								object.matrix.set(
									mat[0],  mat[1],  mat[2],  mat[3],
									mat[4],  mat[5],  mat[6],  mat[7],
									mat[8],  mat[9],  mat[10], mat[11],
									mat[12], mat[13], mat[14], mat[15]
								);

							} else {

								object.position.fromArray( pos );

								if ( quat ) {

									object.quaternion.fromArray( quat );

								} else {

									object.rotation.fromArray( rot );

								}

								object.scale.fromArray( scl );

							}

							object.visible = objJSON.visible;
							object.castShadow = objJSON.castShadow;
							object.receiveShadow = objJSON.receiveShadow;

							parent.add( object );

							result.objects[ objID ] = object;

						}

					// lights

					} else if ( objJSON.type === "AmbientLight" || objJSON.type === "PointLight" ||
						objJSON.type === "DirectionalLight" || objJSON.type === "SpotLight" ||
						objJSON.type === "HemisphereLight" || objJSON.type === "AreaLight" ) {

						var color = objJSON.color;
						var intensity = objJSON.intensity;
						var distance = objJSON.distance;
						var position = objJSON.position;
						var rotation = objJSON.rotation;

						switch ( objJSON.type ) {

							case 'AmbientLight':
								light = new THREE.AmbientLight( color );
								break;

							case 'PointLight':
								light = new THREE.PointLight( color, intensity, distance );
								light.position.fromArray( position );
								break;

							case 'DirectionalLight':
								light = new THREE.DirectionalLight( color, intensity );
								light.position.fromArray( objJSON.direction );
								break;

							case 'SpotLight':
								light = new THREE.SpotLight( color, intensity, distance, 1 );
								light.angle = objJSON.angle;
								light.position.fromArray( position );
								light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
								light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
								break;

							case 'HemisphereLight':
								light = new THREE.DirectionalLight( color, intensity, distance );
								light.target.set( position[ 0 ], position[ 1 ] - distance, position[ 2 ] );
								light.target.applyEuler( new THREE.Euler( rotation[ 0 ], rotation[ 1 ], rotation[ 2 ], 'XYZ' ) );
								break;

							case 'AreaLight':
								light = new THREE.AreaLight(color, intensity);
								light.position.fromArray( position );
								light.width = objJSON.size;
								light.height = objJSON.size_y;
								break;

						}

						parent.add( light );

						light.name = objID;
						result.lights[ objID ] = light;
						result.objects[ objID ] = light;

					// cameras

					} else if ( objJSON.type === "PerspectiveCamera" || objJSON.type === "OrthographicCamera" ) {

						pos = objJSON.position;
						rot = objJSON.rotation;
						quat = objJSON.quaternion;

						if ( objJSON.type === "PerspectiveCamera" ) {

							camera = new THREE.PerspectiveCamera( objJSON.fov, objJSON.aspect, objJSON.near, objJSON.far );

						} else if ( objJSON.type === "OrthographicCamera" ) {

							camera = new THREE.OrthographicCamera( objJSON.left, objJSON.right, objJSON.top, objJSON.bottom, objJSON.near, objJSON.far );

						}

						camera.name = objID;
						camera.position.fromArray( pos );

						if ( quat !== undefined ) {

							camera.quaternion.fromArray( quat );

						} else if ( rot !== undefined ) {

							camera.rotation.fromArray( rot );

						}

						parent.add( camera );

						result.cameras[ objID ] = camera;
						result.objects[ objID ] = camera;

					// pure Object3D

					} else {

						pos = objJSON.position;
						rot = objJSON.rotation;
						scl = objJSON.scale;
						quat = objJSON.quaternion;

						object = new THREE.Object3D();
						object.name = objID;
						object.position.fromArray( pos );

						if ( quat ) {

							object.quaternion.fromArray( quat );

						} else {

							object.rotation.fromArray( rot );

						}

						object.scale.fromArray( scl );
						object.visible = ( objJSON.visible !== undefined ) ? objJSON.visible : false;

						parent.add( object );

						result.objects[ objID ] = object;
						result.empties[ objID ] = object;

					}

					if ( object ) {

						if ( objJSON.userData !== undefined ) {

							for ( var key in objJSON.userData ) {

								var value = objJSON.userData[ key ];
								object.userData[ key ] = value;

							}

						}

						if ( objJSON.groups !== undefined ) {

							for ( var i = 0; i < objJSON.groups.length; i ++ ) {

								var groupID = objJSON.groups[ i ];

								if ( result.groups[ groupID ] === undefined ) {

									result.groups[ groupID ] = [];

								}

								result.groups[ groupID ].push( objID );

							}

						}

					}

				}

				if ( object !== undefined && objJSON.children !== undefined ) {

					handle_children( object, objJSON.children );

				}

			}

		};

		function handle_mesh( geo, mat, id ) {

			result.geometries[ id ] = geo;
			result.face_materials[ id ] = mat;
			handle_objects();

		};

		function handle_hierarchy( node, id, parent, material, obj ) {

			var p = obj.position;
			var r = obj.rotation;
			var q = obj.quaternion;
			var s = obj.scale;

			node.position.fromArray( p );

			if ( q ) {

				node.quaternion.fromArray( q );

			} else {

				node.rotation.fromArray( r );

			}

			node.scale.fromArray( s );

			// override children materials
			// if object material was specified in JSON explicitly

			if ( material ) {

				node.traverse( function ( child ) {

					child.material = material;

				} );

			}

			// override children visibility
			// with root node visibility as specified in JSON

			var visible = ( obj.visible !== undefined ) ? obj.visible : true;

			node.traverse( function ( child ) {

				child.visible = visible;

			} );

			parent.add( node );

			node.name = id;

			result.objects[ id ] = node;
			handle_objects();

		};

		function create_callback_geometry( id ) {

			return function ( geo, mat ) {

				geo.name = id;

				handle_mesh( geo, mat, id );

				counter_models -= 1;

				scope.onLoadComplete();

				async_callback_gate();

			}

		};

		function create_callback_hierachy( id, parent, material, obj ) {

			return function ( event ) {

				var result;

				// loaders which use EventDispatcher

				if ( event.content ) {

					result = event.content;

				// ColladaLoader

				} else if ( event.dae ) {

					result = event.scene;


				// UTF8Loader

				} else {

					result = event;

				}

				handle_hierarchy( result, id, parent, material, obj );

				counter_models -= 1;

				scope.onLoadComplete();

				async_callback_gate();

			}

		};

		function create_callback_embed( id ) {

			return function ( geo, mat ) {

				geo.name = id;

				result.geometries[ id ] = geo;
				result.face_materials[ id ] = mat;

			}

		};

		function async_callback_gate() {

			var progress = {

				totalModels : total_models,
				totalTextures : total_textures,
				loadedModels : total_models - counter_models,
				loadedTextures : total_textures - counter_textures

			};

			scope.callbackProgress( progress, result );

			scope.onLoadProgress();

			if ( counter_models === 0 && counter_textures === 0 ) {

				finalize();
				callbackFinished( result );

			}

		};

		function finalize() {

			// take care of targets which could be asynchronously loaded objects

			for ( var i = 0; i < target_array.length; i ++ ) {

				var ta = target_array[ i ];

				var target = result.objects[ ta.targetName ];

				if ( target ) {

					ta.object.target = target;

				} else {

					// if there was error and target of specified name doesn't exist in the scene file
					// create instead dummy target
					// (target must be added to scene explicitly as parent is already added)

					ta.object.target = new THREE.Object3D();
					result.scene.add( ta.object.target );

				}

				ta.object.target.userData.targetInverse = ta.object;

			}

		};

		var callbackTexture = function ( count ) {

			counter_textures -= count;
			async_callback_gate();

			scope.onLoadComplete();

		};

		// must use this instead of just directly calling callbackTexture
		// because of closure in the calling context loop

		var generateTextureCallback = function ( count ) {

			return function () {

				callbackTexture( count );

			};

		};

		function traverse_json_hierarchy( objJSON, callback ) {

			callback( objJSON );

			if ( objJSON.children !== undefined ) {

				for ( var objChildID in objJSON.children ) {

					traverse_json_hierarchy( objJSON.children[ objChildID ], callback );

				}

			}

		};

		// first go synchronous elements

		// fogs

		var fogID, fogJSON;

		for ( fogID in data.fogs ) {

			fogJSON = data.fogs[ fogID ];

			if ( fogJSON.type === "linear" ) {

				fog = new THREE.Fog( 0x000000, fogJSON.near, fogJSON.far );

			} else if ( fogJSON.type === "exp2" ) {

				fog = new THREE.FogExp2( 0x000000, fogJSON.density );

			}

			color = fogJSON.color;
			fog.color.setRGB( color[0], color[1], color[2] );

			result.fogs[ fogID ] = fog;

		}

		// now come potentially asynchronous elements

		// geometries

		// count how many geometries will be loaded asynchronously

		var geoID, geoJSON;

		for ( geoID in data.geometries ) {

			geoJSON = data.geometries[ geoID ];

			if ( geoJSON.type in this.geometryHandlers ) {

				counter_models += 1;

				scope.onLoadStart();

			}

		}

		// count how many hierarchies will be loaded asynchronously

		for ( var objID in data.objects ) {

			traverse_json_hierarchy( data.objects[ objID ], function ( objJSON ) {

				if ( objJSON.type && ( objJSON.type in scope.hierarchyHandlers ) ) {

					counter_models += 1;

					scope.onLoadStart();

				}

			});

		}

		total_models = counter_models;

		for ( geoID in data.geometries ) {

			geoJSON = data.geometries[ geoID ];

			if ( geoJSON.type === "cube" ) {

				geometry = new THREE.BoxGeometry( geoJSON.width, geoJSON.height, geoJSON.depth, geoJSON.widthSegments, geoJSON.heightSegments, geoJSON.depthSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "plane" ) {

				geometry = new THREE.PlaneGeometry( geoJSON.width, geoJSON.height, geoJSON.widthSegments, geoJSON.heightSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "sphere" ) {

				geometry = new THREE.SphereGeometry( geoJSON.radius, geoJSON.widthSegments, geoJSON.heightSegments );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "cylinder" ) {

				geometry = new THREE.CylinderGeometry( geoJSON.topRad, geoJSON.botRad, geoJSON.height, geoJSON.radSegs, geoJSON.heightSegs );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "torus" ) {

				geometry = new THREE.TorusGeometry( geoJSON.radius, geoJSON.tube, geoJSON.segmentsR, geoJSON.segmentsT );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type === "icosahedron" ) {

				geometry = new THREE.IcosahedronGeometry( geoJSON.radius, geoJSON.subdivisions );
				geometry.name = geoID;
				result.geometries[ geoID ] = geometry;

			} else if ( geoJSON.type in this.geometryHandlers ) {

				var loaderParameters = {};

				for ( var parType in geoJSON ) {

					if ( parType !== "type" && parType !== "url" ) {

						loaderParameters[ parType ] = geoJSON[ parType ];

					}

				}

				var loader = this.geometryHandlers[ geoJSON.type ][ "loaderObject" ];
				loader.load( get_url( geoJSON.url, data.urlBaseType ), create_callback_geometry( geoID ), loaderParameters );

			} else if ( geoJSON.type === "embedded" ) {

				var modelJson = data.embeds[ geoJSON.id ],
					texture_path = "";

				// pass metadata along to jsonLoader so it knows the format version

				modelJson.metadata = data.metadata;

				if ( modelJson ) {

					var jsonLoader = this.geometryHandlers[ "ascii" ][ "loaderObject" ];
					var model = jsonLoader.parse( modelJson, texture_path );
					create_callback_embed( geoID )( model.geometry, model.materials );

				}

			}

		}

		// textures

		// count how many textures will be loaded asynchronously

		var textureID, textureJSON;

		for ( textureID in data.textures ) {

			textureJSON = data.textures[ textureID ];

			if ( textureJSON.url instanceof Array ) {

				counter_textures += textureJSON.url.length;

				for( var n = 0; n < textureJSON.url.length; n ++ ) {

					scope.onLoadStart();

				}

			} else {

				counter_textures += 1;

				scope.onLoadStart();

			}

		}

		total_textures = counter_textures;

		for ( textureID in data.textures ) {

			textureJSON = data.textures[ textureID ];

			if ( textureJSON.mapping !== undefined && THREE[ textureJSON.mapping ] !== undefined ) {

				textureJSON.mapping = new THREE[ textureJSON.mapping ]();

			}

			if ( textureJSON.url instanceof Array ) {

				var count = textureJSON.url.length;
				var url_array = [];

				for( var i = 0; i < count; i ++ ) {

					url_array[ i ] = get_url( textureJSON.url[ i ], data.urlBaseType );

				}

				var isCompressed = /\.dds$/i.test( url_array[ 0 ] );

				if ( isCompressed ) {

					texture = THREE.ImageUtils.loadCompressedTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

				} else {

					texture = THREE.ImageUtils.loadTextureCube( url_array, textureJSON.mapping, generateTextureCallback( count ) );

				}

			} else {

				var isCompressed = /\.dds$/i.test( textureJSON.url );
				var fullUrl = get_url( textureJSON.url, data.urlBaseType );
				var textureCallback = generateTextureCallback( 1 );

				if ( isCompressed ) {

					texture = THREE.ImageUtils.loadCompressedTexture( fullUrl, textureJSON.mapping, textureCallback );

				} else {

					texture = THREE.ImageUtils.loadTexture( fullUrl, textureJSON.mapping, textureCallback );

				}

				if ( THREE[ textureJSON.minFilter ] !== undefined )
					texture.minFilter = THREE[ textureJSON.minFilter ];

				if ( THREE[ textureJSON.magFilter ] !== undefined )
					texture.magFilter = THREE[ textureJSON.magFilter ];

				if ( textureJSON.anisotropy ) texture.anisotropy = textureJSON.anisotropy;

				if ( textureJSON.repeat ) {

					texture.repeat.set( textureJSON.repeat[ 0 ], textureJSON.repeat[ 1 ] );

					if ( textureJSON.repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;
					if ( textureJSON.repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;

				}

				if ( textureJSON.offset ) {

					texture.offset.set( textureJSON.offset[ 0 ], textureJSON.offset[ 1 ] );

				}

				// handle wrap after repeat so that default repeat can be overriden

				if ( textureJSON.wrap ) {

					var wrapMap = {
						"repeat": THREE.RepeatWrapping,
						"mirror": THREE.MirroredRepeatWrapping
					}

					if ( wrapMap[ textureJSON.wrap[ 0 ] ] !== undefined ) texture.wrapS = wrapMap[ textureJSON.wrap[ 0 ] ];
					if ( wrapMap[ textureJSON.wrap[ 1 ] ] !== undefined ) texture.wrapT = wrapMap[ textureJSON.wrap[ 1 ] ];

				}

			}

			result.textures[ textureID ] = texture;

		}

		// materials

		var matID, matJSON;
		var parID;

		for ( matID in data.materials ) {

			matJSON = data.materials[ matID ];

			for ( parID in matJSON.parameters ) {

				if ( parID === "envMap" || parID === "map" || parID === "lightMap" || parID === "bumpMap" ) {

					matJSON.parameters[ parID ] = result.textures[ matJSON.parameters[ parID ] ];

				} else if ( parID === "shading" ) {

					matJSON.parameters[ parID ] = ( matJSON.parameters[ parID ] === "flat" ) ? THREE.FlatShading : THREE.SmoothShading;

				} else if ( parID === "side" ) {

					if ( matJSON.parameters[ parID ] == "double" ) {

						matJSON.parameters[ parID ] = THREE.DoubleSide;

					} else if ( matJSON.parameters[ parID ] == "back" ) {

						matJSON.parameters[ parID ] = THREE.BackSide;

					} else {

						matJSON.parameters[ parID ] = THREE.FrontSide;

					}

				} else if ( parID === "blending" ) {

					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.NormalBlending;

				} else if ( parID === "combine" ) {

					matJSON.parameters[ parID ] = matJSON.parameters[ parID ] in THREE ? THREE[ matJSON.parameters[ parID ] ] : THREE.MultiplyOperation;

				} else if ( parID === "vertexColors" ) {

					if ( matJSON.parameters[ parID ] == "face" ) {

						matJSON.parameters[ parID ] = THREE.FaceColors;

					// default to vertex colors if "vertexColors" is anything else face colors or 0 / null / false

					} else if ( matJSON.parameters[ parID ] ) {

						matJSON.parameters[ parID ] = THREE.VertexColors;

					}

				} else if ( parID === "wrapRGB" ) {

					var v3 = matJSON.parameters[ parID ];
					matJSON.parameters[ parID ] = new THREE.Vector3( v3[ 0 ], v3[ 1 ], v3[ 2 ] );

				}

			}

			if ( matJSON.parameters.opacity !== undefined && matJSON.parameters.opacity < 1.0 ) {

				matJSON.parameters.transparent = true;

			}

			if ( matJSON.parameters.normalMap ) {

				var shader = THREE.ShaderLib[ "normalmap" ];
				var uniforms = THREE.UniformsUtils.clone( shader.uniforms );

				var diffuse = matJSON.parameters.color;
				var specular = matJSON.parameters.specular;
				var ambient = matJSON.parameters.ambient;
				var shininess = matJSON.parameters.shininess;

				uniforms[ "tNormal" ].value = result.textures[ matJSON.parameters.normalMap ];

				if ( matJSON.parameters.normalScale ) {

					uniforms[ "uNormalScale" ].value.set( matJSON.parameters.normalScale[ 0 ], matJSON.parameters.normalScale[ 1 ] );

				}

				if ( matJSON.parameters.map ) {

					uniforms[ "tDiffuse" ].value = matJSON.parameters.map;
					uniforms[ "enableDiffuse" ].value = true;

				}

				if ( matJSON.parameters.envMap ) {

					uniforms[ "tCube" ].value = matJSON.parameters.envMap;
					uniforms[ "enableReflection" ].value = true;
					uniforms[ "reflectivity" ].value = matJSON.parameters.reflectivity;

				}

				if ( matJSON.parameters.lightMap ) {

					uniforms[ "tAO" ].value = matJSON.parameters.lightMap;
					uniforms[ "enableAO" ].value = true;

				}

				if ( matJSON.parameters.specularMap ) {

					uniforms[ "tSpecular" ].value = result.textures[ matJSON.parameters.specularMap ];
					uniforms[ "enableSpecular" ].value = true;

				}

				if ( matJSON.parameters.displacementMap ) {

					uniforms[ "tDisplacement" ].value = result.textures[ matJSON.parameters.displacementMap ];
					uniforms[ "enableDisplacement" ].value = true;

					uniforms[ "uDisplacementBias" ].value = matJSON.parameters.displacementBias;
					uniforms[ "uDisplacementScale" ].value = matJSON.parameters.displacementScale;

				}

				uniforms[ "diffuse" ].value.setHex( diffuse );
				uniforms[ "specular" ].value.setHex( specular );
				uniforms[ "ambient" ].value.setHex( ambient );

				uniforms[ "shininess" ].value = shininess;

				if ( matJSON.parameters.opacity ) {

					uniforms[ "opacity" ].value = matJSON.parameters.opacity;

				}

				var parameters = { fragmentShader: shader.fragmentShader, vertexShader: shader.vertexShader, uniforms: uniforms, lights: true, fog: true };

				material = new THREE.ShaderMaterial( parameters );

			} else {

				material = new THREE[ matJSON.type ]( matJSON.parameters );

			}

			material.name = matID;

			result.materials[ matID ] = material;

		}

		// second pass through all materials to initialize MeshFaceMaterials
		// that could be referring to other materials out of order

		for ( matID in data.materials ) {

			matJSON = data.materials[ matID ];

			if ( matJSON.parameters.materials ) {

				var materialArray = [];

				for ( var i = 0; i < matJSON.parameters.materials.length; i ++ ) {

					var label = matJSON.parameters.materials[ i ];
					materialArray.push( result.materials[ label ] );

				}

				result.materials[ matID ].materials = materialArray;

			}

		}

		// objects ( synchronous init of procedural primitives )

		handle_objects();

		// defaults

		if ( result.cameras && data.defaults.camera ) {

			result.currentCamera = result.cameras[ data.defaults.camera ];

		}

		if ( result.fogs && data.defaults.fog ) {

			result.scene.fog = result.fogs[ data.defaults.fog ];

		}

		// synchronous callback

		scope.callbackSync( result );

		// just in case there are no async elements

		async_callback_gate();

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.TextureLoader = function ( manager ) {

	this.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;

};

THREE.TextureLoader.prototype = {

	constructor: THREE.TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new THREE.ImageLoader( scope.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.load( url, function ( image ) {

			var texture = new THREE.Texture( image );
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		} );

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Material = function () {

	this.id = THREE.MaterialIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.side = THREE.FrontSide;

	this.opacity = 1;
	this.transparent = false;

	this.blending = THREE.NormalBlending;

	this.blendSrc = THREE.SrcAlphaFactor;
	this.blendDst = THREE.OneMinusSrcAlphaFactor;
	this.blendEquation = THREE.AddEquation;

	this.depthTest = true;
	this.depthWrite = true;

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this.needsUpdate = true;

};

THREE.Material.prototype = {

	constructor: THREE.Material,

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			if ( key in this ) {

				var currentValue = this[ key ];

				if ( currentValue instanceof THREE.Color ) {

					currentValue.set( newValue );

				} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {

					currentValue.copy( newValue );

				} else if ( key == 'overdraw') {

					// ensure overdraw is backwards-compatable with legacy boolean type
					this[ key ] = Number(newValue);

				} else {

					this[ key ] = newValue;

				}

			}

		}

	},

	clone: function ( material ) {

		if ( material === undefined ) material = new THREE.Material();

		material.name = this.name;

		material.side = this.side;

		material.opacity = this.opacity;
		material.transparent = this.transparent;

		material.blending = this.blending;

		material.blendSrc = this.blendSrc;
		material.blendDst = this.blendDst;
		material.blendEquation = this.blendEquation;

		material.depthTest = this.depthTest;
		material.depthWrite = this.depthWrite;

		material.polygonOffset = this.polygonOffset;
		material.polygonOffsetFactor = this.polygonOffsetFactor;
		material.polygonOffsetUnits = this.polygonOffsetUnits;

		material.alphaTest = this.alphaTest;

		material.overdraw = this.overdraw;

		material.visible = this.visible;

		return material;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Material.prototype );

THREE.MaterialIdCount = 0;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round",
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineBasicMaterial.prototype.clone = function () {

	var material = new THREE.LineBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;
	material.linecap = this.linecap;
	material.linejoin = this.linejoin;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>,
 *
 *  vertexColors: <bool>
 *
 *  fog: <bool>
 * }
 */

THREE.LineDashedMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.LineDashedMaterial.prototype.clone = function () {

	var material = new THREE.LineDashedMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.linewidth = this.linewidth;

	material.scale = this.scale;
	material.dashSize = this.dashSize;
	material.gapSize = this.gapSize;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.MeshBasicMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshBasicMaterial.prototype.clone = function () {

	var material = new THREE.MeshBasicMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshLambertMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshLambertMaterial.prototype.clone = function () {

	var material = new THREE.MeshLambertMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  ambient: <hex>,
 *  emissive: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.MeshPhongMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff ); // diffuse
	this.ambient = new THREE.Color( 0xffffff );
	this.emissive = new THREE.Color( 0x000000 );
	this.specular = new THREE.Color( 0x111111 );
	this.shininess = 30;

	this.metal = false;

	this.wrapAround = false;
	this.wrapRGB = new THREE.Vector3( 1, 1, 1 );

	this.map = null;

	this.lightMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new THREE.Vector2( 1, 1 );

	this.specularMap = null;

	this.envMap = null;
	this.combine = THREE.MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.fog = true;

	this.shading = THREE.SmoothShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.vertexColors = THREE.NoColors;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

};

THREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshPhongMaterial.prototype.clone = function () {

	var material = new THREE.MeshPhongMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.ambient.copy( this.ambient );
	material.emissive.copy( this.emissive );
	material.specular.copy( this.specular );
	material.shininess = this.shininess;

	material.metal = this.metal;

	material.wrapAround = this.wrapAround;
	material.wrapRGB.copy( this.wrapRGB );

	material.map = this.map;

	material.lightMap = this.lightMap;

	material.bumpMap = this.bumpMap;
	material.bumpScale = this.bumpScale;

	material.normalMap = this.normalMap;
	material.normalScale.copy( this.normalScale );

	material.specularMap = this.specularMap;

	material.envMap = this.envMap;
	material.combine = this.combine;
	material.reflectivity = this.reflectivity;
	material.refractionRatio = this.refractionRatio;

	material.fog = this.fog;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;
	material.wireframeLinecap = this.wireframeLinecap;
	material.wireframeLinejoin = this.wireframeLinejoin;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;
	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshDepthMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.setValues( parameters );

};

THREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshDepthMaterial.prototype.clone = function () {

	var material = new THREE.MeshDepthMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  shading: THREE.FlatShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

THREE.MeshNormalMaterial = function ( parameters ) {

	THREE.Material.call( this, parameters );

	this.shading = THREE.FlatShading;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.morphTargets = false;

	this.setValues( parameters );

};

THREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.MeshNormalMaterial.prototype.clone = function () {

	var material = new THREE.MeshNormalMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.MeshFaceMaterial = function ( materials ) {

	this.materials = materials instanceof Array ? materials : [];

};

THREE.MeshFaceMaterial.prototype.clone = function () {

	var material = new THREE.MeshFaceMaterial();

	for ( var i = 0; i < this.materials.length; i ++ ) {

		material.materials.push( this.materials[ i ].clone() );

	}

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  vertexColors: <bool>,
 *
 *  fog: <bool>
 * }
 */

THREE.ParticleSystemMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.vertexColors = false;

	this.fog = true;

	this.setValues( parameters );

};

THREE.ParticleSystemMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ParticleSystemMaterial.prototype.clone = function () {

	var material = new THREE.ParticleSystemMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );

	material.map = this.map;

	material.size = this.size;
	material.sizeAttenuation = this.sizeAttenuation;

	material.vertexColors = this.vertexColors;

	material.fog = this.fog;

	return material;

};

// backwards compatibility

THREE.ParticleBasicMaterial = THREE.ParticleSystemMaterial;

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  uniforms: { "parameter1": { type: "f", value: 1.0 }, "parameter2": { type: "i" value2: 2 } },
 *
 *  defines: { "label" : "value" },
 *
 *  shading: THREE.SmoothShading,
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  vertexColors: THREE.NoColors / THREE.VertexColors / THREE.FaceColors,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *	fog: <bool>
 * }
 */

THREE.ShaderMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.fragmentShader = "void main() {}";
	this.vertexShader = "void main() {}";
	this.uniforms = {};
	this.defines = {};
	this.attributes = null;

	this.shading = THREE.SmoothShading;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog

	this.lights = false; // set to use scene lights

	this.vertexColors = THREE.NoColors; // set to use "color" attribute stream

	this.skinning = false; // set to use skinning attribute streams

	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		"color" : [ 1, 1, 1],
		"uv" : [ 0, 0 ],
		"uv2" : [ 0, 0 ]
	};

	// By default, bind position to attribute index 0. In WebGL, attribute 0
	// should always be used to avoid potentially expensive emulation.
	this.index0AttributeName = "position";

	this.setValues( parameters );

};

THREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.ShaderMaterial.prototype.clone = function () {

	var material = new THREE.ShaderMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.fragmentShader = this.fragmentShader;
	material.vertexShader = this.vertexShader;

	material.uniforms = THREE.UniformsUtils.clone( this.uniforms );

	material.attributes = this.attributes;
	material.defines = this.defines;

	material.shading = this.shading;

	material.wireframe = this.wireframe;
	material.wireframeLinewidth = this.wireframeLinewidth;

	material.fog = this.fog;

	material.lights = this.lights;

	material.vertexColors = this.vertexColors;

	material.skinning = this.skinning;

	material.morphTargets = this.morphTargets;
	material.morphNormals = this.morphNormals;

	return material;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  blending: THREE.NormalBlending,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2(),
 *
 *  fog: <bool>
 * }
 */

THREE.SpriteMaterial = function ( parameters ) {

	THREE.Material.call( this );

	// defaults

	this.color = new THREE.Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;

	// set parameters

	this.setValues( parameters );

};

THREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteMaterial.prototype.clone = function () {

	var material = new THREE.SpriteMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.map = this.map;

	material.rotation = this.rotation;

	material.fog = this.fog;

	return material;

};

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * parameters = {
 *  color: <hex>,
 *  program: <function>,
 *  opacity: <float>,
 *  blending: THREE.NormalBlending
 * }
 */

THREE.SpriteCanvasMaterial = function ( parameters ) {

	THREE.Material.call( this );

	this.color = new THREE.Color( 0xffffff );
	this.program = function ( context, color ) {};

	this.setValues( parameters );

};

THREE.SpriteCanvasMaterial.prototype = Object.create( THREE.Material.prototype );

THREE.SpriteCanvasMaterial.prototype.clone = function () {

	var material = new THREE.SpriteCanvasMaterial();

	THREE.Material.prototype.clone.call( this, material );

	material.color.copy( this.color );
	material.program = this.program;

	return material;

};

// backwards compatibility

THREE.ParticleCanvasMaterial = THREE.SpriteCanvasMaterial;
/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	this.id = THREE.TextureIdCount ++;
	this.uuid = THREE.Math.generateUUID();

	this.name = '';

	this.image = image;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : new THREE.UVMapping();

	this.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : THREE.RGBAFormat;
	this.type = type !== undefined ? type : THREE.UnsignedByteType;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

	this._needsUpdate = false;
	this.onUpdate = null;

};

THREE.Texture.prototype = {

	constructor: THREE.Texture,

	get needsUpdate () {

		return this._needsUpdate;

	},

	set needsUpdate ( value ) {

		if ( value === true ) this.update();

		this._needsUpdate = value;

	},

	clone: function ( texture ) {

		if ( texture === undefined ) texture = new THREE.Texture();

		texture.image = this.image;
		texture.mipmaps = this.mipmaps.slice(0);

		texture.mapping = this.mapping;

		texture.wrapS = this.wrapS;
		texture.wrapT = this.wrapT;

		texture.magFilter = this.magFilter;
		texture.minFilter = this.minFilter;

		texture.anisotropy = this.anisotropy;

		texture.format = this.format;
		texture.type = this.type;

		texture.offset.copy( this.offset );
		texture.repeat.copy( this.repeat );

		texture.generateMipmaps = this.generateMipmaps;
		texture.premultiplyAlpha = this.premultiplyAlpha;
		texture.flipY = this.flipY;
		texture.unpackAlignment = this.unpackAlignment;

		return texture;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.Texture.prototype );

THREE.TextureIdCount = 0;

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	this.generateMipmaps = false; // WebGL currently can't generate mipmaps for compressed textures, they must be embedded in DDS file

};

THREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.CompressedTexture.prototype.clone = function () {

	var texture = new THREE.CompressedTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {

	THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { data: data, width: width, height: height };

};

THREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );

THREE.DataTexture.prototype.clone = function () {

	var texture = new THREE.DataTexture();

	THREE.Texture.prototype.clone.call( this, texture );

	return texture;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ParticleSystem = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.ParticleSystemMaterial( { color: Math.random() * 0xffffff } );

	this.sortParticles = false;
	this.frustumCulled = false;

};

THREE.ParticleSystem.prototype = Object.create( THREE.Object3D.prototype );

THREE.ParticleSystem.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.ParticleSystem( this.geometry, this.material );

	object.sortParticles = this.sortParticles;

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Line = function ( geometry, material, type ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );

	this.type = ( type !== undefined ) ? type : THREE.LineStrip;

};

THREE.LineStrip = 0;
THREE.LinePieces = 1;

THREE.Line.prototype = Object.create( THREE.Object3D.prototype );

THREE.Line.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Line( this.geometry, this.material, this.type );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

THREE.Mesh = function ( geometry, material ) {

	THREE.Object3D.call( this );

	this.geometry = geometry !== undefined ? geometry : new THREE.Geometry();
	this.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.updateMorphTargets();

};

THREE.Mesh.prototype = Object.create( THREE.Object3D.prototype );

THREE.Mesh.prototype.updateMorphTargets = function () {

	if ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {

		this.morphTargetBase = -1;
		this.morphTargetForcedOrder = [];
		this.morphTargetInfluences = [];
		this.morphTargetDictionary = {};

		for ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {

			this.morphTargetInfluences.push( 0 );
			this.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;

		}

	}

};

THREE.Mesh.prototype.getMorphTargetIndexByName = function ( name ) {

	if ( this.morphTargetDictionary[ name ] !== undefined ) {

		return this.morphTargetDictionary[ name ];

	}

	console.log( "THREE.Mesh.getMorphTargetIndexByName: morph target " + name + " does not exist. Returning 0." );

	return 0;

};

THREE.Mesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Mesh( this.geometry, this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Bone = function( belongsToSkin ) {

	THREE.Object3D.call( this );

	this.skin = belongsToSkin;
	this.skinMatrix = new THREE.Matrix4();

};

THREE.Bone.prototype = Object.create( THREE.Object3D.prototype );

THREE.Bone.prototype.update = function ( parentSkinMatrix, forceUpdate ) {

	// update local

	if ( this.matrixAutoUpdate ) {

		forceUpdate |= this.updateMatrix();

	}

	// update skin matrix

	if ( forceUpdate || this.matrixWorldNeedsUpdate ) {

		if( parentSkinMatrix ) {

			this.skinMatrix.multiplyMatrices( parentSkinMatrix, this.matrix );

		} else {

			this.skinMatrix.copy( this.matrix );

		}

		this.matrixWorldNeedsUpdate = false;
		forceUpdate = true;

	}

	// update children

	var child, i, l = this.children.length;

	for ( i = 0; i < l; i ++ ) {

		this.children[ i ].update( this.skinMatrix, forceUpdate );

	}

};


/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {

	THREE.Mesh.call( this, geometry, material );

	//

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	// init bones

	this.identityMatrix = new THREE.Matrix4();

	this.bones = [];
	this.boneMatrices = [];

	var b, bone, gbone, p, q, s;

	if ( this.geometry && this.geometry.bones !== undefined ) {

		for ( b = 0; b < this.geometry.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];

			p = gbone.pos;
			q = gbone.rotq;
			s = gbone.scl;

			bone = this.addBone();

			bone.name = gbone.name;
			bone.position.set( p[0], p[1], p[2] );
			bone.quaternion.set( q[0], q[1], q[2], q[3] );
		
			if ( s !== undefined ) {

				bone.scale.set( s[0], s[1], s[2] );

			} else {

				bone.scale.set( 1, 1, 1 );

			}

		}

		for ( b = 0; b < this.bones.length; b ++ ) {

			gbone = this.geometry.bones[ b ];
			bone = this.bones[ b ];

			if ( gbone.parent === -1 ) {

				this.add( bone );

			} else {

				this.bones[ gbone.parent ].add( bone );

			}

		}

		//

		var nBones = this.bones.length;

		if ( this.useVertexTexture ) {

			// layout (1 matrix = 4 pixels)
			//	RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
			//  with  8x8  pixel texture max   16 bones  (8 * 8  / 4)
			//  	 16x16 pixel texture max   64 bones (16 * 16 / 4)
			//  	 32x32 pixel texture max  256 bones (32 * 32 / 4)
			//  	 64x64 pixel texture max 1024 bones (64 * 64 / 4)

			var size;

			if ( nBones > 256 )
				size = 64;
			else if ( nBones > 64 )
				size = 32;
			else if ( nBones > 16 )
				size = 16;
			else
				size = 8;

			this.boneTextureWidth = size;
			this.boneTextureHeight = size;

			this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
			this.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );
			this.boneTexture.minFilter = THREE.NearestFilter;
			this.boneTexture.magFilter = THREE.NearestFilter;
			this.boneTexture.generateMipmaps = false;
			this.boneTexture.flipY = false;

		} else {

			this.boneMatrices = new Float32Array( 16 * nBones );

		}

		this.pose();

	}

};

THREE.SkinnedMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.SkinnedMesh.prototype.addBone = function( bone ) {

	if ( bone === undefined ) {

		bone = new THREE.Bone( this );

	}

	this.bones.push( bone );

	return bone;

};

THREE.SkinnedMesh.prototype.updateMatrixWorld = function () {

	var offsetMatrix = new THREE.Matrix4();

	return function ( force ) {

		this.matrixAutoUpdate && this.updateMatrix();

		// update matrixWorld

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent ) {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			} else {

				this.matrixWorld.copy( this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];

			if ( child instanceof THREE.Bone ) {

				child.update( this.identityMatrix, false );

			} else {

				child.updateMatrixWorld( true );

			}

		}

		// make a snapshot of the bones' rest position

		if ( this.boneInverses == undefined ) {

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				var inverse = new THREE.Matrix4();

				inverse.getInverse( this.bones[ b ].skinMatrix );

				this.boneInverses.push( inverse );

			}

		}

		// flatten bone matrices to array

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			// compute the offset between the current and the original transform;

			// TODO: we could get rid of this multiplication step if the skinMatrix
			// was already representing the offset; however, this requires some
			// major changes to the animation system

			offsetMatrix.multiplyMatrices( this.bones[ b ].skinMatrix, this.boneInverses[ b ] );
			offsetMatrix.flattenToArrayOffset( this.boneMatrices, b * 16 );

		}

		if ( this.useVertexTexture ) {

			this.boneTexture.needsUpdate = true;

		}

	};

}();

THREE.SkinnedMesh.prototype.pose = function () {

	this.updateMatrixWorld( true );

	this.normalizeSkinWeights();

};

THREE.SkinnedMesh.prototype.normalizeSkinWeights = function () {

	if ( this.geometry instanceof THREE.Geometry ) {

		for ( var i = 0; i < this.geometry.skinIndices.length; i ++ ) {

			var sw = this.geometry.skinWeights[ i ];

			var scale = 1.0 / sw.lengthManhattan();

			if ( scale !== Infinity ) {

				sw.multiplyScalar( scale );

			} else {

				sw.set( 1 ); // this will be normalized by the shader anyway

			}

		}

	} else {

		// skinning weights assumed to be normalized for THREE.BufferGeometry

	}

};

THREE.SkinnedMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) {

		object = new THREE.SkinnedMesh( this.geometry, this.material, this.useVertexTexture );

	}

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphAnimMesh = function ( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	// API

	this.duration = 1000; // milliseconds
	this.mirroredLoop = false;
	this.time = 0;

	// internals

	this.lastKeyframe = 0;
	this.currentKeyframe = 0;

	this.direction = 1;
	this.directionBackwards = false;

	this.setFrameRange( 0, this.geometry.morphTargets.length - 1 );

};

THREE.MorphAnimMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphAnimMesh.prototype.setFrameRange = function ( start, end ) {

	this.startKeyframe = start;
	this.endKeyframe = end;

	this.length = this.endKeyframe - this.startKeyframe + 1;

};

THREE.MorphAnimMesh.prototype.setDirectionForward = function () {

	this.direction = 1;
	this.directionBackwards = false;

};

THREE.MorphAnimMesh.prototype.setDirectionBackward = function () {

	this.direction = -1;
	this.directionBackwards = true;

};

THREE.MorphAnimMesh.prototype.parseAnimations = function () {

	var geometry = this.geometry;

	if ( ! geometry.animations ) geometry.animations = {};

	var firstAnimation, animations = geometry.animations;

	var pattern = /([a-z]+)(\d+)/;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var parts = morph.name.match( pattern );

		if ( parts && parts.length > 1 ) {

			var label = parts[ 1 ];
			var num = parts[ 2 ];

			if ( ! animations[ label ] ) animations[ label ] = { start: Infinity, end: -Infinity };

			var animation = animations[ label ];

			if ( i < animation.start ) animation.start = i;
			if ( i > animation.end ) animation.end = i;

			if ( ! firstAnimation ) firstAnimation = label;

		}

	}

	geometry.firstAnimation = firstAnimation;

};

THREE.MorphAnimMesh.prototype.setAnimationLabel = function ( label, start, end ) {

	if ( ! this.geometry.animations ) this.geometry.animations = {};

	this.geometry.animations[ label ] = { start: start, end: end };

};

THREE.MorphAnimMesh.prototype.playAnimation = function ( label, fps ) {

	var animation = this.geometry.animations[ label ];

	if ( animation ) {

		this.setFrameRange( animation.start, animation.end );
		this.duration = 1000 * ( ( animation.end - animation.start ) / fps );
		this.time = 0;

	} else {

		console.warn( "animation[" + label + "] undefined" );

	}

};

THREE.MorphAnimMesh.prototype.updateAnimation = function ( delta ) {

	var frameTime = this.duration / this.length;

	this.time += this.direction * delta;

	if ( this.mirroredLoop ) {

		if ( this.time > this.duration || this.time < 0 ) {

			this.direction *= -1;

			if ( this.time > this.duration ) {

				this.time = this.duration;
				this.directionBackwards = true;

			}

			if ( this.time < 0 ) {

				this.time = 0;
				this.directionBackwards = false;

			}

		}

	} else {

		this.time = this.time % this.duration;

		if ( this.time < 0 ) this.time += this.duration;

	}

	var keyframe = this.startKeyframe + THREE.Math.clamp( Math.floor( this.time / frameTime ), 0, this.length - 1 );

	if ( keyframe !== this.currentKeyframe ) {

		this.morphTargetInfluences[ this.lastKeyframe ] = 0;
		this.morphTargetInfluences[ this.currentKeyframe ] = 1;

		this.morphTargetInfluences[ keyframe ] = 0;

		this.lastKeyframe = this.currentKeyframe;
		this.currentKeyframe = keyframe;

	}

	var mix = ( this.time % frameTime ) / frameTime;

	if ( this.directionBackwards ) {

		mix = 1 - mix;

	}

	this.morphTargetInfluences[ this.currentKeyframe ] = mix;
	this.morphTargetInfluences[ this.lastKeyframe ] = 1 - mix;

};

THREE.MorphAnimMesh.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.MorphAnimMesh( this.geometry, this.material );

	object.duration = this.duration;
	object.mirroredLoop = this.mirroredLoop;
	object.time = this.time;

	object.lastKeyframe = this.lastKeyframe;
	object.currentKeyframe = this.currentKeyframe;

	object.direction = this.direction;
	object.directionBackwards = this.directionBackwards;

	THREE.Mesh.prototype.clone.call( this, object );

	return object;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.LOD = function () {

	THREE.Object3D.call( this );

	this.objects = [];

};


THREE.LOD.prototype = Object.create( THREE.Object3D.prototype );

THREE.LOD.prototype.addLevel = function ( object, distance ) {

	if ( distance === undefined ) distance = 0;

	distance = Math.abs( distance );

	for ( var l = 0; l < this.objects.length; l ++ ) {

		if ( distance < this.objects[ l ].distance ) {

			break;

		}

	}

	this.objects.splice( l, 0, { distance: distance, object: object } );
	this.add( object );

};

THREE.LOD.prototype.getObjectForDistance = function ( distance ) {

	for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

		if ( distance < this.objects[ i ].distance ) {

			break;

		}

	}

	return this.objects[ i - 1 ].object;

};

THREE.LOD.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();

	return function ( camera ) {

		if ( this.objects.length > 1 ) {

			v1.setFromMatrixPosition( camera.matrixWorld );
			v2.setFromMatrixPosition( this.matrixWorld );

			var distance = v1.distanceTo( v2 );

			this.objects[ 0 ].object.visible = true;

			for ( var i = 1, l = this.objects.length; i < l; i ++ ) {

				if ( distance >= this.objects[ i ].distance ) {

					this.objects[ i - 1 ].object.visible = false;
					this.objects[ i     ].object.visible = true;

				} else {

					break;

				}

			}

			for( ; i < l; i ++ ) {

				this.objects[ i ].object.visible = false;

			}

		}

	};

}();

THREE.LOD.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.LOD();

	THREE.Object3D.prototype.clone.call( this, object );

	for ( var i = 0, l = this.objects.length; i < l; i ++ ) {
		var x = this.objects[i].object.clone();
		x.visible = i === 0;
		object.addLevel( x, this.objects[i].distance );
	}

	return object;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Sprite = ( function () {

	var geometry = new THREE.Geometry2( 3 );
	geometry.vertices.set( [ - 0.5, - 0.5, 0, 0.5, - 0.5, 0, 0.5, 0.5, 0 ] );

	return function ( material ) {

		THREE.Object3D.call( this );

		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();

	};

} )();

THREE.Sprite.prototype = Object.create( THREE.Object3D.prototype );

/*
 * Custom update matrix
 */

THREE.Sprite.prototype.updateMatrix = function () {

	this.matrix.compose( this.position, this.quaternion, this.scale );

	this.matrixWorldNeedsUpdate = true;

};

THREE.Sprite.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Sprite( this.material );

	THREE.Object3D.prototype.clone.call( this, object );

	return object;

};

// Backwards compatibility

THREE.Particle = THREE.Sprite;
/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.Scene = function () {

	THREE.Object3D.call( this );

	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer
	this.matrixAutoUpdate = false;

	this.__lights = [];

	this.__objectsAdded = [];
	this.__objectsRemoved = [];

};

THREE.Scene.prototype = Object.create( THREE.Object3D.prototype );

THREE.Scene.prototype.__addObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		if ( this.__lights.indexOf( object ) === - 1 ) {

			this.__lights.push( object );

		}

		if ( object.target && object.target.parent === undefined ) {

			this.add( object.target );

		}

	} else if ( !( object instanceof THREE.Camera || object instanceof THREE.Bone ) ) {

		this.__objectsAdded.push( object );

		// check if previously removed

		var i = this.__objectsRemoved.indexOf( object );

		if ( i !== -1 ) {

			this.__objectsRemoved.splice( i, 1 );

		}

	}

	this.dispatchEvent( { type: 'objectAdded', object: object } );
	object.dispatchEvent( { type: 'addedToScene', scene: this } );

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.__addObject( object.children[ c ] );

	}

};

THREE.Scene.prototype.__removeObject = function ( object ) {

	if ( object instanceof THREE.Light ) {

		var i = this.__lights.indexOf( object );

		if ( i !== -1 ) {

			this.__lights.splice( i, 1 );

		}

		if ( object.shadowCascadeArray ) {

			for ( var x = 0; x < object.shadowCascadeArray.length; x ++ ) {

				this.__removeObject( object.shadowCascadeArray[ x ] );

			}

		}

	} else if ( !( object instanceof THREE.Camera ) ) {

		this.__objectsRemoved.push( object );

		// check if previously added

		var i = this.__objectsAdded.indexOf( object );

		if ( i !== -1 ) {

			this.__objectsAdded.splice( i, 1 );

		}

	}

	this.dispatchEvent( { type: 'objectRemoved', object: object } );
	object.dispatchEvent( { type: 'removedFromScene', scene: this } );

	for ( var c = 0; c < object.children.length; c ++ ) {

		this.__removeObject( object.children[ c ] );

	}

};

THREE.Scene.prototype.clone = function ( object ) {

	if ( object === undefined ) object = new THREE.Scene();

	THREE.Object3D.prototype.clone.call(this, object);

	if ( this.fog !== null ) object.fog = this.fog.clone();
	if ( this.overrideMaterial !== null ) object.overrideMaterial = this.overrideMaterial.clone();

	object.autoUpdate = this.autoUpdate;
	object.matrixAutoUpdate = this.matrixAutoUpdate;

	return object;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Fog = function ( color, near, far ) {

	this.name = '';

	this.color = new THREE.Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

};

THREE.Fog.prototype.clone = function () {

	return new THREE.Fog( this.color.getHex(), this.near, this.far );

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.FogExp2 = function ( color, density ) {

	this.name = '';

	this.color = new THREE.Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

};

THREE.FogExp2.prototype.clone = function () {

	return new THREE.FogExp2( this.color.getHex(), this.density );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CanvasRenderer = function ( parameters ) {

	console.log( 'THREE.CanvasRenderer', THREE.REVISION );

	var smoothstep = THREE.Math.smoothstep;

	parameters = parameters || {};

	var _this = this,
	_renderData, _elements, _lights,
	_projector = new THREE.Projector(),

	_canvas = parameters.canvas !== undefined
			? parameters.canvas
			: document.createElement( 'canvas' ),

	_canvasWidth = _canvas.width,
	_canvasHeight = _canvas.height,
	_canvasWidthHalf = Math.floor( _canvasWidth / 2 ),
	_canvasHeightHalf = Math.floor( _canvasHeight / 2 ),
	
	_context = _canvas.getContext( '2d', {
		alpha: parameters.alpha === true
	} ),

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0,

	_contextGlobalAlpha = 1,
	_contextGlobalCompositeOperation = 0,
	_contextStrokeStyle = null,
	_contextFillStyle = null,
	_contextLineWidth = null,
	_contextLineCap = null,
	_contextLineJoin = null,
	_contextDashSize = null,
	_contextGapSize = 0,

	_camera,

	_v1, _v2, _v3, _v4,
	_v5 = new THREE.RenderableVertex(),
	_v6 = new THREE.RenderableVertex(),

	_v1x, _v1y, _v2x, _v2y, _v3x, _v3y,
	_v4x, _v4y, _v5x, _v5y, _v6x, _v6y,

	_color = new THREE.Color(),
	_color1 = new THREE.Color(),
	_color2 = new THREE.Color(),
	_color3 = new THREE.Color(),
	_color4 = new THREE.Color(),

	_diffuseColor = new THREE.Color(),
	_emissiveColor = new THREE.Color(),

	_lightColor = new THREE.Color(),

	_patterns = {},

	_near, _far,

	_image, _uvs,
	_uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y,

	_clipBox = new THREE.Box2(),
	_clearBox = new THREE.Box2(),
	_elemBox = new THREE.Box2(),

	_ambientLight = new THREE.Color(),
	_directionalLights = new THREE.Color(),
	_pointLights = new THREE.Color(),

	_vector3 = new THREE.Vector3(), // Needed for PointLight
	_normal = new THREE.Vector3(),
	_normalViewMatrix = new THREE.Matrix3(),

	_pixelMap, _pixelMapContext, _pixelMapImage, _pixelMapData,
	_gradientMap, _gradientMapContext, _gradientMapQuality = 16;

	_pixelMap = document.createElement( 'canvas' );
	_pixelMap.width = _pixelMap.height = 2;

	_pixelMapContext = _pixelMap.getContext( '2d' );
	_pixelMapContext.fillStyle = 'rgba(0,0,0,1)';
	_pixelMapContext.fillRect( 0, 0, 2, 2 );

	_pixelMapImage = _pixelMapContext.getImageData( 0, 0, 2, 2 );
	_pixelMapData = _pixelMapImage.data;

	_gradientMap = document.createElement( 'canvas' );
	_gradientMap.width = _gradientMap.height = _gradientMapQuality;

	_gradientMapContext = _gradientMap.getContext( '2d' );
	_gradientMapContext.translate( - _gradientMapQuality / 2, - _gradientMapQuality / 2 );
	_gradientMapContext.scale( _gradientMapQuality, _gradientMapQuality );

	_gradientMapQuality --; // Fix UVs

	// dash+gap fallbacks for Firefox and everything else

	if ( _context.setLineDash === undefined ) {

		if ( _context.mozDash !== undefined ) {

			_context.setLineDash = function ( values ) {

				_context.mozDash = values[ 0 ] !== null ? values : null;

			}

		} else {

			_context.setLineDash = function () {}

		}

	}

	this.domElement = _canvas;

	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				? parameters.devicePixelRatio
				: self.devicePixelRatio !== undefined
					? self.devicePixelRatio
					: 1;

	this.autoClear = true;
	this.sortObjects = true;
	this.sortElements = true;

	this.info = {

		render: {

			vertices: 0,
			faces: 0

		}

	}

	// WebGLRenderer compatibility

	this.supportsVertexTextures = function () {};
	this.setFaceCulling = function () {};

	this.setSize = function ( width, height, updateStyle ) {

		_canvasWidth = width * this.devicePixelRatio;
		_canvasHeight = height * this.devicePixelRatio;

		_canvasWidthHalf = Math.floor( _canvasWidth / 2 );
		_canvasHeightHalf = Math.floor( _canvasHeight / 2 );

		_canvas.width = _canvasWidth;
		_canvas.height = _canvasHeight;

		if ( this.devicePixelRatio !== 1 && updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		_clipBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf ),
		_clipBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );

		_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );
		_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );

		_contextGlobalAlpha = 1;
		_contextGlobalCompositeOperation = 0;
		_contextStrokeStyle = null;
		_contextFillStyle = null;
		_contextLineWidth = null;
		_contextLineCap = null;
		_contextLineJoin = null;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_clearBox.min.set( - _canvasWidthHalf, - _canvasHeightHalf );
		_clearBox.max.set(   _canvasWidthHalf,   _canvasHeightHalf );

	};

	this.setClearColorHex = function ( hex, alpha ) {

		console.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getMaxAnisotropy = function () {

		return 0;

	};

	this.clear = function () {

		_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		if ( _clearBox.empty() === false ) {

			_clearBox.intersect( _clipBox );
			_clearBox.expandByScalar( 2 );

			if ( _clearAlpha < 1 ) {

				_context.clearRect(
					_clearBox.min.x | 0,
					_clearBox.min.y | 0,
					( _clearBox.max.x - _clearBox.min.x ) | 0,
					( _clearBox.max.y - _clearBox.min.y ) | 0
				);

			}

			if ( _clearAlpha > 0 ) {

				setBlending( THREE.NormalBlending );
				setOpacity( 1 );

				setFillStyle( 'rgba(' + Math.floor( _clearColor.r * 255 ) + ',' + Math.floor( _clearColor.g * 255 ) + ',' + Math.floor( _clearColor.b * 255 ) + ',' + _clearAlpha + ')' );

				_context.fillRect(
					_clearBox.min.x | 0,
					_clearBox.min.y | 0,
					( _clearBox.max.x - _clearBox.min.x ) | 0,
					( _clearBox.max.y - _clearBox.min.y ) | 0
				);

			}

			_clearBox.makeEmpty();

		}

	};

	// compatibility

	this.clearColor = function () {};
	this.clearDepth = function () {};
	this.clearStencil = function () {};

	this.render = function ( scene, camera ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( this.autoClear === true ) this.clear();

		_context.setTransform( 1, 0, 0, - 1, _canvasWidthHalf, _canvasHeightHalf );

		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;

		_renderData = _projector.projectScene( scene, camera, this.sortObjects, this.sortElements );
		_elements = _renderData.elements;
		_lights = _renderData.lights;
		_camera = camera;

		_normalViewMatrix.getNormalMatrix( camera.matrixWorldInverse );

		/* DEBUG
		setFillStyle( 'rgba( 0, 255, 255, 0.5 )' );
		_context.fillRect( _clipBox.min.x, _clipBox.min.y, _clipBox.max.x - _clipBox.min.x, _clipBox.max.y - _clipBox.min.y );
		*/

		calculateLights();

		for ( var e = 0, el = _elements.length; e < el; e ++ ) {

			var element = _elements[ e ];

			var material = element.material;

			if ( material === undefined || material.visible === false ) continue;

			_elemBox.makeEmpty();

			if ( element instanceof THREE.RenderableSprite ) {

				_v1 = element;
				_v1.x *= _canvasWidthHalf; _v1.y *= _canvasHeightHalf;

				renderSprite( _v1, element, material );

			} else if ( element instanceof THREE.RenderableLine ) {

				_v1 = element.v1; _v2 = element.v2;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;

				_elemBox.setFromPoints( [
					_v1.positionScreen,
					_v2.positionScreen
				] );

				if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {

					renderLine( _v1, _v2, element, material );

				}

			} else if ( element instanceof THREE.RenderableFace ) {

				_v1 = element.v1; _v2 = element.v2; _v3 = element.v3;

				if ( _v1.positionScreen.z < -1 || _v1.positionScreen.z > 1 ) continue;
				if ( _v2.positionScreen.z < -1 || _v2.positionScreen.z > 1 ) continue;
				if ( _v3.positionScreen.z < -1 || _v3.positionScreen.z > 1 ) continue;

				_v1.positionScreen.x *= _canvasWidthHalf; _v1.positionScreen.y *= _canvasHeightHalf;
				_v2.positionScreen.x *= _canvasWidthHalf; _v2.positionScreen.y *= _canvasHeightHalf;
				_v3.positionScreen.x *= _canvasWidthHalf; _v3.positionScreen.y *= _canvasHeightHalf;

				if ( material.overdraw > 0 ) {

					expand( _v1.positionScreen, _v2.positionScreen, material.overdraw );
					expand( _v2.positionScreen, _v3.positionScreen, material.overdraw );
					expand( _v3.positionScreen, _v1.positionScreen, material.overdraw );

				}

				_elemBox.setFromPoints( [
					_v1.positionScreen,
					_v2.positionScreen,
					_v3.positionScreen
				] );

				if ( _clipBox.isIntersectionBox( _elemBox ) === true ) {

					renderFace3( _v1, _v2, _v3, 0, 1, 2, element, material );

				}

			}

			/* DEBUG
			setLineWidth( 1 );
			setStrokeStyle( 'rgba( 0, 255, 0, 0.5 )' );
			_context.strokeRect( _elemBox.min.x, _elemBox.min.y, _elemBox.max.x - _elemBox.min.x, _elemBox.max.y - _elemBox.min.y );
			*/

			_clearBox.union( _elemBox );

		}

		/* DEBUG
		setLineWidth( 1 );
		setStrokeStyle( 'rgba( 255, 0, 0, 0.5 )' );
		_context.strokeRect( _clearBox.min.x, _clearBox.min.y, _clearBox.max.x - _clearBox.min.x, _clearBox.max.y - _clearBox.min.y );
		*/

		_context.setTransform( 1, 0, 0, 1, 0, 0 );

	};

	//

	function calculateLights() {

		_ambientLight.setRGB( 0, 0, 0 );
		_directionalLights.setRGB( 0, 0, 0 );
		_pointLights.setRGB( 0, 0, 0 );

		for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

			var light = _lights[ l ];
			var lightColor = light.color;

			if ( light instanceof THREE.AmbientLight ) {

				_ambientLight.add( lightColor );

			} else if ( light instanceof THREE.DirectionalLight ) {

				// for sprites

				_directionalLights.add( lightColor );

			} else if ( light instanceof THREE.PointLight ) {

				// for sprites

				_pointLights.add( lightColor );

			}

		}

	}

	function calculateLight( position, normal, color ) {

		for ( var l = 0, ll = _lights.length; l < ll; l ++ ) {

			var light = _lights[ l ];

			_lightColor.copy( light.color );

			if ( light instanceof THREE.DirectionalLight ) {

				var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld ).normalize();

				var amount = normal.dot( lightPosition );

				if ( amount <= 0 ) continue;

				amount *= light.intensity;

				color.add( _lightColor.multiplyScalar( amount ) );

			} else if ( light instanceof THREE.PointLight ) {

				var lightPosition = _vector3.setFromMatrixPosition( light.matrixWorld );

				var amount = normal.dot( _vector3.subVectors( lightPosition, position ).normalize() );

				if ( amount <= 0 ) continue;

				amount *= light.distance == 0 ? 1 : 1 - Math.min( position.distanceTo( lightPosition ) / light.distance, 1 );

				if ( amount == 0 ) continue;

				amount *= light.intensity;

				color.add( _lightColor.multiplyScalar( amount ) );

			}

		}

	}

	function renderSprite( v1, element, material ) {

		setOpacity( material.opacity );
		setBlending( material.blending );

		var scaleX = element.scale.x * _canvasWidthHalf;
		var scaleY = element.scale.y * _canvasHeightHalf;

		var dist = 0.5 * Math.sqrt( scaleX * scaleX + scaleY * scaleY ); // allow for rotated sprite
		_elemBox.min.set( v1.x - dist, v1.y - dist );
		_elemBox.max.set( v1.x + dist, v1.y + dist );

		if ( material instanceof THREE.SpriteMaterial ||
			 material instanceof THREE.ParticleSystemMaterial ) { // Backwards compatibility

			var texture = material.map;

			if ( texture !== null ) {

				if ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {

					if ( texture.image !== undefined && texture.image.width > 0 ) {

						textureToPattern( texture );

					}

					texture.addEventListener( 'update', onTextureUpdate );

				}

				var pattern = _patterns[ texture.id ];

				if ( pattern !== undefined ) {

					setFillStyle( pattern );

				} else {

					setFillStyle( 'rgba( 0, 0, 0, 1 )' );

				}

				//

				var bitmap = texture.image;

				var ox = bitmap.width * texture.offset.x;
				var oy = bitmap.height * texture.offset.y;

				var sx = bitmap.width * texture.repeat.x;
				var sy = bitmap.height * texture.repeat.y;

				var cx = scaleX / sx;
				var cy = scaleY / sy;

				_context.save();
				_context.translate( v1.x, v1.y );
				if ( material.rotation !== 0 ) _context.rotate( material.rotation );
				_context.translate( - scaleX / 2, - scaleY / 2 );
				_context.scale( cx, cy );
				_context.translate( - ox, - oy );
				_context.fillRect( ox, oy, sx, sy );
				_context.restore();

			} else { // no texture

				setFillStyle( material.color.getStyle() );

				_context.save();
				_context.translate( v1.x, v1.y );
				if ( material.rotation !== 0 ) _context.rotate( material.rotation );
				_context.scale( scaleX, - scaleY );
				_context.fillRect( - 0.5, - 0.5, 1, 1 );
				_context.restore();

			}

		} else if ( material instanceof THREE.SpriteCanvasMaterial ) {

			setStrokeStyle( material.color.getStyle() );
			setFillStyle( material.color.getStyle() );

			_context.save();
			_context.translate( v1.x, v1.y );
			if ( material.rotation !== 0 ) _context.rotate( material.rotation );
			_context.scale( scaleX, scaleY );

			material.program( _context );

			_context.restore();

		}

		/* DEBUG
		setStrokeStyle( 'rgb(255,255,0)' );
		_context.beginPath();
		_context.moveTo( v1.x - 10, v1.y );
		_context.lineTo( v1.x + 10, v1.y );
		_context.moveTo( v1.x, v1.y - 10 );
		_context.lineTo( v1.x, v1.y + 10 );
		_context.stroke();
		*/

	}

	function renderLine( v1, v2, element, material ) {

		setOpacity( material.opacity );
		setBlending( material.blending );

		_context.beginPath();
		_context.moveTo( v1.positionScreen.x, v1.positionScreen.y );
		_context.lineTo( v2.positionScreen.x, v2.positionScreen.y );

		if ( material instanceof THREE.LineBasicMaterial ) {

			setLineWidth( material.linewidth );
			setLineCap( material.linecap );
			setLineJoin( material.linejoin );

			if ( material.vertexColors !== THREE.VertexColors ) {

				setStrokeStyle( material.color.getStyle() );

			} else {

				var colorStyle1 = element.vertexColors[0].getStyle();
				var colorStyle2 = element.vertexColors[1].getStyle();

				if ( colorStyle1 === colorStyle2 ) {

					setStrokeStyle( colorStyle1 );

				} else {

					try {

						var grad = _context.createLinearGradient(
							v1.positionScreen.x,
							v1.positionScreen.y,
							v2.positionScreen.x,
							v2.positionScreen.y
						);
						grad.addColorStop( 0, colorStyle1 );
						grad.addColorStop( 1, colorStyle2 );

					} catch ( exception ) {

						grad = colorStyle1;

					}

					setStrokeStyle( grad );

				}

			}

			_context.stroke();
			_elemBox.expandByScalar( material.linewidth * 2 );

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			setLineWidth( material.linewidth );
			setLineCap( material.linecap );
			setLineJoin( material.linejoin );
			setStrokeStyle( material.color.getStyle() );
			setDashAndGap( material.dashSize, material.gapSize );

			_context.stroke();

			_elemBox.expandByScalar( material.linewidth * 2 );

			setDashAndGap( null, null );

		}

	}

	function renderFace3( v1, v2, v3, uv1, uv2, uv3, element, material ) {

		_this.info.render.vertices += 3;
		_this.info.render.faces ++;

		setOpacity( material.opacity );
		setBlending( material.blending );

		_v1x = v1.positionScreen.x; _v1y = v1.positionScreen.y;
		_v2x = v2.positionScreen.x; _v2y = v2.positionScreen.y;
		_v3x = v3.positionScreen.x; _v3y = v3.positionScreen.y;

		drawTriangle( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y );

		if ( ( material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) && material.map === null ) {

			_diffuseColor.copy( material.color );
			_emissiveColor.copy( material.emissive );

			if ( material.vertexColors === THREE.FaceColors ) {

				_diffuseColor.multiply( element.color );

			}

			if ( material.wireframe === false && material.shading === THREE.SmoothShading && element.vertexNormalsLength === 3 ) {

				_color1.copy( _ambientLight );
				_color2.copy( _ambientLight );
				_color3.copy( _ambientLight );

				calculateLight( element.v1.positionWorld, element.vertexNormalsModel[ 0 ], _color1 );
				calculateLight( element.v2.positionWorld, element.vertexNormalsModel[ 1 ], _color2 );
				calculateLight( element.v3.positionWorld, element.vertexNormalsModel[ 2 ], _color3 );

				_color1.multiply( _diffuseColor ).add( _emissiveColor );
				_color2.multiply( _diffuseColor ).add( _emissiveColor );
				_color3.multiply( _diffuseColor ).add( _emissiveColor );
				_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

			} else {

				_color.copy( _ambientLight );

				calculateLight( element.centroidModel, element.normalModel, _color );

				_color.multiply( _diffuseColor ).add( _emissiveColor );

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			}

		} else if ( material instanceof THREE.MeshBasicMaterial || material instanceof THREE.MeshLambertMaterial || material instanceof THREE.MeshPhongMaterial ) {

			if ( material.map !== null ) {

				if ( material.map.mapping instanceof THREE.UVMapping ) {

					_uvs = element.uvs[ 0 ];
					patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uvs[ uv1 ].x, _uvs[ uv1 ].y, _uvs[ uv2 ].x, _uvs[ uv2 ].y, _uvs[ uv3 ].x, _uvs[ uv3 ].y, material.map );

				}


			} else if ( material.envMap !== null ) {

				if ( material.envMap.mapping instanceof THREE.SphericalReflectionMapping ) {

					_normal.copy( element.vertexNormalsModel[ uv1 ] ).applyMatrix3( _normalViewMatrix );
					_uv1x = 0.5 * _normal.x + 0.5;
					_uv1y = 0.5 * _normal.y + 0.5;

					_normal.copy( element.vertexNormalsModel[ uv2 ] ).applyMatrix3( _normalViewMatrix );
					_uv2x = 0.5 * _normal.x + 0.5;
					_uv2y = 0.5 * _normal.y + 0.5;

					_normal.copy( element.vertexNormalsModel[ uv3 ] ).applyMatrix3( _normalViewMatrix );
					_uv3x = 0.5 * _normal.x + 0.5;
					_uv3y = 0.5 * _normal.y + 0.5;

					patternPath( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, _uv1x, _uv1y, _uv2x, _uv2y, _uv3x, _uv3y, material.envMap );

				}/* else if ( material.envMap.mapping === THREE.SphericalRefractionMapping ) {



				}*/


			} else {

				_color.copy( material.color );

				if ( material.vertexColors === THREE.FaceColors ) {

					_color.multiply( element.color );

				}

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			}

		} else if ( material instanceof THREE.MeshDepthMaterial ) {

			_near = _camera.near;
			_far = _camera.far;

			_color1.r = _color1.g = _color1.b = 1 - smoothstep( v1.positionScreen.z * v1.positionScreen.w, _near, _far );
			_color2.r = _color2.g = _color2.b = 1 - smoothstep( v2.positionScreen.z * v2.positionScreen.w, _near, _far );
			_color3.r = _color3.g = _color3.b = 1 - smoothstep( v3.positionScreen.z * v3.positionScreen.w, _near, _far );
			_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

			_image = getGradientTexture( _color1, _color2, _color3, _color4 );

			clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			if ( material.shading === THREE.FlatShading ) {

				_normal.copy( element.normalModel ).applyMatrix3( _normalViewMatrix );

				_color.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				material.wireframe === true
					? strokePath( _color, material.wireframeLinewidth, material.wireframeLinecap, material.wireframeLinejoin )
					: fillPath( _color );

			} else if ( material.shading === THREE.SmoothShading ) {

				_normal.copy( element.vertexNormalsModel[ uv1 ] ).applyMatrix3( _normalViewMatrix );
				_color1.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				_normal.copy( element.vertexNormalsModel[ uv2 ] ).applyMatrix3( _normalViewMatrix );
				_color2.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				_normal.copy( element.vertexNormalsModel[ uv3 ] ).applyMatrix3( _normalViewMatrix );
				_color3.setRGB( _normal.x, _normal.y, _normal.z ).multiplyScalar( 0.5 ).addScalar( 0.5 );

				_color4.addColors( _color2, _color3 ).multiplyScalar( 0.5 );

				_image = getGradientTexture( _color1, _color2, _color3, _color4 );

				clipImage( _v1x, _v1y, _v2x, _v2y, _v3x, _v3y, 0, 0, 1, 0, 0, 1, _image );

			}

		}

	}

	//

	function drawTriangle( x0, y0, x1, y1, x2, y2 ) {

		_context.beginPath();
		_context.moveTo( x0, y0 );
		_context.lineTo( x1, y1 );
		_context.lineTo( x2, y2 );
		_context.closePath();

	}

	function strokePath( color, linewidth, linecap, linejoin ) {

		setLineWidth( linewidth );
		setLineCap( linecap );
		setLineJoin( linejoin );
		setStrokeStyle( color.getStyle() );

		_context.stroke();

		_elemBox.expandByScalar( linewidth * 2 );

	}

	function fillPath( color ) {

		setFillStyle( color.getStyle() );
		_context.fill();

	}

	function onTextureUpdate ( event ) {

		textureToPattern( event.target );

	}

	function textureToPattern( texture ) {

		var repeatX = texture.wrapS === THREE.RepeatWrapping;
		var repeatY = texture.wrapT === THREE.RepeatWrapping;

		var image = texture.image;

		var canvas = document.createElement( 'canvas' );
		canvas.width = image.width;
		canvas.height = image.height;

		var context = canvas.getContext( '2d' );
		context.setTransform( 1, 0, 0, - 1, 0, image.height );
		context.drawImage( image, 0, 0 );

		_patterns[ texture.id ] = _context.createPattern(
			canvas, repeatX === true && repeatY === true
				? 'repeat'
				: repeatX === true && repeatY === false
					? 'repeat-x'
					: repeatX === false && repeatY === true
						? 'repeat-y'
						: 'no-repeat'
		);

	}

	function patternPath( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, texture ) {

		if ( texture instanceof THREE.DataTexture ) return;

		if ( texture.hasEventListener( 'update', onTextureUpdate ) === false ) {

			if ( texture.image !== undefined && texture.image.width > 0 ) {

				textureToPattern( texture );

			}

			texture.addEventListener( 'update', onTextureUpdate );

		}

		var pattern = _patterns[ texture.id ];

		if ( pattern !== undefined ) {

			setFillStyle( pattern );

		} else {

			setFillStyle( 'rgba(0,0,0,1)' );
			_context.fill();

			return;

		}	

		// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

		var a, b, c, d, e, f, det, idet,
		offsetX = texture.offset.x / texture.repeat.x,
		offsetY = texture.offset.y / texture.repeat.y,
		width = texture.image.width * texture.repeat.x,
		height = texture.image.height * texture.repeat.y;

		u0 = ( u0 + offsetX ) * width;
		v0 = ( v0 + offsetY ) * height;

		u1 = ( u1 + offsetX ) * width;
		v1 = ( v1 + offsetY ) * height;

		u2 = ( u2 + offsetX ) * width;
		v2 = ( v2 + offsetY ) * height;

		x1 -= x0; y1 -= y0;
		x2 -= x0; y2 -= y0;

		u1 -= u0; v1 -= v0;
		u2 -= u0; v2 -= v0;

		det = u1 * v2 - u2 * v1;

		if ( det === 0 ) return;

		idet = 1 / det;

		a = ( v2 * x1 - v1 * x2 ) * idet;
		b = ( v2 * y1 - v1 * y2 ) * idet;
		c = ( u1 * x2 - u2 * x1 ) * idet;
		d = ( u1 * y2 - u2 * y1 ) * idet;

		e = x0 - a * u0 - c * v0;
		f = y0 - b * u0 - d * v0;

		_context.save();
		_context.transform( a, b, c, d, e, f );
		_context.fill();
		_context.restore();

	}

	function clipImage( x0, y0, x1, y1, x2, y2, u0, v0, u1, v1, u2, v2, image ) {

		// http://extremelysatisfactorytotalitarianism.com/blog/?p=2120

		var a, b, c, d, e, f, det, idet,
		width = image.width - 1,
		height = image.height - 1;

		u0 *= width; v0 *= height;
		u1 *= width; v1 *= height;
		u2 *= width; v2 *= height;

		x1 -= x0; y1 -= y0;
		x2 -= x0; y2 -= y0;

		u1 -= u0; v1 -= v0;
		u2 -= u0; v2 -= v0;

		det = u1 * v2 - u2 * v1;

		idet = 1 / det;

		a = ( v2 * x1 - v1 * x2 ) * idet;
		b = ( v2 * y1 - v1 * y2 ) * idet;
		c = ( u1 * x2 - u2 * x1 ) * idet;
		d = ( u1 * y2 - u2 * y1 ) * idet;

		e = x0 - a * u0 - c * v0;
		f = y0 - b * u0 - d * v0;

		_context.save();
		_context.transform( a, b, c, d, e, f );
		_context.clip();
		_context.drawImage( image, 0, 0 );
		_context.restore();

	}

	function getGradientTexture( color1, color2, color3, color4 ) {

		// http://mrdoob.com/blog/post/710

		_pixelMapData[ 0 ] = ( color1.r * 255 ) | 0;
		_pixelMapData[ 1 ] = ( color1.g * 255 ) | 0;
		_pixelMapData[ 2 ] = ( color1.b * 255 ) | 0;

		_pixelMapData[ 4 ] = ( color2.r * 255 ) | 0;
		_pixelMapData[ 5 ] = ( color2.g * 255 ) | 0;
		_pixelMapData[ 6 ] = ( color2.b * 255 ) | 0;

		_pixelMapData[ 8 ] = ( color3.r * 255 ) | 0;
		_pixelMapData[ 9 ] = ( color3.g * 255 ) | 0;
		_pixelMapData[ 10 ] = ( color3.b * 255 ) | 0;

		_pixelMapData[ 12 ] = ( color4.r * 255 ) | 0;
		_pixelMapData[ 13 ] = ( color4.g * 255 ) | 0;
		_pixelMapData[ 14 ] = ( color4.b * 255 ) | 0;

		_pixelMapContext.putImageData( _pixelMapImage, 0, 0 );
		_gradientMapContext.drawImage( _pixelMap, 0, 0 );

		return _gradientMap;

	}

	// Hide anti-alias gaps

	function expand( v1, v2, pixels ) {

		var x = v2.x - v1.x, y = v2.y - v1.y,
		det = x * x + y * y, idet;

		if ( det === 0 ) return;

		idet = pixels / Math.sqrt( det );

		x *= idet; y *= idet;

		v2.x += x; v2.y += y;
		v1.x -= x; v1.y -= y;

	}

	// Context cached methods.

	function setOpacity( value ) {

		if ( _contextGlobalAlpha !== value ) {

			_context.globalAlpha = value;
			_contextGlobalAlpha = value;

		}

	}

	function setBlending( value ) {

		if ( _contextGlobalCompositeOperation !== value ) {

			if ( value === THREE.NormalBlending ) {

				_context.globalCompositeOperation = 'source-over';

			} else if ( value === THREE.AdditiveBlending ) {

				_context.globalCompositeOperation = 'lighter';

			} else if ( value === THREE.SubtractiveBlending ) {

				_context.globalCompositeOperation = 'darker';

			}

			_contextGlobalCompositeOperation = value;

		}

	}

	function setLineWidth( value ) {

		if ( _contextLineWidth !== value ) {

			_context.lineWidth = value;
			_contextLineWidth = value;

		}

	}

	function setLineCap( value ) {

		// "butt", "round", "square"

		if ( _contextLineCap !== value ) {

			_context.lineCap = value;
			_contextLineCap = value;

		}

	}

	function setLineJoin( value ) {

		// "round", "bevel", "miter"

		if ( _contextLineJoin !== value ) {

			_context.lineJoin = value;
			_contextLineJoin = value;

		}

	}

	function setStrokeStyle( value ) {

		if ( _contextStrokeStyle !== value ) {

			_context.strokeStyle = value;
			_contextStrokeStyle = value;

		}

	}

	function setFillStyle( value ) {

		if ( _contextFillStyle !== value ) {

			_context.fillStyle = value;
			_contextFillStyle = value;

		}

	}

	function setDashAndGap( dashSizeValue, gapSizeValue ) {

		if ( _contextDashSize !== dashSizeValue || _contextGapSize !== gapSizeValue ) {

			_context.setLineDash( [ dashSizeValue, gapSizeValue ] );
			_contextDashSize = dashSizeValue;
			_contextGapSize = gapSizeValue;

		}

	}

};

/**
 * Shader chunks for WebLG Shader library
 * 
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

THREE.ShaderChunk = {

	// FOG

	fog_pars_fragment: [

		"#ifdef USE_FOG",

			"uniform vec3 fogColor;",

			"#ifdef FOG_EXP2",

				"uniform float fogDensity;",

			"#else",

				"uniform float fogNear;",
				"uniform float fogFar;",

			"#endif",

		"#endif"

	].join("\n"),

	fog_fragment: [

		"#ifdef USE_FOG",

			"float depth = gl_FragCoord.z / gl_FragCoord.w;",

			"#ifdef FOG_EXP2",

				"const float LOG2 = 1.442695;",
				"float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );",
				"fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );",

			"#else",

				"float fogFactor = smoothstep( fogNear, fogFar, depth );",

			"#endif",

			"gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );",

		"#endif"

	].join("\n"),

	// ENVIRONMENT MAP

	envmap_pars_fragment: [

		"#ifdef USE_ENVMAP",

			"uniform float reflectivity;",
			"uniform samplerCube envMap;",
			"uniform float flipEnvMap;",
			"uniform int combine;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"uniform bool useRefract;",
				"uniform float refractionRatio;",

			"#else",

				"varying vec3 vReflect;",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_fragment: [

		"#ifdef USE_ENVMAP",

			"vec3 reflectVec;",

			"#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )",

				"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

				"if ( useRefract ) {",

					"reflectVec = refract( cameraToVertex, normal, refractionRatio );",

				"} else { ",

					"reflectVec = reflect( cameraToVertex, normal );",

				"}",

			"#else",

				"reflectVec = vReflect;",

			"#endif",

			"#ifdef DOUBLE_SIDED",

				"float flipNormal = ( -1.0 + 2.0 * float( gl_FrontFacing ) );",
				"vec4 cubeColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#else",

				"vec4 cubeColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );",

			"#endif",

			"#ifdef GAMMA_INPUT",

				"cubeColor.xyz *= cubeColor.xyz;",

			"#endif",

			"if ( combine == 1 ) {",

				"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularStrength * reflectivity );",

			"} else if ( combine == 2 ) {",

				"gl_FragColor.xyz += cubeColor.xyz * specularStrength * reflectivity;",

			"} else {",

				"gl_FragColor.xyz = mix( gl_FragColor.xyz, gl_FragColor.xyz * cubeColor.xyz, specularStrength * reflectivity );",

			"}",

		"#endif"

	].join("\n"),

	envmap_pars_vertex: [

		"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"varying vec3 vReflect;",

			"uniform float refractionRatio;",
			"uniform bool useRefract;",

		"#endif"

	].join("\n"),

	worldpos_vertex : [

		"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )",

			"#ifdef USE_SKINNING",

				"vec4 worldPosition = modelMatrix * skinned;",

			"#endif",

			"#if defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( morphed, 1.0 );",

			"#endif",

			"#if ! defined( USE_MORPHTARGETS ) && ! defined( USE_SKINNING )",

				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	envmap_vertex : [

		"#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP )",

			"vec3 worldNormal = mat3( modelMatrix[ 0 ].xyz, modelMatrix[ 1 ].xyz, modelMatrix[ 2 ].xyz ) * objectNormal;",
			"worldNormal = normalize( worldNormal );",

			"vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );",

			"if ( useRefract ) {",

				"vReflect = refract( cameraToVertex, worldNormal, refractionRatio );",

			"} else {",

				"vReflect = reflect( cameraToVertex, worldNormal );",

			"}",

		"#endif"

	].join("\n"),

	// COLOR MAP (particles)

	map_particle_pars_fragment: [

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),


	map_particle_fragment: [

		"#ifdef USE_MAP",

			"gl_FragColor = gl_FragColor * texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );",

		"#endif"

	].join("\n"),

	// COLOR MAP (triangles)

	map_pars_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"varying vec2 vUv;",
			"uniform vec4 offsetRepeat;",

		"#endif"

	].join("\n"),

	map_pars_fragment: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"varying vec2 vUv;",

		"#endif",

		"#ifdef USE_MAP",

			"uniform sampler2D map;",

		"#endif"

	].join("\n"),

	map_vertex: [

		"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP )",

			"vUv = uv * offsetRepeat.zw + offsetRepeat.xy;",

		"#endif"

	].join("\n"),

	map_fragment: [

		"#ifdef USE_MAP",

			"vec4 texelColor = texture2D( map, vUv );",

			"#ifdef GAMMA_INPUT",

				"texelColor.xyz *= texelColor.xyz;",

			"#endif",

			"gl_FragColor = gl_FragColor * texelColor;",

		"#endif"

	].join("\n"),

	// LIGHT MAP

	lightmap_pars_fragment: [

		"#ifdef USE_LIGHTMAP",

			"varying vec2 vUv2;",
			"uniform sampler2D lightMap;",

		"#endif"

	].join("\n"),

	lightmap_pars_vertex: [

		"#ifdef USE_LIGHTMAP",

			"varying vec2 vUv2;",

		"#endif"

	].join("\n"),

	lightmap_fragment: [

		"#ifdef USE_LIGHTMAP",

			"gl_FragColor = gl_FragColor * texture2D( lightMap, vUv2 );",

		"#endif"

	].join("\n"),

	lightmap_vertex: [

		"#ifdef USE_LIGHTMAP",

			"vUv2 = uv2;",

		"#endif"

	].join("\n"),

	// BUMP MAP

	bumpmap_pars_fragment: [

		"#ifdef USE_BUMPMAP",

			"uniform sampler2D bumpMap;",
			"uniform float bumpScale;",

			// Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen
			//	http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html

			// Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

			"vec2 dHdxy_fwd() {",

				"vec2 dSTdx = dFdx( vUv );",
				"vec2 dSTdy = dFdy( vUv );",

				"float Hll = bumpScale * texture2D( bumpMap, vUv ).x;",
				"float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;",
				"float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;",

				"return vec2( dBx, dBy );",

			"}",

			"vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {",

				"vec3 vSigmaX = dFdx( surf_pos );",
				"vec3 vSigmaY = dFdy( surf_pos );",
				"vec3 vN = surf_norm;",		// normalized

				"vec3 R1 = cross( vSigmaY, vN );",
				"vec3 R2 = cross( vN, vSigmaX );",

				"float fDet = dot( vSigmaX, R1 );",

				"vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );",
				"return normalize( abs( fDet ) * surf_norm - vGrad );",

			"}",

		"#endif"

	].join("\n"),

	// NORMAL MAP

	normalmap_pars_fragment: [

		"#ifdef USE_NORMALMAP",

			"uniform sampler2D normalMap;",
			"uniform vec2 normalScale;",

			// Per-Pixel Tangent Space Normal Mapping
			// http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html

			"vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {",

				"vec3 q0 = dFdx( eye_pos.xyz );",
				"vec3 q1 = dFdy( eye_pos.xyz );",
				"vec2 st0 = dFdx( vUv.st );",
				"vec2 st1 = dFdy( vUv.st );",

				"vec3 S = normalize(  q0 * st1.t - q1 * st0.t );",
				"vec3 T = normalize( -q0 * st1.s + q1 * st0.s );",
				"vec3 N = normalize( surf_norm );",

				"vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;",
				"mapN.xy = normalScale * mapN.xy;",
				"mat3 tsn = mat3( S, T, N );",
				"return normalize( tsn * mapN );",

			"}",

		"#endif"

	].join("\n"),

	// SPECULAR MAP

	specularmap_pars_fragment: [

		"#ifdef USE_SPECULARMAP",

			"uniform sampler2D specularMap;",

		"#endif"

	].join("\n"),

	specularmap_fragment: [

		"float specularStrength;",

		"#ifdef USE_SPECULARMAP",

			"vec4 texelSpecular = texture2D( specularMap, vUv );",
			"specularStrength = texelSpecular.r;",

		"#else",

			"specularStrength = 1.0;",

		"#endif"

	].join("\n"),

	// LIGHTS LAMBERT

	lights_lambert_pars_vertex: [

		"uniform vec3 ambient;",
		"uniform vec3 diffuse;",
		"uniform vec3 emissive;",

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif"

	].join("\n"),

	lights_lambert_vertex: [

		"vLightFront = vec3( 0.0 );",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = vec3( 0.0 );",

		"#endif",

		"transformedNormal = normalize( transformedNormal );",

		"#if MAX_DIR_LIGHTS > 0",

		"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

			"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
			"vec3 dirVector = normalize( lDirection.xyz );",

			"float dotProduct = dot( transformedNormal, dirVector );",
			"vec3 directionalLightWeighting = vec3( max( dotProduct, 0.0 ) );",

			"#ifdef DOUBLE_SIDED",

				"vec3 directionalLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

				"#ifdef WRAP_AROUND",

					"vec3 directionalLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

				"#endif",

			"#endif",

			"#ifdef WRAP_AROUND",

				"vec3 directionalLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
				"directionalLightWeighting = mix( directionalLightWeighting, directionalLightWeightingHalf, wrapRGB );",

				"#ifdef DOUBLE_SIDED",

					"directionalLightWeightingBack = mix( directionalLightWeightingBack, directionalLightWeightingHalfBack, wrapRGB );",

				"#endif",

			"#endif",

			"vLightFront += directionalLightColor[ i ] * directionalLightWeighting;",

			"#ifdef DOUBLE_SIDED",

				"vLightBack += directionalLightColor[ i ] * directionalLightWeightingBack;",

			"#endif",

		"}",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"for( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( pointLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

				"lVector = normalize( lVector );",
				"float dotProduct = dot( transformedNormal, lVector );",

				"vec3 pointLightWeighting = vec3( max( dotProduct, 0.0 ) );",

				"#ifdef DOUBLE_SIDED",

					"vec3 pointLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

					"#ifdef WRAP_AROUND",

						"vec3 pointLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

					"#endif",

				"#endif",

				"#ifdef WRAP_AROUND",

					"vec3 pointLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
					"pointLightWeighting = mix( pointLightWeighting, pointLightWeightingHalf, wrapRGB );",

					"#ifdef DOUBLE_SIDED",

						"pointLightWeightingBack = mix( pointLightWeightingBack, pointLightWeightingHalfBack, wrapRGB );",

					"#endif",

				"#endif",

				"vLightFront += pointLightColor[ i ] * pointLightWeighting * lDistance;",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += pointLightColor[ i ] * pointLightWeightingBack * lDistance;",

				"#endif",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"for( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz - mvPosition.xyz;",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - worldPosition.xyz ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					"float lDistance = 1.0;",
					"if ( spotLightDistance[ i ] > 0.0 )",
						"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

					"lVector = normalize( lVector );",

					"float dotProduct = dot( transformedNormal, lVector );",
					"vec3 spotLightWeighting = vec3( max( dotProduct, 0.0 ) );",

					"#ifdef DOUBLE_SIDED",

						"vec3 spotLightWeightingBack = vec3( max( -dotProduct, 0.0 ) );",

						"#ifdef WRAP_AROUND",

							"vec3 spotLightWeightingHalfBack = vec3( max( -0.5 * dotProduct + 0.5, 0.0 ) );",

						"#endif",

					"#endif",

					"#ifdef WRAP_AROUND",

						"vec3 spotLightWeightingHalf = vec3( max( 0.5 * dotProduct + 0.5, 0.0 ) );",
						"spotLightWeighting = mix( spotLightWeighting, spotLightWeightingHalf, wrapRGB );",

						"#ifdef DOUBLE_SIDED",

							"spotLightWeightingBack = mix( spotLightWeightingBack, spotLightWeightingHalfBack, wrapRGB );",

						"#endif",

					"#endif",

					"vLightFront += spotLightColor[ i ] * spotLightWeighting * lDistance * spotEffect;",

					"#ifdef DOUBLE_SIDED",

						"vLightBack += spotLightColor[ i ] * spotLightWeightingBack * lDistance * spotEffect;",

					"#endif",

				"}",

			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				"float dotProduct = dot( transformedNormal, lVector );",

				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",
				"float hemiDiffuseWeightBack = -0.5 * dotProduct + 0.5;",

				"vLightFront += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"#ifdef DOUBLE_SIDED",

					"vLightBack += mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeightBack );",

				"#endif",

			"}",

		"#endif",

		"vLightFront = vLightFront * diffuse + ambient * ambientLightColor + emissive;",

		"#ifdef DOUBLE_SIDED",

			"vLightBack = vLightBack * diffuse + ambient * ambientLightColor + emissive;",

		"#endif"

	].join("\n"),

	// LIGHTS PHONG

	lights_phong_pars_vertex: [

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif"

	].join("\n"),


	lights_phong_vertex: [

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"vWorldPosition = worldPosition.xyz;",

		"#endif"

	].join("\n"),

	lights_phong_pars_fragment: [

		"uniform vec3 ambientLightColor;",

		"#if MAX_DIR_LIGHTS > 0",

			"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
			"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
			"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",

			"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
			"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
			"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
			"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",

			"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0 || defined( USE_BUMPMAP )",

			"varying vec3 vWorldPosition;",

		"#endif",

		"#ifdef WRAP_AROUND",

			"uniform vec3 wrapRGB;",

		"#endif",

		"varying vec3 vViewPosition;",
		"varying vec3 vNormal;"

	].join("\n"),

	lights_phong_fragment: [

		"vec3 normal = normalize( vNormal );",
		"vec3 viewPosition = normalize( vViewPosition );",

		"#ifdef DOUBLE_SIDED",

			"normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );",

		"#endif",

		"#ifdef USE_NORMALMAP",

			"normal = perturbNormal2Arb( -vViewPosition, normal );",

		"#elif defined( USE_BUMPMAP )",

			"normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"vec3 pointDiffuse  = vec3( 0.0 );",
			"vec3 pointSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( pointLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / pointLightDistance[ i ] ), 1.0 );",

				"lVector = normalize( lVector );",

				// diffuse

				"float dotProduct = dot( normal, lVector );",

				"#ifdef WRAP_AROUND",

					"float pointDiffuseWeightFull = max( dotProduct, 0.0 );",
					"float pointDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

					"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

				"#else",

					"float pointDiffuseWeight = max( dotProduct, 0.0 );",

				"#endif",

				"pointDiffuse  += diffuse * pointLightColor[ i ] * pointDiffuseWeight * lDistance;",

				// specular

				"vec3 pointHalfVector = normalize( lVector + viewPosition );",
				"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
				"float pointSpecularWeight = specularStrength * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, pointHalfVector ), 0.0 ), 5.0 );",
				"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * lDistance * specularNormalization;",

			"}",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"vec3 spotDiffuse  = vec3( 0.0 );",
			"vec3 spotSpecular = vec3( 0.0 );",

			"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

				"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
				"vec3 lVector = lPosition.xyz + vViewPosition.xyz;",

				"float lDistance = 1.0;",
				"if ( spotLightDistance[ i ] > 0.0 )",
					"lDistance = 1.0 - min( ( length( lVector ) / spotLightDistance[ i ] ), 1.0 );",

				"lVector = normalize( lVector );",

				"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

				"if ( spotEffect > spotLightAngleCos[ i ] ) {",

					"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

					// diffuse

					"float dotProduct = dot( normal, lVector );",

					"#ifdef WRAP_AROUND",

						"float spotDiffuseWeightFull = max( dotProduct, 0.0 );",
						"float spotDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

						"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

					"#else",

						"float spotDiffuseWeight = max( dotProduct, 0.0 );",

					"#endif",

					"spotDiffuse += diffuse * spotLightColor[ i ] * spotDiffuseWeight * lDistance * spotEffect;",

					// specular

					"vec3 spotHalfVector = normalize( lVector + viewPosition );",
					"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
					"float spotSpecularWeight = specularStrength * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

					// 2.0 => 2.0001 is hack to work around ANGLE bug

					"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

					"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, spotHalfVector ), 0.0 ), 5.0 );",
					"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * lDistance * specularNormalization * spotEffect;",

				"}",

			"}",

		"#endif",

		"#if MAX_DIR_LIGHTS > 0",

			"vec3 dirDiffuse  = vec3( 0.0 );",
			"vec3 dirSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_DIR_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
				"vec3 dirVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, dirVector );",

				"#ifdef WRAP_AROUND",

					"float dirDiffuseWeightFull = max( dotProduct, 0.0 );",
					"float dirDiffuseWeightHalf = max( 0.5 * dotProduct + 0.5, 0.0 );",

					"vec3 dirDiffuseWeight = mix( vec3( dirDiffuseWeightFull ), vec3( dirDiffuseWeightHalf ), wrapRGB );",

				"#else",

					"float dirDiffuseWeight = max( dotProduct, 0.0 );",

				"#endif",

				"dirDiffuse  += diffuse * directionalLightColor[ i ] * dirDiffuseWeight;",

				// specular

				"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
				"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
				"float dirSpecularWeight = specularStrength * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

					/*
				// fresnel term from skin shader
				"const float F0 = 0.128;",

				"float base = 1.0 - dot( viewPosition, dirHalfVector );",
				"float exponential = pow( base, 5.0 );",

				"float fresnel = exponential + F0 * ( 1.0 - exponential );",
				*/

				/*
				// fresnel term from fresnel shader
				"const float mFresnelBias = 0.08;",
				"const float mFresnelScale = 0.3;",
				"const float mFresnelPower = 5.0;",

				"float fresnel = mFresnelBias + mFresnelScale * pow( 1.0 + dot( normalize( -viewPosition ), normal ), mFresnelPower );",
				*/

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				//"dirSpecular += specular * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization * fresnel;",

				"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );",
				"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",


			"}",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"vec3 hemiDiffuse  = vec3( 0.0 );",
			"vec3 hemiSpecular = vec3( 0.0 );" ,

			"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

				"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
				"vec3 lVector = normalize( lDirection.xyz );",

				// diffuse

				"float dotProduct = dot( normal, lVector );",
				"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

				"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

				"hemiDiffuse += diffuse * hemiColor;",

				// specular (sky light)

				"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
				"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
				"float hemiSpecularWeightSky = specularStrength * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",

				// specular (ground light)

				"vec3 lVectorGround = -lVector;",

				"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
				"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
				"float hemiSpecularWeightGround = specularStrength * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",

				"float dotProductGround = dot( normal, lVectorGround );",

				// 2.0 => 2.0001 is hack to work around ANGLE bug

				"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

				"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVector, hemiHalfVectorSky ), 0.0 ), 5.0 );",
				"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 0.0 ), 5.0 );",
				"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

			"}",

		"#endif",

		"vec3 totalDiffuse = vec3( 0.0 );",
		"vec3 totalSpecular = vec3( 0.0 );",

		"#if MAX_DIR_LIGHTS > 0",

			"totalDiffuse += dirDiffuse;",
			"totalSpecular += dirSpecular;",

		"#endif",

		"#if MAX_HEMI_LIGHTS > 0",

			"totalDiffuse += hemiDiffuse;",
			"totalSpecular += hemiSpecular;",

		"#endif",

		"#if MAX_POINT_LIGHTS > 0",

			"totalDiffuse += pointDiffuse;",
			"totalSpecular += pointSpecular;",

		"#endif",

		"#if MAX_SPOT_LIGHTS > 0",

			"totalDiffuse += spotDiffuse;",
			"totalSpecular += spotSpecular;",

		"#endif",

		"#ifdef METAL",

			"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient + totalSpecular );",

		"#else",

			"gl_FragColor.xyz = gl_FragColor.xyz * ( emissive + totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

		"#endif"

	].join("\n"),

	// VERTEX COLORS

	color_pars_fragment: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_fragment: [

		"#ifdef USE_COLOR",

			"gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );",

		"#endif"

	].join("\n"),

	color_pars_vertex: [

		"#ifdef USE_COLOR",

			"varying vec3 vColor;",

		"#endif"

	].join("\n"),


	color_vertex: [

		"#ifdef USE_COLOR",

			"#ifdef GAMMA_INPUT",

				"vColor = color * color;",

			"#else",

				"vColor = color;",

			"#endif",

		"#endif"

	].join("\n"),

	// SKINNING

	skinning_pars_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef BONE_TEXTURE",

				"uniform sampler2D boneTexture;",
				"uniform int boneTextureWidth;",
				"uniform int boneTextureHeight;",

				"mat4 getBoneMatrix( const in float i ) {",

					"float j = i * 4.0;",
					"float x = mod( j, float( boneTextureWidth ) );",
					"float y = floor( j / float( boneTextureWidth ) );",

					"float dx = 1.0 / float( boneTextureWidth );",
					"float dy = 1.0 / float( boneTextureHeight );",

					"y = dy * ( y + 0.5 );",

					"vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );",
					"vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );",
					"vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );",
					"vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );",

					"mat4 bone = mat4( v1, v2, v3, v4 );",

					"return bone;",

				"}",

			"#else",

				"uniform mat4 boneGlobalMatrices[ MAX_BONES ];",

				"mat4 getBoneMatrix( const in float i ) {",

					"mat4 bone = boneGlobalMatrices[ int(i) ];",
					"return bone;",

				"}",

			"#endif",

		"#endif"

	].join("\n"),

	skinbase_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 boneMatX = getBoneMatrix( skinIndex.x );",
			"mat4 boneMatY = getBoneMatrix( skinIndex.y );",
			"mat4 boneMatZ = getBoneMatrix( skinIndex.z );",
			"mat4 boneMatW = getBoneMatrix( skinIndex.w );",

		"#endif"

	].join("\n"),

	skinning_vertex: [

		"#ifdef USE_SKINNING",

			"#ifdef USE_MORPHTARGETS",

			"vec4 skinVertex = vec4( morphed, 1.0 );",

			"#else",

			"vec4 skinVertex = vec4( position, 1.0 );",

			"#endif",

			"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
			"skinned      += boneMatY * skinVertex * skinWeight.y;",
			"skinned      += boneMatZ * skinVertex * skinWeight.z;",
			"skinned      += boneMatW * skinVertex * skinWeight.w;",

		"#endif"

	].join("\n"),

	// MORPHING

	morphtarget_pars_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"#ifndef USE_MORPHNORMALS",

			"uniform float morphTargetInfluences[ 8 ];",

			"#else",

			"uniform float morphTargetInfluences[ 4 ];",

			"#endif",

		"#endif"

	].join("\n"),

	morphtarget_vertex: [

		"#ifdef USE_MORPHTARGETS",

			"vec3 morphed = vec3( 0.0 );",
			"morphed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];",
			"morphed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];",
			"morphed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];",
			"morphed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];",

			"#ifndef USE_MORPHNORMALS",

			"morphed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];",
			"morphed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];",
			"morphed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];",
			"morphed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];",

			"#endif",

			"morphed += position;",

		"#endif"

	].join("\n"),

	default_vertex : [

		"vec4 mvPosition;",

		"#ifdef USE_SKINNING",

			"mvPosition = modelViewMatrix * skinned;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( morphed, 1.0 );",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHTARGETS )",

			"mvPosition = modelViewMatrix * vec4( position, 1.0 );",

		"#endif",

		"gl_Position = projectionMatrix * mvPosition;"

	].join("\n"),

	morphnormal_vertex: [

		"#ifdef USE_MORPHNORMALS",

			"vec3 morphedNormal = vec3( 0.0 );",

			"morphedNormal +=  ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];",
			"morphedNormal +=  ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];",
			"morphedNormal +=  ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];",
			"morphedNormal +=  ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];",

			"morphedNormal += normal;",

		"#endif"

	].join("\n"),

	skinnormal_vertex: [

		"#ifdef USE_SKINNING",

			"mat4 skinMatrix = skinWeight.x * boneMatX;",
			"skinMatrix 	+= skinWeight.y * boneMatY;",

			"#ifdef USE_MORPHNORMALS",

			"vec4 skinnedNormal = skinMatrix * vec4( morphedNormal, 0.0 );",

			"#else",

			"vec4 skinnedNormal = skinMatrix * vec4( normal, 0.0 );",

			"#endif",

		"#endif"

	].join("\n"),

	defaultnormal_vertex: [

		"vec3 objectNormal;",

		"#ifdef USE_SKINNING",

			"objectNormal = skinnedNormal.xyz;",

		"#endif",

		"#if !defined( USE_SKINNING ) && defined( USE_MORPHNORMALS )",

			"objectNormal = morphedNormal;",

		"#endif",

		"#if !defined( USE_SKINNING ) && ! defined( USE_MORPHNORMALS )",

			"objectNormal = normal;",

		"#endif",

		"#ifdef FLIP_SIDED",

			"objectNormal = -objectNormal;",

		"#endif",

		"vec3 transformedNormal = normalMatrix * objectNormal;"

	].join("\n"),

	// SHADOW MAP

	// based on SpiderGL shadow map and Fabien Sanglard's GLSL shadow mapping examples
	//  http://spidergl.org/example.php?id=6
	// 	http://fabiensanglard.net/shadowmapping

	shadowmap_pars_fragment: [

		"#ifdef USE_SHADOWMAP",

			"uniform sampler2D shadowMap[ MAX_SHADOWS ];",
			"uniform vec2 shadowMapSize[ MAX_SHADOWS ];",

			"uniform float shadowDarkness[ MAX_SHADOWS ];",
			"uniform float shadowBias[ MAX_SHADOWS ];",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",

			"float unpackDepth( const in vec4 rgba_depth ) {",

				"const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );",
				"float depth = dot( rgba_depth, bit_shift );",
				"return depth;",

			"}",

		"#endif"

	].join("\n"),

	shadowmap_fragment: [

		"#ifdef USE_SHADOWMAP",

			"#ifdef SHADOWMAP_DEBUG",

				"vec3 frustumColors[3];",
				"frustumColors[0] = vec3( 1.0, 0.5, 0.0 );",
				"frustumColors[1] = vec3( 0.0, 1.0, 0.8 );",
				"frustumColors[2] = vec3( 0.0, 0.5, 1.0 );",

			"#endif",

			"#ifdef SHADOWMAP_CASCADE",

				"int inFrustumCount = 0;",

			"#endif",

			"float fDepth;",
			"vec3 shadowColor = vec3( 1.0 );",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vec3 shadowCoord = vShadowCoord[ i ].xyz / vShadowCoord[ i ].w;",

				// "if ( something && something )" 		 breaks ATI OpenGL shader compiler
				// "if ( all( something, something ) )"  using this instead

				"bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );",
				"bool inFrustum = all( inFrustumVec );",

				// don't shadow pixels outside of light frustum
				// use just first frustum (for cascades)
				// don't shadow pixels behind far plane of light frustum

				"#ifdef SHADOWMAP_CASCADE",

					"inFrustumCount += int( inFrustum );",
					"bvec3 frustumTestVec = bvec3( inFrustum, inFrustumCount == 1, shadowCoord.z <= 1.0 );",

				"#else",

					"bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );",

				"#endif",

				"bool frustumTest = all( frustumTestVec );",

				"if ( frustumTest ) {",

					"shadowCoord.z += shadowBias[ i ];",

					"#if defined( SHADOWMAP_TYPE_PCF )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						/*
						// nested loops breaks shader compiler / validator on some ATI cards when using OpenGL
						// must enroll loop manually

						"for ( float y = -1.25; y <= 1.25; y += 1.25 )",
							"for ( float x = -1.25; x <= 1.25; x += 1.25 ) {",

								"vec4 rgbaDepth = texture2D( shadowMap[ i ], vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy );",

								// doesn't seem to produce any noticeable visual difference compared to simple "texture2D" lookup
								//"vec4 rgbaDepth = texture2DProj( shadowMap[ i ], vec4( vShadowCoord[ i ].w * ( vec2( x * xPixelOffset, y * yPixelOffset ) + shadowCoord.xy ), 0.05, vShadowCoord[ i ].w ) );",

								"float fDepth = unpackDepth( rgbaDepth );",

								"if ( fDepth < shadowCoord.z )",
									"shadow += 1.0;",

						"}",

						"shadow /= 9.0;",

						*/

						"const float shadowDelta = 1.0 / 9.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.25 * xPixelOffset;",
						"float dy0 = -1.25 * yPixelOffset;",
						"float dx1 = 1.25 * xPixelOffset;",
						"float dy1 = 1.25 * yPixelOffset;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"fDepth = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",
						"if ( fDepth < shadowCoord.z ) shadow += shadowDelta;",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#elif defined( SHADOWMAP_TYPE_PCF_SOFT )",

						// Percentage-close filtering
						// (9 pixel kernel)
						// http://fabiensanglard.net/shadowmappingPCF/

						"float shadow = 0.0;",

						"float xPixelOffset = 1.0 / shadowMapSize[ i ].x;",
						"float yPixelOffset = 1.0 / shadowMapSize[ i ].y;",

						"float dx0 = -1.0 * xPixelOffset;",
						"float dy0 = -1.0 * yPixelOffset;",
						"float dx1 = 1.0 * xPixelOffset;",
						"float dy1 = 1.0 * yPixelOffset;",

						"mat3 shadowKernel;",
						"mat3 depthKernel;",

						"depthKernel[0][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy0 ) ) );",
						"depthKernel[0][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, 0.0 ) ) );",
						"depthKernel[0][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx0, dy1 ) ) );",
						"depthKernel[1][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy0 ) ) );",
						"depthKernel[1][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy ) );",
						"depthKernel[1][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( 0.0, dy1 ) ) );",
						"depthKernel[2][0] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy0 ) ) );",
						"depthKernel[2][1] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, 0.0 ) ) );",
						"depthKernel[2][2] = unpackDepth( texture2D( shadowMap[ i ], shadowCoord.xy + vec2( dx1, dy1 ) ) );",

						"vec3 shadowZ = vec3( shadowCoord.z );",
						"shadowKernel[0] = vec3(lessThan(depthKernel[0], shadowZ ));",
						"shadowKernel[0] *= vec3(0.25);",
													
						"shadowKernel[1] = vec3(lessThan(depthKernel[1], shadowZ ));",
						"shadowKernel[1] *= vec3(0.25);",

						"shadowKernel[2] = vec3(lessThan(depthKernel[2], shadowZ ));",
						"shadowKernel[2] *= vec3(0.25);",

						"vec2 fractionalCoord = 1.0 - fract( shadowCoord.xy * shadowMapSize[i].xy );",

						"shadowKernel[0] = mix( shadowKernel[1], shadowKernel[0], fractionalCoord.x );",
						"shadowKernel[1] = mix( shadowKernel[2], shadowKernel[1], fractionalCoord.x );",

						"vec4 shadowValues;",
						"shadowValues.x = mix( shadowKernel[0][1], shadowKernel[0][0], fractionalCoord.y );",
						"shadowValues.y = mix( shadowKernel[0][2], shadowKernel[0][1], fractionalCoord.y );",
						"shadowValues.z = mix( shadowKernel[1][1], shadowKernel[1][0], fractionalCoord.y );",
						"shadowValues.w = mix( shadowKernel[1][2], shadowKernel[1][1], fractionalCoord.y );",

						"shadow = dot( shadowValues, vec4( 1.0 ) );",

						"shadowColor = shadowColor * vec3( ( 1.0 - shadowDarkness[ i ] * shadow ) );",

					"#else",

						"vec4 rgbaDepth = texture2D( shadowMap[ i ], shadowCoord.xy );",
						"float fDepth = unpackDepth( rgbaDepth );",

						"if ( fDepth < shadowCoord.z )",

							// spot with multiple shadows is darker

							"shadowColor = shadowColor * vec3( 1.0 - shadowDarkness[ i ] );",

							// spot with multiple shadows has the same color as single shadow spot

							//"shadowColor = min( shadowColor, vec3( shadowDarkness[ i ] ) );",

					"#endif",

				"}",


				"#ifdef SHADOWMAP_DEBUG",

					"#ifdef SHADOWMAP_CASCADE",

						"if ( inFrustum && inFrustumCount == 1 ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#else",

						"if ( inFrustum ) gl_FragColor.xyz *= frustumColors[ i ];",

					"#endif",

				"#endif",

			"}",

			"#ifdef GAMMA_OUTPUT",

				"shadowColor *= shadowColor;",

			"#endif",

			"gl_FragColor.xyz = gl_FragColor.xyz * shadowColor;",

		"#endif"

	].join("\n"),

	shadowmap_pars_vertex: [

		"#ifdef USE_SHADOWMAP",

			"varying vec4 vShadowCoord[ MAX_SHADOWS ];",
			"uniform mat4 shadowMatrix[ MAX_SHADOWS ];",

		"#endif"

	].join("\n"),

	shadowmap_vertex: [

		"#ifdef USE_SHADOWMAP",

			"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

				"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

			"}",

		"#endif"

	].join("\n"),

	// ALPHATEST

	alphatest_fragment: [

		"#ifdef ALPHATEST",

			"if ( gl_FragColor.a < ALPHATEST ) discard;",

		"#endif"

	].join("\n"),

	// LINEAR SPACE

	linear_to_gamma_fragment: [

		"#ifdef GAMMA_OUTPUT",

			"gl_FragColor.xyz = sqrt( gl_FragColor.xyz );",

		"#endif"

	].join("\n")


};
/**
 * Uniform Utilities
 */

THREE.UniformsUtils = {

	merge: function ( uniforms ) {

		var u, p, tmp, merged = {};

		for ( u = 0; u < uniforms.length; u ++ ) {

			tmp = this.clone( uniforms[ u ] );

			for ( p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var u, p, parameter, parameter_src, uniforms_dst = {};

		for ( u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( p in uniforms_src[ u ] ) {

				parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src instanceof THREE.Color ||
					 parameter_src instanceof THREE.Vector2 ||
					 parameter_src instanceof THREE.Vector3 ||
					 parameter_src instanceof THREE.Vector4 ||
					 parameter_src instanceof THREE.Matrix4 ||
					 parameter_src instanceof THREE.Texture ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( parameter_src instanceof Array ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};
/**
 * Uniforms library for shared webgl shaders
 */

THREE.UniformsLib = {

	common: {

		"diffuse" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },

		"map" : { type: "t", value: null },
		"offsetRepeat" : { type: "v4", value: new THREE.Vector4( 0, 0, 1, 1 ) },

		"lightMap" : { type: "t", value: null },
		"specularMap" : { type: "t", value: null },

		"envMap" : { type: "t", value: null },
		"flipEnvMap" : { type: "f", value: -1 },
		"useRefract" : { type: "i", value: 0 },
		"reflectivity" : { type: "f", value: 1.0 },
		"refractionRatio" : { type: "f", value: 0.98 },
		"combine" : { type: "i", value: 0 },

		"morphTargetInfluences" : { type: "f", value: 0 }

	},

	bump: {

		"bumpMap" : { type: "t", value: null },
		"bumpScale" : { type: "f", value: 1 }

	},

	normalmap: {

		"normalMap" : { type: "t", value: null },
		"normalScale" : { type: "v2", value: new THREE.Vector2( 1, 1 ) }
	},

	fog : {

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	lights: {

		"ambientLightColor" : { type: "fv", value: [] },

		"directionalLightDirection" : { type: "fv", value: [] },
		"directionalLightColor" : { type: "fv", value: [] },

		"hemisphereLightDirection" : { type: "fv", value: [] },
		"hemisphereLightSkyColor" : { type: "fv", value: [] },
		"hemisphereLightGroundColor" : { type: "fv", value: [] },

		"pointLightColor" : { type: "fv", value: [] },
		"pointLightPosition" : { type: "fv", value: [] },
		"pointLightDistance" : { type: "fv1", value: [] },

		"spotLightColor" : { type: "fv", value: [] },
		"spotLightPosition" : { type: "fv", value: [] },
		"spotLightDirection" : { type: "fv", value: [] },
		"spotLightDistance" : { type: "fv1", value: [] },
		"spotLightAngleCos" : { type: "fv1", value: [] },
		"spotLightExponent" : { type: "fv1", value: [] }

	},

	particle: {

		"psColor" : { type: "c", value: new THREE.Color( 0xeeeeee ) },
		"opacity" : { type: "f", value: 1.0 },
		"size" : { type: "f", value: 1.0 },
		"scale" : { type: "f", value: 1.0 },
		"map" : { type: "t", value: null },

		"fogDensity" : { type: "f", value: 0.00025 },
		"fogNear" : { type: "f", value: 1 },
		"fogFar" : { type: "f", value: 2000 },
		"fogColor" : { type: "c", value: new THREE.Color( 0xffffff ) }

	},

	shadowmap: {

		"shadowMap": { type: "tv", value: [] },
		"shadowMapSize": { type: "v2v", value: [] },

		"shadowBias" : { type: "fv1", value: [] },
		"shadowDarkness": { type: "fv1", value: [] },

		"shadowMatrix" : { type: "m4v", value: [] }

	}

};
/**
 * Webgl Shader Library for three.js
 *
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */


THREE.ShaderLib = {

	'basic': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],

				"#ifdef USE_ENVMAP",

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"#endif",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],
				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'lambert': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define LAMBERT",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

				"varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_lambert_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_lambert_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",

			"varying vec3 vLightFront;",

			"#ifdef DOUBLE_SIDED",

				"varying vec3 vLightBack;",

			"#endif",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				"#ifdef DOUBLE_SIDED",

					//"float isFront = float( gl_FrontFacing );",
					//"gl_FragColor.xyz *= isFront * vLightFront + ( 1.0 - isFront ) * vLightBack;",

					"if ( gl_FrontFacing )",
						"gl_FragColor.xyz *= vLightFront;",
					"else",
						"gl_FragColor.xyz *= vLightBack;",

				"#else",

					"gl_FragColor.xyz *= vLightFront;",

				"#endif",

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'phong': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "bump" ],
			THREE.UniformsLib[ "normalmap" ],
			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{
				"ambient"  : { type: "c", value: new THREE.Color( 0xffffff ) },
				"emissive" : { type: "c", value: new THREE.Color( 0x000000 ) },
				"specular" : { type: "c", value: new THREE.Color( 0x111111 ) },
				"shininess": { type: "f", value: 30 },
				"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }
			}

		] ),

		vertexShader: [

			"#define PHONG",

			"varying vec3 vViewPosition;",
			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "map_pars_vertex" ],
			THREE.ShaderChunk[ "lightmap_pars_vertex" ],
			THREE.ShaderChunk[ "envmap_pars_vertex" ],
			THREE.ShaderChunk[ "lights_phong_pars_vertex" ],
			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "map_vertex" ],
				THREE.ShaderChunk[ "lightmap_vertex" ],
				THREE.ShaderChunk[ "color_vertex" ],

				THREE.ShaderChunk[ "morphnormal_vertex" ],
				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],
				THREE.ShaderChunk[ "defaultnormal_vertex" ],

				"vNormal = normalize( transformedNormal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

				"vViewPosition = -mvPosition.xyz;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "envmap_vertex" ],
				THREE.ShaderChunk[ "lights_phong_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform vec3 ambient;",
			"uniform vec3 emissive;",
			"uniform vec3 specular;",
			"uniform float shininess;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_pars_fragment" ],
			THREE.ShaderChunk[ "lightmap_pars_fragment" ],
			THREE.ShaderChunk[ "envmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "lights_phong_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "bumpmap_pars_fragment" ],
			THREE.ShaderChunk[ "normalmap_pars_fragment" ],
			THREE.ShaderChunk[ "specularmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3 ( 1.0 ), opacity );",

				THREE.ShaderChunk[ "map_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "specularmap_fragment" ],

				THREE.ShaderChunk[ "lights_phong_fragment" ],

				THREE.ShaderChunk[ "lightmap_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "envmap_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],

				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],

				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'particle_basic': {

		uniforms:  THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "particle" ],
			THREE.UniformsLib[ "shadowmap" ]

		] ),

		vertexShader: [

			"uniform float size;",
			"uniform float scale;",

			THREE.ShaderChunk[ "color_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",

				"#ifdef USE_SIZEATTENUATION",
					"gl_PointSize = size * ( scale / length( mvPosition.xyz ) );",
				"#else",
					"gl_PointSize = size;",
				"#endif",

				"gl_Position = projectionMatrix * mvPosition;",

				THREE.ShaderChunk[ "worldpos_vertex" ],
				THREE.ShaderChunk[ "shadowmap_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 psColor;",
			"uniform float opacity;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "map_particle_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],
			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( psColor, opacity );",

				THREE.ShaderChunk[ "map_particle_fragment" ],
				THREE.ShaderChunk[ "alphatest_fragment" ],
				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'dashed': {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "common" ],
			THREE.UniformsLib[ "fog" ],

			{
				"scale":     { type: "f", value: 1 },
				"dashSize":  { type: "f", value: 1 },
				"totalSize": { type: "f", value: 2 }
			}

		] ),

		vertexShader: [

			"uniform float scale;",
			"attribute float lineDistance;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "color_vertex" ],

				"vLineDistance = scale * lineDistance;",

				"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );",
				"gl_Position = projectionMatrix * mvPosition;",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform vec3 diffuse;",
			"uniform float opacity;",

			"uniform float dashSize;",
			"uniform float totalSize;",

			"varying float vLineDistance;",

			THREE.ShaderChunk[ "color_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],

			"void main() {",

				"if ( mod( vLineDistance, totalSize ) > dashSize ) {",

					"discard;",

				"}",

				"gl_FragColor = vec4( diffuse, opacity );",

				THREE.ShaderChunk[ "color_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n")

	},

	'depth': {

		uniforms: {

			"mNear": { type: "f", value: 1.0 },
			"mFar" : { type: "f", value: 2000.0 },
			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"void main() {",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float mNear;",
			"uniform float mFar;",
			"uniform float opacity;",

			"void main() {",

				"float depth = gl_FragCoord.z / gl_FragCoord.w;",
				"float color = 1.0 - smoothstep( mNear, mFar, depth );",
				"gl_FragColor = vec4( vec3( color ), opacity );",

			"}"

		].join("\n")

	},

	'normal': {

		uniforms: {

			"opacity" : { type: "f", value: 1.0 }

		},

		vertexShader: [

			"varying vec3 vNormal;",

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],

			"void main() {",

				"vNormal = normalize( normalMatrix * normal );",

				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform float opacity;",
			"varying vec3 vNormal;",

			"void main() {",

				"gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Normal map shader
	//		- Blinn-Phong
	//		- normal + diffuse + specular + AO + displacement + reflection + shadow maps
	//		- point and directional lights (use with "lights: true" material option)
	 ------------------------------------------------------------------------- */

	'normalmap' : {

		uniforms: THREE.UniformsUtils.merge( [

			THREE.UniformsLib[ "fog" ],
			THREE.UniformsLib[ "lights" ],
			THREE.UniformsLib[ "shadowmap" ],

			{

			"enableAO"		  : { type: "i", value: 0 },
			"enableDiffuse"	  : { type: "i", value: 0 },
			"enableSpecular"  : { type: "i", value: 0 },
			"enableReflection": { type: "i", value: 0 },
			"enableDisplacement": { type: "i", value: 0 },

			"tDisplacement": { type: "t", value: null }, // must go first as this is vertex texture
			"tDiffuse"	   : { type: "t", value: null },
			"tCube"		   : { type: "t", value: null },
			"tNormal"	   : { type: "t", value: null },
			"tSpecular"	   : { type: "t", value: null },
			"tAO"		   : { type: "t", value: null },

			"uNormalScale": { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"uDisplacementBias": { type: "f", value: 0.0 },
			"uDisplacementScale": { type: "f", value: 1.0 },

			"diffuse": { type: "c", value: new THREE.Color( 0xffffff ) },
			"specular": { type: "c", value: new THREE.Color( 0x111111 ) },
			"ambient": { type: "c", value: new THREE.Color( 0xffffff ) },
			"shininess": { type: "f", value: 30 },
			"opacity": { type: "f", value: 1 },

			"useRefract": { type: "i", value: 0 },
			"refractionRatio": { type: "f", value: 0.98 },
			"reflectivity": { type: "f", value: 0.5 },

			"uOffset" : { type: "v2", value: new THREE.Vector2( 0, 0 ) },
			"uRepeat" : { type: "v2", value: new THREE.Vector2( 1, 1 ) },

			"wrapRGB"  : { type: "v3", value: new THREE.Vector3( 1, 1, 1 ) }

			}

		] ),

		fragmentShader: [

			"uniform vec3 ambient;",
			"uniform vec3 diffuse;",
			"uniform vec3 specular;",
			"uniform float shininess;",
			"uniform float opacity;",

			"uniform bool enableDiffuse;",
			"uniform bool enableSpecular;",
			"uniform bool enableAO;",
			"uniform bool enableReflection;",

			"uniform sampler2D tDiffuse;",
			"uniform sampler2D tNormal;",
			"uniform sampler2D tSpecular;",
			"uniform sampler2D tAO;",

			"uniform samplerCube tCube;",

			"uniform vec2 uNormalScale;",

			"uniform bool useRefract;",
			"uniform float refractionRatio;",
			"uniform float reflectivity;",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"uniform vec3 ambientLightColor;",

			"#if MAX_DIR_LIGHTS > 0",

				"uniform vec3 directionalLightColor[ MAX_DIR_LIGHTS ];",
				"uniform vec3 directionalLightDirection[ MAX_DIR_LIGHTS ];",

			"#endif",

			"#if MAX_HEMI_LIGHTS > 0",

				"uniform vec3 hemisphereLightSkyColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightGroundColor[ MAX_HEMI_LIGHTS ];",
				"uniform vec3 hemisphereLightDirection[ MAX_HEMI_LIGHTS ];",

			"#endif",

			"#if MAX_POINT_LIGHTS > 0",

				"uniform vec3 pointLightColor[ MAX_POINT_LIGHTS ];",
				"uniform vec3 pointLightPosition[ MAX_POINT_LIGHTS ];",
				"uniform float pointLightDistance[ MAX_POINT_LIGHTS ];",

			"#endif",

			"#if MAX_SPOT_LIGHTS > 0",

				"uniform vec3 spotLightColor[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightPosition[ MAX_SPOT_LIGHTS ];",
				"uniform vec3 spotLightDirection[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightAngleCos[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightExponent[ MAX_SPOT_LIGHTS ];",
				"uniform float spotLightDistance[ MAX_SPOT_LIGHTS ];",

			"#endif",

			"#ifdef WRAP_AROUND",

				"uniform vec3 wrapRGB;",

			"#endif",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "shadowmap_pars_fragment" ],
			THREE.ShaderChunk[ "fog_pars_fragment" ],

			"void main() {",

				"gl_FragColor = vec4( vec3( 1.0 ), opacity );",

				"vec3 specularTex = vec3( 1.0 );",

				"vec3 normalTex = texture2D( tNormal, vUv ).xyz * 2.0 - 1.0;",
				"normalTex.xy *= uNormalScale;",
				"normalTex = normalize( normalTex );",

				"if( enableDiffuse ) {",

					"#ifdef GAMMA_INPUT",

						"vec4 texelColor = texture2D( tDiffuse, vUv );",
						"texelColor.xyz *= texelColor.xyz;",

						"gl_FragColor = gl_FragColor * texelColor;",

					"#else",

						"gl_FragColor = gl_FragColor * texture2D( tDiffuse, vUv );",

					"#endif",

				"}",

				"if( enableAO ) {",

					"#ifdef GAMMA_INPUT",

						"vec4 aoColor = texture2D( tAO, vUv );",
						"aoColor.xyz *= aoColor.xyz;",

						"gl_FragColor.xyz = gl_FragColor.xyz * aoColor.xyz;",

					"#else",

						"gl_FragColor.xyz = gl_FragColor.xyz * texture2D( tAO, vUv ).xyz;",

					"#endif",

				"}",

				"if( enableSpecular )",
					"specularTex = texture2D( tSpecular, vUv ).xyz;",

				"mat3 tsb = mat3( normalize( vTangent ), normalize( vBinormal ), normalize( vNormal ) );",
				"vec3 finalNormal = tsb * normalTex;",

				"#ifdef FLIP_SIDED",

					"finalNormal = -finalNormal;",

				"#endif",

				"vec3 normal = normalize( finalNormal );",
				"vec3 viewPosition = normalize( vViewPosition );",

				// point lights

				"#if MAX_POINT_LIGHTS > 0",

					"vec3 pointDiffuse = vec3( 0.0 );",
					"vec3 pointSpecular = vec3( 0.0 );",

					"for ( int i = 0; i < MAX_POINT_LIGHTS; i ++ ) {",

						"vec4 lPosition = viewMatrix * vec4( pointLightPosition[ i ], 1.0 );",
						"vec3 pointVector = lPosition.xyz + vViewPosition.xyz;",

						"float pointDistance = 1.0;",
						"if ( pointLightDistance[ i ] > 0.0 )",
							"pointDistance = 1.0 - min( ( length( pointVector ) / pointLightDistance[ i ] ), 1.0 );",

						"pointVector = normalize( pointVector );",

						// diffuse

						"#ifdef WRAP_AROUND",

							"float pointDiffuseWeightFull = max( dot( normal, pointVector ), 0.0 );",
							"float pointDiffuseWeightHalf = max( 0.5 * dot( normal, pointVector ) + 0.5, 0.0 );",

							"vec3 pointDiffuseWeight = mix( vec3 ( pointDiffuseWeightFull ), vec3( pointDiffuseWeightHalf ), wrapRGB );",

						"#else",

							"float pointDiffuseWeight = max( dot( normal, pointVector ), 0.0 );",

						"#endif",

						"pointDiffuse += pointDistance * pointLightColor[ i ] * diffuse * pointDiffuseWeight;",

						// specular

						"vec3 pointHalfVector = normalize( pointVector + viewPosition );",
						"float pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );",
						"float pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );",

						// 2.0 => 2.0001 is hack to work around ANGLE bug

						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

						"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( pointVector, pointHalfVector ), 5.0 );",
						"pointSpecular += schlick * pointLightColor[ i ] * pointSpecularWeight * pointDiffuseWeight * pointDistance * specularNormalization;",

					"}",

				"#endif",

				// spot lights

				"#if MAX_SPOT_LIGHTS > 0",

					"vec3 spotDiffuse = vec3( 0.0 );",
					"vec3 spotSpecular = vec3( 0.0 );",

					"for ( int i = 0; i < MAX_SPOT_LIGHTS; i ++ ) {",

						"vec4 lPosition = viewMatrix * vec4( spotLightPosition[ i ], 1.0 );",
						"vec3 spotVector = lPosition.xyz + vViewPosition.xyz;",

						"float spotDistance = 1.0;",
						"if ( spotLightDistance[ i ] > 0.0 )",
							"spotDistance = 1.0 - min( ( length( spotVector ) / spotLightDistance[ i ] ), 1.0 );",

						"spotVector = normalize( spotVector );",

						"float spotEffect = dot( spotLightDirection[ i ], normalize( spotLightPosition[ i ] - vWorldPosition ) );",

						"if ( spotEffect > spotLightAngleCos[ i ] ) {",

							"spotEffect = max( pow( spotEffect, spotLightExponent[ i ] ), 0.0 );",

							// diffuse

							"#ifdef WRAP_AROUND",

								"float spotDiffuseWeightFull = max( dot( normal, spotVector ), 0.0 );",
								"float spotDiffuseWeightHalf = max( 0.5 * dot( normal, spotVector ) + 0.5, 0.0 );",

								"vec3 spotDiffuseWeight = mix( vec3 ( spotDiffuseWeightFull ), vec3( spotDiffuseWeightHalf ), wrapRGB );",

							"#else",

								"float spotDiffuseWeight = max( dot( normal, spotVector ), 0.0 );",

							"#endif",

							"spotDiffuse += spotDistance * spotLightColor[ i ] * diffuse * spotDiffuseWeight * spotEffect;",

							// specular

							"vec3 spotHalfVector = normalize( spotVector + viewPosition );",
							"float spotDotNormalHalf = max( dot( normal, spotHalfVector ), 0.0 );",
							"float spotSpecularWeight = specularTex.r * max( pow( spotDotNormalHalf, shininess ), 0.0 );",

							// 2.0 => 2.0001 is hack to work around ANGLE bug

							"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

							"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( spotVector, spotHalfVector ), 5.0 );",
							"spotSpecular += schlick * spotLightColor[ i ] * spotSpecularWeight * spotDiffuseWeight * spotDistance * specularNormalization * spotEffect;",

						"}",

					"}",

				"#endif",

				// directional lights

				"#if MAX_DIR_LIGHTS > 0",

					"vec3 dirDiffuse = vec3( 0.0 );",
					"vec3 dirSpecular = vec3( 0.0 );",

					"for( int i = 0; i < MAX_DIR_LIGHTS; i++ ) {",

						"vec4 lDirection = viewMatrix * vec4( directionalLightDirection[ i ], 0.0 );",
						"vec3 dirVector = normalize( lDirection.xyz );",

						// diffuse

						"#ifdef WRAP_AROUND",

							"float directionalLightWeightingFull = max( dot( normal, dirVector ), 0.0 );",
							"float directionalLightWeightingHalf = max( 0.5 * dot( normal, dirVector ) + 0.5, 0.0 );",

							"vec3 dirDiffuseWeight = mix( vec3( directionalLightWeightingFull ), vec3( directionalLightWeightingHalf ), wrapRGB );",

						"#else",

							"float dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );",

						"#endif",

						"dirDiffuse += directionalLightColor[ i ] * diffuse * dirDiffuseWeight;",

						// specular

						"vec3 dirHalfVector = normalize( dirVector + viewPosition );",
						"float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );",
						"float dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );",

						// 2.0 => 2.0001 is hack to work around ANGLE bug

						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

						"vec3 schlick = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( dirVector, dirHalfVector ), 5.0 );",
						"dirSpecular += schlick * directionalLightColor[ i ] * dirSpecularWeight * dirDiffuseWeight * specularNormalization;",

					"}",

				"#endif",

				// hemisphere lights

				"#if MAX_HEMI_LIGHTS > 0",

					"vec3 hemiDiffuse  = vec3( 0.0 );",
					"vec3 hemiSpecular = vec3( 0.0 );" ,

					"for( int i = 0; i < MAX_HEMI_LIGHTS; i ++ ) {",

						"vec4 lDirection = viewMatrix * vec4( hemisphereLightDirection[ i ], 0.0 );",
						"vec3 lVector = normalize( lDirection.xyz );",

						// diffuse

						"float dotProduct = dot( normal, lVector );",
						"float hemiDiffuseWeight = 0.5 * dotProduct + 0.5;",

						"vec3 hemiColor = mix( hemisphereLightGroundColor[ i ], hemisphereLightSkyColor[ i ], hemiDiffuseWeight );",

						"hemiDiffuse += diffuse * hemiColor;",

						// specular (sky light)


						"vec3 hemiHalfVectorSky = normalize( lVector + viewPosition );",
						"float hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;",
						"float hemiSpecularWeightSky = specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );",

						// specular (ground light)

						"vec3 lVectorGround = -lVector;",

						"vec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );",
						"float hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;",
						"float hemiSpecularWeightGround = specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );",

						"float dotProductGround = dot( normal, lVectorGround );",

						// 2.0 => 2.0001 is hack to work around ANGLE bug

						"float specularNormalization = ( shininess + 2.0001 ) / 8.0;",

						"vec3 schlickSky = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVector, hemiHalfVectorSky ), 5.0 );",
						"vec3 schlickGround = specular + vec3( 1.0 - specular ) * pow( 1.0 - dot( lVectorGround, hemiHalfVectorGround ), 5.0 );",
						"hemiSpecular += hemiColor * specularNormalization * ( schlickSky * hemiSpecularWeightSky * max( dotProduct, 0.0 ) + schlickGround * hemiSpecularWeightGround * max( dotProductGround, 0.0 ) );",

					"}",

				"#endif",

				// all lights contribution summation

				"vec3 totalDiffuse = vec3( 0.0 );",
				"vec3 totalSpecular = vec3( 0.0 );",

				"#if MAX_DIR_LIGHTS > 0",

					"totalDiffuse += dirDiffuse;",
					"totalSpecular += dirSpecular;",

				"#endif",

				"#if MAX_HEMI_LIGHTS > 0",

					"totalDiffuse += hemiDiffuse;",
					"totalSpecular += hemiSpecular;",

				"#endif",

				"#if MAX_POINT_LIGHTS > 0",

					"totalDiffuse += pointDiffuse;",
					"totalSpecular += pointSpecular;",

				"#endif",

				"#if MAX_SPOT_LIGHTS > 0",

					"totalDiffuse += spotDiffuse;",
					"totalSpecular += spotSpecular;",

				"#endif",

				"#ifdef METAL",

					"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient + totalSpecular );",

				"#else",

					"gl_FragColor.xyz = gl_FragColor.xyz * ( totalDiffuse + ambientLightColor * ambient ) + totalSpecular;",

				"#endif",

				"if ( enableReflection ) {",

					"vec3 vReflect;",
					"vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );",

					"if ( useRefract ) {",

						"vReflect = refract( cameraToVertex, normal, refractionRatio );",

					"} else {",

						"vReflect = reflect( cameraToVertex, normal );",

					"}",

					"vec4 cubeColor = textureCube( tCube, vec3( -vReflect.x, vReflect.yz ) );",

					"#ifdef GAMMA_INPUT",

						"cubeColor.xyz *= cubeColor.xyz;",

					"#endif",

					"gl_FragColor.xyz = mix( gl_FragColor.xyz, cubeColor.xyz, specularTex.r * reflectivity );",

				"}",

				THREE.ShaderChunk[ "shadowmap_fragment" ],
				THREE.ShaderChunk[ "linear_to_gamma_fragment" ],
				THREE.ShaderChunk[ "fog_fragment" ],

			"}"

		].join("\n"),

		vertexShader: [

			"attribute vec4 tangent;",

			"uniform vec2 uOffset;",
			"uniform vec2 uRepeat;",

			"uniform bool enableDisplacement;",

			"#ifdef VERTEX_TEXTURES",

				"uniform sampler2D tDisplacement;",
				"uniform float uDisplacementScale;",
				"uniform float uDisplacementBias;",

			"#endif",

			"varying vec3 vTangent;",
			"varying vec3 vBinormal;",
			"varying vec3 vNormal;",
			"varying vec2 vUv;",

			"varying vec3 vWorldPosition;",
			"varying vec3 vViewPosition;",

			THREE.ShaderChunk[ "skinning_pars_vertex" ],
			THREE.ShaderChunk[ "shadowmap_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "skinnormal_vertex" ],

				// normal, tangent and binormal vectors

				"#ifdef USE_SKINNING",

					"vNormal = normalize( normalMatrix * skinnedNormal.xyz );",

					"vec4 skinnedTangent = skinMatrix * vec4( tangent.xyz, 0.0 );",
					"vTangent = normalize( normalMatrix * skinnedTangent.xyz );",

				"#else",

					"vNormal = normalize( normalMatrix * normal );",
					"vTangent = normalize( normalMatrix * tangent.xyz );",

				"#endif",

				"vBinormal = normalize( cross( vNormal, vTangent ) * tangent.w );",

				"vUv = uv * uRepeat + uOffset;",

				// displacement mapping

				"vec3 displacedPosition;",

				"#ifdef VERTEX_TEXTURES",

					"if ( enableDisplacement ) {",

						"vec3 dv = texture2D( tDisplacement, uv ).xyz;",
						"float df = uDisplacementScale * dv.x + uDisplacementBias;",
						"displacedPosition = position + normalize( normal ) * df;",

					"} else {",

						"#ifdef USE_SKINNING",

							"vec4 skinVertex = vec4( position, 1.0 );",

							"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
							"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

							"displacedPosition  = skinned.xyz;",

						"#else",

							"displacedPosition = position;",

						"#endif",

					"}",

				"#else",

					"#ifdef USE_SKINNING",

						"vec4 skinVertex = vec4( position, 1.0 );",

						"vec4 skinned  = boneMatX * skinVertex * skinWeight.x;",
						"skinned 	  += boneMatY * skinVertex * skinWeight.y;",

						"displacedPosition  = skinned.xyz;",

					"#else",

						"displacedPosition = position;",

					"#endif",

				"#endif",

				//

				"vec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );",
				"vec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );",

				"gl_Position = projectionMatrix * mvPosition;",

				//

				"vWorldPosition = worldPosition.xyz;",
				"vViewPosition = -mvPosition.xyz;",

				// shadows

				"#ifdef USE_SHADOWMAP",

					"for( int i = 0; i < MAX_SHADOWS; i ++ ) {",

						"vShadowCoord[ i ] = shadowMatrix[ i ] * worldPosition;",

					"}",

				"#endif",

			"}"

		].join("\n")

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	'cube': {

		uniforms: { "tCube": { type: "t", value: null },
					"tFlip": { type: "f", value: -1 } },

		vertexShader: [

			"varying vec3 vWorldPosition;",

			"void main() {",

				"vec4 worldPosition = modelMatrix * vec4( position, 1.0 );",
				"vWorldPosition = worldPosition.xyz;",

				"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join("\n"),

		fragmentShader: [

			"uniform samplerCube tCube;",
			"uniform float tFlip;",

			"varying vec3 vWorldPosition;",

			"void main() {",

				"gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );",

			"}"

		].join("\n")

	},

	// Depth encoding into RGBA texture
	// 	based on SpiderGL shadow map example
	// 		http://spidergl.org/example.php?id=6
	// 	originally from
	//		http://www.gamedev.net/topic/442138-packing-a-float-into-a-a8r8g8b8-texture-shader/page__whichpage__1%25EF%25BF%25BD
	// 	see also here:
	//		http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/

	'depthRGBA': {

		uniforms: {},

		vertexShader: [

			THREE.ShaderChunk[ "morphtarget_pars_vertex" ],
			THREE.ShaderChunk[ "skinning_pars_vertex" ],

			"void main() {",

				THREE.ShaderChunk[ "skinbase_vertex" ],
				THREE.ShaderChunk[ "morphtarget_vertex" ],
				THREE.ShaderChunk[ "skinning_vertex" ],
				THREE.ShaderChunk[ "default_vertex" ],

			"}"

		].join("\n"),

		fragmentShader: [

			"vec4 pack_depth( const in float depth ) {",

				"const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );",
				"const vec4 bit_mask  = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );",
				"vec4 res = fract( depth * bit_shift );",
				"res -= res.xxyz * bit_mask;",
				"return res;",

			"}",

			"void main() {",

				"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );",

				//"gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z / gl_FragCoord.w );",
				//"float z = ( ( gl_FragCoord.z / gl_FragCoord.w ) - 3.0 ) / ( 4000.0 - 3.0 );",
				//"gl_FragData[ 0 ] = pack_depth( z );",
				//"gl_FragData[ 0 ] = vec4( z, z, z, 1.0 );",

			"}"

		].join("\n")

	}

};

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

THREE.WebGLRenderer = function ( parameters ) {

	console.log( 'THREE.WebGLRenderer', THREE.REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),
	_context = parameters.context !== undefined ? parameters.context : null,

	_precision = parameters.precision !== undefined ? parameters.precision : 'highp',

	_buffers = {},

	_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
	_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
	_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
	_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
	_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,

	_clearColor = new THREE.Color( 0x000000 ),
	_clearAlpha = 0;

	// public properties

	this.domElement = _canvas;
	this.context = null;
	this.devicePixelRatio = parameters.devicePixelRatio !== undefined
				? parameters.devicePixelRatio
				: self.devicePixelRatio !== undefined
					? self.devicePixelRatio
					: 1;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;
	this.autoUpdateObjects = true;

	// physically based shading

	this.gammaInput = false;
	this.gammaOutput = false;

	// shadow map

	this.shadowMapEnabled = false;
	this.shadowMapAutoUpdate = true;
	this.shadowMapType = THREE.PCFShadowMap;
	this.shadowMapCullFace = THREE.CullFaceFront;
	this.shadowMapDebug = false;
	this.shadowMapCascade = false;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// flags

	this.autoScaleCubemaps = true;

	// custom render plugins

	this.renderPluginsPre = [];
	this.renderPluginsPost = [];

	// info

	this.info = {

		memory: {

			programs: 0,
			geometries: 0,
			textures: 0

		},

		render: {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		}

	};

	// internal properties

	var _this = this,

	_programs = [],
	_programs_counter = 0,

	// internal state cache

	_currentProgram = null,
	_currentFramebuffer = null,
	_currentMaterialId = -1,
	_currentGeometryGroupHash = null,
	_currentCamera = null,

	_usedTextureUnits = 0,

	// GL state cache

	_oldDoubleSided = -1,
	_oldFlipSided = -1,

	_oldBlending = -1,

	_oldBlendEquation = -1,
	_oldBlendSrc = -1,
	_oldBlendDst = -1,

	_oldDepthTest = -1,
	_oldDepthWrite = -1,

	_oldPolygonOffset = null,
	_oldPolygonOffsetFactor = null,
	_oldPolygonOffsetUnits = null,

	_oldLineWidth = null,

	_viewportX = 0,
	_viewportY = 0,
	_viewportWidth = _canvas.width,
	_viewportHeight = _canvas.height,
	_currentWidth = 0,
	_currentHeight = 0,

	_enabledAttributes = new Uint8Array( 16 ),

	// frustum

	_frustum = new THREE.Frustum(),

	 // camera matrices cache

	_projScreenMatrix = new THREE.Matrix4(),
	_projScreenMatrixPS = new THREE.Matrix4(),

	_vector3 = new THREE.Vector3(),

	// light arrays cache

	_direction = new THREE.Vector3(),

	_lightsNeedUpdate = true,

	_lights = {

		ambient: [ 0, 0, 0 ],
		directional: { length: 0, colors: new Array(), positions: new Array() },
		point: { length: 0, colors: new Array(), positions: new Array(), distances: new Array() },
		spot: { length: 0, colors: new Array(), positions: new Array(), distances: new Array(), directions: new Array(), anglesCos: new Array(), exponents: new Array() },
		hemi: { length: 0, skyColors: new Array(), groundColors: new Array(), positions: new Array() }

	};

	// initialize

	var _gl;

	var _glExtensionTextureFloat;
	var _glExtensionTextureFloatLinear;
	var _glExtensionStandardDerivatives;
	var _glExtensionTextureFilterAnisotropic;
	var _glExtensionCompressedTextureS3TC;

	initGL();

	setDefaultGLState();

	this.context = _gl;

	// GPU capabilities

	var _maxTextures = _gl.getParameter( _gl.MAX_TEXTURE_IMAGE_UNITS );
	var _maxVertexTextures = _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var _maxTextureSize = _gl.getParameter( _gl.MAX_TEXTURE_SIZE );
	var _maxCubemapSize = _gl.getParameter( _gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var _maxAnisotropy = _glExtensionTextureFilterAnisotropic ? _gl.getParameter( _glExtensionTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT ) : 0;

	var _supportsVertexTextures = ( _maxVertexTextures > 0 );
	var _supportsBoneTextures = _supportsVertexTextures && _glExtensionTextureFloat;

	var _compressedTextureFormats = _glExtensionCompressedTextureS3TC ? _gl.getParameter( _gl.COMPRESSED_TEXTURE_FORMATS ) : [];

	//

	var _vertexShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_FLOAT );
	var _vertexShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_FLOAT );
	var _vertexShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_FLOAT );

	var _fragmentShaderPrecisionHighpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_FLOAT );
	var _fragmentShaderPrecisionMediumpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_FLOAT );
	var _fragmentShaderPrecisionLowpFloat = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_FLOAT );

	var _vertexShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.HIGH_INT );
	var _vertexShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.MEDIUM_INT );
	var _vertexShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.VERTEX_SHADER, _gl.LOW_INT );

	var _fragmentShaderPrecisionHighpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.HIGH_INT );
	var _fragmentShaderPrecisionMediumpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.MEDIUM_INT );
	var _fragmentShaderPrecisionLowpInt = _gl.getShaderPrecisionFormat( _gl.FRAGMENT_SHADER, _gl.LOW_INT );

	// clamp precision to maximum available

	var highpAvailable = _vertexShaderPrecisionHighpFloat.precision > 0 && _fragmentShaderPrecisionHighpFloat.precision > 0;
	var mediumpAvailable = _vertexShaderPrecisionMediumpFloat.precision > 0 && _fragmentShaderPrecisionMediumpFloat.precision > 0;

	if ( _precision === "highp" && ! highpAvailable ) {

		if ( mediumpAvailable ) {

			_precision = "mediump";
			console.warn( "WebGLRenderer: highp not supported, using mediump" );

		} else {

			_precision = "lowp";
			console.warn( "WebGLRenderer: highp and mediump not supported, using lowp" );

		}

	}

	if ( _precision === "mediump" && ! mediumpAvailable ) {

		_precision = "lowp";
		console.warn( "WebGLRenderer: mediump not supported, using lowp" );

	}

	// API

	this.getContext = function () {

		return _gl;

	};

	this.supportsVertexTextures = function () {

		return _supportsVertexTextures;

	};

	this.supportsFloatTextures = function () {

		return _glExtensionTextureFloat;

	};

	this.supportsStandardDerivatives = function () {

		return _glExtensionStandardDerivatives;

	};

	this.supportsCompressedTextureS3TC = function () {

		return _glExtensionCompressedTextureS3TC;

	};

	this.getMaxAnisotropy  = function () {

		return _maxAnisotropy;

	};

	this.getPrecision = function () {

		return _precision;

	};

	this.setSize = function ( width, height, updateStyle ) {

		_canvas.width = width * this.devicePixelRatio;
		_canvas.height = height * this.devicePixelRatio;

		if ( this.devicePixelRatio !== 1 && updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		_viewportX = x * this.devicePixelRatio;
		_viewportY = y * this.devicePixelRatio;

		_viewportWidth = width * this.devicePixelRatio;
		_viewportHeight = height * this.devicePixelRatio;

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );

	};

	this.setScissor = function ( x, y, width, height ) {

		_gl.scissor(
			x * this.devicePixelRatio,
			y * this.devicePixelRatio,
			width * this.devicePixelRatio,
			height * this.devicePixelRatio
		);

	};

	this.enableScissorTest = function ( enable ) {

		enable ? _gl.enable( _gl.SCISSOR_TEST ) : _gl.disable( _gl.SCISSOR_TEST );

	};

	// Clearing

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );
		_clearAlpha = alpha !== undefined ? alpha : 1;

		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	this.setClearColorHex = function ( hex, alpha ) {

		console.warn( 'DEPRECATED: .setClearColorHex() is being removed. Use .setClearColor() instead.' );
		this.setClearColor( hex, alpha );

	};

	this.getClearColor = function () {

		return _clearColor;

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		_gl.clear( _gl.COLOR_BUFFER_BIT );

	};

	this.clearDepth = function () {

		_gl.clear( _gl.DEPTH_BUFFER_BIT );

	};

	this.clearStencil = function () {

		_gl.clear( _gl.STENCIL_BUFFER_BIT );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Plugins

	this.addPostPlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPost.push( plugin );

	};

	this.addPrePlugin = function ( plugin ) {

		plugin.init( this );
		this.renderPluginsPre.push( plugin );

	};

	// Rendering

	this.updateShadowMap = function ( scene, camera ) {

		_currentProgram = null;
		_oldBlending = -1;
		_oldDepthTest = -1;
		_oldDepthWrite = -1;
		_currentGeometryGroupHash = -1;
		_currentMaterialId = -1;
		_lightsNeedUpdate = true;
		_oldDoubleSided = -1;
		_oldFlipSided = -1;

		this.shadowMapPlugin.update( scene, camera );

	};

	// Internal functions

	// Buffer allocation

	function createParticleBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createLineBuffers ( geometry ) {

		geometry.__webglVertexBuffer = _gl.createBuffer();
		geometry.__webglColorBuffer = _gl.createBuffer();
		geometry.__webglLineDistanceBuffer = _gl.createBuffer();

		_this.info.memory.geometries ++;

	};

	function createMeshBuffers ( geometryGroup ) {

		geometryGroup.__webglVertexBuffer = _gl.createBuffer();
		geometryGroup.__webglNormalBuffer = _gl.createBuffer();
		geometryGroup.__webglTangentBuffer = _gl.createBuffer();
		geometryGroup.__webglColorBuffer = _gl.createBuffer();
		geometryGroup.__webglUVBuffer = _gl.createBuffer();
		geometryGroup.__webglUV2Buffer = _gl.createBuffer();

		geometryGroup.__webglSkinIndicesBuffer = _gl.createBuffer();
		geometryGroup.__webglSkinWeightsBuffer = _gl.createBuffer();

		geometryGroup.__webglFaceBuffer = _gl.createBuffer();
		geometryGroup.__webglLineBuffer = _gl.createBuffer();

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__webglMorphTargetsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__webglMorphTargetsBuffers.push( _gl.createBuffer() );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__webglMorphNormalsBuffers = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__webglMorphNormalsBuffers.push( _gl.createBuffer() );

			}

		}

		_this.info.memory.geometries ++;

	};

	// Events

	var onGeometryDispose = function ( event ) {

		var geometry = event.target;

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		deallocateGeometry( geometry );

	};

	var onTextureDispose = function ( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_this.info.memory.textures --;


	};

	var onRenderTargetDispose = function ( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_this.info.memory.textures --;

	};

	var onMaterialDispose = function ( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	};

	// Buffer deallocation

	var deleteBuffers = function ( geometry ) {

		if ( geometry.__webglVertexBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglVertexBuffer );
		if ( geometry.__webglNormalBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglNormalBuffer );
		if ( geometry.__webglTangentBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglTangentBuffer );
		if ( geometry.__webglColorBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglColorBuffer );
		if ( geometry.__webglUVBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglUVBuffer );
		if ( geometry.__webglUV2Buffer !== undefined ) _gl.deleteBuffer( geometry.__webglUV2Buffer );

		if ( geometry.__webglSkinIndicesBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinIndicesBuffer );
		if ( geometry.__webglSkinWeightsBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglSkinWeightsBuffer );

		if ( geometry.__webglFaceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglFaceBuffer );
		if ( geometry.__webglLineBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineBuffer );

		if ( geometry.__webglLineDistanceBuffer !== undefined ) _gl.deleteBuffer( geometry.__webglLineDistanceBuffer );
		// custom attributes

		if ( geometry.__webglCustomAttributesList !== undefined ) {

			for ( var id in geometry.__webglCustomAttributesList ) {

				_gl.deleteBuffer( geometry.__webglCustomAttributesList[ id ].buffer );

			}

		}

		_this.info.memory.geometries --;

	};

	var deallocateGeometry = function ( geometry ) {

		geometry.__webglInit = undefined;

		if ( geometry instanceof THREE.BufferGeometry ) {

			var attributes = geometry.attributes;

			for ( var key in attributes ) {

				if ( attributes[ key ].buffer !== undefined ) {

					_gl.deleteBuffer( attributes[ key ].buffer );
		
				}

			}

			_this.info.memory.geometries --;

		} else {

			if ( geometry.geometryGroups !== undefined ) {

				for ( var g in geometry.geometryGroups ) {

					var geometryGroup = geometry.geometryGroups[ g ];

					if ( geometryGroup.numMorphTargets !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphTargetsBuffers[ m ] );

						}

					}

					if ( geometryGroup.numMorphNormals !== undefined ) {

						for ( var m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

							_gl.deleteBuffer( geometryGroup.__webglMorphNormalsBuffers[ m ] );

						}

					}

					deleteBuffers( geometryGroup );

				}

			} else {

				deleteBuffers( geometry );

			}

		}

	};

	var deallocateTexture = function ( texture ) {

		if ( texture.image && texture.image.__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( texture.image.__webglTextureCube );

		} else {

			// 2D texture

			if ( ! texture.__webglInit ) return;

			texture.__webglInit = false;
			_gl.deleteTexture( texture.__webglTexture );

		}

	};

	var deallocateRenderTarget = function ( renderTarget ) {

		if ( !renderTarget || ! renderTarget.__webglTexture ) return;

		_gl.deleteTexture( renderTarget.__webglTexture );

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTarget.__webglFramebuffer[ i ] );
				_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTarget.__webglFramebuffer );
			_gl.deleteRenderbuffer( renderTarget.__webglRenderbuffer );

		}

	};

	var deallocateMaterial = function ( material ) {

		var program = material.program;

		if ( program === undefined ) return;

		material.program = undefined;

		// only deallocate GL program if this was the last use of shared program
		// assumed there is only single copy of any program in the _programs list
		// (that's how it's constructed)

		var i, il, programInfo;
		var deleteProgram = false;

		for ( i = 0, il = _programs.length; i < il; i ++ ) {

			programInfo = _programs[ i ];

			if ( programInfo.program === program ) {

				programInfo.usedTimes --;

				if ( programInfo.usedTimes === 0 ) {

					deleteProgram = true;

				}

				break;

			}

		}

		if ( deleteProgram === true ) {

			// avoid using array.splice, this is costlier than creating new array from scratch

			var newPrograms = [];

			for ( i = 0, il = _programs.length; i < il; i ++ ) {

				programInfo = _programs[ i ];

				if ( programInfo.program !== program ) {

					newPrograms.push( programInfo );

				}

			}

			_programs = newPrograms;

			_gl.deleteProgram( program );

			_this.info.memory.programs --;

		}

	};

	// Buffer initialization

	function initCustomAttributes ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		var material = object.material;

		if ( material.attributes ) {

			if ( geometry.__webglCustomAttributesList === undefined ) {

				geometry.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				var attribute = material.attributes[ a ];

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if ( attribute.type === "v2" ) size = 2;
					else if ( attribute.type === "v3" ) size = 3;
					else if ( attribute.type === "v4" ) size = 4;
					else if ( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					attribute.needsUpdate = true;

				}

				geometry.__webglCustomAttributesList.push( attribute );

			}

		}

	};

	function initParticleBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );

		geometry.__sortArray = [];

		geometry.__webglParticleCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initLineBuffers ( geometry, object ) {

		var nvertices = geometry.vertices.length;

		geometry.__vertexArray = new Float32Array( nvertices * 3 );
		geometry.__colorArray = new Float32Array( nvertices * 3 );
		geometry.__lineDistanceArray = new Float32Array( nvertices * 1 );

		geometry.__webglLineCount = nvertices;

		initCustomAttributes ( geometry, object );

	};

	function initMeshBuffers ( geometryGroup, object ) {

		var geometry = object.geometry,
			faces3 = geometryGroup.faces3,

			nvertices = faces3.length * 3,
			ntris     = faces3.length * 1,
			nlines    = faces3.length * 3,

			material = getBufferMaterial( object, geometryGroup ),

			uvType = bufferGuessUVType( material ),
			normalType = bufferGuessNormalType( material ),
			vertexColorType = bufferGuessVertexColorType( material );

		// console.log( "uvType", uvType, "normalType", normalType, "vertexColorType", vertexColorType, object, geometryGroup, material );

		geometryGroup.__vertexArray = new Float32Array( nvertices * 3 );

		if ( normalType ) {

			geometryGroup.__normalArray = new Float32Array( nvertices * 3 );

		}

		if ( geometry.hasTangents ) {

			geometryGroup.__tangentArray = new Float32Array( nvertices * 4 );

		}

		if ( vertexColorType ) {

			geometryGroup.__colorArray = new Float32Array( nvertices * 3 );

		}

		if ( uvType ) {

			if ( geometry.faceVertexUvs.length > 0 ) {

				geometryGroup.__uvArray = new Float32Array( nvertices * 2 );

			}

			if ( geometry.faceVertexUvs.length > 1 ) {

				geometryGroup.__uv2Array = new Float32Array( nvertices * 2 );

			}

		}

		if ( object.geometry.skinWeights.length && object.geometry.skinIndices.length ) {

			geometryGroup.__skinIndexArray = new Float32Array( nvertices * 4 );
			geometryGroup.__skinWeightArray = new Float32Array( nvertices * 4 );

		}

		geometryGroup.__faceArray = new Uint16Array( ntris * 3 );
		geometryGroup.__lineArray = new Uint16Array( nlines * 2 );

		var m, ml;

		if ( geometryGroup.numMorphTargets ) {

			geometryGroup.__morphTargetsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphTargets; m < ml; m ++ ) {

				geometryGroup.__morphTargetsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		if ( geometryGroup.numMorphNormals ) {

			geometryGroup.__morphNormalsArrays = [];

			for ( m = 0, ml = geometryGroup.numMorphNormals; m < ml; m ++ ) {

				geometryGroup.__morphNormalsArrays.push( new Float32Array( nvertices * 3 ) );

			}

		}

		geometryGroup.__webglFaceCount = ntris * 3;
		geometryGroup.__webglLineCount = nlines * 2;


		// custom attributes

		if ( material.attributes ) {

			if ( geometryGroup.__webglCustomAttributesList === undefined ) {

				geometryGroup.__webglCustomAttributesList = [];

			}

			for ( var a in material.attributes ) {

				// Do a shallow copy of the attribute object so different geometryGroup chunks use different
				// attribute buffers which are correctly indexed in the setMeshBuffers function

				var originalAttribute = material.attributes[ a ];

				var attribute = {};

				for ( var property in originalAttribute ) {

					attribute[ property ] = originalAttribute[ property ];

				}

				if ( !attribute.__webglInitialized || attribute.createUniqueBuffers ) {

					attribute.__webglInitialized = true;

					var size = 1;		// "f" and "i"

					if( attribute.type === "v2" ) size = 2;
					else if( attribute.type === "v3" ) size = 3;
					else if( attribute.type === "v4" ) size = 4;
					else if( attribute.type === "c"  ) size = 3;

					attribute.size = size;

					attribute.array = new Float32Array( nvertices * size );

					attribute.buffer = _gl.createBuffer();
					attribute.buffer.belongsToAttribute = a;

					originalAttribute.needsUpdate = true;
					attribute.__original = originalAttribute;

				}

				geometryGroup.__webglCustomAttributesList.push( attribute );

			}

		}

		geometryGroup.__inittedArrays = true;

	};

	function getBufferMaterial( object, geometryGroup ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ geometryGroup.materialIndex ]
			: object.material;

	};

	function materialNeedsSmoothNormals ( material ) {

		return material && material.shading !== undefined && material.shading === THREE.SmoothShading;

	};

	function bufferGuessNormalType ( material ) {

		// only MeshBasicMaterial and MeshDepthMaterial don't need normals

		if ( ( material instanceof THREE.MeshBasicMaterial && !material.envMap ) || material instanceof THREE.MeshDepthMaterial ) {

			return false;

		}

		if ( materialNeedsSmoothNormals( material ) ) {

			return THREE.SmoothShading;

		} else {

			return THREE.FlatShading;

		}

	};

	function bufferGuessVertexColorType( material ) {

		if ( material.vertexColors ) {

			return material.vertexColors;

		}

		return false;

	};

	function bufferGuessUVType( material ) {

		// material must use some texture to require uvs

		if ( material.map ||
		     material.lightMap ||
		     material.bumpMap ||
		     material.normalMap ||
		     material.specularMap ||
		     material instanceof THREE.ShaderMaterial ) {

			return true;

		}

		return false;

	};

	//

	function initDirectBuffers( geometry ) {

		var a, attribute, type;

		for ( a in geometry.attributes ) {

			if ( a === "index" ) {

				type = _gl.ELEMENT_ARRAY_BUFFER;

			} else {

				type = _gl.ARRAY_BUFFER;

			}

			attribute = geometry.attributes[ a ];

			attribute.buffer = _gl.createBuffer();

			_gl.bindBuffer( type, attribute.buffer );
			_gl.bufferData( type, attribute.array, _gl.STATIC_DRAW );

		}

	};

	// Buffer setting

	function setParticleBuffers ( geometry, hint, object ) {

		var v, c, vertex, offset, index, color,

		vertices = geometry.vertices,
		vl = vertices.length,

		colors = geometry.colors,
		cl = colors.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,

		sortArray = geometry.__sortArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,
		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( object.sortParticles ) {

			_projScreenMatrixPS.copy( _projScreenMatrix );
			_projScreenMatrixPS.multiply( object.matrixWorld );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				_vector3.copy( vertex );
				_vector3.applyProjection( _projScreenMatrixPS );

				sortArray[ v ] = [ _vector3.z, v ];

			}

			sortArray.sort( numericalSort );

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ sortArray[v][1] ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			for ( c = 0; c < cl; c ++ ) {

				offset = c * 3;

				color = colors[ sortArray[c][1] ];

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( ! ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) ) continue;

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							customAttribute.array[ ca ] = customAttribute.value[ index ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ]     = value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								index = sortArray[ ca ][ 1 ];

								value = customAttribute.value[ index ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							index = sortArray[ ca ][ 1 ];

							value = customAttribute.value[ index ];

							customAttribute.array[ offset ]      = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

				}

			}

		} else {

			if ( dirtyVertices ) {

				for ( v = 0; v < vl; v ++ ) {

					vertex = vertices[ v ];

					offset = v * 3;

					vertexArray[ offset ]     = vertex.x;
					vertexArray[ offset + 1 ] = vertex.y;
					vertexArray[ offset + 2 ] = vertex.z;

				}

			}

			if ( dirtyColors ) {

				for ( c = 0; c < cl; c ++ ) {

					color = colors[ c ];

					offset = c * 3;

					colorArray[ offset ]     = color.r;
					colorArray[ offset + 1 ] = color.g;
					colorArray[ offset + 2 ] = color.b;

				}

			}

			if ( customAttributes ) {

				for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

					customAttribute = customAttributes[ i ];

					if ( customAttribute.needsUpdate &&
						 ( customAttribute.boundTo === undefined ||
						   customAttribute.boundTo === "vertices") ) {

						cal = customAttribute.value.length;

						offset = 0;

						if ( customAttribute.size === 1 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								customAttribute.array[ ca ] = customAttribute.value[ ca ];

							}

						} else if ( customAttribute.size === 2 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;

								offset += 2;

							}

						} else if ( customAttribute.size === 3 ) {

							if ( customAttribute.type === "c" ) {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.r;
									customAttribute.array[ offset + 1 ] = value.g;
									customAttribute.array[ offset + 2 ] = value.b;

									offset += 3;

								}

							} else {

								for ( ca = 0; ca < cal; ca ++ ) {

									value = customAttribute.value[ ca ];

									customAttribute.array[ offset ] 	= value.x;
									customAttribute.array[ offset + 1 ] = value.y;
									customAttribute.array[ offset + 2 ] = value.z;

									offset += 3;

								}

							}

						} else if ( customAttribute.size === 4 ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ]      = value.x;
								customAttribute.array[ offset + 1  ] = value.y;
								customAttribute.array[ offset + 2  ] = value.z;
								customAttribute.array[ offset + 3  ] = value.w;

								offset += 4;

							}

						}

					}

				}

			}

		}

		if ( dirtyVertices || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors || object.sortParticles ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate || object.sortParticles ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}


	};

	function setLineBuffers ( geometry, hint ) {

		var v, c, d, vertex, offset, color,

		vertices = geometry.vertices,
		colors = geometry.colors,
		lineDistances = geometry.lineDistances,

		vl = vertices.length,
		cl = colors.length,
		dl = lineDistances.length,

		vertexArray = geometry.__vertexArray,
		colorArray = geometry.__colorArray,
		lineDistanceArray = geometry.__lineDistanceArray,

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyLineDistances = geometry.lineDistancesNeedUpdate,

		customAttributes = geometry.__webglCustomAttributesList,

		i, il,
		a, ca, cal, value,
		customAttribute;

		if ( dirtyVertices ) {

			for ( v = 0; v < vl; v ++ ) {

				vertex = vertices[ v ];

				offset = v * 3;

				vertexArray[ offset ]     = vertex.x;
				vertexArray[ offset + 1 ] = vertex.y;
				vertexArray[ offset + 2 ] = vertex.z;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyColors ) {

			for ( c = 0; c < cl; c ++ ) {

				color = colors[ c ];

				offset = c * 3;

				colorArray[ offset ]     = color.r;
				colorArray[ offset + 1 ] = color.g;
				colorArray[ offset + 2 ] = color.b;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

		}

		if ( dirtyLineDistances ) {

			for ( d = 0; d < dl; d ++ ) {

				lineDistanceArray[ d ] = lineDistances[ d ];

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometry.__webglLineDistanceBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, lineDistanceArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( customAttribute.needsUpdate &&
					 ( customAttribute.boundTo === undefined ||
					   customAttribute.boundTo === "vertices" ) ) {

					offset = 0;

					cal = customAttribute.value.length;

					if ( customAttribute.size === 1 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							customAttribute.array[ ca ] = customAttribute.value[ ca ];

						}

					} else if ( customAttribute.size === 2 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	= value.x;
							customAttribute.array[ offset + 1 ] = value.y;

							offset += 2;

						}

					} else if ( customAttribute.size === 3 ) {

						if ( customAttribute.type === "c" ) {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.r;
								customAttribute.array[ offset + 1 ] = value.g;
								customAttribute.array[ offset + 2 ] = value.b;

								offset += 3;

							}

						} else {

							for ( ca = 0; ca < cal; ca ++ ) {

								value = customAttribute.value[ ca ];

								customAttribute.array[ offset ] 	= value.x;
								customAttribute.array[ offset + 1 ] = value.y;
								customAttribute.array[ offset + 2 ] = value.z;

								offset += 3;

							}

						}

					} else if ( customAttribute.size === 4 ) {

						for ( ca = 0; ca < cal; ca ++ ) {

							value = customAttribute.value[ ca ];

							customAttribute.array[ offset ] 	 = value.x;
							customAttribute.array[ offset + 1  ] = value.y;
							customAttribute.array[ offset + 2  ] = value.z;
							customAttribute.array[ offset + 3  ] = value.w;

							offset += 4;

						}

					}

					_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

				}

			}

		}

	};

	function setMeshBuffers( geometryGroup, object, hint, dispose, material ) {

		if ( ! geometryGroup.__inittedArrays ) {

			return;

		}

		var normalType = bufferGuessNormalType( material ),
		vertexColorType = bufferGuessVertexColorType( material ),
		uvType = bufferGuessUVType( material ),

		needsSmoothNormals = ( normalType === THREE.SmoothShading );

		var f, fl, fi, face,
		vertexNormals, faceNormal, normal,
		vertexColors, faceColor,
		vertexTangents,
		uv, uv2, v1, v2, v3, v4, t1, t2, t3, t4, n1, n2, n3, n4,
		c1, c2, c3, c4,
		sw1, sw2, sw3, sw4,
		si1, si2, si3, si4,
		sa1, sa2, sa3, sa4,
		sb1, sb2, sb3, sb4,
		m, ml, i, il,
		vn, uvi, uv2i,
		vk, vkl, vka,
		nka, chf, faceVertexNormals,
		a,

		vertexIndex = 0,

		offset = 0,
		offset_uv = 0,
		offset_uv2 = 0,
		offset_face = 0,
		offset_normal = 0,
		offset_tangent = 0,
		offset_line = 0,
		offset_color = 0,
		offset_skin = 0,
		offset_morphTarget = 0,
		offset_custom = 0,
		offset_customSrc = 0,

		value,

		vertexArray = geometryGroup.__vertexArray,
		uvArray = geometryGroup.__uvArray,
		uv2Array = geometryGroup.__uv2Array,
		normalArray = geometryGroup.__normalArray,
		tangentArray = geometryGroup.__tangentArray,
		colorArray = geometryGroup.__colorArray,

		skinIndexArray = geometryGroup.__skinIndexArray,
		skinWeightArray = geometryGroup.__skinWeightArray,

		morphTargetsArrays = geometryGroup.__morphTargetsArrays,
		morphNormalsArrays = geometryGroup.__morphNormalsArrays,

		customAttributes = geometryGroup.__webglCustomAttributesList,
		customAttribute,

		faceArray = geometryGroup.__faceArray,
		lineArray = geometryGroup.__lineArray,

		geometry = object.geometry, // this is shared for all chunks

		dirtyVertices = geometry.verticesNeedUpdate,
		dirtyElements = geometry.elementsNeedUpdate,
		dirtyUvs = geometry.uvsNeedUpdate,
		dirtyNormals = geometry.normalsNeedUpdate,
		dirtyTangents = geometry.tangentsNeedUpdate,
		dirtyColors = geometry.colorsNeedUpdate,
		dirtyMorphTargets = geometry.morphTargetsNeedUpdate,

		vertices = geometry.vertices,
		chunk_faces3 = geometryGroup.faces3,
		obj_faces = geometry.faces,

		obj_uvs  = geometry.faceVertexUvs[ 0 ],
		obj_uvs2 = geometry.faceVertexUvs[ 1 ],

		obj_colors = geometry.colors,

		obj_skinIndices = geometry.skinIndices,
		obj_skinWeights = geometry.skinWeights,

		morphTargets = geometry.morphTargets,
		morphNormals = geometry.morphNormals;

		if ( dirtyVertices ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ] ];

				v1 = vertices[ face.a ];
				v2 = vertices[ face.b ];
				v3 = vertices[ face.c ];

				vertexArray[ offset ]     = v1.x;
				vertexArray[ offset + 1 ] = v1.y;
				vertexArray[ offset + 2 ] = v1.z;

				vertexArray[ offset + 3 ] = v2.x;
				vertexArray[ offset + 4 ] = v2.y;
				vertexArray[ offset + 5 ] = v2.z;

				vertexArray[ offset + 6 ] = v3.x;
				vertexArray[ offset + 7 ] = v3.y;
				vertexArray[ offset + 8 ] = v3.z;

				offset += 9;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, vertexArray, hint );

		}

		if ( dirtyMorphTargets ) {

			for ( vk = 0, vkl = morphTargets.length; vk < vkl; vk ++ ) {

				offset_morphTarget = 0;

				for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

					chf = chunk_faces3[ f ];
					face = obj_faces[ chf ];

					// morph positions

					v1 = morphTargets[ vk ].vertices[ face.a ];
					v2 = morphTargets[ vk ].vertices[ face.b ];
					v3 = morphTargets[ vk ].vertices[ face.c ];

					vka = morphTargetsArrays[ vk ];

					vka[ offset_morphTarget ] 	  = v1.x;
					vka[ offset_morphTarget + 1 ] = v1.y;
					vka[ offset_morphTarget + 2 ] = v1.z;

					vka[ offset_morphTarget + 3 ] = v2.x;
					vka[ offset_morphTarget + 4 ] = v2.y;
					vka[ offset_morphTarget + 5 ] = v2.z;

					vka[ offset_morphTarget + 6 ] = v3.x;
					vka[ offset_morphTarget + 7 ] = v3.y;
					vka[ offset_morphTarget + 8 ] = v3.z;

					// morph normals

					if ( material.morphNormals ) {

						if ( needsSmoothNormals ) {

							faceVertexNormals = morphNormals[ vk ].vertexNormals[ chf ];

							n1 = faceVertexNormals.a;
							n2 = faceVertexNormals.b;
							n3 = faceVertexNormals.c;

						} else {

							n1 = morphNormals[ vk ].faceNormals[ chf ];
							n2 = n1;
							n3 = n1;

						}

						nka = morphNormalsArrays[ vk ];

						nka[ offset_morphTarget ] 	  = n1.x;
						nka[ offset_morphTarget + 1 ] = n1.y;
						nka[ offset_morphTarget + 2 ] = n1.z;

						nka[ offset_morphTarget + 3 ] = n2.x;
						nka[ offset_morphTarget + 4 ] = n2.y;
						nka[ offset_morphTarget + 5 ] = n2.z;

						nka[ offset_morphTarget + 6 ] = n3.x;
						nka[ offset_morphTarget + 7 ] = n3.y;
						nka[ offset_morphTarget + 8 ] = n3.z;

					}

					//

					offset_morphTarget += 9;

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ vk ] );
				_gl.bufferData( _gl.ARRAY_BUFFER, morphTargetsArrays[ vk ], hint );

				if ( material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ vk ] );
					_gl.bufferData( _gl.ARRAY_BUFFER, morphNormalsArrays[ vk ], hint );

				}

			}

		}

		if ( obj_skinWeights.length ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				// weights

				sw1 = obj_skinWeights[ face.a ];
				sw2 = obj_skinWeights[ face.b ];
				sw3 = obj_skinWeights[ face.c ];

				skinWeightArray[ offset_skin ]     = sw1.x;
				skinWeightArray[ offset_skin + 1 ] = sw1.y;
				skinWeightArray[ offset_skin + 2 ] = sw1.z;
				skinWeightArray[ offset_skin + 3 ] = sw1.w;

				skinWeightArray[ offset_skin + 4 ] = sw2.x;
				skinWeightArray[ offset_skin + 5 ] = sw2.y;
				skinWeightArray[ offset_skin + 6 ] = sw2.z;
				skinWeightArray[ offset_skin + 7 ] = sw2.w;

				skinWeightArray[ offset_skin + 8 ]  = sw3.x;
				skinWeightArray[ offset_skin + 9 ]  = sw3.y;
				skinWeightArray[ offset_skin + 10 ] = sw3.z;
				skinWeightArray[ offset_skin + 11 ] = sw3.w;

				// indices

				si1 = obj_skinIndices[ face.a ];
				si2 = obj_skinIndices[ face.b ];
				si3 = obj_skinIndices[ face.c ];

				skinIndexArray[ offset_skin ]     = si1.x;
				skinIndexArray[ offset_skin + 1 ] = si1.y;
				skinIndexArray[ offset_skin + 2 ] = si1.z;
				skinIndexArray[ offset_skin + 3 ] = si1.w;

				skinIndexArray[ offset_skin + 4 ] = si2.x;
				skinIndexArray[ offset_skin + 5 ] = si2.y;
				skinIndexArray[ offset_skin + 6 ] = si2.z;
				skinIndexArray[ offset_skin + 7 ] = si2.w;

				skinIndexArray[ offset_skin + 8 ]  = si3.x;
				skinIndexArray[ offset_skin + 9 ]  = si3.y;
				skinIndexArray[ offset_skin + 10 ] = si3.z;
				skinIndexArray[ offset_skin + 11 ] = si3.w;

				offset_skin += 12;

			}

			if ( offset_skin > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinIndexArray, hint );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, skinWeightArray, hint );

			}

		}

		if ( dirtyColors && vertexColorType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexColors = face.vertexColors;
				faceColor = face.color;

				if ( vertexColors.length === 3 && vertexColorType === THREE.VertexColors ) {

					c1 = vertexColors[ 0 ];
					c2 = vertexColors[ 1 ];
					c3 = vertexColors[ 2 ];

				} else {

					c1 = faceColor;
					c2 = faceColor;
					c3 = faceColor;

				}

				colorArray[ offset_color ]     = c1.r;
				colorArray[ offset_color + 1 ] = c1.g;
				colorArray[ offset_color + 2 ] = c1.b;

				colorArray[ offset_color + 3 ] = c2.r;
				colorArray[ offset_color + 4 ] = c2.g;
				colorArray[ offset_color + 5 ] = c2.b;

				colorArray[ offset_color + 6 ] = c3.r;
				colorArray[ offset_color + 7 ] = c3.g;
				colorArray[ offset_color + 8 ] = c3.b;

				offset_color += 9;

			}

			if ( offset_color > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, colorArray, hint );

			}

		}

		if ( dirtyTangents && geometry.hasTangents ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexTangents = face.vertexTangents;

				t1 = vertexTangents[ 0 ];
				t2 = vertexTangents[ 1 ];
				t3 = vertexTangents[ 2 ];

				tangentArray[ offset_tangent ]     = t1.x;
				tangentArray[ offset_tangent + 1 ] = t1.y;
				tangentArray[ offset_tangent + 2 ] = t1.z;
				tangentArray[ offset_tangent + 3 ] = t1.w;

				tangentArray[ offset_tangent + 4 ] = t2.x;
				tangentArray[ offset_tangent + 5 ] = t2.y;
				tangentArray[ offset_tangent + 6 ] = t2.z;
				tangentArray[ offset_tangent + 7 ] = t2.w;

				tangentArray[ offset_tangent + 8 ]  = t3.x;
				tangentArray[ offset_tangent + 9 ]  = t3.y;
				tangentArray[ offset_tangent + 10 ] = t3.z;
				tangentArray[ offset_tangent + 11 ] = t3.w;

				offset_tangent += 12;

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, tangentArray, hint );

		}

		if ( dirtyNormals && normalType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				face = obj_faces[ chunk_faces3[ f ]	];

				vertexNormals = face.vertexNormals;
				faceNormal = face.normal;

				if ( vertexNormals.length === 3 && needsSmoothNormals ) {

					for ( i = 0; i < 3; i ++ ) {

						vn = vertexNormals[ i ];

						normalArray[ offset_normal ]     = vn.x;
						normalArray[ offset_normal + 1 ] = vn.y;
						normalArray[ offset_normal + 2 ] = vn.z;

						offset_normal += 3;

					}

				} else {

					for ( i = 0; i < 3; i ++ ) {

						normalArray[ offset_normal ]     = faceNormal.x;
						normalArray[ offset_normal + 1 ] = faceNormal.y;
						normalArray[ offset_normal + 2 ] = faceNormal.z;

						offset_normal += 3;

					}

				}

			}

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, normalArray, hint );

		}

		if ( dirtyUvs && obj_uvs && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv = obj_uvs[ fi ];

				if ( uv === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uvi = uv[ i ];

					uvArray[ offset_uv ]     = uvi.x;
					uvArray[ offset_uv + 1 ] = uvi.y;

					offset_uv += 2;

				}

			}

			if ( offset_uv > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uvArray, hint );

			}

		}

		if ( dirtyUvs && obj_uvs2 && uvType ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				fi = chunk_faces3[ f ];

				uv2 = obj_uvs2[ fi ];

				if ( uv2 === undefined ) continue;

				for ( i = 0; i < 3; i ++ ) {

					uv2i = uv2[ i ];

					uv2Array[ offset_uv2 ]     = uv2i.x;
					uv2Array[ offset_uv2 + 1 ] = uv2i.y;

					offset_uv2 += 2;

				}

			}

			if ( offset_uv2 > 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, uv2Array, hint );

			}

		}

		if ( dirtyElements ) {

			for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

				faceArray[ offset_face ] 	 = vertexIndex;
				faceArray[ offset_face + 1 ] = vertexIndex + 1;
				faceArray[ offset_face + 2 ] = vertexIndex + 2;

				offset_face += 3;

				lineArray[ offset_line ]     = vertexIndex;
				lineArray[ offset_line + 1 ] = vertexIndex + 1;

				lineArray[ offset_line + 2 ] = vertexIndex;
				lineArray[ offset_line + 3 ] = vertexIndex + 2;

				lineArray[ offset_line + 4 ] = vertexIndex + 1;
				lineArray[ offset_line + 5 ] = vertexIndex + 2;

				offset_line += 6;

				vertexIndex += 3;

			}

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faceArray, hint );

			_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
			_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, lineArray, hint );

		}

		if ( customAttributes ) {

			for ( i = 0, il = customAttributes.length; i < il; i ++ ) {

				customAttribute = customAttributes[ i ];

				if ( ! customAttribute.__original.needsUpdate ) continue;

				offset_custom = 0;
				offset_customSrc = 0;

				if ( customAttribute.size === 1 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							customAttribute.array[ offset_custom ] 	   = customAttribute.value[ face.a ];
							customAttribute.array[ offset_custom + 1 ] = customAttribute.value[ face.b ];
							customAttribute.array[ offset_custom + 2 ] = customAttribute.value[ face.c ];

							offset_custom += 3;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							customAttribute.array[ offset_custom ] 	   = value;
							customAttribute.array[ offset_custom + 1 ] = value;
							customAttribute.array[ offset_custom + 2 ] = value;

							offset_custom += 3;

						}

					}

				} else if ( customAttribute.size === 2 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1.x;
							customAttribute.array[ offset_custom + 1 ] = v1.y;

							customAttribute.array[ offset_custom + 2 ] = v2.x;
							customAttribute.array[ offset_custom + 3 ] = v2.y;

							customAttribute.array[ offset_custom + 4 ] = v3.x;
							customAttribute.array[ offset_custom + 5 ] = v3.y;

							offset_custom += 6;

						}

					}

				} else if ( customAttribute.size === 3 ) {

					var pp;

					if ( customAttribute.type === "c" ) {

						pp = [ "r", "g", "b" ];

					} else {

						pp = [ "x", "y", "z" ];

					}

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom ] 	   = v1[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 1 ] = v1[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 2 ] = v1[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 3 ] = v2[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 4 ] = v2[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 5 ] = v2[ pp[ 2 ] ];

							customAttribute.array[ offset_custom + 6 ] = v3[ pp[ 0 ] ];
							customAttribute.array[ offset_custom + 7 ] = v3[ pp[ 1 ] ];
							customAttribute.array[ offset_custom + 8 ] = v3[ pp[ 2 ] ];

							offset_custom += 9;

						}

					}

				} else if ( customAttribute.size === 4 ) {

					if ( customAttribute.boundTo === undefined || customAttribute.boundTo === "vertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							face = obj_faces[ chunk_faces3[ f ]	];

							v1 = customAttribute.value[ face.a ];
							v2 = customAttribute.value[ face.b ];
							v3 = customAttribute.value[ face.c ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faces" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value;
							v2 = value;
							v3 = value;

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					} else if ( customAttribute.boundTo === "faceVertices" ) {

						for ( f = 0, fl = chunk_faces3.length; f < fl; f ++ ) {

							value = customAttribute.value[ chunk_faces3[ f ] ];

							v1 = value[ 0 ];
							v2 = value[ 1 ];
							v3 = value[ 2 ];

							customAttribute.array[ offset_custom  ] 	= v1.x;
							customAttribute.array[ offset_custom + 1  ] = v1.y;
							customAttribute.array[ offset_custom + 2  ] = v1.z;
							customAttribute.array[ offset_custom + 3  ] = v1.w;

							customAttribute.array[ offset_custom + 4  ] = v2.x;
							customAttribute.array[ offset_custom + 5  ] = v2.y;
							customAttribute.array[ offset_custom + 6  ] = v2.z;
							customAttribute.array[ offset_custom + 7  ] = v2.w;

							customAttribute.array[ offset_custom + 8  ] = v3.x;
							customAttribute.array[ offset_custom + 9  ] = v3.y;
							customAttribute.array[ offset_custom + 10 ] = v3.z;
							customAttribute.array[ offset_custom + 11 ] = v3.w;

							offset_custom += 12;

						}

					}

				}

				_gl.bindBuffer( _gl.ARRAY_BUFFER, customAttribute.buffer );
				_gl.bufferData( _gl.ARRAY_BUFFER, customAttribute.array, hint );

			}

		}

		if ( dispose ) {

			delete geometryGroup.__inittedArrays;
			delete geometryGroup.__colorArray;
			delete geometryGroup.__normalArray;
			delete geometryGroup.__tangentArray;
			delete geometryGroup.__uvArray;
			delete geometryGroup.__uv2Array;
			delete geometryGroup.__faceArray;
			delete geometryGroup.__vertexArray;
			delete geometryGroup.__lineArray;
			delete geometryGroup.__skinIndexArray;
			delete geometryGroup.__skinWeightArray;

		}

	};

	// used by renderBufferDirect for THREE.Line
	function setupLinesVertexAttributes( material, programAttributes, geometryAttributes, startIndex ) {

		var attributeItem, attributeName, attributePointer, attributeSize;

		for ( attributeName in programAttributes ) {

			attributePointer = programAttributes[ attributeName ];
			attributeItem = geometryAttributes[ attributeName ];
			
			if ( attributePointer >= 0 ) {

				if ( attributeItem ) {

					attributeSize = attributeItem.itemSize;
					_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
					enableAttribute( attributePointer );
					_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32

				} else if ( material.defaultAttributeValues ) {

					if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

						_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

					} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

						_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

					}

				}

			}

		}

	}

	function setDirectBuffers( geometry, hint ) {

		var attributes = geometry.attributes;

		var attributeName, attributeItem;

		for ( attributeName in attributes ) {

			attributeItem = attributes[ attributeName ];

			if ( attributeItem.needsUpdate ) {

				if ( attributeName === 'index' ) {

					_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.buffer );
					_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, attributeItem.array, hint );

				} else {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
					_gl.bufferData( _gl.ARRAY_BUFFER, attributeItem.array, hint );

				}

				attributeItem.needsUpdate = false;

			}

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		if ( object.hasPositions && ! object.__webglVertexBuffer ) object.__webglVertexBuffer = _gl.createBuffer();
		if ( object.hasNormals && ! object.__webglNormalBuffer ) object.__webglNormalBuffer = _gl.createBuffer();
		if ( object.hasUvs && ! object.__webglUvBuffer ) object.__webglUvBuffer = _gl.createBuffer();
		if ( object.hasColors && ! object.__webglColorBuffer ) object.__webglColorBuffer = _gl.createBuffer();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglVertexBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.position );
			_gl.vertexAttribPointer( program.attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglNormalBuffer );

			if ( material.shading === THREE.FlatShading ) {

				var nx, ny, nz,
					nax, nbx, ncx, nay, nby, ncy, naz, nbz, ncz,
					normalArray,
					i, il = object.count * 3;

				for( i = 0; i < il; i += 9 ) {

					normalArray = object.normalArray;

					nax  = normalArray[ i ];
					nay  = normalArray[ i + 1 ];
					naz  = normalArray[ i + 2 ];

					nbx  = normalArray[ i + 3 ];
					nby  = normalArray[ i + 4 ];
					nbz  = normalArray[ i + 5 ];

					ncx  = normalArray[ i + 6 ];
					ncy  = normalArray[ i + 7 ];
					ncz  = normalArray[ i + 8 ];

					nx = ( nax + nbx + ncx ) / 3;
					ny = ( nay + nby + ncy ) / 3;
					nz = ( naz + nbz + ncz ) / 3;

					normalArray[ i ] 	 = nx;
					normalArray[ i + 1 ] = ny;
					normalArray[ i + 2 ] = nz;

					normalArray[ i + 3 ] = nx;
					normalArray[ i + 4 ] = ny;
					normalArray[ i + 5 ] = nz;

					normalArray[ i + 6 ] = nx;
					normalArray[ i + 7 ] = ny;
					normalArray[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.normal );
			_gl.vertexAttribPointer( program.attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglUvBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.uv );
			_gl.vertexAttribPointer( program.attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== THREE.NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, object.__webglColorBuffer );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
			_gl.enableVertexAttribArray( program.attributes.color );
			_gl.vertexAttribPointer( program.attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, lights, fog, material, geometry, object ) {

		if ( material.visible === false ) return;

		var linewidth, a, attribute;
		var attributeItem, attributeName, attributePointer, attributeSize;

		var program = setProgram( camera, lights, fog, material, object );

		var programAttributes = program.attributes;
		var geometryAttributes = geometry.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryHash = ( geometry.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			var index = geometryAttributes[ "index" ];

			// indexed triangles

			if ( index ) {

				var offsets = geometry.offsets;

				// if there is more than 1 chunk
				// must set attribute pointers to use new offsets for each chunk
				// even if geometry and materials didn't change

				if ( offsets.length > 1 ) updateBuffers = true;

				for ( var i = 0, il = offsets.length; i < il; i ++ ) {

					var startIndex = offsets[ i ].index;

					if ( updateBuffers ) {

						for ( attributeName in programAttributes ) {

							attributePointer = programAttributes[ attributeName ];
							attributeItem = geometryAttributes[ attributeName ];

							if ( attributePointer >= 0 ) {

								if ( attributeItem ) {

									attributeSize = attributeItem.itemSize;
									_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
									enableAttribute( attributePointer );
									_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, startIndex * attributeSize * 4 ); // 4 bytes per Float32

								} else if ( material.defaultAttributeValues ) {

									if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

										_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

									} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

										_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

									}

								}

							}

						}

						// indices

						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					// render indexed triangles

					_gl.drawElements( _gl.TRIANGLES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16

					_this.info.render.calls ++;
					_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared
					_this.info.render.faces += offsets[ i ].count / 3;

				}

			// non-indexed triangles

			} else {

				if ( updateBuffers ) {

					for ( attributeName in programAttributes ) {

						if ( attributeName === 'index') continue;

						attributePointer = programAttributes[ attributeName ];
						attributeItem = geometryAttributes[ attributeName ];
						
						if ( attributePointer >= 0 ) {

							if ( attributeItem ) {

								attributeSize = attributeItem.itemSize;
								_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
								enableAttribute( attributePointer );
								_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );

							} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {

								if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

									_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

								} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

									_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

								}

							}

						}

					}

				}

				var position = geometry.attributes[ "position" ];

				// render non-indexed triangles

				_gl.drawArrays( _gl.TRIANGLES, 0, position.array.length / 3 );

				_this.info.render.calls ++;
				_this.info.render.vertices += position.array.length / 3;
				_this.info.render.faces += position.array.length / 3 / 3;

			}

		// render particles

		} else if ( object instanceof THREE.ParticleSystem ) {

			if ( updateBuffers ) {

				for ( attributeName in programAttributes ) {

					attributePointer = programAttributes[ attributeName ];
					attributeItem = geometryAttributes[ attributeName ];
					
					if ( attributePointer >= 0 ) {

						if ( attributeItem ) {

							attributeSize = attributeItem.itemSize;
							_gl.bindBuffer( _gl.ARRAY_BUFFER, attributeItem.buffer );
							enableAttribute( attributePointer );
							_gl.vertexAttribPointer( attributePointer, attributeSize, _gl.FLOAT, false, 0, 0 );

						} else if ( material.defaultAttributeValues && material.defaultAttributeValues[ attributeName ] ) {

							if ( material.defaultAttributeValues[ attributeName ].length === 2 ) {

								_gl.vertexAttrib2fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							} else if ( material.defaultAttributeValues[ attributeName ].length === 3 ) {

								_gl.vertexAttrib3fv( attributePointer, material.defaultAttributeValues[ attributeName ] );

							}

						}

					}

				}

			}

			var position = geometryAttributes[ "position" ];

			// render particles

			_gl.drawArrays( _gl.POINTS, 0, position.array.length / 3 );

			_this.info.render.calls ++;
			_this.info.render.points += position.array.length / 3;

		} else if ( object instanceof THREE.Line ) {

			var primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			var index = geometryAttributes[ "index" ];

			// indexed lines
			
			if ( index ) {

				var offsets = geometry.offsets;

				// if there is more than 1 chunk
				// must set attribute pointers to use new offsets for each chunk
				// even if geometry and materials didn't change

				if ( offsets.length > 1 ) updateBuffers = true;

				for ( var i = 0, il = offsets.length; i < il; i ++ ) {

					var startIndex = offsets[ i ].index;

					if ( updateBuffers ) {

						setupLinesVertexAttributes(material, programAttributes, geometryAttributes, startIndex);

						// indices
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, index.buffer );

					}

					// render indexed lines

					_gl.drawElements( _gl.LINES, offsets[ i ].count, _gl.UNSIGNED_SHORT, offsets[ i ].start * 2 ); // 2 bytes per Uint16Array

					_this.info.render.calls ++;
					_this.info.render.vertices += offsets[ i ].count; // not really true, here vertices can be shared

				}

			}

			// non-indexed lines

			else {

				if ( updateBuffers ) {

					setupLinesVertexAttributes(material, programAttributes, geometryAttributes, 0);
				}

				var position = geometryAttributes[ "position" ];

				_gl.drawArrays( primitives, 0, position.array.length / 3 );
				_this.info.render.calls ++;
				_this.info.render.points += position.array.length;
			}



		}

	};

	this.renderBuffer = function ( camera, lights, fog, material, geometryGroup, object ) {

		if ( material.visible === false ) return;

		var linewidth, a, attribute, i, il;

		var program = setProgram( camera, lights, fog, material, object );

		var attributes = program.attributes;

		var updateBuffers = false,
			wireframeBit = material.wireframe ? 1 : 0,
			geometryGroupHash = ( geometryGroup.id * 0xffffff ) + ( program.id * 2 ) + wireframeBit;

		if ( geometryGroupHash !== _currentGeometryGroupHash ) {

			_currentGeometryGroupHash = geometryGroupHash;
			updateBuffers = true;

		}

		if ( updateBuffers ) {

			disableAttributes();

		}

		// vertices

		if ( !material.morphTargets && attributes.position >= 0 ) {

			if ( updateBuffers ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
				enableAttribute( attributes.position );
				_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

			}

		} else {

			if ( object.morphTargetBase ) {

				setupMorphTargets( material, geometryGroup, object );

			}

		}


		if ( updateBuffers ) {

			// custom attributes

			// Use the per-geometryGroup custom attribute arrays which are setup in initMeshBuffers

			if ( geometryGroup.__webglCustomAttributesList ) {

				for ( i = 0, il = geometryGroup.__webglCustomAttributesList.length; i < il; i ++ ) {

					attribute = geometryGroup.__webglCustomAttributesList[ i ];

					if ( attributes[ attribute.buffer.belongsToAttribute ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, attribute.buffer );
						enableAttribute( attributes[ attribute.buffer.belongsToAttribute ] );
						_gl.vertexAttribPointer( attributes[ attribute.buffer.belongsToAttribute ], attribute.size, _gl.FLOAT, false, 0, 0 );

					}

				}

			}


			// colors

			if ( attributes.color >= 0 ) {

				if ( object.geometry.colors.length > 0 || object.geometry.faces.length > 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglColorBuffer );
					enableAttribute( attributes.color );
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib3fv( attributes.color, material.defaultAttributeValues.color );

				}

			}

			// normals

			if ( attributes.normal >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglNormalBuffer );
				enableAttribute( attributes.normal );
				_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

			}

			// tangents

			if ( attributes.tangent >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglTangentBuffer );
				enableAttribute( attributes.tangent );
				_gl.vertexAttribPointer( attributes.tangent, 4, _gl.FLOAT, false, 0, 0 );

			}

			// uvs

			if ( attributes.uv >= 0 ) {

				if ( object.geometry.faceVertexUvs[0] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUVBuffer );
					enableAttribute( attributes.uv );
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv, material.defaultAttributeValues.uv );

				}

			}

			if ( attributes.uv2 >= 0 ) {

				if ( object.geometry.faceVertexUvs[1] ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglUV2Buffer );
					enableAttribute( attributes.uv2 );
					_gl.vertexAttribPointer( attributes.uv2, 2, _gl.FLOAT, false, 0, 0 );

				} else if ( material.defaultAttributeValues ) {


					_gl.vertexAttrib2fv( attributes.uv2, material.defaultAttributeValues.uv2 );

				}

			}

			if ( material.skinning &&
				 attributes.skinIndex >= 0 && attributes.skinWeight >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinIndicesBuffer );
				enableAttribute( attributes.skinIndex );
				_gl.vertexAttribPointer( attributes.skinIndex, 4, _gl.FLOAT, false, 0, 0 );

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglSkinWeightsBuffer );
				enableAttribute( attributes.skinWeight );
				_gl.vertexAttribPointer( attributes.skinWeight, 4, _gl.FLOAT, false, 0, 0 );

			}

			// line distances

			if ( attributes.lineDistance >= 0 ) {

				_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglLineDistanceBuffer );
				enableAttribute( attributes.lineDistance );
				_gl.vertexAttribPointer( attributes.lineDistance, 1, _gl.FLOAT, false, 0, 0 );

			}

		}

		// render mesh

		if ( object instanceof THREE.Mesh ) {

			// wireframe

			if ( material.wireframe ) {

				setLineWidth( material.wireframeLinewidth );

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglLineBuffer );
				_gl.drawElements( _gl.LINES, geometryGroup.__webglLineCount, _gl.UNSIGNED_SHORT, 0 );

			// triangles

			} else {

				if ( updateBuffers ) _gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, geometryGroup.__webglFaceBuffer );
				_gl.drawElements( _gl.TRIANGLES, geometryGroup.__webglFaceCount, _gl.UNSIGNED_SHORT, 0 );

			}

			_this.info.render.calls ++;
			_this.info.render.vertices += geometryGroup.__webglFaceCount;
			_this.info.render.faces += geometryGroup.__webglFaceCount / 3;

		// render lines

		} else if ( object instanceof THREE.Line ) {

			var primitives = ( object.type === THREE.LineStrip ) ? _gl.LINE_STRIP : _gl.LINES;

			setLineWidth( material.linewidth );

			_gl.drawArrays( primitives, 0, geometryGroup.__webglLineCount );

			_this.info.render.calls ++;

		// render particles

		} else if ( object instanceof THREE.ParticleSystem ) {

			_gl.drawArrays( _gl.POINTS, 0, geometryGroup.__webglParticleCount );

			_this.info.render.calls ++;
			_this.info.render.points += geometryGroup.__webglParticleCount;

		}

	};

	function enableAttribute( attribute ) {

		if ( _enabledAttributes[ attribute ] === 0 ) {

			_gl.enableVertexAttribArray( attribute );
			_enabledAttributes[ attribute ] = 1;

		}

	};

	function disableAttributes() {

		for ( var attribute in _enabledAttributes ) {

			if ( _enabledAttributes[ attribute ] === 1 ) {

				_gl.disableVertexAttribArray( attribute );
				_enabledAttributes[ attribute ] = 0;

			}

		}

	};

	function setupMorphTargets ( material, geometryGroup, object ) {

		// set base

		var attributes = material.program.attributes;

		if ( object.morphTargetBase !== -1 && attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ object.morphTargetBase ] );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		} else if ( attributes.position >= 0 ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglVertexBuffer );
			enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.morphTargetForcedOrder.length ) {

			// set forced order

			var m = 0;
			var order = object.morphTargetForcedOrder;
			var influences = object.morphTargetInfluences;

			while ( m < material.numSupportedMorphTargets && m < order.length ) {

				if ( attributes[ "morphTarget" + m ] >= 0 ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphTarget" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {

					_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ order[ m ] ] );
					enableAttribute( attributes[ "morphNormal" + m ] );
					_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

				}

				object.__webglMorphTargetInfluences[ m ] = influences[ order[ m ] ];

				m ++;
			}

		} else {

			// find the most influencing

			var influence, activeInfluenceIndices = [];
			var influences = object.morphTargetInfluences;
			var i, il = influences.length;

			for ( i = 0; i < il; i ++ ) {

				influence = influences[ i ];

				if ( influence > 0 ) {

					activeInfluenceIndices.push( [ influence, i ] );

				}

			}

			if ( activeInfluenceIndices.length > material.numSupportedMorphTargets ) {

				activeInfluenceIndices.sort( numericalSort );
				activeInfluenceIndices.length = material.numSupportedMorphTargets;

			} else if ( activeInfluenceIndices.length > material.numSupportedMorphNormals ) {

				activeInfluenceIndices.sort( numericalSort );

			} else if ( activeInfluenceIndices.length === 0 ) {

				activeInfluenceIndices.push( [ 0, 0 ] );

			};

			var influenceIndex, m = 0;

			while ( m < material.numSupportedMorphTargets ) {

				if ( activeInfluenceIndices[ m ] ) {

					influenceIndex = activeInfluenceIndices[ m ][ 1 ];

					if ( attributes[ "morphTarget" + m ] >= 0 ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphTargetsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphTarget" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}

					if ( attributes[ "morphNormal" + m ] >= 0 && material.morphNormals ) {

						_gl.bindBuffer( _gl.ARRAY_BUFFER, geometryGroup.__webglMorphNormalsBuffers[ influenceIndex ] );
						enableAttribute( attributes[ "morphNormal" + m ] );
						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );


					}

					object.__webglMorphTargetInfluences[ m ] = influences[ influenceIndex ];

				} else {

					/*
					_gl.vertexAttribPointer( attributes[ "morphTarget" + m ], 3, _gl.FLOAT, false, 0, 0 );

					if ( material.morphNormals ) {

						_gl.vertexAttribPointer( attributes[ "morphNormal" + m ], 3, _gl.FLOAT, false, 0, 0 );

					}
					*/

					object.__webglMorphTargetInfluences[ m ] = 0;

				}

				m ++;

			}

		}

		// load updated influences uniform

		if ( material.program.uniforms.morphTargetInfluences !== null ) {

			_gl.uniform1fv( material.program.uniforms.morphTargetInfluences, object.__webglMorphTargetInfluences );

		}

	};

	// Sorting

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	};

	function numericalSort ( a, b ) {

		return b[ 0 ] - a[ 0 ];

	};


	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera instanceof THREE.Camera === false ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		var i, il,

		webglObject, object,
		renderList,

		lights = scene.__lights,
		fog = scene.fog;

		// reset caching for this frame

		_currentMaterialId = -1;
		_lightsNeedUpdate = true;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === undefined ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// update WebGL objects

		if ( this.autoUpdateObjects ) this.initWebGLObjects( scene );

		// custom render plugins (pre pass)

		renderPlugins( this.renderPluginsPre, scene, camera );

		//

		_this.info.render.calls = 0;
		_this.info.render.vertices = 0;
		_this.info.render.faces = 0;
		_this.info.render.points = 0;

		this.setRenderTarget( renderTarget );

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		// set matrices for regular objects (frustum culled)

		renderList = scene.__webglObjects;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			webglObject.id = i;
			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

					setupMatrices( object, camera );

					unrollBufferMaterial( webglObject );

					webglObject.render = true;

					if ( this.sortObjects === true ) {

						if ( object.renderDepth !== null ) {

							webglObject.z = object.renderDepth;

						} else {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

							webglObject.z = _vector3.z;

						}

					}

				}

			}

		}

		if ( this.sortObjects ) {

			renderList.sort( painterSortStable );

		}

		// set matrices for immediate objects

		renderList = scene.__webglObjectsImmediate;

		for ( i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				setupMatrices( object, camera );

				unrollImmediateBufferMaterial( webglObject );

			}

		}

		if ( scene.overrideMaterial ) {

			var material = scene.overrideMaterial;

			this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			this.setDepthTest( material.depthTest );
			this.setDepthWrite( material.depthWrite );
			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

			renderObjects( scene.__webglObjects, false, "", camera, lights, fog, true, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "", camera, lights, fog, false, material );

		} else {

			var material = null;

			// opaque pass (front-to-back order)

			this.setBlending( THREE.NoBlending );

			renderObjects( scene.__webglObjects, true, "opaque", camera, lights, fog, false, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "opaque", camera, lights, fog, false, material );

			// transparent pass (back-to-front order)

			renderObjects( scene.__webglObjects, false, "transparent", camera, lights, fog, true, material );
			renderObjectsImmediate( scene.__webglObjectsImmediate, "transparent", camera, lights, fog, true, material );

		}

		// custom render plugins (post pass)

		renderPlugins( this.renderPluginsPost, scene, camera );


		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget && renderTarget.generateMipmaps && renderTarget.minFilter !== THREE.NearestFilter && renderTarget.minFilter !== THREE.LinearFilter ) {

			updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		this.setDepthTest( true );
		this.setDepthWrite( true );

		// _gl.finish();

	};

	function renderPlugins( plugins, scene, camera ) {

		if ( ! plugins.length ) return;

		for ( var i = 0, il = plugins.length; i < il; i ++ ) {

			// reset state for plugin (to start from clean slate)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

			plugins[ i ].render( scene, camera, _currentWidth, _currentHeight );

			// reset state after plugin (anything could have changed)

			_currentProgram = null;
			_currentCamera = null;

			_oldBlending = -1;
			_oldDepthTest = -1;
			_oldDepthWrite = -1;
			_oldDoubleSided = -1;
			_oldFlipSided = -1;
			_currentGeometryGroupHash = -1;
			_currentMaterialId = -1;

			_lightsNeedUpdate = true;

		}

	};

	function renderObjects( renderList, reverse, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, buffer, material, start, end, delta;

		if ( reverse ) {

			start = renderList.length - 1;
			end = -1;
			delta = -1;

		} else {

			start = 0;
			end = renderList.length;
			delta = 1;
		}

		for ( var i = start; i !== end; i += delta ) {

			webglObject = renderList[ i ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.setMaterialFaces( material );

				if ( buffer instanceof THREE.BufferGeometry ) {

					_this.renderBufferDirect( camera, lights, fog, material, buffer, object );

				} else {

					_this.renderBuffer( camera, lights, fog, material, buffer, object );

				}

			}

		}

	};

	function renderObjectsImmediate ( renderList, materialType, camera, lights, fog, useBlending, overrideMaterial ) {

		var webglObject, object, material, program;

		for ( var i = 0, il = renderList.length; i < il; i ++ ) {

			webglObject = renderList[ i ];
			object = webglObject.object;

			if ( object.visible ) {

				if ( overrideMaterial ) {

					material = overrideMaterial;

				} else {

					material = webglObject[ materialType ];

					if ( ! material ) continue;

					if ( useBlending ) _this.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );

					_this.setDepthTest( material.depthTest );
					_this.setDepthWrite( material.depthWrite );
					setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

				}

				_this.renderImmediateObject( camera, lights, fog, material, object );

			}

		}

	};

	this.renderImmediateObject = function ( camera, lights, fog, material, object ) {

		var program = setProgram( camera, lights, fog, material, object );

		_currentGeometryGroupHash = -1;

		_this.setMaterialFaces( material );

		if ( object.immediateRenderCallback ) {

			object.immediateRenderCallback( program, _gl, _frustum );

		} else {

			object.render( function( object ) { _this.renderBufferImmediate( object, program, material ); } );

		}

	};

	function unrollImmediateBufferMaterial ( globject ) {

		var object = globject.object,
			material = object.material;

		if ( material.transparent ) {

			globject.transparent = material;
			globject.opaque = null;

		} else {

			globject.opaque = material;
			globject.transparent = null;

		}

	};

	function unrollBufferMaterial ( globject ) {

		var object = globject.object;
		var buffer = globject.buffer;

		var geometry = object.geometry;
		var material = object.material;

		if ( material instanceof THREE.MeshFaceMaterial ) {

			var materialIndex = geometry instanceof THREE.BufferGeometry ? 0 : buffer.materialIndex;

			material = material.materials[ materialIndex ];

			if ( material.transparent ) {

				globject.transparent = material;
				globject.opaque = null;

			} else {

				globject.opaque = material;
				globject.transparent = null;

			}

		} else {

			if ( material ) {

				if ( material.transparent ) {

					globject.transparent = material;
					globject.opaque = null;

				} else {

					globject.opaque = material;
					globject.transparent = null;

				}

			}

		}

	};

	// Objects refresh

	this.initWebGLObjects = function ( scene ) {

		if ( !scene.__webglObjects ) {

			scene.__webglObjects = [];
			scene.__webglObjectsImmediate = [];
			scene.__webglSprites = [];
			scene.__webglFlares = [];

		}

		while ( scene.__objectsAdded.length ) {

			addObject( scene.__objectsAdded[ 0 ], scene );
			scene.__objectsAdded.splice( 0, 1 );

		}

		while ( scene.__objectsRemoved.length ) {

			removeObject( scene.__objectsRemoved[ 0 ], scene );
			scene.__objectsRemoved.splice( 0, 1 );

		}

		// update must be called after objects adding / removal

		for ( var o = 0, ol = scene.__webglObjects.length; o < ol; o ++ ) {

			var object = scene.__webglObjects[ o ].object;

			// TODO: Remove this hack (WebGLRenderer refactoring)

			if ( object.__webglInit === undefined ) {

				if ( object.__webglActive !== undefined ) {

					removeObject( object, scene );

				}

				addObject( object, scene );

			}

			updateObject( object );

		}

	};

	// Objects adding

	function addObject( object, scene ) {

		var g, geometry, material, geometryGroup;

		if ( object.__webglInit === undefined ) {

			object.__webglInit = true;

			object._modelViewMatrix = new THREE.Matrix4();
			object._normalMatrix = new THREE.Matrix3();

			if ( object.geometry !== undefined && object.geometry.__webglInit === undefined ) {

				object.geometry.__webglInit = true;
				object.geometry.addEventListener( 'dispose', onGeometryDispose );

			}

			geometry = object.geometry;

			if ( geometry === undefined ) {

				// fail silently for now

			} else if ( geometry instanceof THREE.BufferGeometry ) {

				initDirectBuffers( geometry );

			} else if ( object instanceof THREE.Mesh ) {

				material = object.material;

				if ( geometry.geometryGroups === undefined ) {

					geometry.makeGroups( material instanceof THREE.MeshFaceMaterial );

				}

				// create separate VBOs per geometry chunk

				for ( g in geometry.geometryGroups ) {

					geometryGroup = geometry.geometryGroups[ g ];

					// initialise VBO on the first access

					if ( ! geometryGroup.__webglVertexBuffer ) {

						createMeshBuffers( geometryGroup );
						initMeshBuffers( geometryGroup, object );

						geometry.verticesNeedUpdate = true;
						geometry.morphTargetsNeedUpdate = true;
						geometry.elementsNeedUpdate = true;
						geometry.uvsNeedUpdate = true;
						geometry.normalsNeedUpdate = true;
						geometry.tangentsNeedUpdate = true;
						geometry.colorsNeedUpdate = true;

					}

				}

			} else if ( object instanceof THREE.Line ) {

				if ( ! geometry.__webglVertexBuffer ) {

					createLineBuffers( geometry );
					initLineBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;
					geometry.lineDistancesNeedUpdate = true;

				}

			} else if ( object instanceof THREE.ParticleSystem ) {

				if ( ! geometry.__webglVertexBuffer ) {

					createParticleBuffers( geometry );
					initParticleBuffers( geometry, object );

					geometry.verticesNeedUpdate = true;
					geometry.colorsNeedUpdate = true;

				}

			}

		}

		if ( object.__webglActive === undefined ) {

			if ( object instanceof THREE.Mesh ) {

				geometry = object.geometry;

				if ( geometry instanceof THREE.BufferGeometry ) {

					addBuffer( scene.__webglObjects, geometry, object );

				} else if ( geometry instanceof THREE.Geometry ) {

					for ( g in geometry.geometryGroups ) {

						geometryGroup = geometry.geometryGroups[ g ];

						addBuffer( scene.__webglObjects, geometryGroup, object );

					}

				}

			} else if ( object instanceof THREE.Line ||
						object instanceof THREE.ParticleSystem ) {

				geometry = object.geometry;
				addBuffer( scene.__webglObjects, geometry, object );

			} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

				addBufferImmediate( scene.__webglObjectsImmediate, object );

			} else if ( object instanceof THREE.Sprite ) {

				scene.__webglSprites.push( object );

			} else if ( object instanceof THREE.LensFlare ) {

				scene.__webglFlares.push( object );

			}

			object.__webglActive = true;

		}

	};

	function addBuffer( objlist, buffer, object ) {

		objlist.push(
			{
				id: null,
				buffer: buffer,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	function addBufferImmediate( objlist, object ) {

		objlist.push(
			{
				id: null,
				object: object,
				opaque: null,
				transparent: null,
				z: 0
			}
		);

	};

	// Objects updates

	function updateObject( object ) {

		var geometry = object.geometry,
			geometryGroup, customAttributesDirty, material;

		if ( geometry instanceof THREE.BufferGeometry ) {

			setDirectBuffers( geometry, _gl.DYNAMIC_DRAW );

		} else if ( object instanceof THREE.Mesh ) {

			// check all geometry groups

			for( var i = 0, il = geometry.geometryGroupsList.length; i < il; i ++ ) {

				geometryGroup = geometry.geometryGroupsList[ i ];

				material = getBufferMaterial( object, geometryGroup );

				if ( geometry.buffersNeedUpdate ) {

					initMeshBuffers( geometryGroup, object );

				}

				customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

				if ( geometry.verticesNeedUpdate || geometry.morphTargetsNeedUpdate || geometry.elementsNeedUpdate ||
					 geometry.uvsNeedUpdate || geometry.normalsNeedUpdate ||
					 geometry.colorsNeedUpdate || geometry.tangentsNeedUpdate || customAttributesDirty ) {

					setMeshBuffers( geometryGroup, object, _gl.DYNAMIC_DRAW, !geometry.dynamic, material );

				}

			}

			geometry.verticesNeedUpdate = false;
			geometry.morphTargetsNeedUpdate = false;
			geometry.elementsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.tangentsNeedUpdate = false;

			geometry.buffersNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		} else if ( object instanceof THREE.Line ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || geometry.lineDistancesNeedUpdate || customAttributesDirty ) {

				setLineBuffers( geometry, _gl.DYNAMIC_DRAW );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.lineDistancesNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );


		} else if ( object instanceof THREE.ParticleSystem ) {

			material = getBufferMaterial( object, geometry );

			customAttributesDirty = material.attributes && areCustomAttributesDirty( material );

			if ( geometry.verticesNeedUpdate || geometry.colorsNeedUpdate || object.sortParticles || customAttributesDirty ) {

				setParticleBuffers( geometry, _gl.DYNAMIC_DRAW, object );

			}

			geometry.verticesNeedUpdate = false;
			geometry.colorsNeedUpdate = false;

			material.attributes && clearCustomAttributes( material );

		}

	};

	// Objects updates - custom attributes check

	function areCustomAttributesDirty( material ) {

		for ( var a in material.attributes ) {

			if ( material.attributes[ a ].needsUpdate ) return true;

		}

		return false;

	};

	function clearCustomAttributes( material ) {

		for ( var a in material.attributes ) {

			material.attributes[ a ].needsUpdate = false;

		}

	};

	// Objects removal

	function removeObject( object, scene ) {

		if ( object instanceof THREE.Mesh  ||
			 object instanceof THREE.ParticleSystem ||
			 object instanceof THREE.Line ) {

			removeInstances( scene.__webglObjects, object );

		} else if ( object instanceof THREE.Sprite ) {

			removeInstancesDirect( scene.__webglSprites, object );

		} else if ( object instanceof THREE.LensFlare ) {

			removeInstancesDirect( scene.__webglFlares, object );

		} else if ( object instanceof THREE.ImmediateRenderObject || object.immediateRenderCallback ) {

			removeInstances( scene.__webglObjectsImmediate, object );

		}

		delete object.__webglActive;

	};

	function removeInstances( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ].object === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	function removeInstancesDirect( objlist, object ) {

		for ( var o = objlist.length - 1; o >= 0; o -- ) {

			if ( objlist[ o ] === object ) {

				objlist.splice( o, 1 );

			}

		}

	};

	// Materials

	this.initMaterial = function ( material, lights, fog, object ) {

		material.addEventListener( 'dispose', onMaterialDispose );

		var u, a, identifiers, i, parameters, maxLightCount, maxBones, maxShadows, shaderID;

		if ( material instanceof THREE.MeshDepthMaterial ) {

			shaderID = 'depth';

		} else if ( material instanceof THREE.MeshNormalMaterial ) {

			shaderID = 'normal';

		} else if ( material instanceof THREE.MeshBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.MeshLambertMaterial ) {

			shaderID = 'lambert';

		} else if ( material instanceof THREE.MeshPhongMaterial ) {

			shaderID = 'phong';

		} else if ( material instanceof THREE.LineBasicMaterial ) {

			shaderID = 'basic';

		} else if ( material instanceof THREE.LineDashedMaterial ) {

			shaderID = 'dashed';

		} else if ( material instanceof THREE.ParticleSystemMaterial ) {

			shaderID = 'particle_basic';

		}

		if ( shaderID ) {

			setMaterialShaders( material, THREE.ShaderLib[ shaderID ] );

		}

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		maxLightCount = allocateLights( lights );

		maxShadows = allocateShadows( lights );

		maxBones = allocateBones( object );

		parameters = {

			map: !!material.map,
			envMap: !!material.envMap,
			lightMap: !!material.lightMap,
			bumpMap: !!material.bumpMap,
			normalMap: !!material.normalMap,
			specularMap: !!material.specularMap,

			vertexColors: material.vertexColors,

			fog: fog,
			useFog: material.fog,
			fogExp: fog instanceof THREE.FogExp2,

			sizeAttenuation: material.sizeAttenuation,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: _supportsBoneTextures && object && object.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: this.maxMorphTargets,
			maxMorphNormals: this.maxMorphNormals,

			maxDirLights: maxLightCount.directional,
			maxPointLights: maxLightCount.point,
			maxSpotLights: maxLightCount.spot,
			maxHemiLights: maxLightCount.hemi,

			maxShadows: maxShadows,
			shadowMapEnabled: this.shadowMapEnabled && object.receiveShadow && maxShadows > 0,
			shadowMapType: this.shadowMapType,
			shadowMapDebug: this.shadowMapDebug,
			shadowMapCascade: this.shadowMapCascade,

			alphaTest: material.alphaTest,
			metal: material.metal,
			wrapAround: material.wrapAround,
			doubleSided: material.side === THREE.DoubleSide,
			flipSided: material.side === THREE.BackSide

		};

		material.program = buildProgram( shaderID, material.fragmentShader, material.vertexShader, material.uniforms, material.attributes, material.defines, parameters, material.index0AttributeName );

		var attributes = material.program.attributes;

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			var id, base = "morphTarget";

			for ( i = 0; i < this.maxMorphTargets; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			var id, base = "morphNormal";

			for ( i = 0; i < this.maxMorphNormals; i ++ ) {

				id = base + i;

				if ( attributes[ id ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		material.uniformsList = [];

		for ( u in material.uniforms ) {

			material.uniformsList.push( [ material.uniforms[ u ], u ] );

		}

	};

	function setMaterialShaders( material, shaders ) {

		material.uniforms = THREE.UniformsUtils.clone( shaders.uniforms );
		material.vertexShader = shaders.vertexShader;
		material.fragmentShader = shaders.fragmentShader;

	};

	function setProgram( camera, lights, fog, material, object ) {

		_usedTextureUnits = 0;

		if ( material.needsUpdate ) {

			if ( material.program ) deallocateMaterial( material );

			_this.initMaterial( material, lights, fog, object );
			material.needsUpdate = false;

		}

		if ( material.morphTargets ) {

			if ( ! object.__webglMorphTargetInfluences ) {

				object.__webglMorphTargetInfluences = new Float32Array( _this.maxMorphTargets );

			}

		}

		var refreshMaterial = false;

		var program = material.program,
			p_uniforms = program.uniforms,
			m_uniforms = material.uniforms;

		if ( program !== _currentProgram ) {

			_gl.useProgram( program );
			_currentProgram = program;

			refreshMaterial = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;
			refreshMaterial = true;

		}

		if ( refreshMaterial || camera !== _currentCamera ) {

			_gl.uniformMatrix4fv( p_uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

			if ( camera !== _currentCamera ) _currentCamera = camera;

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			if ( _supportsBoneTextures && object.useVertexTexture ) {

				if ( p_uniforms.boneTexture !== null ) {

					var textureUnit = getTextureUnit();

					_gl.uniform1i( p_uniforms.boneTexture, textureUnit );
					_this.setTexture( object.boneTexture, textureUnit );

				}

				if ( p_uniforms.boneTextureWidth !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureWidth, object.boneTextureWidth );

				}

				if ( p_uniforms.boneTextureHeight !== null ) {

					_gl.uniform1i( p_uniforms.boneTextureHeight, object.boneTextureHeight );

				}

			} else {

				if ( p_uniforms.boneGlobalMatrices !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.boneGlobalMatrices, false, object.boneMatrices );

				}

			}

		}

		if ( refreshMaterial ) {

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material.lights ) {

				if ( _lightsNeedUpdate ) {

					setupLights( program, lights );
					_lightsNeedUpdate = false;

				}

				refreshUniformsLights( m_uniforms, _lights );

			}

			if ( material instanceof THREE.MeshBasicMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material instanceof THREE.LineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material instanceof THREE.LineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material instanceof THREE.ParticleSystemMaterial ) {

				refreshUniformsParticle( m_uniforms, material );

			} else if ( material instanceof THREE.MeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material instanceof THREE.MeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material instanceof THREE.MeshDepthMaterial ) {

				m_uniforms.mNear.value = camera.near;
				m_uniforms.mFar.value = camera.far;
				m_uniforms.opacity.value = material.opacity;

			} else if ( material instanceof THREE.MeshNormalMaterial ) {

				m_uniforms.opacity.value = material.opacity;

			}

			if ( object.receiveShadow && ! material._shadowPass ) {

				refreshUniformsShadow( m_uniforms, lights );

			}

			// load common uniforms

			loadUniformsGeneric( program, material.uniformsList );

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material instanceof THREE.ShaderMaterial ||
				 material instanceof THREE.MeshPhongMaterial ||
				 material.envMap ) {

				if ( p_uniforms.cameraPosition !== null ) {

					_vector3.setFromMatrixPosition( camera.matrixWorld );
					_gl.uniform3f( p_uniforms.cameraPosition, _vector3.x, _vector3.y, _vector3.z );

				}

			}

			if ( material instanceof THREE.MeshPhongMaterial ||
				 material instanceof THREE.MeshLambertMaterial ||
				 material instanceof THREE.ShaderMaterial ||
				 material.skinning ) {

				if ( p_uniforms.viewMatrix !== null ) {

					_gl.uniformMatrix4fv( p_uniforms.viewMatrix, false, camera.matrixWorldInverse.elements );

				}

			}

		}

		loadUniformsMatrices( p_uniforms, object );

		if ( p_uniforms.modelMatrix !== null ) {

			_gl.uniformMatrix4fv( p_uniforms.modelMatrix, false, object.matrixWorld.elements );

		}

		return program;

	};

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon ( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( _this.gammaInput ) {

			uniforms.diffuse.value.copyGammaToLinear( material.color );

		} else {

			uniforms.diffuse.value = material.color;

		}

		uniforms.map.value = material.map;
		uniforms.lightMap.value = material.lightMap;
		uniforms.specularMap.value = material.specularMap;

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		// uv repeat and offset setting priorities
		//	1. color map
		//	2. specular map
		//	3. normal map
		//	4. bump map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		}

		if ( uvScaleMap !== undefined ) {

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;
		uniforms.flipEnvMap.value = ( material.envMap instanceof THREE.WebGLRenderTargetCube ) ? 1 : -1;

		if ( _this.gammaInput ) {

			//uniforms.reflectivity.value = material.reflectivity * material.reflectivity;
			uniforms.reflectivity.value = material.reflectivity;

		} else {

			uniforms.reflectivity.value = material.reflectivity;

		}

		uniforms.refractionRatio.value = material.refractionRatio;
		uniforms.combine.value = material.combine;
		uniforms.useRefract.value = material.envMap && material.envMap.mapping instanceof THREE.CubeRefractionMapping;

	};

	function refreshUniformsLine ( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	};

	function refreshUniformsDash ( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	};

	function refreshUniformsParticle ( uniforms, material ) {

		uniforms.psColor.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size;
		uniforms.scale.value = _canvas.height / 2.0; // TODO: Cache this.

		uniforms.map.value = material.map;

	};

	function refreshUniformsFog ( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog instanceof THREE.Fog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog instanceof THREE.FogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	};

	function refreshUniformsPhong ( uniforms, material ) {

		uniforms.shininess.value = material.shininess;

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );
			uniforms.specular.value.copyGammaToLinear( material.specular );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;
			uniforms.specular.value = material.specular;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	};

	function refreshUniformsLambert ( uniforms, material ) {

		if ( _this.gammaInput ) {

			uniforms.ambient.value.copyGammaToLinear( material.ambient );
			uniforms.emissive.value.copyGammaToLinear( material.emissive );

		} else {

			uniforms.ambient.value = material.ambient;
			uniforms.emissive.value = material.emissive;

		}

		if ( material.wrapAround ) {

			uniforms.wrapRGB.value.copy( material.wrapRGB );

		}

	};

	function refreshUniformsLights ( uniforms, lights ) {

		uniforms.ambientLightColor.value = lights.ambient;

		uniforms.directionalLightColor.value = lights.directional.colors;
		uniforms.directionalLightDirection.value = lights.directional.positions;

		uniforms.pointLightColor.value = lights.point.colors;
		uniforms.pointLightPosition.value = lights.point.positions;
		uniforms.pointLightDistance.value = lights.point.distances;

		uniforms.spotLightColor.value = lights.spot.colors;
		uniforms.spotLightPosition.value = lights.spot.positions;
		uniforms.spotLightDistance.value = lights.spot.distances;
		uniforms.spotLightDirection.value = lights.spot.directions;
		uniforms.spotLightAngleCos.value = lights.spot.anglesCos;
		uniforms.spotLightExponent.value = lights.spot.exponents;

		uniforms.hemisphereLightSkyColor.value = lights.hemi.skyColors;
		uniforms.hemisphereLightGroundColor.value = lights.hemi.groundColors;
		uniforms.hemisphereLightDirection.value = lights.hemi.positions;

	};

	function refreshUniformsShadow ( uniforms, lights ) {

		if ( uniforms.shadowMatrix ) {

			var j = 0;

			for ( var i = 0, il = lights.length; i < il; i ++ ) {

				var light = lights[ i ];

				if ( ! light.castShadow ) continue;

				if ( light instanceof THREE.SpotLight || ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) ) {

					uniforms.shadowMap.value[ j ] = light.shadowMap;
					uniforms.shadowMapSize.value[ j ] = light.shadowMapSize;

					uniforms.shadowMatrix.value[ j ] = light.shadowMatrix;

					uniforms.shadowDarkness.value[ j ] = light.shadowDarkness;
					uniforms.shadowBias.value[ j ] = light.shadowBias;

					j ++;

				}

			}

		}

	};

	// Uniforms (load to GPU)

	function loadUniformsMatrices ( uniforms, object ) {

		_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, object._modelViewMatrix.elements );

		if ( uniforms.normalMatrix ) {

			_gl.uniformMatrix3fv( uniforms.normalMatrix, false, object._normalMatrix.elements );

		}

	};

	function getTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= _maxTextures ) {

			console.warn( "WebGLRenderer: trying to use " + textureUnit + " texture units while this GPU supports only " + _maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	};

	function loadUniformsGeneric ( program, uniforms ) {

		var uniform, value, type, location, texture, textureUnit, i, il, j, jl, offset;

		for ( j = 0, jl = uniforms.length; j < jl; j ++ ) {

			location = program.uniforms[ uniforms[ j ][ 1 ] ];
			if ( !location ) continue;

			uniform = uniforms[ j ][ 0 ];

			type = uniform.type;
			value = uniform.value;

			if ( type === "i" ) { // single integer

				_gl.uniform1i( location, value );

			} else if ( type === "f" ) { // single float

				_gl.uniform1f( location, value );

			} else if ( type === "v2" ) { // single THREE.Vector2

				_gl.uniform2f( location, value.x, value.y );

			} else if ( type === "v3" ) { // single THREE.Vector3

				_gl.uniform3f( location, value.x, value.y, value.z );

			} else if ( type === "v4" ) { // single THREE.Vector4

				_gl.uniform4f( location, value.x, value.y, value.z, value.w );

			} else if ( type === "c" ) { // single THREE.Color

				_gl.uniform3f( location, value.r, value.g, value.b );

			} else if ( type === "iv1" ) { // flat array of integers (JS or typed array)

				_gl.uniform1iv( location, value );

			} else if ( type === "iv" ) { // flat array of integers with 3 x N size (JS or typed array)

				_gl.uniform3iv( location, value );

			} else if ( type === "fv1" ) { // flat array of floats (JS or typed array)

				_gl.uniform1fv( location, value );

			} else if ( type === "fv" ) { // flat array of floats with 3 x N size (JS or typed array)

				_gl.uniform3fv( location, value );

			} else if ( type === "v2v" ) { // array of THREE.Vector2

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 2 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 2;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;

				}

				_gl.uniform2fv( location, uniform._array );

			} else if ( type === "v3v" ) { // array of THREE.Vector3

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 3 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 3;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;

				}

				_gl.uniform3fv( location, uniform._array );

			} else if ( type === "v4v" ) { // array of THREE.Vector4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 4 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					offset = i * 4;

					uniform._array[ offset ] 	 = value[ i ].x;
					uniform._array[ offset + 1 ] = value[ i ].y;
					uniform._array[ offset + 2 ] = value[ i ].z;
					uniform._array[ offset + 3 ] = value[ i ].w;

				}

				_gl.uniform4fv( location, uniform._array );

			} else if ( type === "m4") { // single THREE.Matrix4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 16 );

				}

				value.flattenToArray( uniform._array );
				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "m4v" ) { // array of THREE.Matrix4

				if ( uniform._array === undefined ) {

					uniform._array = new Float32Array( 16 * value.length );

				}

				for ( i = 0, il = value.length; i < il; i ++ ) {

					value[ i ].flattenToArrayOffset( uniform._array, i * 16 );

				}

				_gl.uniformMatrix4fv( location, false, uniform._array );

			} else if ( type === "t" ) { // single THREE.Texture (2d or cube)

				texture = value;
				textureUnit = getTextureUnit();

				_gl.uniform1i( location, textureUnit );

				if ( !texture ) continue;

				if ( texture.image instanceof Array && texture.image.length === 6 ) {

					setCubeTexture( texture, textureUnit );

				} else if ( texture instanceof THREE.WebGLRenderTargetCube ) {

					setCubeTextureDynamic( texture, textureUnit );

				} else {

					_this.setTexture( texture, textureUnit );

				}

			} else if ( type === "tv" ) { // array of THREE.Texture (2d)

				if ( uniform._array === undefined ) {

					uniform._array = [];

				}

				for( i = 0, il = uniform.value.length; i < il; i ++ ) {

					uniform._array[ i ] = getTextureUnit();

				}

				_gl.uniform1iv( location, uniform._array );

				for( i = 0, il = uniform.value.length; i < il; i ++ ) {

					texture = uniform.value[ i ];
					textureUnit = uniform._array[ i ];

					if ( !texture ) continue;

					_this.setTexture( texture, textureUnit );

				}

			} else {

				console.warn( 'THREE.WebGLRenderer: Unknown uniform type: ' + type );

			}

		}

	};

	function setupMatrices ( object, camera ) {

		object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object._normalMatrix.getNormalMatrix( object._modelViewMatrix );

	};

	//

	function setColorGamma( array, offset, color, intensitySq ) {

		array[ offset ]     = color.r * color.r * intensitySq;
		array[ offset + 1 ] = color.g * color.g * intensitySq;
		array[ offset + 2 ] = color.b * color.b * intensitySq;

	};

	function setColorLinear( array, offset, color, intensity ) {

		array[ offset ]     = color.r * intensity;
		array[ offset + 1 ] = color.g * intensity;
		array[ offset + 2 ] = color.b * intensity;

	};

	function setupLights ( program, lights ) {

		var l, ll, light, n,
		r = 0, g = 0, b = 0,
		color, skyColor, groundColor,
		intensity,  intensitySq,
		position,
		distance,

		zlights = _lights,

		dirColors = zlights.directional.colors,
		dirPositions = zlights.directional.positions,

		pointColors = zlights.point.colors,
		pointPositions = zlights.point.positions,
		pointDistances = zlights.point.distances,

		spotColors = zlights.spot.colors,
		spotPositions = zlights.spot.positions,
		spotDistances = zlights.spot.distances,
		spotDirections = zlights.spot.directions,
		spotAnglesCos = zlights.spot.anglesCos,
		spotExponents = zlights.spot.exponents,

		hemiSkyColors = zlights.hemi.skyColors,
		hemiGroundColors = zlights.hemi.groundColors,
		hemiPositions = zlights.hemi.positions,

		dirLength = 0,
		pointLength = 0,
		spotLength = 0,
		hemiLength = 0,

		dirCount = 0,
		pointCount = 0,
		spotCount = 0,
		hemiCount = 0,

		dirOffset = 0,
		pointOffset = 0,
		spotOffset = 0,
		hemiOffset = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			if ( light.onlyShadow ) continue;

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			if ( light instanceof THREE.AmbientLight ) {

				if ( ! light.visible ) continue;

				if ( _this.gammaInput ) {

					r += color.r * color.r;
					g += color.g * color.g;
					b += color.b * color.b;

				} else {

					r += color.r;
					g += color.g;
					b += color.b;

				}

			} else if ( light instanceof THREE.DirectionalLight ) {

				dirCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;

				dirOffset = dirLength * 3;

				dirPositions[ dirOffset ]     = _direction.x;
				dirPositions[ dirOffset + 1 ] = _direction.y;
				dirPositions[ dirOffset + 2 ] = _direction.z;

				if ( _this.gammaInput ) {

					setColorGamma( dirColors, dirOffset, color, intensity * intensity );

				} else {

					setColorLinear( dirColors, dirOffset, color, intensity );

				}

				dirLength += 1;

			} else if ( light instanceof THREE.PointLight ) {

				pointCount += 1;

				if ( ! light.visible ) continue;

				pointOffset = pointLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( pointColors, pointOffset, color, intensity * intensity );

				} else {

					setColorLinear( pointColors, pointOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				pointPositions[ pointOffset ]     = _vector3.x;
				pointPositions[ pointOffset + 1 ] = _vector3.y;
				pointPositions[ pointOffset + 2 ] = _vector3.z;

				pointDistances[ pointLength ] = distance;

				pointLength += 1;

			} else if ( light instanceof THREE.SpotLight ) {

				spotCount += 1;

				if ( ! light.visible ) continue;

				spotOffset = spotLength * 3;

				if ( _this.gammaInput ) {

					setColorGamma( spotColors, spotOffset, color, intensity * intensity );

				} else {

					setColorLinear( spotColors, spotOffset, color, intensity );

				}

				_vector3.setFromMatrixPosition( light.matrixWorld );

				spotPositions[ spotOffset ]     = _vector3.x;
				spotPositions[ spotOffset + 1 ] = _vector3.y;
				spotPositions[ spotOffset + 2 ] = _vector3.z;

				spotDistances[ spotLength ] = distance;

				_direction.copy( _vector3 );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				_direction.sub( _vector3 );
				_direction.normalize();

				spotDirections[ spotOffset ]     = _direction.x;
				spotDirections[ spotOffset + 1 ] = _direction.y;
				spotDirections[ spotOffset + 2 ] = _direction.z;

				spotAnglesCos[ spotLength ] = Math.cos( light.angle );
				spotExponents[ spotLength ] = light.exponent;

				spotLength += 1;

			} else if ( light instanceof THREE.HemisphereLight ) {

				hemiCount += 1;

				if ( ! light.visible ) continue;

				_direction.setFromMatrixPosition( light.matrixWorld );
				_direction.normalize();

				// skip lights with undefined direction
				// these create troubles in OpenGL (making pixel black)

				if ( _direction.x === 0 && _direction.y === 0 && _direction.z === 0 ) continue;

				hemiOffset = hemiLength * 3;

				hemiPositions[ hemiOffset ]     = _direction.x;
				hemiPositions[ hemiOffset + 1 ] = _direction.y;
				hemiPositions[ hemiOffset + 2 ] = _direction.z;

				skyColor = light.color;
				groundColor = light.groundColor;

				if ( _this.gammaInput ) {

					intensitySq = intensity * intensity;

					setColorGamma( hemiSkyColors, hemiOffset, skyColor, intensitySq );
					setColorGamma( hemiGroundColors, hemiOffset, groundColor, intensitySq );

				} else {

					setColorLinear( hemiSkyColors, hemiOffset, skyColor, intensity );
					setColorLinear( hemiGroundColors, hemiOffset, groundColor, intensity );

				}

				hemiLength += 1;

			}

		}

		// null eventual remains from removed lights
		// (this is to avoid if in shader)

		for ( l = dirLength * 3, ll = Math.max( dirColors.length, dirCount * 3 ); l < ll; l ++ ) dirColors[ l ] = 0.0;
		for ( l = pointLength * 3, ll = Math.max( pointColors.length, pointCount * 3 ); l < ll; l ++ ) pointColors[ l ] = 0.0;
		for ( l = spotLength * 3, ll = Math.max( spotColors.length, spotCount * 3 ); l < ll; l ++ ) spotColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiSkyColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiSkyColors[ l ] = 0.0;
		for ( l = hemiLength * 3, ll = Math.max( hemiGroundColors.length, hemiCount * 3 ); l < ll; l ++ ) hemiGroundColors[ l ] = 0.0;

		zlights.directional.length = dirLength;
		zlights.point.length = pointLength;
		zlights.spot.length = spotLength;
		zlights.hemi.length = hemiLength;

		zlights.ambient[ 0 ] = r;
		zlights.ambient[ 1 ] = g;
		zlights.ambient[ 2 ] = b;

	};

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		if ( cullFace === THREE.CullFaceNone ) {

			_gl.disable( _gl.CULL_FACE );

		} else {

			if ( frontFaceDirection === THREE.FrontFaceDirectionCW ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			if ( cullFace === THREE.CullFaceBack ) {

				_gl.cullFace( _gl.BACK );

			} else if ( cullFace === THREE.CullFaceFront ) {

				_gl.cullFace( _gl.FRONT );

			} else {

				_gl.cullFace( _gl.FRONT_AND_BACK );

			}

			_gl.enable( _gl.CULL_FACE );

		}

	};

	this.setMaterialFaces = function ( material ) {

		var doubleSided = material.side === THREE.DoubleSide;
		var flipSided = material.side === THREE.BackSide;

		if ( _oldDoubleSided !== doubleSided ) {

			if ( doubleSided ) {

				_gl.disable( _gl.CULL_FACE );

			} else {

				_gl.enable( _gl.CULL_FACE );

			}

			_oldDoubleSided = doubleSided;

		}

		if ( _oldFlipSided !== flipSided ) {

			if ( flipSided ) {

				_gl.frontFace( _gl.CW );

			} else {

				_gl.frontFace( _gl.CCW );

			}

			_oldFlipSided = flipSided;

		}

	};

	this.setDepthTest = function ( depthTest ) {

		if ( _oldDepthTest !== depthTest ) {

			if ( depthTest ) {

				_gl.enable( _gl.DEPTH_TEST );

			} else {

				_gl.disable( _gl.DEPTH_TEST );

			}

			_oldDepthTest = depthTest;

		}

	};

	this.setDepthWrite = function ( depthWrite ) {

		if ( _oldDepthWrite !== depthWrite ) {

			_gl.depthMask( depthWrite );
			_oldDepthWrite = depthWrite;

		}

	};

	function setLineWidth ( width ) {

		if ( width !== _oldLineWidth ) {

			_gl.lineWidth( width );

			_oldLineWidth = width;

		}

	};

	function setPolygonOffset ( polygonoffset, factor, units ) {

		if ( _oldPolygonOffset !== polygonoffset ) {

			if ( polygonoffset ) {

				_gl.enable( _gl.POLYGON_OFFSET_FILL );

			} else {

				_gl.disable( _gl.POLYGON_OFFSET_FILL );

			}

			_oldPolygonOffset = polygonoffset;

		}

		if ( polygonoffset && ( _oldPolygonOffsetFactor !== factor || _oldPolygonOffsetUnits !== units ) ) {

			_gl.polygonOffset( factor, units );

			_oldPolygonOffsetFactor = factor;
			_oldPolygonOffsetUnits = units;

		}

	};

	this.setBlending = function ( blending, blendEquation, blendSrc, blendDst ) {

		if ( blending !== _oldBlending ) {

			if ( blending === THREE.NoBlending ) {

				_gl.disable( _gl.BLEND );

			} else if ( blending === THREE.AdditiveBlending ) {

				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE );

			} else if ( blending === THREE.SubtractiveBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.ONE_MINUS_SRC_COLOR );

			} else if ( blending === THREE.MultiplyBlending ) {

				// TODO: Find blendFuncSeparate() combination
				_gl.enable( _gl.BLEND );
				_gl.blendEquation( _gl.FUNC_ADD );
				_gl.blendFunc( _gl.ZERO, _gl.SRC_COLOR );

			} else if ( blending === THREE.CustomBlending ) {

				_gl.enable( _gl.BLEND );

			} else {

				_gl.enable( _gl.BLEND );
				_gl.blendEquationSeparate( _gl.FUNC_ADD, _gl.FUNC_ADD );
				_gl.blendFuncSeparate( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA, _gl.ONE, _gl.ONE_MINUS_SRC_ALPHA );

			}

			_oldBlending = blending;

		}

		if ( blending === THREE.CustomBlending ) {

			if ( blendEquation !== _oldBlendEquation ) {

				_gl.blendEquation( paramThreeToGL( blendEquation ) );

				_oldBlendEquation = blendEquation;

			}

			if ( blendSrc !== _oldBlendSrc || blendDst !== _oldBlendDst ) {

				_gl.blendFunc( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ) );

				_oldBlendSrc = blendSrc;
				_oldBlendDst = blendDst;

			}

		} else {

			_oldBlendEquation = null;
			_oldBlendSrc = null;
			_oldBlendDst = null;

		}

	};

	// Defines

	function generateDefines ( defines ) {

		var value, chunk, chunks = [];

		for ( var d in defines ) {

			value = defines[ d ];
			if ( value === false ) continue;

			chunk = "#define " + d + " " + value;
			chunks.push( chunk );

		}

		return chunks.join( "\n" );

	};

	// Shaders

	function buildProgram( shaderID, fragmentShader, vertexShader, uniforms, attributes, defines, parameters, index0AttributeName ) {

		var p, pl, d, program, code;
		var chunks = [];

		// Generate code

		if ( shaderID ) {

			chunks.push( shaderID );

		} else {

			chunks.push( fragmentShader );
			chunks.push( vertexShader );

		}

		for ( d in defines ) {

			chunks.push( d );
			chunks.push( defines[ d ] );

		}

		for ( p in parameters ) {

			chunks.push( p );
			chunks.push( parameters[ p ] );

		}

		code = chunks.join();

		// Check if code has been already compiled

		for ( p = 0, pl = _programs.length; p < pl; p ++ ) {

			var programInfo = _programs[ p ];

			if ( programInfo.code === code ) {

				// console.log( "Code already compiled." /*: \n\n" + code*/ );

				programInfo.usedTimes ++;

				return programInfo.program;

			}

		}

		var shadowMapTypeDefine = "SHADOWMAP_TYPE_BASIC";

		if ( parameters.shadowMapType === THREE.PCFShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF";

		} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {

			shadowMapTypeDefine = "SHADOWMAP_TYPE_PCF_SOFT";

		}

		// console.log( "building new program " );

		//

		var customDefines = generateDefines( defines );

		//

		program = _gl.createProgram();

		var prefix_vertex = [

			"precision " + _precision + " float;",
			"precision " + _precision + " int;",

			customDefines,

			_supportsVertexTextures ? "#define VERTEX_TEXTURES" : "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
			"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
			"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			"#define MAX_BONES " + parameters.maxBones,

			parameters.map ? "#define USE_MAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",

			parameters.skinning ? "#define USE_SKINNING" : "",
			parameters.useVertexTexture ? "#define BONE_TEXTURE" : "",

			parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
			parameters.morphNormals ? "#define USE_MORPHNORMALS" : "",
			parameters.wrapAround ? "#define WRAP_AROUND" : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",

			"uniform mat4 modelMatrix;",
			"uniform mat4 modelViewMatrix;",
			"uniform mat4 projectionMatrix;",
			"uniform mat4 viewMatrix;",
			"uniform mat3 normalMatrix;",
			"uniform vec3 cameraPosition;",

			"attribute vec3 position;",
			"attribute vec3 normal;",
			"attribute vec2 uv;",
			"attribute vec2 uv2;",

			"#ifdef USE_COLOR",

				"attribute vec3 color;",

			"#endif",

			"#ifdef USE_MORPHTARGETS",

				"attribute vec3 morphTarget0;",
				"attribute vec3 morphTarget1;",
				"attribute vec3 morphTarget2;",
				"attribute vec3 morphTarget3;",

				"#ifdef USE_MORPHNORMALS",

					"attribute vec3 morphNormal0;",
					"attribute vec3 morphNormal1;",
					"attribute vec3 morphNormal2;",
					"attribute vec3 morphNormal3;",

				"#else",

					"attribute vec3 morphTarget4;",
					"attribute vec3 morphTarget5;",
					"attribute vec3 morphTarget6;",
					"attribute vec3 morphTarget7;",

				"#endif",

			"#endif",

			"#ifdef USE_SKINNING",

				"attribute vec4 skinIndex;",
				"attribute vec4 skinWeight;",

			"#endif",

			""

		].join("\n");

		var prefix_fragment = [

			"precision " + _precision + " float;",
			"precision " + _precision + " int;",

			( parameters.bumpMap || parameters.normalMap ) ? "#extension GL_OES_standard_derivatives : enable" : "",

			customDefines,

			"#define MAX_DIR_LIGHTS " + parameters.maxDirLights,
			"#define MAX_POINT_LIGHTS " + parameters.maxPointLights,
			"#define MAX_SPOT_LIGHTS " + parameters.maxSpotLights,
			"#define MAX_HEMI_LIGHTS " + parameters.maxHemiLights,

			"#define MAX_SHADOWS " + parameters.maxShadows,

			parameters.alphaTest ? "#define ALPHATEST " + parameters.alphaTest: "",

			_this.gammaInput ? "#define GAMMA_INPUT" : "",
			_this.gammaOutput ? "#define GAMMA_OUTPUT" : "",

			( parameters.useFog && parameters.fog ) ? "#define USE_FOG" : "",
			( parameters.useFog && parameters.fogExp ) ? "#define FOG_EXP2" : "",

			parameters.map ? "#define USE_MAP" : "",
			parameters.envMap ? "#define USE_ENVMAP" : "",
			parameters.lightMap ? "#define USE_LIGHTMAP" : "",
			parameters.bumpMap ? "#define USE_BUMPMAP" : "",
			parameters.normalMap ? "#define USE_NORMALMAP" : "",
			parameters.specularMap ? "#define USE_SPECULARMAP" : "",
			parameters.vertexColors ? "#define USE_COLOR" : "",

			parameters.metal ? "#define METAL" : "",
			parameters.wrapAround ? "#define WRAP_AROUND" : "",
			parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
			parameters.flipSided ? "#define FLIP_SIDED" : "",

			parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
			parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
			parameters.shadowMapDebug ? "#define SHADOWMAP_DEBUG" : "",
			parameters.shadowMapCascade ? "#define SHADOWMAP_CASCADE" : "",

			"uniform mat4 viewMatrix;",
			"uniform vec3 cameraPosition;",
			""

		].join("\n");

		var glVertexShader = getShader( "vertex", prefix_vertex + vertexShader );
		var glFragmentShader = getShader( "fragment", prefix_fragment + fragmentShader );

		_gl.attachShader( program, glVertexShader );
		_gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.
		// because potentially expensive emulation is done by browser if attribute 0 is disabled.
		// And, color, for example is often automatically bound to index 0 so disabling it
		if ( index0AttributeName !== undefined ) {

			_gl.bindAttribLocation( program, 0, index0AttributeName );

		}

		_gl.linkProgram( program );

		if ( _gl.getProgramParameter( program, _gl.LINK_STATUS ) === false ) {

			console.error( 'Could not initialise shader' );
			console.error( 'gl.VALIDATE_STATUS', _gl.getProgramParameter( program, _gl.VALIDATE_STATUS ) );
			console.error( 'gl.getError()', _gl.getError() );

		}

		if ( _gl.getProgramInfoLog( program ) !== '' ) {

			console.error( 'gl.getProgramInfoLog()', _gl.getProgramInfoLog( program ) );

		}

		// clean up

		_gl.deleteShader( glFragmentShader );
		_gl.deleteShader( glVertexShader );

		// console.log( prefix_fragment + fragmentShader );
		// console.log( prefix_vertex + vertexShader );

		program.uniforms = {};
		program.attributes = {};

		var identifiers, u, a, i;

		// cache uniform locations

		identifiers = [

			'viewMatrix', 'modelViewMatrix', 'projectionMatrix', 'normalMatrix', 'modelMatrix', 'cameraPosition',
			'morphTargetInfluences'

		];

		if ( parameters.useVertexTexture ) {

			identifiers.push( 'boneTexture' );
			identifiers.push( 'boneTextureWidth' );
			identifiers.push( 'boneTextureHeight' );

		} else {

			identifiers.push( 'boneGlobalMatrices' );

		}

		for ( u in uniforms ) {

			identifiers.push( u );

		}

		cacheUniformLocations( program, identifiers );

		// cache attributes locations

		identifiers = [

			"position", "normal", "uv", "uv2", "tangent", "color",
			"skinIndex", "skinWeight", "lineDistance"

		];

		for ( i = 0; i < parameters.maxMorphTargets; i ++ ) {

			identifiers.push( "morphTarget" + i );

		}

		for ( i = 0; i < parameters.maxMorphNormals; i ++ ) {

			identifiers.push( "morphNormal" + i );

		}

		for ( a in attributes ) {

			identifiers.push( a );

		}

		cacheAttributeLocations( program, identifiers );

		program.id = _programs_counter ++;

		_programs.push( { program: program, code: code, usedTimes: 1 } );

		_this.info.memory.programs = _programs.length;

		return program;

	};

	// Shader parameters cache

	function cacheUniformLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i ++ ) {

			id = identifiers[ i ];
			program.uniforms[ id ] = _gl.getUniformLocation( program, id );

		}

	};

	function cacheAttributeLocations ( program, identifiers ) {

		var i, l, id;

		for( i = 0, l = identifiers.length; i < l; i ++ ) {

			id = identifiers[ i ];
			program.attributes[ id ] = _gl.getAttribLocation( program, id );

		}

	};

	function addLineNumbers ( string ) {

		var chunks = string.split( "\n" );

		for ( var i = 0, il = chunks.length; i < il; i ++ ) {

			// Chrome reports shader errors on lines
			// starting counting from 1

			chunks[ i ] = ( i + 1 ) + ": " + chunks[ i ];

		}

		return chunks.join( "\n" );

	};

	function getShader ( type, string ) {

		var shader;

		if ( type === "fragment" ) {

			shader = _gl.createShader( _gl.FRAGMENT_SHADER );

		} else if ( type === "vertex" ) {

			shader = _gl.createShader( _gl.VERTEX_SHADER );

		}

		_gl.shaderSource( shader, string );
		_gl.compileShader( shader );

		if ( !_gl.getShaderParameter( shader, _gl.COMPILE_STATUS ) ) {

			console.error( _gl.getShaderInfoLog( shader ) );
			console.error( addLineNumbers( string ) );
			return null;

		}

		return shader;

	};

	// Textures

	function setTextureParameters ( textureType, texture, isImagePowerOfTwo ) {

		if ( isImagePowerOfTwo ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

		}

		if ( _glExtensionTextureFilterAnisotropic && texture.type !== THREE.FloatType ) {

			if ( texture.anisotropy > 1 || texture.__oldAnisotropy ) {

				_gl.texParameterf( textureType, _glExtensionTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _maxAnisotropy ) );
				texture.__oldAnisotropy = texture.anisotropy;

			}

		}

	};

	this.setTexture = function ( texture, slot ) {

		if ( texture.needsUpdate ) {

			if ( ! texture.__webglInit ) {

				texture.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				texture.__webglTexture = _gl.createTexture();

				_this.info.memory.textures ++;

			}

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

			_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
			_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
			_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

			var image = texture.image,
			isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
			glFormat = paramThreeToGL( texture.format ),
			glType = paramThreeToGL( texture.type );

			setTextureParameters( _gl.TEXTURE_2D, texture, isImagePowerOfTwo );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture instanceof THREE.DataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

				}

			} else if ( texture instanceof THREE.CompressedTexture ) {

				for( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					if ( texture.format!==THREE.RGBAFormat ) {
						_gl.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
					} else {
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
					}

				}

			} else { // regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && isImagePowerOfTwo ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						_gl.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;

				} else {

					_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, texture.image );

				}

			}

			if ( texture.generateMipmaps && isImagePowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			texture.needsUpdate = false;

			if ( texture.onUpdate ) texture.onUpdate();

		} else {

			_gl.activeTexture( _gl.TEXTURE0 + slot );
			_gl.bindTexture( _gl.TEXTURE_2D, texture.__webglTexture );

		}

	};

	function clampToMaxSize ( image, maxSize ) {

		if ( image.width <= maxSize && image.height <= maxSize ) {

			return image;

		}

		// Warning: Scaling through the canvas will only work with images that use
		// premultiplied alpha.

		var maxDimension = Math.max( image.width, image.height );
		var newWidth = Math.floor( image.width * maxSize / maxDimension );
		var newHeight = Math.floor( image.height * maxSize / maxDimension );

		var canvas = document.createElement( 'canvas' );
		canvas.width = newWidth;
		canvas.height = newHeight;

		var ctx = canvas.getContext( "2d" );
		ctx.drawImage( image, 0, 0, image.width, image.height, 0, 0, newWidth, newHeight );

		return canvas;

	}

	function setCubeTexture ( texture, slot ) {

		if ( texture.image.length === 6 ) {

			if ( texture.needsUpdate ) {

				if ( ! texture.image.__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					texture.image.__webglTextureCube = _gl.createTexture();

					_this.info.memory.textures ++;

				}

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = texture instanceof THREE.CompressedTexture;

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( _this.autoScaleCubemaps && ! isCompressed ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], _maxCubemapSize );

					} else {

						cubeImage[ i ] = texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isImagePowerOfTwo = THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isImagePowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					if( !isCompressed ) {

						_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

					} else {
						
						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];
							if ( texture.format!==THREE.RGBAFormat ) {

								_gl.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

							} else {
								_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
							}

						}
					}
				}

				if ( texture.generateMipmaps && isImagePowerOfTwo ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				texture.needsUpdate = false;

				if ( texture.onUpdate ) texture.onUpdate();

			} else {

				_gl.activeTexture( _gl.TEXTURE0 + slot );
				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.image.__webglTextureCube );

			}

		}

	};

	function setCubeTextureDynamic ( texture, slot ) {

		_gl.activeTexture( _gl.TEXTURE0 + slot );
		_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, texture.__webglTexture );

	};

	// Render targets

	function setupFrameBuffer ( framebuffer, renderTarget, textureTarget ) {

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, textureTarget, renderTarget.__webglTexture, 0 );

	};

	function setupRenderBuffer ( renderbuffer, renderTarget  ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		/* For some reason this is not working. Defaulting to RGBA4.
		} else if( ! renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.STENCIL_INDEX8, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
		*/
		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

	};

	this.setRenderTarget = function ( renderTarget ) {

		var isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );

		if ( renderTarget && ! renderTarget.__webglFramebuffer ) {

			if ( renderTarget.depthBuffer === undefined ) renderTarget.depthBuffer = true;
			if ( renderTarget.stencilBuffer === undefined ) renderTarget.stencilBuffer = true;

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			renderTarget.__webglTexture = _gl.createTexture();

			_this.info.memory.textures ++;

			// Setup texture, create render and frame buffers

			var isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height ),
				glFormat = paramThreeToGL( renderTarget.format ),
				glType = paramThreeToGL( renderTarget.type );

			if ( isCube ) {

				renderTarget.__webglFramebuffer = [];
				renderTarget.__webglRenderbuffer = [];

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget, isTargetPowerOfTwo );

				for ( var i = 0; i < 6; i ++ ) {

					renderTarget.__webglFramebuffer[ i ] = _gl.createFramebuffer();
					renderTarget.__webglRenderbuffer[ i ] = _gl.createRenderbuffer();

					_gl.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

					setupFrameBuffer( renderTarget.__webglFramebuffer[ i ], renderTarget, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
					setupRenderBuffer( renderTarget.__webglRenderbuffer[ i ], renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

			} else {

				renderTarget.__webglFramebuffer = _gl.createFramebuffer();

				if ( renderTarget.shareDepthFrom ) {

					renderTarget.__webglRenderbuffer = renderTarget.shareDepthFrom.__webglRenderbuffer;

				} else {

					renderTarget.__webglRenderbuffer = _gl.createRenderbuffer();

				}

				_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
				setTextureParameters( _gl.TEXTURE_2D, renderTarget, isTargetPowerOfTwo );

				_gl.texImage2D( _gl.TEXTURE_2D, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

				setupFrameBuffer( renderTarget.__webglFramebuffer, renderTarget, _gl.TEXTURE_2D );

				if ( renderTarget.shareDepthFrom ) {

					if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

						_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderTarget.__webglRenderbuffer );

					}

				} else {

					setupRenderBuffer( renderTarget.__webglRenderbuffer, renderTarget );

				}

				if ( isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );

			}

			// Release everything

			if ( isCube ) {

				_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

			} else {

				_gl.bindTexture( _gl.TEXTURE_2D, null );

			}

			_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
			_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

		}

		var framebuffer, width, height, vx, vy;

		if ( renderTarget ) {

			if ( isCube ) {

				framebuffer = renderTarget.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTarget.__webglFramebuffer;

			}

			width = renderTarget.width;
			height = renderTarget.height;

			vx = 0;
			vy = 0;

		} else {

			framebuffer = null;

			width = _viewportWidth;
			height = _viewportHeight;

			vx = _viewportX;
			vy = _viewportY;

		}

		if ( framebuffer !== _currentFramebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_gl.viewport( vx, vy, width, height );

			_currentFramebuffer = framebuffer;

		}

		_currentWidth = width;
		_currentHeight = height;

	};

	function updateRenderTargetMipmap ( renderTarget ) {

		if ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {

			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			_gl.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			_gl.bindTexture( _gl.TEXTURE_2D, renderTarget.__webglTexture );
			_gl.generateMipmap( _gl.TEXTURE_2D );
			_gl.bindTexture( _gl.TEXTURE_2D, null );

		}

	};

	// Fallback filters for non-power-of-2 textures

	function filterFallback ( f ) {

		if ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	};

	// Map three.js constants to WebGL constants

	function paramThreeToGL ( p ) {

		if ( p === THREE.RepeatWrapping ) return _gl.REPEAT;
		if ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === THREE.NearestFilter ) return _gl.NEAREST;
		if ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === THREE.LinearFilter ) return _gl.LINEAR;
		if ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === THREE.ByteType ) return _gl.BYTE;
		if ( p === THREE.ShortType ) return _gl.SHORT;
		if ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === THREE.IntType ) return _gl.INT;
		if ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === THREE.FloatType ) return _gl.FLOAT;

		if ( p === THREE.AlphaFormat ) return _gl.ALPHA;
		if ( p === THREE.RGBFormat ) return _gl.RGB;
		if ( p === THREE.RGBAFormat ) return _gl.RGBA;
		if ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;

		if ( p === THREE.AddEquation ) return _gl.FUNC_ADD;
		if ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === THREE.ZeroFactor ) return _gl.ZERO;
		if ( p === THREE.OneFactor ) return _gl.ONE;
		if ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;
		if ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		if ( _glExtensionCompressedTextureS3TC !== undefined ) {

			if ( p === THREE.RGB_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT1_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT1_EXT;
			if ( p === THREE.RGBA_S3TC_DXT3_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;
			if ( p === THREE.RGBA_S3TC_DXT5_Format ) return _glExtensionCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;

		}

		return 0;

	};

	// Allocations

	function allocateBones ( object ) {

		if ( _supportsBoneTextures && object && object.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader
			//   to be used with multiple objects )
			//
			// 	- leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = _gl.getParameter( _gl.MAX_VERTEX_UNIFORM_VECTORS );
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && object instanceof THREE.SkinnedMesh ) {

				maxBones = Math.min( object.bones.length, maxBones );

				if ( maxBones < object.bones.length ) {

					console.warn( "WebGLRenderer: too many bones - " + object.bones.length + ", this GPU supports just " + maxBones + " (try OpenGL instead of ANGLE)" );

				}

			}

			return maxBones;

		}

	};

	function allocateLights( lights ) {

		var dirLights = 0;
		var pointLights = 0;
		var spotLights = 0;
		var hemiLights = 0;

		for ( var l = 0, ll = lights.length; l < ll; l ++ ) {

			var light = lights[ l ];

			if ( light.onlyShadow || light.visible === false ) continue;

			if ( light instanceof THREE.DirectionalLight ) dirLights ++;
			if ( light instanceof THREE.PointLight ) pointLights ++;
			if ( light instanceof THREE.SpotLight ) spotLights ++;
			if ( light instanceof THREE.HemisphereLight ) hemiLights ++;

		}

		return { 'directional' : dirLights, 'point' : pointLights, 'spot': spotLights, 'hemi': hemiLights };

	};

	function allocateShadows( lights ) {

		var maxShadows = 0;

		for ( var l = 0, ll = lights.length; l < ll; l++ ) {

			var light = lights[ l ];

			if ( ! light.castShadow ) continue;

			if ( light instanceof THREE.SpotLight ) maxShadows ++;
			if ( light instanceof THREE.DirectionalLight && ! light.shadowCascade ) maxShadows ++;

		}

		return maxShadows;

	};

	// Initialization

	function initGL() {

		try {

			var attributes = {
				alpha: _alpha,
				premultipliedAlpha: _premultipliedAlpha,
				antialias: _antialias,
				stencil: _stencil,
				preserveDrawingBuffer: _preserveDrawingBuffer
			};

			_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

			if ( _gl === null ) {

				throw 'Error creating WebGL context.';

			}

		} catch ( error ) {

			console.error( error );

		}

		_glExtensionTextureFloat = _gl.getExtension( 'OES_texture_float' );
		_glExtensionTextureFloatLinear = _gl.getExtension( 'OES_texture_float_linear' );
		_glExtensionStandardDerivatives = _gl.getExtension( 'OES_standard_derivatives' );

		_glExtensionTextureFilterAnisotropic = _gl.getExtension( 'EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || _gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );

		_glExtensionCompressedTextureS3TC = _gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || _gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );

		if ( ! _glExtensionTextureFloat ) {

			console.log( 'THREE.WebGLRenderer: Float textures not supported.' );

		}

		if ( ! _glExtensionStandardDerivatives ) {

			console.log( 'THREE.WebGLRenderer: Standard derivatives not supported.' );

		}

		if ( ! _glExtensionTextureFilterAnisotropic ) {

			console.log( 'THREE.WebGLRenderer: Anisotropic texture filtering not supported.' );

		}

		if ( ! _glExtensionCompressedTextureS3TC ) {

			console.log( 'THREE.WebGLRenderer: S3TC compressed textures not supported.' );

		}

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function() {

				return {
					"rangeMin"  : 1,
					"rangeMax"  : 1,
					"precision" : 1
				};

			}
		}

	};

	function setDefaultGLState () {

		_gl.clearColor( 0, 0, 0, 1 );
		_gl.clearDepth( 1 );
		_gl.clearStencil( 0 );

		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthFunc( _gl.LEQUAL );

		_gl.frontFace( _gl.CCW );
		_gl.cullFace( _gl.BACK );
		_gl.enable( _gl.CULL_FACE );

		_gl.enable( _gl.BLEND );
		_gl.blendEquation( _gl.FUNC_ADD );
		_gl.blendFunc( _gl.SRC_ALPHA, _gl.ONE_MINUS_SRC_ALPHA );

		_gl.viewport( _viewportX, _viewportY, _viewportWidth, _viewportHeight );
		
		_gl.clearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );

	};

	// default plugins (order is important)

	this.shadowMapPlugin = new THREE.ShadowMapPlugin();
	this.addPrePlugin( this.shadowMapPlugin );

	this.addPostPlugin( new THREE.SpritePlugin() );
	this.addPostPlugin( new THREE.LensFlarePlugin() );

};

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.WebGLRenderTarget = function ( width, height, options ) {

	this.width = width;
	this.height = height;

	options = options || {};

	this.wrapS = options.wrapS !== undefined ? options.wrapS : THREE.ClampToEdgeWrapping;
	this.wrapT = options.wrapT !== undefined ? options.wrapT : THREE.ClampToEdgeWrapping;

	this.magFilter = options.magFilter !== undefined ? options.magFilter : THREE.LinearFilter;
	this.minFilter = options.minFilter !== undefined ? options.minFilter : THREE.LinearMipMapLinearFilter;

	this.anisotropy = options.anisotropy !== undefined ? options.anisotropy : 1;

	this.offset = new THREE.Vector2( 0, 0 );
	this.repeat = new THREE.Vector2( 1, 1 );

	this.format = options.format !== undefined ? options.format : THREE.RGBAFormat;
	this.type = options.type !== undefined ? options.type : THREE.UnsignedByteType;

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;

	this.generateMipmaps = true;

	this.shareDepthFrom = null;

};

THREE.WebGLRenderTarget.prototype = {

	constructor: THREE.WebGLRenderTarget,

	clone: function () {

		var tmp = new THREE.WebGLRenderTarget( this.width, this.height );

		tmp.wrapS = this.wrapS;
		tmp.wrapT = this.wrapT;

		tmp.magFilter = this.magFilter;
		tmp.minFilter = this.minFilter;

		tmp.anisotropy = this.anisotropy;

		tmp.offset.copy( this.offset );
		tmp.repeat.copy( this.repeat );

		tmp.format = this.format;
		tmp.type = this.type;

		tmp.depthBuffer = this.depthBuffer;
		tmp.stencilBuffer = this.stencilBuffer;

		tmp.generateMipmaps = this.generateMipmaps;

		tmp.shareDepthFrom = this.shareDepthFrom;

		return tmp;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

THREE.EventDispatcher.prototype.apply( THREE.WebGLRenderTarget.prototype );

/**
 * @author alteredq / http://alteredqualia.com
 */

THREE.WebGLRenderTargetCube = function ( width, height, options ) {

	THREE.WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5

};

THREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableVertex = function () {

	this.position = new THREE.Vector3();
	this.positionWorld = new THREE.Vector3();
	this.positionScreen = new THREE.Vector4();

	this.visible = true;

};

THREE.RenderableVertex.prototype.copy = function ( vertex ) {

	this.positionWorld.copy( vertex.positionWorld );
	this.positionScreen.copy( vertex.positionScreen );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableFace = function () {

	this.id = 0;

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();
	this.v3 = new THREE.RenderableVertex();

	this.centroidModel = new THREE.Vector3();

	this.normalModel = new THREE.Vector3();

	this.vertexNormalsModel = [ new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3() ];
	this.vertexNormalsLength = 0;

	this.color = null;
	this.material = null;
	this.uvs = [[]];

	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableObject = function () {

	this.id = 0;

	this.object = null;
	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableSprite = function () {

	this.id = 0;

	this.object = null;

	this.x = 0;
	this.y = 0;
	this.z = 0;

	this.rotation = 0;
	this.scale = new THREE.Vector2();

	this.material = null;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.RenderableLine = function () {

	this.id = 0;

	this.v1 = new THREE.RenderableVertex();
	this.v2 = new THREE.RenderableVertex();

	this.vertexColors = [ new THREE.Color(), new THREE.Color() ];
	this.material = null;

	this.z = 0;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.GeometryUtils = {

	// Merge two geometries or geometry and geometry from object (using object's transform)

	merge: function ( geometry1, object2 /* mesh | geometry */, materialIndexOffset ) {

		var matrix, normalMatrix,
		vertexOffset = geometry1.vertices.length,
		uvPosition = geometry1.faceVertexUvs[ 0 ].length,
		geometry2 = object2 instanceof THREE.Mesh ? object2.geometry : object2,
		vertices1 = geometry1.vertices,
		vertices2 = geometry2.vertices,
		faces1 = geometry1.faces,
		faces2 = geometry2.faces,
		uvs1 = geometry1.faceVertexUvs[ 0 ],
		uvs2 = geometry2.faceVertexUvs[ 0 ];

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( object2 instanceof THREE.Mesh ) {

			object2.matrixAutoUpdate && object2.updateMatrix();

			matrix = object2.matrix;

			normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faceCopy.centroid.copy( face.centroid );

			if ( matrix ) {

				faceCopy.centroid.applyMatrix4( matrix );

			}

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( new THREE.Vector2( uv[ j ].x, uv[ j ].y ) );

			}

			uvs1.push( uvCopy );

		}

	},

	// Get random point in triangle (via barycentric coordinates)
	// 	(uniform distribution)
	// 	http://www.cgafaq.info/wiki/Random_Point_In_Triangle

	randomPointInTriangle: function () {

		var vector = new THREE.Vector3();

		return function ( vectorA, vectorB, vectorC ) {

			var point = new THREE.Vector3();

			var a = THREE.Math.random16();
			var b = THREE.Math.random16();

			if ( ( a + b ) > 1 ) {

				a = 1 - a;
				b = 1 - b;

			}

			var c = 1 - a - b;

			point.copy( vectorA );
			point.multiplyScalar( a );

			vector.copy( vectorB );
			vector.multiplyScalar( b );

			point.add( vector );

			vector.copy( vectorC );
			vector.multiplyScalar( c );

			point.add( vector );

			return point;

		};

	}(),

	// Get random point in face (triangle / quad)
	// (uniform distribution)

	randomPointInFace: function ( face, geometry, useCachedAreas ) {

		var vA, vB, vC, vD;

		vA = geometry.vertices[ face.a ];
		vB = geometry.vertices[ face.b ];
		vC = geometry.vertices[ face.c ];

		return THREE.GeometryUtils.randomPointInTriangle( vA, vB, vC );

	},

	// Get uniformly distributed random points in mesh
	// 	- create array with cumulative sums of face areas
	//  - pick random number from 0 to total area
	//  - find corresponding place in area array by binary search
	//	- get random point in face

	randomPointsInGeometry: function ( geometry, n ) {

		var face, i,
			faces = geometry.faces,
			vertices = geometry.vertices,
			il = faces.length,
			totalArea = 0,
			cumulativeAreas = [],
			vA, vB, vC, vD;

		// precompute face areas

		for ( i = 0; i < il; i ++ ) {

			face = faces[ i ];

			vA = vertices[ face.a ];
			vB = vertices[ face.b ];
			vC = vertices[ face.c ];

			face._area = THREE.GeometryUtils.triangleArea( vA, vB, vC );

			totalArea += face._area;

			cumulativeAreas[ i ] = totalArea;

		}

		// binary search cumulative areas array

		function binarySearchIndices( value ) {

			function binarySearch( start, end ) {

				// return closest larger index
				// if exact number is not found

				if ( end < start )
					return start;

				var mid = start + Math.floor( ( end - start ) / 2 );

				if ( cumulativeAreas[ mid ] > value ) {

					return binarySearch( start, mid - 1 );

				} else if ( cumulativeAreas[ mid ] < value ) {

					return binarySearch( mid + 1, end );

				} else {

					return mid;

				}

			}

			var result = binarySearch( 0, cumulativeAreas.length - 1 )
			return result;

		}

		// pick random face weighted by face area

		var r, index,
			result = [];

		var stats = {};

		for ( i = 0; i < n; i ++ ) {

			r = THREE.Math.random16() * totalArea;

			index = binarySearchIndices( r );

			result[ i ] = THREE.GeometryUtils.randomPointInFace( faces[ index ], geometry, true );

			if ( ! stats[ index ] ) {

				stats[ index ] = 1;

			} else {

				stats[ index ] += 1;

			}

		}

		return result;

	},

	// Get triangle area (half of parallelogram)
	//	http://mathworld.wolfram.com/TriangleArea.html

	triangleArea: function () {

		var vector1 = new THREE.Vector3();
		var vector2 = new THREE.Vector3();

		return function ( vectorA, vectorB, vectorC ) {

			vector1.subVectors( vectorB, vectorA );
			vector2.subVectors( vectorC, vectorA );
			vector1.cross( vector2 );

			return 0.5 * vector1.length();

		};

	}(),

	// Center geometry so that 0,0,0 is in center of bounding box

	center: function ( geometry ) {

		geometry.computeBoundingBox();

		var bb = geometry.boundingBox;

		var offset = new THREE.Vector3();

		offset.addVectors( bb.min, bb.max );
		offset.multiplyScalar( -0.5 );

		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( offset.x, offset.y, offset.z ) );
		geometry.computeBoundingBox();

		return offset;

	},

	triangulateQuads: function ( geometry ) {

		var i, il, j, jl;

		var faces = [];
		var faceVertexUvs = [];

		for ( i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {

			faceVertexUvs[ i ] = [];

		}

		for ( i = 0, il = geometry.faces.length; i < il; i ++ ) {

			var face = geometry.faces[ i ];

			faces.push( face );

			for ( j = 0, jl = geometry.faceVertexUvs.length; j < jl; j ++ ) {

				faceVertexUvs[ j ].push( geometry.faceVertexUvs[ j ][ i ] );

			}

		}

		geometry.faces = faces;
		geometry.faceVertexUvs = faceVertexUvs;

		geometry.computeCentroids();
		geometry.computeFaceNormals();
		geometry.computeVertexNormals();

		if ( geometry.hasTangents ) geometry.computeTangents();

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		var loader = new THREE.ImageLoader();
		loader.crossOrigin = this.crossOrigin;

		var texture = new THREE.Texture( undefined, mapping );

		var image = loader.load( url, function () {

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		} );

		texture.image = image;
		texture.sourceFile = url;

		return texture;

	},

	loadCompressedTexture: function ( url, mapping, onLoad, onError ) {

		var texture = new THREE.CompressedTexture();
		texture.mapping = mapping;

		var request = new XMLHttpRequest();

		request.onload = function () {

			var buffer = request.response;
			var dds = THREE.ImageUtils.parseDDS( buffer, true );

			texture.format = dds.format;

			texture.mipmaps = dds.mipmaps;
			texture.image.width = dds.width;
			texture.image.height = dds.height;

			// gl.generateMipmap fails for compressed textures
			// mipmaps must be embedded in the DDS file
			// or texture filters must not use mipmapping

			texture.generateMipmaps = false;

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture );

		}

		request.onerror = onError;

		request.open( 'GET', url, true );
		request.responseType = "arraybuffer";
		request.send( null );

		return texture;

	},

	loadTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.Texture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping needed for cube textures

		texture.flipY = false;

		for ( var i = 0, il = array.length; i < il; ++ i ) {

			var cubeImage = new Image();
			images[ i ] = cubeImage;

			cubeImage.onload = function () {

				images.loadCount += 1;

				if ( images.loadCount === 6 ) {

					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			};

			cubeImage.onerror = onError;

			cubeImage.crossOrigin = this.crossOrigin;
			cubeImage.src = array[ i ];

		}

		return texture;

	},

	loadCompressedTextureCube: function ( array, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.CompressedTexture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		texture.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		texture.generateMipmaps = false;

		var generateCubeFaceCallback = function ( rq, img ) {

			return function () {

				var buffer = rq.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				img.format = dds.format;

				img.mipmaps = dds.mipmaps;
				img.width = dds.width;
				img.height = dds.height;

				images.loadCount += 1;

				if ( images.loadCount === 6 ) {

					texture.format = dds.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			}

		}

		// compressed cubemap textures as 6 separate DDS files

		if ( array instanceof Array ) {

			for ( var i = 0, il = array.length; i < il; ++ i ) {

				var cubeImage = {};
				images[ i ] = cubeImage;

				var request = new XMLHttpRequest();

				request.onload = generateCubeFaceCallback( request, cubeImage );
				request.onerror = onError;

				var url = array[ i ];

				request.open( 'GET', url, true );
				request.responseType = "arraybuffer";
				request.send( null );

			}

		// compressed cubemap texture stored in a single DDS file

		} else {

			var url = array;
			var request = new XMLHttpRequest();

			request.onload = function( ) {

				var buffer = request.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				if ( dds.isCubemap ) {

					var faces = dds.mipmaps.length / dds.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < dds.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
							images[ f ].format = dds.format;
							images[ f ].width = dds.width;
							images[ f ].height = dds.height;

						}

					}

					texture.format = dds.format;
					texture.needsUpdate = true;
					if ( onLoad ) onLoad( texture );

				}

			}

			request.onerror = onError;

			request.open( 'GET', url, true );
			request.responseType = "arraybuffer";
			request.send( null );

		}

		return texture;

	},

	loadDDSTexture: function ( url, mapping, onLoad, onError ) {

		var images = [];
		images.loadCount = 0;

		var texture = new THREE.CompressedTexture();
		texture.image = images;
		if ( mapping !== undefined ) texture.mapping = mapping;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		texture.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		texture.generateMipmaps = false;

		{
			var request = new XMLHttpRequest();

			request.onload = function( ) {

				var buffer = request.response;
				var dds = THREE.ImageUtils.parseDDS( buffer, true );

				if ( dds.isCubemap ) {

					var faces = dds.mipmaps.length / dds.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < dds.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( dds.mipmaps[ f * dds.mipmapCount + i ] );
							images[ f ].format = dds.format;
							images[ f ].width = dds.width;
							images[ f ].height = dds.height;

						}

					}


				} else {
					texture.image.width = dds.width;
					texture.image.height = dds.height;
					texture.mipmaps = dds.mipmaps;
				}

				texture.format = dds.format;
				texture.needsUpdate = true;
				if ( onLoad ) onLoad( texture );

			}

			request.onerror = onError;

			request.open( 'GET', url, true );
			request.responseType = "arraybuffer";
			request.send( null );

		}

		return texture;

	},

	parseDDS: function ( buffer, loadMipmaps ) {

		var dds = { mipmaps: [], width: 0, height: 0, format: null, mipmapCount: 1 };

		// Adapted from @toji's DDS utils
		//	https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js

		// All values and structures referenced from:
		// http://msdn.microsoft.com/en-us/library/bb943991.aspx/

		var DDS_MAGIC = 0x20534444;

		var DDSD_CAPS = 0x1,
			DDSD_HEIGHT = 0x2,
			DDSD_WIDTH = 0x4,
			DDSD_PITCH = 0x8,
			DDSD_PIXELFORMAT = 0x1000,
			DDSD_MIPMAPCOUNT = 0x20000,
			DDSD_LINEARSIZE = 0x80000,
			DDSD_DEPTH = 0x800000;

		var DDSCAPS_COMPLEX = 0x8,
			DDSCAPS_MIPMAP = 0x400000,
			DDSCAPS_TEXTURE = 0x1000;

		var DDSCAPS2_CUBEMAP = 0x200,
			DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
			DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
			DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
			DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
			DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
			DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
			DDSCAPS2_VOLUME = 0x200000;

		var DDPF_ALPHAPIXELS = 0x1,
			DDPF_ALPHA = 0x2,
			DDPF_FOURCC = 0x4,
			DDPF_RGB = 0x40,
			DDPF_YUV = 0x200,
			DDPF_LUMINANCE = 0x20000;

		function fourCCToInt32( value ) {

			return value.charCodeAt(0) +
				(value.charCodeAt(1) << 8) +
				(value.charCodeAt(2) << 16) +
				(value.charCodeAt(3) << 24);

		}

		function int32ToFourCC( value ) {

			return String.fromCharCode(
				value & 0xff,
				(value >> 8) & 0xff,
				(value >> 16) & 0xff,
				(value >> 24) & 0xff
			);
		}

		function loadARGBMip( buffer, dataOffset, width, height ) {
			var dataLength = width*height*4;
			var srcBuffer = new Uint8Array( buffer, dataOffset, dataLength );
			var byteArray = new Uint8Array( dataLength );
			var dst = 0;
			var src = 0;
			for ( var y = 0; y < height; y++ ) {
				for ( var x = 0; x < width; x++ ) {
					var b = srcBuffer[src]; src++;
					var g = srcBuffer[src]; src++;
					var r = srcBuffer[src]; src++;
					var a = srcBuffer[src]; src++;
					byteArray[dst] = r; dst++;	//r
					byteArray[dst] = g; dst++;	//g
					byteArray[dst] = b; dst++;	//b
					byteArray[dst] = a; dst++;	//a
				}
			}
			return byteArray;
		}

		var FOURCC_DXT1 = fourCCToInt32("DXT1");
		var FOURCC_DXT3 = fourCCToInt32("DXT3");
		var FOURCC_DXT5 = fourCCToInt32("DXT5");

		var headerLengthInt = 31; // The header length in 32 bit ints

		// Offsets into the header array

		var off_magic = 0;

		var off_size = 1;
		var off_flags = 2;
		var off_height = 3;
		var off_width = 4;

		var off_mipmapCount = 7;

		var off_pfFlags = 20;
		var off_pfFourCC = 21;
		var off_RGBBitCount = 22;
		var off_RBitMask = 23;
		var off_GBitMask = 24;
		var off_BBitMask = 25;
		var off_ABitMask = 26;

		var off_caps = 27;
		var off_caps2 = 28;
		var off_caps3 = 29;
		var off_caps4 = 30;

		// Parse header

		var header = new Int32Array( buffer, 0, headerLengthInt );

		if ( header[ off_magic ] !== DDS_MAGIC ) {

			console.error( "ImageUtils.parseDDS(): Invalid magic number in DDS header" );
			return dds;

		}

		if ( ! header[ off_pfFlags ] & DDPF_FOURCC ) {

			console.error( "ImageUtils.parseDDS(): Unsupported format, must contain a FourCC code" );
			return dds;

		}

		var blockBytes;

		var fourCC = header[ off_pfFourCC ];

		var isRGBAUncompressed = false;

		switch ( fourCC ) {

			case FOURCC_DXT1:

				blockBytes = 8;
				dds.format = THREE.RGB_S3TC_DXT1_Format;
				break;

			case FOURCC_DXT3:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT3_Format;
				break;

			case FOURCC_DXT5:

				blockBytes = 16;
				dds.format = THREE.RGBA_S3TC_DXT5_Format;
				break;

			default:

				if( header[off_RGBBitCount] ==32 
					&& header[off_RBitMask]&0xff0000
					&& header[off_GBitMask]&0xff00 
					&& header[off_BBitMask]&0xff
					&& header[off_ABitMask]&0xff000000  ) {
					isRGBAUncompressed = true;
					blockBytes = 64;
					dds.format = THREE.RGBAFormat;
				} else {
					console.error( "ImageUtils.parseDDS(): Unsupported FourCC code: ", int32ToFourCC( fourCC ) );
					return dds;
				}
		}

		dds.mipmapCount = 1;

		if ( header[ off_flags ] & DDSD_MIPMAPCOUNT && loadMipmaps !== false ) {

			dds.mipmapCount = Math.max( 1, header[ off_mipmapCount ] );

		}

		//TODO: Verify that all faces of the cubemap are present with DDSCAPS2_CUBEMAP_POSITIVEX, etc.

		dds.isCubemap = header[ off_caps2 ] & DDSCAPS2_CUBEMAP ? true : false;

		dds.width = header[ off_width ];
		dds.height = header[ off_height ];

		var dataOffset = header[ off_size ] + 4;

		// Extract mipmaps buffers

		var width = dds.width;
		var height = dds.height;

		var faces = dds.isCubemap ? 6 : 1;

		for ( var face = 0; face < faces; face ++ ) {

			for ( var i = 0; i < dds.mipmapCount; i ++ ) {

				if( isRGBAUncompressed ) {
					var byteArray = loadARGBMip( buffer, dataOffset, width, height );
					var dataLength = byteArray.length;
				} else {
					var dataLength = Math.max( 4, width ) / 4 * Math.max( 4, height ) / 4 * blockBytes;
					var byteArray = new Uint8Array( buffer, dataOffset, dataLength );
				}
				
				var mipmap = { "data": byteArray, "width": width, "height": height };
				dds.mipmaps.push( mipmap );

				dataOffset += dataLength;

				width = Math.max( width * 0.5, 1 );
				height = Math.max( height * 0.5, 1 );

			}

			width = dds.width;
			height = dds.height;

		}

		return dds;

	},

	getNormalMap: function ( image, depth ) {

		// Adapted from http://www.paulbrunt.co.uk/lab/heightnormal/

		var cross = function ( a, b ) {

			return [ a[ 1 ] * b[ 2 ] - a[ 2 ] * b[ 1 ], a[ 2 ] * b[ 0 ] - a[ 0 ] * b[ 2 ], a[ 0 ] * b[ 1 ] - a[ 1 ] * b[ 0 ] ];

		}

		var subtract = function ( a, b ) {

			return [ a[ 0 ] - b[ 0 ], a[ 1 ] - b[ 1 ], a[ 2 ] - b[ 2 ] ];

		}

		var normalize = function ( a ) {

			var l = Math.sqrt( a[ 0 ] * a[ 0 ] + a[ 1 ] * a[ 1 ] + a[ 2 ] * a[ 2 ] );
			return [ a[ 0 ] / l, a[ 1 ] / l, a[ 2 ] / l ];

		}

		depth = depth | 1;

		var width = image.width;
		var height = image.height;

		var canvas = document.createElement( 'canvas' );
		canvas.width = width;
		canvas.height = height;

		var context = canvas.getContext( '2d' );
		context.drawImage( image, 0, 0 );

		var data = context.getImageData( 0, 0, width, height ).data;
		var imageData = context.createImageData( width, height );
		var output = imageData.data;

		for ( var x = 0; x < width; x ++ ) {

			for ( var y = 0; y < height; y ++ ) {

				var ly = y - 1 < 0 ? 0 : y - 1;
				var uy = y + 1 > height - 1 ? height - 1 : y + 1;
				var lx = x - 1 < 0 ? 0 : x - 1;
				var ux = x + 1 > width - 1 ? width - 1 : x + 1;

				var points = [];
				var origin = [ 0, 0, data[ ( y * width + x ) * 4 ] / 255 * depth ];
				points.push( [ - 1, 0, data[ ( y * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, - 1, data[ ( ly * width + lx ) * 4 ] / 255 * depth ] );
				points.push( [ 0, - 1, data[ ( ly * width + x ) * 4 ] / 255 * depth ] );
				points.push( [  1, - 1, data[ ( ly * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 0, data[ ( y * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 1, 1, data[ ( uy * width + ux ) * 4 ] / 255 * depth ] );
				points.push( [ 0, 1, data[ ( uy * width + x ) * 4 ] / 255 * depth ] );
				points.push( [ - 1, 1, data[ ( uy * width + lx ) * 4 ] / 255 * depth ] );

				var normals = [];
				var num_points = points.length;

				for ( var i = 0; i < num_points; i ++ ) {

					var v1 = points[ i ];
					var v2 = points[ ( i + 1 ) % num_points ];
					v1 = subtract( v1, origin );
					v2 = subtract( v2, origin );
					normals.push( normalize( cross( v1, v2 ) ) );

				}

				var normal = [ 0, 0, 0 ];

				for ( var i = 0; i < normals.length; i ++ ) {

					normal[ 0 ] += normals[ i ][ 0 ];
					normal[ 1 ] += normals[ i ][ 1 ];
					normal[ 2 ] += normals[ i ][ 2 ];

				}

				normal[ 0 ] /= normals.length;
				normal[ 1 ] /= normals.length;
				normal[ 2 ] /= normals.length;

				var idx = ( y * width + x ) * 4;

				output[ idx ] = ( ( normal[ 0 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 1 ] = ( ( normal[ 1 ] + 1.0 ) / 2.0 * 255 ) | 0;
				output[ idx + 2 ] = ( normal[ 2 ] * 255 ) | 0;
				output[ idx + 3 ] = 255;

			}

		}

		context.putImageData( imageData, 0, 0 );

		return canvas;

	},

	generateDataTexture: function ( width, height, color ) {

		var size = width * height;
		var data = new Uint8Array( 3 * size );

		var r = Math.floor( color.r * 255 );
		var g = Math.floor( color.g * 255 );
		var b = Math.floor( color.b * 255 );

		for ( var i = 0; i < size; i ++ ) {

			data[ i * 3 ] 	  = r;
			data[ i * 3 + 1 ] = g;
			data[ i * 3 + 2 ] = b;

		}

		var texture = new THREE.DataTexture( data, width, height, THREE.RGBFormat );
		texture.needsUpdate = true;

		return texture;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new THREE.Object3D();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new THREE.Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach : function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new THREE.Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For Text operations in three.js (See TextGeometry)
 *
 * It uses techniques used in:
 *
 * 	typeface.js and canvastext
 * 		For converting fonts and rendering with javascript
 *		http://typeface.neocracy.org
 *
 *	Triangulation ported from AS3
 *		Simple Polygon Triangulation
 *		http://actionsnippet.com/?p=1462
 *
 * 	A Method to triangulate shapes with holes
 *		http://www.sakri.net/blog/2009/06/12/an-approach-to-triangulating-polygons-with-holes/
 *
 */

THREE.FontUtils = {

	faces : {},

	// Just for now. face[weight][style]

	face : "helvetiker",
	weight: "normal",
	style : "normal",
	size : 150,
	divisions : 10,

	getFace : function() {

		return this.faces[ this.face ][ this.weight ][ this.style ];

	},

	loadFace : function( data ) {

		var family = data.familyName.toLowerCase();

		var ThreeFont = this;

		ThreeFont.faces[ family ] = ThreeFont.faces[ family ] || {};

		ThreeFont.faces[ family ][ data.cssFontWeight ] = ThreeFont.faces[ family ][ data.cssFontWeight ] || {};
		ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		var face = ThreeFont.faces[ family ][ data.cssFontWeight ][ data.cssFontStyle ] = data;

		return data;

	},

	drawText : function( text ) {

		var characterPts = [], allPts = [];

		// RenderText

		var i, p,
			face = this.getFace(),
			scale = this.size / face.resolution,
			offset = 0,
			chars = String( text ).split( '' ),
			length = chars.length;

		var fontPaths = [];

		for ( i = 0; i < length; i ++ ) {

			var path = new THREE.Path();

			var ret = this.extractGlyphPoints( chars[ i ], face, scale, offset, path );
			offset += ret.offset;

			fontPaths.push( ret.path );

		}

		// get the width

		var width = offset / 2;
		//
		// for ( p = 0; p < allPts.length; p++ ) {
		//
		// 	allPts[ p ].x -= width;
		//
		// }

		//var extract = this.extractPoints( allPts, characterPts );
		//extract.contour = allPts;

		//extract.paths = fontPaths;
		//extract.offset = width;

		return { paths : fontPaths, offset : width };

	},




	extractGlyphPoints : function( c, face, scale, offset, path ) {

		var pts = [];

		var i, i2, divisions,
			outline, action, length,
			scaleX, scaleY,
			x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2,
			laste,
			glyph = face.glyphs[ c ] || face.glyphs[ '?' ];

		if ( !glyph ) return;

		if ( glyph.o ) {

			outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
			length = outline.length;

			scaleX = scale;
			scaleY = scale;

			for ( i = 0; i < length; ) {

				action = outline[ i ++ ];

				//console.log( action );

				switch( action ) {

				case 'm':

					// Move To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;

					path.moveTo( x, y );
					break;

				case 'l':

					// Line To

					x = outline[ i++ ] * scaleX + offset;
					y = outline[ i++ ] * scaleY;
					path.lineTo(x,y);
					break;

				case 'q':

					// QuadraticCurveTo

					cpx  = outline[ i++ ] * scaleX + offset;
					cpy  = outline[ i++ ] * scaleY;
					cpx1 = outline[ i++ ] * scaleX + offset;
					cpy1 = outline[ i++ ] * scaleY;

					path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
							var ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );
					  }

				  }

				  break;

				case 'b':

					// Cubic Bezier Curve

					cpx  = outline[ i++ ] *  scaleX + offset;
					cpy  = outline[ i++ ] *  scaleY;
					cpx1 = outline[ i++ ] *  scaleX + offset;
					cpy1 = outline[ i++ ] * -scaleY;
					cpx2 = outline[ i++ ] *  scaleX + offset;
					cpy2 = outline[ i++ ] * -scaleY;

					path.bezierCurveTo( cpx, cpy, cpx1, cpy1, cpx2, cpy2 );

					laste = pts[ pts.length - 1 ];

					if ( laste ) {

						cpx0 = laste.x;
						cpy0 = laste.y;

						for ( i2 = 1, divisions = this.divisions; i2 <= divisions; i2 ++ ) {

							var t = i2 / divisions;
							var tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
							var ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

						}

					}

					break;

				}

			}
		}



		return { offset: glyph.ha*scale, path:path};
	}

};


THREE.FontUtils.generateShapes = function( text, parameters ) {

	// Parameters 

	parameters = parameters || {};

	var size = parameters.size !== undefined ? parameters.size : 100;
	var curveSegments = parameters.curveSegments !== undefined ? parameters.curveSegments: 4;

	var font = parameters.font !== undefined ? parameters.font : "helvetiker";
	var weight = parameters.weight !== undefined ? parameters.weight : "normal";
	var style = parameters.style !== undefined ? parameters.style : "normal";

	THREE.FontUtils.size = size;
	THREE.FontUtils.divisions = curveSegments;

	THREE.FontUtils.face = font;
	THREE.FontUtils.weight = weight;
	THREE.FontUtils.style = style;

	// Get a Font data json object

	var data = THREE.FontUtils.drawText( text );

	var paths = data.paths;
	var shapes = [];

	for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

		Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

	}

	return shapes;

};


/**
 * This code is a quick port of code written in C++ which was submitted to
 * flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 * www.actionsnippet.com
 *
 * ported to javascript by Joshua Koo
 * http://www.lab4games.net/zz85/blog
 *
 */


( function( namespace ) {

	var EPSILON = 0.0000000001;

	// takes in an contour array and returns

	var process = function( contour, indices ) {

		var n = contour.length;

		if ( n < 3 ) return null;

		var result = [],
			verts = [],
			vertIndices = [];

		/* we want a counter-clockwise polygon in verts */

		var u, v, w;

		if ( area( contour ) > 0.0 ) {

			for ( v = 0; v < n; v++ ) verts[ v ] = v;

		} else {

			for ( v = 0; v < n; v++ ) verts[ v ] = ( n - 1 ) - v;

		}

		var nv = n;

		/*  remove nv - 2 vertices, creating 1 triangle every time */

		var count = 2 * nv;   /* error detection */

		for( v = nv - 1; nv > 2; ) {

			/* if we loop, it is probably a non-simple polygon */

			if ( ( count-- ) <= 0 ) {

				//** Triangulate: ERROR - probable bad polygon!

				//throw ( "Warning, unable to triangulate polygon!" );
				//return null;
				// Sometimes warning is fine, especially polygons are triangulated in reverse.
				console.log( "Warning, unable to triangulate polygon!" );

				if ( indices ) return vertIndices;
				return result;

			}

			/* three consecutive vertices in current polygon, <u,v,w> */

			u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
			v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
			w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

			if ( snip( contour, u, v, w, nv, verts ) ) {

				var a, b, c, s, t;

				/* true names of the vertices */

				a = verts[ u ];
				b = verts[ v ];
				c = verts[ w ];

				/* output Triangle */

				result.push( [ contour[ a ],
					contour[ b ],
					contour[ c ] ] );


				vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

				/* remove v from the remaining polygon */

				for( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv--;

				/* reset error detection counter */

				count = 2 * nv;

			}

		}

		if ( indices ) return vertIndices;
		return result;

	};

	// calculate area of the contour polygon

	var area = function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for( var p = n - 1, q = 0; q < n; p = q++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	};

	var snip = function ( contour, u, v, w, n, verts ) {

		var p;
		var ax, ay, bx, by;
		var cx, cy, px, py;

		ax = contour[ verts[ u ] ].x;
		ay = contour[ verts[ u ] ].y;

		bx = contour[ verts[ v ] ].x;
		by = contour[ verts[ v ] ].y;

		cx = contour[ verts[ w ] ].x;
		cy = contour[ verts[ w ] ].y;

		if ( EPSILON > (((bx-ax)*(cy-ay)) - ((by-ay)*(cx-ax))) ) return false;

		var aX, aY, bX, bY, cX, cY;
		var apx, apy, bpx, bpy, cpx, cpy;
		var cCROSSap, bCROSScp, aCROSSbp;

		aX = cx - bx;  aY = cy - by;
		bX = ax - cx;  bY = ay - cy;
		cX = bx - ax;  cY = by - ay;

		for ( p = 0; p < n; p++ ) {

			px = contour[ verts[ p ] ].x
			py = contour[ verts[ p ] ].y

			if ( ( (px === ax) && (py === ay) ) ||
				 ( (px === bx) && (py === by) ) ||
				 ( (px === cx) && (py === cy) ) )	continue;

			apx = px - ax;  apy = py - ay;
			bpx = px - bx;  bpy = py - by;
			cpx = px - cx;  cpy = py - cy;

			// see if p is inside triangle abc

			aCROSSbp = aX*bpy - aY*bpx;
			cCROSSap = cX*apy - cY*apx;
			bCROSScp = bX*cpy - bY*cpx;

			if ( (aCROSSbp >= -EPSILON) && (bCROSScp >= -EPSILON) && (cCROSSap >= -EPSILON) ) return false;

		}

		return true;

	};


	namespace.Triangulate = process;
	namespace.Triangulate.area = area;

	return namespace;

})(THREE.FontUtils);

// To use the typeface.js face files, hook up the API
self._typeface_js = { faces: THREE.FontUtils.faces, loadFace: THREE.FontUtils.loadFace };
THREE.typeface_js = self._typeface_js;

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTagentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 * THREE.ClosedSplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

THREE.Curve = function () {

};

// Virtual base class method to overwrite and implement in subclasses
//	- t [0 .. 1]

THREE.Curve.prototype.getPoint = function ( t ) {

	console.log( "Warning, getPoint() not implemented!" );
	return null;

};

// Get point at relative position in curve according to arc length
// - u [0 .. 1]

THREE.Curve.prototype.getPointAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getPoint( t );

};

// Get sequence of points using getPoint( t )

THREE.Curve.prototype.getPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPoint( d / divisions ) );

	}

	return pts;

};

// Get sequence of points using getPointAt( u )

THREE.Curve.prototype.getSpacedPoints = function ( divisions ) {

	if ( !divisions ) divisions = 5;

	var d, pts = [];

	for ( d = 0; d <= divisions; d ++ ) {

		pts.push( this.getPointAt( d / divisions ) );

	}

	return pts;

};

// Get total curve arc length

THREE.Curve.prototype.getLength = function () {

	var lengths = this.getLengths();
	return lengths[ lengths.length - 1 ];

};

// Get list of cumulative segment lengths

THREE.Curve.prototype.getLengths = function ( divisions ) {

	if ( !divisions ) divisions = (this.__arcLengthDivisions) ? (this.__arcLengthDivisions): 200;

	if ( this.cacheArcLengths
		&& ( this.cacheArcLengths.length == divisions + 1 )
		&& !this.needsUpdate) {

		//console.log( "cached", this.cacheArcLengths );
		return this.cacheArcLengths;

	}

	this.needsUpdate = false;

	var cache = [];
	var current, last = this.getPoint( 0 );
	var p, sum = 0;

	cache.push( 0 );

	for ( p = 1; p <= divisions; p ++ ) {

		current = this.getPoint ( p / divisions );
		sum += current.distanceTo( last );
		cache.push( sum );
		last = current;

	}

	this.cacheArcLengths = cache;

	return cache; // { sums: cache, sum:sum }; Sum is in the last element.

};


THREE.Curve.prototype.updateArcLengths = function() {
	this.needsUpdate = true;
	this.getLengths();
};

// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equi distance

THREE.Curve.prototype.getUtoTmapping = function ( u, distance ) {

	var arcLengths = this.getLengths();

	var i = 0, il = arcLengths.length;

	var targetArcLength; // The targeted u distance value to get

	if ( distance ) {

		targetArcLength = distance;

	} else {

		targetArcLength = u * arcLengths[ il - 1 ];

	}

	//var time = Date.now();

	// binary search for the index with largest value smaller than target u distance

	var low = 0, high = il - 1, comparison;

	while ( low <= high ) {

		i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

		comparison = arcLengths[ i ] - targetArcLength;

		if ( comparison < 0 ) {

			low = i + 1;
			continue;

		} else if ( comparison > 0 ) {

			high = i - 1;
			continue;

		} else {

			high = i;
			break;

			// DONE

		}

	}

	i = high;

	//console.log('b' , i, low, high, Date.now()- time);

	if ( arcLengths[ i ] == targetArcLength ) {

		var t = i / ( il - 1 );
		return t;

	}

	// we could get finer grain at lengths, or use simple interpolatation between two points

	var lengthBefore = arcLengths[ i ];
    var lengthAfter = arcLengths[ i + 1 ];

    var segmentLength = lengthAfter - lengthBefore;

    // determine where we are between the 'before' and 'after' points

    var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

    // add that fractional amount to t

    var t = ( i + segmentFraction ) / ( il -1 );

	return t;

};

// Returns a unit vector tangent at t
// In case any sub curve does not implement its tangent derivation,
// 2 points a small delta apart will be used to find its gradient
// which seems to give a reasonable approximation

THREE.Curve.prototype.getTangent = function( t ) {

	var delta = 0.0001;
	var t1 = t - delta;
	var t2 = t + delta;

	// Capping in case of danger

	if ( t1 < 0 ) t1 = 0;
	if ( t2 > 1 ) t2 = 1;

	var pt1 = this.getPoint( t1 );
	var pt2 = this.getPoint( t2 );

	var vec = pt2.clone().sub(pt1);
	return vec.normalize();

};


THREE.Curve.prototype.getTangentAt = function ( u ) {

	var t = this.getUtoTmapping( u );
	return this.getTangent( t );

};





/**************************************************************
 *	Utils
 **************************************************************/

THREE.Curve.Utils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function (t, p0, p1, p2, p3 ) {

		return -3 * p0 * (1 - t) * (1 - t)  +
			3 * p1 * (1 - t) * (1-t) - 6 *t *p1 * (1-t) +
			6 * t *  p2 * (1-t) - 3 * t * t * p2 +
			3 * t * t * p3;
	},


	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
		var h01 = -6 * t * t + 6 * t; 	// − 2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3 − t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};


// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

THREE.Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( THREE.Curve.prototype );
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

THREE.CurvePath = function () {

	this.curves = [];
	this.bends = [];
	
	this.autoClose = false; // Automatically closes the path
};

THREE.CurvePath.prototype = Object.create( THREE.Curve.prototype );

THREE.CurvePath.prototype.add = function ( curve ) {

	this.curves.push( curve );

};

THREE.CurvePath.prototype.checkConnection = function() {
	// TODO
	// If the ending of curve is not connected to the starting
	// or the next curve, then, this is not a real path
};

THREE.CurvePath.prototype.closePath = function() {
	// TODO Test
	// and verify for vector3 (needs to implement equals)
	// Add a line curve if start and end of lines are not connected
	var startPoint = this.curves[0].getPoint(0);
	var endPoint = this.curves[this.curves.length-1].getPoint(1);
	
	if (!startPoint.equals(endPoint)) {
		this.curves.push( new THREE.LineCurve(endPoint, startPoint) );
	}
	
};

// To get accurate point with reference to
// entire path distance at time t,
// following has to be done:

// 1. Length of each sub path have to be known
// 2. Locate and identify type of curve
// 3. Get t for the curve
// 4. Return curve.getPointAt(t')

THREE.CurvePath.prototype.getPoint = function( t ) {

	var d = t * this.getLength();
	var curveLengths = this.getCurveLengths();
	var i = 0, diff, curve;

	// To think about boundaries points.

	while ( i < curveLengths.length ) {

		if ( curveLengths[ i ] >= d ) {

			diff = curveLengths[ i ] - d;
			curve = this.curves[ i ];

			var u = 1 - diff / curve.getLength();

			return curve.getPointAt( u );

			break;
		}

		i ++;

	}

	return null;

	// loop where sum != 0, sum > d , sum+1 <d

};

/*
THREE.CurvePath.prototype.getTangent = function( t ) {
};*/


// We cannot use the default THREE.Curve getPoint() with getLength() because in
// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
// getPoint() depends on getLength

THREE.CurvePath.prototype.getLength = function() {

	var lens = this.getCurveLengths();
	return lens[ lens.length - 1 ];

};

// Compute lengths and cache them
// We cannot overwrite getLengths() because UtoT mapping uses it.

THREE.CurvePath.prototype.getCurveLengths = function() {

	// We use cache values if curves and cache array are same length

	if ( this.cacheLengths && this.cacheLengths.length == this.curves.length ) {

		return this.cacheLengths;

	};

	// Get length of subsurve
	// Push sums into cached array

	var lengths = [], sums = 0;
	var i, il = this.curves.length;

	for ( i = 0; i < il; i ++ ) {

		sums += this.curves[ i ].getLength();
		lengths.push( sums );

	}

	this.cacheLengths = lengths;

	return lengths;

};



// Returns min and max coordinates, as well as centroid

THREE.CurvePath.prototype.getBoundingBox = function () {

	var points = this.getPoints();

	var maxX, maxY, maxZ;
	var minX, minY, minZ;

	maxX = maxY = Number.NEGATIVE_INFINITY;
	minX = minY = Number.POSITIVE_INFINITY;

	var p, i, il, sum;

	var v3 = points[0] instanceof THREE.Vector3;

	sum = v3 ? new THREE.Vector3() : new THREE.Vector2();

	for ( i = 0, il = points.length; i < il; i ++ ) {

		p = points[ i ];

		if ( p.x > maxX ) maxX = p.x;
		else if ( p.x < minX ) minX = p.x;

		if ( p.y > maxY ) maxY = p.y;
		else if ( p.y < minY ) minY = p.y;

		if ( v3 ) {

			if ( p.z > maxZ ) maxZ = p.z;
			else if ( p.z < minZ ) minZ = p.z;

		}

		sum.add( p );

	}

	var ret = {

		minX: minX,
		minY: minY,
		maxX: maxX,
		maxY: maxY,
		centroid: sum.divideScalar( il )

	};

	if ( v3 ) {

		ret.maxZ = maxZ;
		ret.minZ = minZ;

	}

	return ret;

};

/**************************************************************
 *	Create Geometries Helpers
 **************************************************************/

/// Generate geometry from path points (for Line or ParticleSystem objects)

THREE.CurvePath.prototype.createPointsGeometry = function( divisions ) {

	var pts = this.getPoints( divisions, true );
	return this.createGeometry( pts );

};

// Generate geometry from equidistance sampling along the path

THREE.CurvePath.prototype.createSpacedPointsGeometry = function( divisions ) {

	var pts = this.getSpacedPoints( divisions, true );
	return this.createGeometry( pts );

};

THREE.CurvePath.prototype.createGeometry = function( points ) {

	var geometry = new THREE.Geometry();

	for ( var i = 0; i < points.length; i ++ ) {

		geometry.vertices.push( new THREE.Vector3( points[ i ].x, points[ i ].y, points[ i ].z || 0) );

	}

	return geometry;

};


/**************************************************************
 *	Bend / Wrap Helper Methods
 **************************************************************/

// Wrap path / Bend modifiers?

THREE.CurvePath.prototype.addWrapPath = function ( bendpath ) {

	this.bends.push( bendpath );

};

THREE.CurvePath.prototype.getTransformedPoints = function( segments, bends ) {

	var oldPts = this.getPoints( segments ); // getPoints getSpacedPoints
	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

THREE.CurvePath.prototype.getTransformedSpacedPoints = function( segments, bends ) {

	var oldPts = this.getSpacedPoints( segments );

	var i, il;

	if ( !bends ) {

		bends = this.bends;

	}

	for ( i = 0, il = bends.length; i < il; i ++ ) {

		oldPts = this.getWrapPoints( oldPts, bends[ i ] );

	}

	return oldPts;

};

// This returns getPoints() bend/wrapped around the contour of a path.
// Read http://www.planetclegg.com/projects/WarpingTextToSplines.html

THREE.CurvePath.prototype.getWrapPoints = function ( oldPts, path ) {

	var bounds = this.getBoundingBox();

	var i, il, p, oldX, oldY, xNorm;

	for ( i = 0, il = oldPts.length; i < il; i ++ ) {

		p = oldPts[ i ];

		oldX = p.x;
		oldY = p.y;

		xNorm = oldX / bounds.maxX;

		// If using actual distance, for length > path, requires line extrusions
		//xNorm = path.getUtoTmapping(xNorm, oldX); // 3 styles. 1) wrap stretched. 2) wrap stretch by arc length 3) warp by actual distance

		xNorm = path.getUtoTmapping( xNorm, oldX );

		// check for out of bounds?

		var pathPt = path.getPoint( xNorm );
		var normal = path.getTangent( xNorm );
		normal.set( -normal.y, normal.x ).multiplyScalar( oldY );

		p.x = pathPt.x + normal.x;
		p.y = pathPt.y + normal.y;

	}

	return oldPts;

};


/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Gyroscope = function () {

	THREE.Object3D.call( this );

};

THREE.Gyroscope.prototype = Object.create( THREE.Object3D.prototype );

THREE.Gyroscope.prototype.updateMatrixWorld = function ( force ) {

	this.matrixAutoUpdate && this.updateMatrix();

	// update matrixWorld

	if ( this.matrixWorldNeedsUpdate || force ) {

		if ( this.parent ) {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			this.matrixWorld.decompose( this.translationWorld, this.quaternionWorld, this.scaleWorld );
			this.matrix.decompose( this.translationObject, this.quaternionObject, this.scaleObject );

			this.matrixWorld.compose( this.translationWorld, this.quaternionObject, this.scaleWorld );


		} else {

			this.matrixWorld.copy( this.matrix );

		}


		this.matrixWorldNeedsUpdate = false;

		force = true;

	}

	// update children

	for ( var i = 0, l = this.children.length; i < l; i ++ ) {

		this.children[ i ].updateMatrixWorld( force );

	}

};

THREE.Gyroscope.prototype.translationWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.translationObject = new THREE.Vector3();
THREE.Gyroscope.prototype.quaternionWorld = new THREE.Quaternion();
THREE.Gyroscope.prototype.quaternionObject = new THREE.Quaternion();
THREE.Gyroscope.prototype.scaleWorld = new THREE.Vector3();
THREE.Gyroscope.prototype.scaleObject = new THREE.Vector3();


/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

THREE.Path = function ( points ) {

	THREE.CurvePath.call(this);

	this.actions = [];

	if ( points ) {

		this.fromPoints( points );

	}

};

THREE.Path.prototype = Object.create( THREE.CurvePath.prototype );

THREE.PathActions = {

	MOVE_TO: 'moveTo',
	LINE_TO: 'lineTo',
	QUADRATIC_CURVE_TO: 'quadraticCurveTo', // Bezier quadratic curve
	BEZIER_CURVE_TO: 'bezierCurveTo', 		// Bezier cubic curve
	CSPLINE_THRU: 'splineThru',				// Catmull-rom spline
	ARC: 'arc',								// Circle
	ELLIPSE: 'ellipse'
};

// TODO Clean up PATH API

// Create path using straight lines to connect all points
// - vectors: array of Vector2

THREE.Path.prototype.fromPoints = function ( vectors ) {

	this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

	for ( var v = 1, vlen = vectors.length; v < vlen; v ++ ) {

		this.lineTo( vectors[ v ].x, vectors[ v ].y );

	};

};

// startPath() endPath()?

THREE.Path.prototype.moveTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );
	this.actions.push( { action: THREE.PathActions.MOVE_TO, args: args } );

};

THREE.Path.prototype.lineTo = function ( x, y ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.LINE_TO, args: args } );

};

THREE.Path.prototype.quadraticCurveTo = function( aCPx, aCPy, aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.QuadraticBezierCurve( new THREE.Vector2( x0, y0 ),
												new THREE.Vector2( aCPx, aCPy ),
												new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.QUADRATIC_CURVE_TO, args: args } );

};

THREE.Path.prototype.bezierCurveTo = function( aCP1x, aCP1y,
											   aCP2x, aCP2y,
											   aX, aY ) {

	var args = Array.prototype.slice.call( arguments );

	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	var curve = new THREE.CubicBezierCurve( new THREE.Vector2( x0, y0 ),
											new THREE.Vector2( aCP1x, aCP1y ),
											new THREE.Vector2( aCP2x, aCP2y ),
											new THREE.Vector2( aX, aY ) );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.BEZIER_CURVE_TO, args: args } );

};

THREE.Path.prototype.splineThru = function( pts /*Array of Vector*/ ) {

	var args = Array.prototype.slice.call( arguments );
	var lastargs = this.actions[ this.actions.length - 1 ].args;

	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];
//---
	var npts = [ new THREE.Vector2( x0, y0 ) ];
	Array.prototype.push.apply( npts, pts );

	var curve = new THREE.SplineCurve( npts );
	this.curves.push( curve );

	this.actions.push( { action: THREE.PathActions.CSPLINE_THRU, args: args } );

};

// FUTURE: Change the API or follow canvas API?

THREE.Path.prototype.arc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absarc(aX + x0, aY + y0, aRadius,
		aStartAngle, aEndAngle, aClockwise );

 };

 THREE.Path.prototype.absarc = function ( aX, aY, aRadius,
									  aStartAngle, aEndAngle, aClockwise ) {
	this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
 };

THREE.Path.prototype.ellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var lastargs = this.actions[ this.actions.length - 1].args;
	var x0 = lastargs[ lastargs.length - 2 ];
	var y0 = lastargs[ lastargs.length - 1 ];

	this.absellipse(aX + x0, aY + y0, xRadius, yRadius,
		aStartAngle, aEndAngle, aClockwise );

 };


THREE.Path.prototype.absellipse = function ( aX, aY, xRadius, yRadius,
									  aStartAngle, aEndAngle, aClockwise ) {

	var args = Array.prototype.slice.call( arguments );
	var curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius,
									aStartAngle, aEndAngle, aClockwise );
	this.curves.push( curve );

	var lastPoint = curve.getPoint(1);
	args.push(lastPoint.x);
	args.push(lastPoint.y);

	this.actions.push( { action: THREE.PathActions.ELLIPSE, args: args } );

 };

THREE.Path.prototype.getSpacedPoints = function ( divisions, closedPath ) {

	if ( ! divisions ) divisions = 40;

	var points = [];

	for ( var i = 0; i < divisions; i ++ ) {

		points.push( this.getPoint( i / divisions ) );

		//if( !this.getPoint( i / divisions ) ) throw "DIE";

	}

	// if ( closedPath ) {
	//
	// 	points.push( points[ 0 ] );
	//
	// }

	return points;

};

/* Return an array of vectors based on contour of the path */

THREE.Path.prototype.getPoints = function( divisions, closedPath ) {

	if (this.useSpacedPoints) {
		console.log('tata');
		return this.getSpacedPoints( divisions, closedPath );
	}

	divisions = divisions || 12;

	var points = [];

	var i, il, item, action, args;
	var cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,
		laste, j,
		t, tx, ty;

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		action = item.action;
		args = item.args;

		switch( action ) {

		case THREE.PathActions.MOVE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.LINE_TO:

			points.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );

			break;

		case THREE.PathActions.QUADRATIC_CURVE_TO:

			cpx  = args[ 2 ];
			cpy  = args[ 3 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}

			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b2( t, cpx0, cpx1, cpx );
				ty = THREE.Shape.Utils.b2( t, cpy0, cpy1, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.BEZIER_CURVE_TO:

			cpx  = args[ 4 ];
			cpy  = args[ 5 ];

			cpx1 = args[ 0 ];
			cpy1 = args[ 1 ];

			cpx2 = args[ 2 ];
			cpy2 = args[ 3 ];

			if ( points.length > 0 ) {

				laste = points[ points.length - 1 ];

				cpx0 = laste.x;
				cpy0 = laste.y;

			} else {

				laste = this.actions[ i - 1 ].args;

				cpx0 = laste[ laste.length - 2 ];
				cpy0 = laste[ laste.length - 1 ];

			}


			for ( j = 1; j <= divisions; j ++ ) {

				t = j / divisions;

				tx = THREE.Shape.Utils.b3( t, cpx0, cpx1, cpx2, cpx );
				ty = THREE.Shape.Utils.b3( t, cpy0, cpy1, cpy2, cpy );

				points.push( new THREE.Vector2( tx, ty ) );

			}

			break;

		case THREE.PathActions.CSPLINE_THRU:

			laste = this.actions[ i - 1 ].args;

			var last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );
			var spts = [ last ];

			var n = divisions * args[ 0 ].length;

			spts = spts.concat( args[ 0 ] );

			var spline = new THREE.SplineCurve( spts );

			for ( j = 1; j <= n; j ++ ) {

				points.push( spline.getPointAt( j / n ) ) ;

			}

			break;

		case THREE.PathActions.ARC:

			var aX = args[ 0 ], aY = args[ 1 ],
				aRadius = args[ 2 ],
				aStartAngle = args[ 3 ], aEndAngle = args[ 4 ],
				aClockwise = !!args[ 5 ];

			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + aRadius * Math.cos( angle );
				ty = aY + aRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;
		  
		case THREE.PathActions.ELLIPSE:

			var aX = args[ 0 ], aY = args[ 1 ],
				xRadius = args[ 2 ],
				yRadius = args[ 3 ],
				aStartAngle = args[ 4 ], aEndAngle = args[ 5 ],
				aClockwise = !!args[ 6 ];


			var deltaAngle = aEndAngle - aStartAngle;
			var angle;
			var tdivisions = divisions * 2;

			for ( j = 1; j <= tdivisions; j ++ ) {

				t = j / tdivisions;

				if ( ! aClockwise ) {

					t = 1 - t;

				}

				angle = aStartAngle + t * deltaAngle;

				tx = aX + xRadius * Math.cos( angle );
				ty = aY + yRadius * Math.sin( angle );

				//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);

				points.push( new THREE.Vector2( tx, ty ) );

			}

			//console.log(points);

		  break;

		} // end switch

	}



	// Normalize to remove the closing point by default.
	var lastPoint = points[ points.length - 1];
	var EPSILON = 0.0000000001;
	if ( Math.abs(lastPoint.x - points[ 0 ].x) < EPSILON &&
			 Math.abs(lastPoint.y - points[ 0 ].y) < EPSILON)
		points.splice( points.length - 1, 1);
	if ( closedPath ) {

		points.push( points[ 0 ] );

	}

	return points;

};

// Breaks path into shapes

THREE.Path.prototype.toShapes = function( isCCW ) {

	function isPointInsidePolygon( inPt, inPolygon ) {
		var EPSILON = 0.0000000001;

		var polyLen = inPolygon.length;

		// inPt on polygon contour => immediate success    or
		// toggling of inside/outside at every single! intersection point of an edge
		//  with the horizontal line through inPt, left of inPt
		//  not counting lowerY endpoints of edges and whole edges on that line
		var inside = false;
		for( var p = polyLen - 1, q = 0; q < polyLen; p = q++ ) {
			var edgeLowPt  = inPolygon[ p ];
			var edgeHighPt = inPolygon[ q ];

			var edgeDx = edgeHighPt.x - edgeLowPt.x;
			var edgeDy = edgeHighPt.y - edgeLowPt.y;

			if ( Math.abs(edgeDy) > EPSILON ) {			// not parallel
				if ( edgeDy < 0 ) {
					edgeLowPt  = inPolygon[ q ]; edgeDx = -edgeDx;
					edgeHighPt = inPolygon[ p ]; edgeDy = -edgeDy;
				}
				if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

				if ( inPt.y == edgeLowPt.y ) {
					if ( inPt.x == edgeLowPt.x )		return	true;		// inPt is on contour ?
					// continue;				// no intersection or edgeLowPt => doesn't count !!!
				} else {
					var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
					if ( perpEdge == 0 )				return	true;		// inPt is on contour ?
					if ( perpEdge < 0 ) 				continue;
					inside = !inside;		// true intersection left of inPt
				}
			} else {		// parallel or colinear
				if ( inPt.y != edgeLowPt.y ) 		continue;			// parallel
				// egde lies on the same horizontal line as inPt
				if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
					 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
				// continue;
			}
		}

		return	inside;
	}

	var i, il, item, action, args;

	var subPaths = [], lastPath = new THREE.Path();

	for ( i = 0, il = this.actions.length; i < il; i ++ ) {

		item = this.actions[ i ];

		args = item.args;
		action = item.action;

		if ( action == THREE.PathActions.MOVE_TO ) {

			if ( lastPath.actions.length != 0 ) {

				subPaths.push( lastPath );
				lastPath = new THREE.Path();

			}

		}

		lastPath[ action ].apply( lastPath, args );

	}

	if ( lastPath.actions.length != 0 ) {

		subPaths.push( lastPath );

	}

	// console.log(subPaths);

	if ( subPaths.length == 0 ) return [];

	var solid, tmpPath, tmpShape, shapes = [];

	if ( subPaths.length == 1) {

		tmpPath = subPaths[0];
		tmpShape = new THREE.Shape();
		tmpShape.actions = tmpPath.actions;
		tmpShape.curves = tmpPath.curves;
		shapes.push( tmpShape );
		return shapes;

	}

	var holesFirst = !THREE.Shape.Utils.isClockWise( subPaths[ 0 ].getPoints() );
	holesFirst = isCCW ? !holesFirst : holesFirst;

	// console.log("Holes first", holesFirst);
	
	var betterShapeHoles = [];
	var newShapes = [];
	var newShapeHoles = [];
	var mainIdx = 0;
	var tmpPoints;

	newShapes[mainIdx] = undefined;
	newShapeHoles[mainIdx] = [];

	for ( i = 0, il = subPaths.length; i < il; i ++ ) {

		tmpPath = subPaths[ i ];
		tmpPoints = tmpPath.getPoints();
		solid = THREE.Shape.Utils.isClockWise( tmpPoints );
		solid = isCCW ? !solid : solid;

		if ( solid ) {

			if ( (! holesFirst ) && ( newShapes[mainIdx] ) )	mainIdx++;

			newShapes[mainIdx] = { s: new THREE.Shape(), p: tmpPoints };
			newShapes[mainIdx].s.actions = tmpPath.actions;
			newShapes[mainIdx].s.curves = tmpPath.curves;
			
			if ( holesFirst )	mainIdx++;
			newShapeHoles[mainIdx] = [];

			//console.log('cw', i);

		} else {

			newShapeHoles[mainIdx].push( { h: tmpPath, p: tmpPoints[0] } );

			//console.log('ccw', i);

		}

	}

	if ( newShapes.length > 1 ) {
		var ambigious = false;
		var toChange = [];

		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {
			betterShapeHoles[sIdx] = [];
		}
		for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++ ) {
			var sh = newShapes[sIdx];
			var sho = newShapeHoles[sIdx];
			for (var hIdx = 0; hIdx < sho.length; hIdx++ ) {
				var ho = sho[hIdx];
				var hole_unassigned = true;
				for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++ ) {
					if ( isPointInsidePolygon( ho.p, newShapes[s2Idx].p ) ) {
						if ( sIdx != s2Idx )		toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
						if ( hole_unassigned ) {
							hole_unassigned = false;
							betterShapeHoles[s2Idx].push( ho );
						} else {
							ambigious = true;
						}
					}
				}
				if ( hole_unassigned ) { betterShapeHoles[sIdx].push( ho ); }
			}
		}
		// console.log("ambigious: ", ambigious);
		if ( toChange.length > 0 ) {
			// console.log("to change: ", toChange);
			if (! ambigious)	newShapeHoles = betterShapeHoles;
		}
	}

	var tmpHoles, j, jl;
	for ( i = 0, il = newShapes.length; i < il; i ++ ) {
		tmpShape = newShapes[i].s;
		shapes.push( tmpShape );
		tmpHoles = newShapeHoles[i];
		for ( j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
			tmpShape.holes.push( tmpHoles[j].h );
		}
	}

	//console.log("shape", shapes);

	return shapes;

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

THREE.Shape = function () {

	THREE.Path.apply( this, arguments );
	this.holes = [];

};

THREE.Shape.prototype = Object.create( THREE.Path.prototype );

// Convenience method to return ExtrudeGeometry

THREE.Shape.prototype.extrude = function ( options ) {

	var extruded = new THREE.ExtrudeGeometry( this, options );
	return extruded;

};

// Convenience method to return ShapeGeometry

THREE.Shape.prototype.makeGeometry = function ( options ) {

	var geometry = new THREE.ShapeGeometry( this, options );
	return geometry;

};

// Get points of holes

THREE.Shape.prototype.getPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedPoints( divisions, this.bends );

	}

	return holesPts;

};

// Get points of holes (spaced by regular distance)

THREE.Shape.prototype.getSpacedPointsHoles = function ( divisions ) {

	var i, il = this.holes.length, holesPts = [];

	for ( i = 0; i < il; i ++ ) {

		holesPts[ i ] = this.holes[ i ].getTransformedSpacedPoints( divisions, this.bends );

	}

	return holesPts;

};


// Get points of shape and holes (keypoints based on segments parameter)

THREE.Shape.prototype.extractAllPoints = function ( divisions ) {

	return {

		shape: this.getTransformedPoints( divisions ),
		holes: this.getPointsHoles( divisions )

	};

};

THREE.Shape.prototype.extractPoints = function ( divisions ) {

	if (this.useSpacedPoints) {
		return this.extractAllSpacedPoints(divisions);
	}

	return this.extractAllPoints(divisions);

};

//
// THREE.Shape.prototype.extractAllPointsWithBend = function ( divisions, bend ) {
//
// 	return {
//
// 		shape: this.transform( bend, divisions ),
// 		holes: this.getPointsHoles( divisions, bend )
//
// 	};
//
// };

// Get points of shape and holes (spaced by regular distance)

THREE.Shape.prototype.extractAllSpacedPoints = function ( divisions ) {

	return {

		shape: this.getTransformedSpacedPoints( divisions ),
		holes: this.getSpacedPointsHoles( divisions )

	};

};

/**************************************************************
 *	Utils
 **************************************************************/

THREE.Shape.Utils = {

	triangulateShape: function ( contour, holes ) {

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
			// inOtherPt needs to be colinear to the inSegment
			if ( inSegPt1.x != inSegPt2.x ) {
				if ( inSegPt1.x < inSegPt2.x ) {
					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
				} else {
					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
				}
			} else {
				if ( inSegPt1.y < inSegPt2.y ) {
					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
				} else {
					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
				}
			}
		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
			var EPSILON = 0.0000000001;

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs(limit) > EPSILON ) {			// not parallel

				var perpSeg2;
				if ( limit > 0 ) {
					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
				} else {
					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 == 0 ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt1 ];
				}
				if ( perpSeg2 == limit ) {
					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 == 0 ) || ( perpSeg1 == limit ) ) )		return [];
					return  [ inSeg1Pt2 ];
				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 == 0 )		return  [ inSeg2Pt1 ];
				if ( perpSeg1 == limit )	return  [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {		// parallel or colinear
				if ( ( perpSeg1 != 0 ) ||
					 ( seg2dy * seg1seg2dx != seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( (seg1dx == 0) && (seg1dy == 0) );	// segment1 ist just a point?
				var seg2Pt = ( (seg2dx == 0) && (seg2dy == 0) );	// segment2 ist just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {
					if ( (inSeg1Pt1.x != inSeg2Pt1.x) ||
						 (inSeg1Pt1.y != inSeg2Pt1.y) )		return [];   	// they are distinct  points
					return  [ inSeg1Pt1 ];                 					// they are the same point
				}
				// segment#1  is a single point
				if ( seg1Pt ) {
					if (! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return  [ inSeg1Pt1 ];
				}
				// segment#2  is a single point
				if ( seg2Pt ) {
					if (! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return  [ inSeg2Pt1 ];
				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if (seg1dx != 0) {		// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
					}
				} else {				// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
					} else {
						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
					} else {
						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
					}
				}
				if ( seg1minVal <= seg2minVal ) {
					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal == seg2minVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];
				} else {
					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal == seg2maxVal )	{
						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];
					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];
				}
			}
		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
			// The order of legs is important

			var EPSILON = 0.0000000001;

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs(from2toAngle) > EPSILON ) {			// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {				// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
				} else {								// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
				}
			} else {										// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );
			}
		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[inShapeIdx], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[inHoleIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;
				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[inHoleIdx], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[inShapeIdx] );
				if (! insideAngle ) {
					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;
				}

				return	true;
			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {
				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx++ ) {
					nextIdx = sIdx+1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[sIdx], shape[nextIdx], true );
					if ( intersection.length > 0 )		return	true;
				}

				return	false;
			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {
				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx++ ) {
					chkHole = holes[indepHoles[ihIdx]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx++ ) {
						nextIdx = hIdx+1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[hIdx], chkHole[nextIdx], true );
						if ( intersection.length > 0 )		return	true;
					}
				}
				return	false;
			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {
				counter --;
				if ( counter < 0 ) {
					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;
				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = 0; shapeIndex < shape.length; shapeIndex++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= -1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {
						holeIdx = indepHoles[h];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[cutKey] !== undefined )			continue;

						hole = holes[holeIdx];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
							holePt = hole[ h2 ];
							if (! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice(h,1);

							tmpShape1 = shape.slice( 0, shapeIndex+1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex+1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;
						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[cutKey] = true;			// remember failure
					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found
				}
			}

			return shape; 			/* shape with no holes */
		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[h] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.log( "Duplicate point", key );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = THREE.FontUtils.Triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return THREE.FontUtils.Triangulate.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * p;

	},

	b2p1: function ( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	},

	b2p2: function ( t, p ) {

		return t * t * p;

	},

	b2: function ( t, p0, p1, p2 ) {

		return this.b2p0( t, p0 ) + this.b2p1( t, p1 ) + this.b2p2( t, p2 );

	},

	// Cubic Bezier Functions

	b3p0: function ( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	},

	b3p1: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	},

	b3p2: function ( t, p ) {

		var k = 1 - t;
		return 3 * k * t * t * p;

	},

	b3p3: function ( t, p ) {

		return t * t * t * p;

	},

	b3: function ( t, p0, p1, p2, p3 ) {

		return this.b3p0( t, p0 ) + this.b3p1( t, p1 ) + this.b3p2( t, p2 ) +  this.b3p3( t, p3 );

	}

};


/**************************************************************
 *	Line
 **************************************************************/

THREE.LineCurve = function ( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

};

THREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.LineCurve.prototype.getPoint = function ( t ) {

	var point = this.v2.clone().sub(this.v1);
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

THREE.LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

THREE.LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub(this.v1);

	return tangent.normalize();

};
/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


THREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

};

THREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );


THREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );

	return new THREE.Vector2( tx, ty );

};


THREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x );
	ty = THREE.Curve.Utils.tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y );

	// returns unit vector

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};
/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

THREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

};

THREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.CubicBezierCurve.prototype.getPoint = function ( t ) {

	var tx, ty;

	tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	return new THREE.Vector2( tx, ty );

};

THREE.CubicBezierCurve.prototype.getTangent = function( t ) {

	var tx, ty;

	tx = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
	ty = THREE.Curve.Utils.tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );

	var tangent = new THREE.Vector2( tx, ty );
	tangent.normalize();

	return tangent;

};
/**************************************************************
 *	Spline curve
 **************************************************************/

THREE.SplineCurve = function ( points /* array of Vector2 */ ) {

	this.points = (points == undefined) ? [] : points;

};

THREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.SplineCurve.prototype.getPoint = function ( t ) {

	var v = new THREE.Vector2();
	var c = [];
	var points = this.points, point, intPoint, weight;
	point = ( points.length - 1 ) * t;

	intPoint = Math.floor( point );
	weight = point - intPoint;

	c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
	c[ 1 ] = intPoint;
	c[ 2 ] = intPoint  > points.length - 2 ? points.length -1 : intPoint + 1;
	c[ 3 ] = intPoint  > points.length - 3 ? points.length -1 : intPoint + 2;

	v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
	v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );

	return v;

};
/**************************************************************
 *	Ellipse curve
 **************************************************************/

THREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

};

THREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );

THREE.EllipseCurve.prototype.getPoint = function ( t ) {

	var angle;
	var deltaAngle = this.aEndAngle - this.aStartAngle;

	if ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;
	if ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;

	if ( this.aClockwise === true ) {

		angle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );

	} else {

		angle = this.aStartAngle + t * deltaAngle;

	}

	var tx = this.aX + this.xRadius * Math.cos( angle );
	var ty = this.aY + this.yRadius * Math.sin( angle );

	return new THREE.Vector2( tx, ty );

};

/**************************************************************
 *	Arc curve
 **************************************************************/

THREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	THREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
};

THREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );
/**************************************************************
 *	Line3D
 **************************************************************/

THREE.LineCurve3 = THREE.Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var r = new THREE.Vector3();


		r.subVectors( this.v2, this.v1 ); // diff
		r.multiplyScalar( t );
		r.add( this.v1 );

		return r;

	}

);

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

THREE.QuadraticBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b2( t, this.v0.x, this.v1.x, this.v2.x );
		ty = THREE.Shape.Utils.b2( t, this.v0.y, this.v1.y, this.v2.y );
		tz = THREE.Shape.Utils.b2( t, this.v0.z, this.v1.z, this.v2.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);
/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

THREE.CubicBezierCurve3 = THREE.Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var tx, ty, tz;

		tx = THREE.Shape.Utils.b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x );
		ty = THREE.Shape.Utils.b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y );
		tz = THREE.Shape.Utils.b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z );

		return new THREE.Vector3( tx, ty, tz );

	}

);
/**************************************************************
 *	Spline 3D curve
 **************************************************************/


THREE.SplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = (points == undefined) ? [] : points;

	},

	function ( t ) {

		var v = new THREE.Vector3();
		var c = [];
		var points = this.points, point, intPoint, weight;
		point = ( points.length - 1 ) * t;

		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;

		var pt0 = points[ c[0] ],
			pt1 = points[ c[1] ],
			pt2 = points[ c[2] ],
			pt3 = points[ c[3] ];

		v.x = THREE.Curve.Utils.interpolate(pt0.x, pt1.x, pt2.x, pt3.x, weight);
		v.y = THREE.Curve.Utils.interpolate(pt0.y, pt1.y, pt2.y, pt3.y, weight);
		v.z = THREE.Curve.Utils.interpolate(pt0.z, pt1.z, pt2.z, pt3.z, weight);

		return v;

	}

);


// THREE.SplineCurve3.prototype.getTangent = function(t) {
// 		var v = new THREE.Vector3();
// 		var c = [];
// 		var points = this.points, point, intPoint, weight;
// 		point = ( points.length - 1 ) * t;

// 		intPoint = Math.floor( point );
// 		weight = point - intPoint;

// 		c[ 0 ] = intPoint == 0 ? intPoint : intPoint - 1;
// 		c[ 1 ] = intPoint;
// 		c[ 2 ] = intPoint  > points.length - 2 ? points.length - 1 : intPoint + 1;
// 		c[ 3 ] = intPoint  > points.length - 3 ? points.length - 1 : intPoint + 2;

// 		var pt0 = points[ c[0] ],
// 			pt1 = points[ c[1] ],
// 			pt2 = points[ c[2] ],
// 			pt3 = points[ c[3] ];

// 	// t = weight;
// 	v.x = THREE.Curve.Utils.tangentSpline( t, pt0.x, pt1.x, pt2.x, pt3.x );
// 	v.y = THREE.Curve.Utils.tangentSpline( t, pt0.y, pt1.y, pt2.y, pt3.y );
// 	v.z = THREE.Curve.Utils.tangentSpline( t, pt0.z, pt1.z, pt2.z, pt3.z );

// 	return v;

// }
/**************************************************************
 *	Closed Spline 3D curve
 **************************************************************/


THREE.ClosedSplineCurve3 = THREE.Curve.create(

	function ( points /* array of Vector3 */) {

		this.points = (points == undefined) ? [] : points;

	},

    function ( t ) {

        var v = new THREE.Vector3();
        var c = [];
        var points = this.points, point, intPoint, weight;
        point = ( points.length - 0 ) * t;
            // This needs to be from 0-length +1

        intPoint = Math.floor( point );
        weight = point - intPoint;

        intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
        c[ 0 ] = ( intPoint - 1 ) % points.length;
        c[ 1 ] = ( intPoint ) % points.length;
        c[ 2 ] = ( intPoint + 1 ) % points.length;
        c[ 3 ] = ( intPoint + 2 ) % points.length;

        v.x = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].x, points[ c[ 1 ] ].x, points[ c[ 2 ] ].x, points[ c[ 3 ] ].x, weight );
        v.y = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].y, points[ c[ 1 ] ].y, points[ c[ 2 ] ].y, points[ c[ 3 ] ].y, weight );
        v.z = THREE.Curve.Utils.interpolate( points[ c[ 0 ] ].z, points[ c[ 1 ] ].z, points[ c[ 2 ] ].z, points[ c[ 3 ] ].z, weight );

        return v;

    }

);
/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.AnimationHandler = (function() {

	var playing = [];
	var library = {};
	var that    = {};


	//--- update ---

	that.update = function( deltaTimeMS ) {

		for( var i = 0; i < playing.length; i ++ )
			playing[ i ].update( deltaTimeMS );

	};


	//--- add ---

	that.addToUpdate = function( animation ) {

		if ( playing.indexOf( animation ) === -1 )
			playing.push( animation );

	};


	//--- remove ---

	that.removeFromUpdate = function( animation ) {

		var index = playing.indexOf( animation );

		if( index !== -1 )
			playing.splice( index, 1 );

	};


	//--- add ---

	that.add = function( data ) {

		if ( library[ data.name ] !== undefined )
			console.log( "THREE.AnimationHandler.add: Warning! " + data.name + " already exists in library. Overwriting." );

		library[ data.name ] = data;
		initData( data );

	};


	//--- get ---

	that.get = function( name ) {

		if ( typeof name === "string" ) {

			if ( library[ name ] ) {

				return library[ name ];

			} else {

				console.log( "THREE.AnimationHandler.get: Couldn't find animation " + name );
				return null;

			}

		} else {

			// todo: add simple tween library

		}

	};

	//--- parse ---

	that.parse = function( root ) {

		// setup hierarchy

		var hierarchy = [];

		if ( root instanceof THREE.SkinnedMesh ) {

			for( var b = 0; b < root.bones.length; b++ ) {

				hierarchy.push( root.bones[ b ] );

			}

		} else {

			parseRecurseHierarchy( root, hierarchy );

		}

		return hierarchy;

	};

	var parseRecurseHierarchy = function( root, hierarchy ) {

		hierarchy.push( root );

		for( var c = 0; c < root.children.length; c++ )
			parseRecurseHierarchy( root.children[ c ], hierarchy );

	}


	//--- init data ---

	var initData = function( data ) {

		if( data.initialized === true )
			return;


		// loop through all keys

		for( var h = 0; h < data.hierarchy.length; h ++ ) {

			for( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				// remove minus times

				if( data.hierarchy[ h ].keys[ k ].time < 0 )
					data.hierarchy[ h ].keys[ k ].time = 0;


				// create quaternions

				if( data.hierarchy[ h ].keys[ k ].rot !== undefined &&
				 !( data.hierarchy[ h ].keys[ k ].rot instanceof THREE.Quaternion ) ) {

					var quat = data.hierarchy[ h ].keys[ k ].rot;
					data.hierarchy[ h ].keys[ k ].rot = new THREE.Quaternion( quat[0], quat[1], quat[2], quat[3] );

				}

			}


			// prepare morph target keys

			if( data.hierarchy[ h ].keys.length && data.hierarchy[ h ].keys[ 0 ].morphTargets !== undefined ) {

				// get all used

				var usedMorphTargets = {};

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

						var morphTargetName = data.hierarchy[ h ].keys[ k ].morphTargets[ m ];
						usedMorphTargets[ morphTargetName ] = -1;

					}

				}

				data.hierarchy[ h ].usedMorphTargets = usedMorphTargets;


				// set all used on all frames

				for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

					var influences = {};

					for ( var morphTargetName in usedMorphTargets ) {

						for ( var m = 0; m < data.hierarchy[ h ].keys[ k ].morphTargets.length; m ++ ) {

							if ( data.hierarchy[ h ].keys[ k ].morphTargets[ m ] === morphTargetName ) {

								influences[ morphTargetName ] = data.hierarchy[ h ].keys[ k ].morphTargetsInfluences[ m ];
								break;

							}

						}

						if ( m === data.hierarchy[ h ].keys[ k ].morphTargets.length ) {

							influences[ morphTargetName ] = 0;

						}

					}

					data.hierarchy[ h ].keys[ k ].morphTargetsInfluences = influences;

				}

			}


			// remove all keys that are on the same time

			for ( var k = 1; k < data.hierarchy[ h ].keys.length; k ++ ) {

				if ( data.hierarchy[ h ].keys[ k ].time === data.hierarchy[ h ].keys[ k - 1 ].time ) {

					data.hierarchy[ h ].keys.splice( k, 1 );
					k --;

				}

			}


			// set index

			for ( var k = 0; k < data.hierarchy[ h ].keys.length; k ++ ) {

				data.hierarchy[ h ].keys[ k ].index = k;

			}

		}

		// done

		data.initialized = true;

	};


	// interpolation types

	that.LINEAR = 0;
	that.CATMULLROM = 1;
	that.CATMULLROM_FORWARD = 2;

	return that;

}());

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.Animation = function ( root, name ) {

	this.root = root;
	this.data = THREE.AnimationHandler.get( name );
	this.hierarchy = THREE.AnimationHandler.parse( root );

	this.currentTime = 0;
	this.timeScale = 1;

	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;

	this.interpolationType = THREE.AnimationHandler.LINEAR;

};

THREE.Animation.prototype.play = function ( startTime ) {

	this.currentTime = startTime !== undefined ? startTime : 0;

	if ( this.isPlaying === false ) {

		this.isPlaying = true;

		this.reset();
		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.addToUpdate( this );

};


THREE.Animation.prototype.pause = function() {

	if ( this.isPaused === true ) {

		THREE.AnimationHandler.addToUpdate( this );

	} else {

		THREE.AnimationHandler.removeFromUpdate( this );

	}

	this.isPaused = !this.isPaused;

};


THREE.Animation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;
	THREE.AnimationHandler.removeFromUpdate( this );

};

THREE.Animation.prototype.reset = function () {

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var object = this.hierarchy[ h ];

		object.matrixAutoUpdate = true;

		if ( object.animationCache === undefined ) {

			object.animationCache = {};
			object.animationCache.prevKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.nextKey = { pos: 0, rot: 0, scl: 0 };
			object.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;

		}

		var prevKey = object.animationCache.prevKey;
		var nextKey = object.animationCache.nextKey;

		prevKey.pos = this.data.hierarchy[ h ].keys[ 0 ];
		prevKey.rot = this.data.hierarchy[ h ].keys[ 0 ];
		prevKey.scl = this.data.hierarchy[ h ].keys[ 0 ];

		nextKey.pos = this.getNextKeyWith( "pos", h, 1 );
		nextKey.rot = this.getNextKeyWith( "rot", h, 1 );
		nextKey.scl = this.getNextKeyWith( "scl", h, 1 );

	}

};


THREE.Animation.prototype.update = (function(){

	var points = [];
	var target = new THREE.Vector3();
	
	// Catmull-Rom spline

	var interpolateCatmullRom = function ( points, scale ) {

		var c = [], v3 = [],
		point, intPoint, weight, w2, w3,
		pa, pb, pc, pd;
	
		point = ( points.length - 1 ) * scale;
		intPoint = Math.floor( point );
		weight = point - intPoint;
	
		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint > points.length - 2 ? intPoint : intPoint + 1;
		c[ 3 ] = intPoint > points.length - 3 ? intPoint : intPoint + 2;
	
		pa = points[ c[ 0 ] ];
		pb = points[ c[ 1 ] ];
		pc = points[ c[ 2 ] ];
		pd = points[ c[ 3 ] ];
	
		w2 = weight * weight;
		w3 = weight * w2;
	
		v3[ 0 ] = interpolate( pa[ 0 ], pb[ 0 ], pc[ 0 ], pd[ 0 ], weight, w2, w3 );
		v3[ 1 ] = interpolate( pa[ 1 ], pb[ 1 ], pc[ 1 ], pd[ 1 ], weight, w2, w3 );
		v3[ 2 ] = interpolate( pa[ 2 ], pb[ 2 ], pc[ 2 ], pd[ 2 ], weight, w2, w3 );
	
		return v3;

	};

	var interpolate = function ( p0, p1, p2, p3, t, t2, t3 ) {
	
		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;
	
		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
	};
	
	return function ( delta ) {
		if ( this.isPlaying === false ) return;
	
		this.currentTime += delta * this.timeScale;
	
		//
	
		var vector;
		var types = [ "pos", "rot", "scl" ];
	
		var duration = this.data.length;
	
		if ( this.loop === true && this.currentTime > duration ) {
	
			this.currentTime %= duration;
			this.reset();
	
		} else if ( this.loop === false && this.currentTime > duration ) {
	
			this.stop();
			return;
	
		}
	
		this.currentTime = Math.min( this.currentTime, duration );
	
		for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {
	
			var object = this.hierarchy[ h ];
			var animationCache = object.animationCache;
	
			// loop through pos/rot/scl
	
			for ( var t = 0; t < 3; t ++ ) {
	
				// get keys
	
				var type    = types[ t ];
				var prevKey = animationCache.prevKey[ type ];
				var nextKey = animationCache.nextKey[ type ];
	
				if ( nextKey.time <= this.currentTime ) {
	
					prevKey = this.data.hierarchy[ h ].keys[ 0 ];
					nextKey = this.getNextKeyWith( type, h, 1 );
	
					while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {
	
						prevKey = nextKey;
						nextKey = this.getNextKeyWith( type, h, nextKey.index + 1 );
	
					}
	
					animationCache.prevKey[ type ] = prevKey;
					animationCache.nextKey[ type ] = nextKey;
	
				}
	
				object.matrixAutoUpdate = true;
				object.matrixWorldNeedsUpdate = true;
	
				var scale = ( this.currentTime - prevKey.time ) / ( nextKey.time - prevKey.time );
	
				var prevXYZ = prevKey[ type ];
				var nextXYZ = nextKey[ type ];
	
				if ( scale < 0 ) scale = 0;
				if ( scale > 1 ) scale = 1;
	
				// interpolate
	
				if ( type === "pos" ) {
	
					vector = object.position;
	
					if ( this.interpolationType === THREE.AnimationHandler.LINEAR ) {
	
						vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
						vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
						vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;
	
					} else if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
						this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
						points[ 0 ] = this.getPrevKeyWith( "pos", h, prevKey.index - 1 )[ "pos" ];
						points[ 1 ] = prevXYZ;
						points[ 2 ] = nextXYZ;
						points[ 3 ] = this.getNextKeyWith( "pos", h, nextKey.index + 1 )[ "pos" ];
	
						scale = scale * 0.33 + 0.33;
	
						var currentPoint = interpolateCatmullRom( points, scale );
	
						vector.x = currentPoint[ 0 ];
						vector.y = currentPoint[ 1 ];
						vector.z = currentPoint[ 2 ];
	
						if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {
	
							var forwardPoint = interpolateCatmullRom( points, scale * 1.01 );
	
							target.set( forwardPoint[ 0 ], forwardPoint[ 1 ], forwardPoint[ 2 ] );
							target.sub( vector );
							target.y = 0;
							target.normalize();
	
							var angle = Math.atan2( target.x, target.z );
							object.rotation.set( 0, angle, 0 );
	
						}
	
					}
	
				} else if ( type === "rot" ) {
	
					THREE.Quaternion.slerp( prevXYZ, nextXYZ, object.quaternion, scale );
	
				} else if ( type === "scl" ) {
	
					vector = object.scale;
	
					vector.x = prevXYZ[ 0 ] + ( nextXYZ[ 0 ] - prevXYZ[ 0 ] ) * scale;
					vector.y = prevXYZ[ 1 ] + ( nextXYZ[ 1 ] - prevXYZ[ 1 ] ) * scale;
					vector.z = prevXYZ[ 2 ] + ( nextXYZ[ 2 ] - prevXYZ[ 2 ] ) * scale;
	
				}
	
			}
	
		}

	};

})();





// Get next key with

THREE.Animation.prototype.getNextKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		 this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key < keys.length - 1 ? key : keys.length - 1;

	} else {

		key = key % keys.length;

	}

	for ( ; key < keys.length; key++ ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ 0 ];

};

// Get previous key with

THREE.Animation.prototype.getPrevKeyWith = function ( type, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;

	if ( this.interpolationType === THREE.AnimationHandler.CATMULLROM ||
		this.interpolationType === THREE.AnimationHandler.CATMULLROM_FORWARD ) {

		key = key > 0 ? key : 0;

	} else {

		key = key >= 0 ? key : key + keys.length;

	}


	for ( ; key >= 0; key -- ) {

		if ( keys[ key ][ type ] !== undefined ) {

			return keys[ key ];

		}

	}

	return this.data.hierarchy[ h ].keys[ keys.length - 1 ];

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author khang duong
 * @author erik kitson
 */

THREE.KeyFrameAnimation = function ( root, data ) {

	this.root = root;
	this.data = THREE.AnimationHandler.get( data );
	this.hierarchy = THREE.AnimationHandler.parse( root );
	this.currentTime = 0;
	this.timeScale = 0.001;
	this.isPlaying = false;
	this.isPaused = true;
	this.loop = true;

	// initialize to first keyframes

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h ++ ) {

		var keys = this.data.hierarchy[h].keys,
			sids = this.data.hierarchy[h].sids,
			obj = this.hierarchy[h];

		if ( keys.length && sids ) {

			for ( var s = 0; s < sids.length; s++ ) {

				var sid = sids[ s ],
					next = this.getNextKeyWith( sid, h, 0 );

				if ( next ) {

					next.apply( sid );

				}

			}

			obj.matrixAutoUpdate = false;
			this.data.hierarchy[h].node.updateMatrix();
			obj.matrixWorldNeedsUpdate = true;

		}

	}

};

// Play

THREE.KeyFrameAnimation.prototype.play = function ( startTime ) {

	this.currentTime = startTime !== undefined ? startTime : 0;

	if ( this.isPlaying === false ) {

		this.isPlaying = true;

		// reset key cache

		var h, hl = this.hierarchy.length,
			object,
			node;

		for ( h = 0; h < hl; h++ ) {

			object = this.hierarchy[ h ];
			node = this.data.hierarchy[ h ];

			if ( node.animationCache === undefined ) {

				node.animationCache = {};
				node.animationCache.prevKey = null;
				node.animationCache.nextKey = null;
				node.animationCache.originalMatrix = object instanceof THREE.Bone ? object.skinMatrix : object.matrix;

			}

			var keys = this.data.hierarchy[h].keys;

			if (keys.length) {

				node.animationCache.prevKey = keys[ 0 ];
				node.animationCache.nextKey = keys[ 1 ];

				this.startTime = Math.min( keys[0].time, this.startTime );
				this.endTime = Math.max( keys[keys.length - 1].time, this.endTime );

			}

		}

		this.update( 0 );

	}

	this.isPaused = false;

	THREE.AnimationHandler.addToUpdate( this );

};



// Pause

THREE.KeyFrameAnimation.prototype.pause = function() {

	if( this.isPaused ) {

		THREE.AnimationHandler.addToUpdate( this );

	} else {

		THREE.AnimationHandler.removeFromUpdate( this );

	}

	this.isPaused = !this.isPaused;

};


// Stop

THREE.KeyFrameAnimation.prototype.stop = function() {

	this.isPlaying = false;
	this.isPaused  = false;

	THREE.AnimationHandler.removeFromUpdate( this );

	// reset JIT matrix and remove cache

	for ( var h = 0; h < this.data.hierarchy.length; h++ ) {
        
		var obj = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		if ( node.animationCache !== undefined ) {

			var original = node.animationCache.originalMatrix;

			if( obj instanceof THREE.Bone ) {

				original.copy( obj.skinMatrix );
				obj.skinMatrix = original;

			} else {

				original.copy( obj.matrix );
				obj.matrix = original;

			}

			delete node.animationCache;

		}

	}

};


// Update

THREE.KeyFrameAnimation.prototype.update = function ( delta ) {

	if ( this.isPlaying === false ) return;

	this.currentTime += delta * this.timeScale;

	//

	var duration = this.data.length;

	if ( this.loop === true && this.currentTime > duration ) {

		this.currentTime %= duration;

	}

	this.currentTime = Math.min( this.currentTime, duration );

	for ( var h = 0, hl = this.hierarchy.length; h < hl; h++ ) {

		var object = this.hierarchy[ h ];
		var node = this.data.hierarchy[ h ];

		var keys = node.keys,
			animationCache = node.animationCache;


		if ( keys.length ) {

			var prevKey = animationCache.prevKey;
			var nextKey = animationCache.nextKey;

			if ( nextKey.time <= this.currentTime ) {

				while ( nextKey.time < this.currentTime && nextKey.index > prevKey.index ) {

					prevKey = nextKey;
					nextKey = keys[ prevKey.index + 1 ];

				}

				animationCache.prevKey = prevKey;
				animationCache.nextKey = nextKey;

			}

			if ( nextKey.time >= this.currentTime ) {

				prevKey.interpolate( nextKey, this.currentTime );

			} else {

				prevKey.interpolate( nextKey, nextKey.time );

			}

			this.data.hierarchy[ h ].node.updateMatrix();
			object.matrixWorldNeedsUpdate = true;

		}

	}

};

// Get next key with

THREE.KeyFrameAnimation.prototype.getNextKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key % keys.length;

	for ( ; key < keys.length; key++ ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ 0 ];

};

// Get previous key with

THREE.KeyFrameAnimation.prototype.getPrevKeyWith = function( sid, h, key ) {

	var keys = this.data.hierarchy[ h ].keys;
	key = key >= 0 ? key : key + keys.length;

	for ( ; key >= 0; key-- ) {

		if ( keys[ key ].hasTarget( sid ) ) {

			return keys[ key ];

		}

	}

	return keys[ keys.length - 1 ];

};

/**
 * @author mrdoob / http://mrdoob.com
 */

THREE.MorphAnimation = function ( mesh ) {

	this.mesh = mesh;
	this.frames = mesh.morphTargetInfluences.length;
	this.currentTime = 0;
	this.duration = 1000;
	this.loop = true;

	this.isPlaying = false;

};

THREE.MorphAnimation.prototype = {

	play: function () {

		this.isPlaying = true;

	},

	pause: function () {

		this.isPlaying = false;
	},

	update: ( function () {

		var lastFrame = 0;
		var currentFrame = 0;

		return function ( delta ) {

			if ( this.isPlaying === false ) return;

			this.currentTime += delta;

			if ( this.loop === true && this.currentTime > this.duration ) {

				this.currentTime %= this.duration;

			}

			this.currentTime = Math.min( this.currentTime, this.duration );

			var interpolation = this.duration / this.frames;
			var frame = Math.floor( this.currentTime / interpolation );

			if ( frame != currentFrame ) {

				this.mesh.morphTargetInfluences[ lastFrame ] = 0;
				this.mesh.morphTargetInfluences[ currentFrame ] = 1;
				this.mesh.morphTargetInfluences[ frame ] = 0;

				lastFrame = currentFrame;
				currentFrame = frame;

			}

			this.mesh.morphTargetInfluences[ frame ] = ( this.currentTime % interpolation ) / interpolation;
			this.mesh.morphTargetInfluences[ lastFrame ] = 1 - this.mesh.morphTargetInfluences[ frame ];

		}

	} )()

};

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

THREE.CubeCamera = function ( near, far, cubeResolution ) {

	THREE.Object3D.call( this );

	var fov = 90, aspect = 1;

	var cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, -1, 0 );
	cameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, -1, 0 );
	cameraNX.lookAt( new THREE.Vector3( -1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, -1 );
	cameraNY.lookAt( new THREE.Vector3( 0, -1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, -1, 0 );
	cameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, -1, 0 );
	cameraNZ.lookAt( new THREE.Vector3( 0, 0, -1 ) );
	this.add( cameraNZ );

	this.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter } );

	this.updateCubeMap = function ( renderer, scene ) {

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.generateMipmaps;

		renderTarget.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

	};

};

THREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );

/**
 *	@author zz85 / http://twitter.com/blurspline / http://www.lab4games.net/zz85/blog
 *
 *	A general perpose camera, for setting FOV, Lens Focal Length,
 *		and switching between perspective and orthographic views easily.
 *		Use this only if you do not wish to manage
 *		both a Orthographic and Perspective Camera
 *
 */


THREE.CombinedCamera = function ( width, height, fov, near, far, orthoNear, orthoFar ) {

	THREE.Camera.call( this );

	this.fov = fov;

	this.left = -width / 2;
	this.right = width / 2
	this.top = height / 2;
	this.bottom = -height / 2;

	// We could also handle the projectionMatrix internally, but just wanted to test nested camera objects

	this.cameraO = new THREE.OrthographicCamera( width / - 2, width / 2, height / 2, height / - 2, 	orthoNear, orthoFar );
	this.cameraP = new THREE.PerspectiveCamera( fov, width / height, near, far );

	this.zoom = 1;

	this.toPerspective();

	var aspect = width/height;

};

THREE.CombinedCamera.prototype = Object.create( THREE.Camera.prototype );

THREE.CombinedCamera.prototype.toPerspective = function () {

	// Switches to the Perspective Camera

	this.near = this.cameraP.near;
	this.far = this.cameraP.far;

	this.cameraP.fov =  this.fov / this.zoom ;

	this.cameraP.updateProjectionMatrix();

	this.projectionMatrix = this.cameraP.projectionMatrix;

	this.inPerspectiveMode = true;
	this.inOrthographicMode = false;

};

THREE.CombinedCamera.prototype.toOrthographic = function () {

	// Switches to the Orthographic camera estimating viewport from Perspective

	var fov = this.fov;
	var aspect = this.cameraP.aspect;
	var near = this.cameraP.near;
	var far = this.cameraP.far;

	// The size that we set is the mid plane of the viewing frustum

	var hyperfocus = ( near + far ) / 2;

	var halfHeight = Math.tan( fov / 2 ) * hyperfocus;
	var planeHeight = 2 * halfHeight;
	var planeWidth = planeHeight * aspect;
	var halfWidth = planeWidth / 2;

	halfHeight /= this.zoom;
	halfWidth /= this.zoom;

	this.cameraO.left = -halfWidth;
	this.cameraO.right = halfWidth;
	this.cameraO.top = halfHeight;
	this.cameraO.bottom = -halfHeight;

	// this.cameraO.left = -farHalfWidth;
	// this.cameraO.right = farHalfWidth;
	// this.cameraO.top = farHalfHeight;
	// this.cameraO.bottom = -farHalfHeight;

	// this.cameraO.left = this.left / this.zoom;
	// this.cameraO.right = this.right / this.zoom;
	// this.cameraO.top = this.top / this.zoom;
	// this.cameraO.bottom = this.bottom / this.zoom;

	this.cameraO.updateProjectionMatrix();

	this.near = this.cameraO.near;
	this.far = this.cameraO.far;
	this.projectionMatrix = this.cameraO.projectionMatrix;

	this.inPerspectiveMode = false;
	this.inOrthographicMode = true;

};


THREE.CombinedCamera.prototype.setSize = function( width, height ) {

	this.cameraP.aspect = width / height;
	this.left = -width / 2;
	this.right = width / 2
	this.top = height / 2;
	this.bottom = -height / 2;

};


THREE.CombinedCamera.prototype.setFov = function( fov ) {

	this.fov = fov;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}

};

// For mantaining similar API with PerspectiveCamera

THREE.CombinedCamera.prototype.updateProjectionMatrix = function() {

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toPerspective();
		this.toOrthographic();

	}

};

/*
* Uses Focal Length (in mm) to estimate and set FOV
* 35mm (fullframe) camera is used if frame size is not specified;
* Formula based on http://www.bobatkins.com/photography/technical/field_of_view.html
*/
THREE.CombinedCamera.prototype.setLens = function ( focalLength, frameHeight ) {

	if ( frameHeight === undefined ) frameHeight = 24;

	var fov = 2 * THREE.Math.radToDeg( Math.atan( frameHeight / ( focalLength * 2 ) ) );

	this.setFov( fov );

	return fov;
};


THREE.CombinedCamera.prototype.setZoom = function( zoom ) {

	this.zoom = zoom;

	if ( this.inPerspectiveMode ) {

		this.toPerspective();

	} else {

		this.toOrthographic();

	}

};

THREE.CombinedCamera.prototype.toFrontView = function() {

	this.rotation.x = 0;
	this.rotation.y = 0;
	this.rotation.z = 0;

	// should we be modifing the matrix instead?

	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBackView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toLeftView = function() {

	this.rotation.x = 0;
	this.rotation.y = - Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toRightView = function() {

	this.rotation.x = 0;
	this.rotation.y = Math.PI / 2;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toTopView = function() {

	this.rotation.x = - Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

THREE.CombinedCamera.prototype.toBottomView = function() {

	this.rotation.x = Math.PI / 2;
	this.rotation.y = 0;
	this.rotation.z = 0;
	this.rotationAutoUpdate = false;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

THREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.width = width;
	this.height = height;
	this.depth = depth;

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;
	this.depthSegments = depthSegments || 1;

	var width_half = this.width / 2;
	var height_half = this.height / 2;
	var depth_half = this.depth / 2;

	buildPlane( 'z', 'y', - 1, - 1, this.depth, this.height, width_half, 0 ); // px
	buildPlane( 'z', 'y',   1, - 1, this.depth, this.height, - width_half, 1 ); // nx
	buildPlane( 'x', 'z',   1,   1, this.width, this.depth, height_half, 2 ); // py
	buildPlane( 'x', 'z',   1, - 1, this.width, this.depth, - height_half, 3 ); // ny
	buildPlane( 'x', 'y',   1, - 1, this.width, this.height, depth_half, 4 ); // pz
	buildPlane( 'x', 'y', - 1, - 1, this.width, this.height, - depth_half, 5 ); // nz

	function buildPlane( u, v, udir, vdir, width, height, depth, materialIndex ) {

		var w, ix, iy,
		gridX = scope.widthSegments,
		gridY = scope.heightSegments,
		width_half = width / 2,
		height_half = height / 2,
		offset = scope.vertices.length;

		if ( ( u === 'x' && v === 'y' ) || ( u === 'y' && v === 'x' ) ) {

			w = 'z';

		} else if ( ( u === 'x' && v === 'z' ) || ( u === 'z' && v === 'x' ) ) {

			w = 'y';
			gridY = scope.depthSegments;

		} else if ( ( u === 'z' && v === 'y' ) || ( u === 'y' && v === 'z' ) ) {

			w = 'x';
			gridX = scope.depthSegments;

		}

		var gridX1 = gridX + 1,
		gridY1 = gridY + 1,
		segment_width = width / gridX,
		segment_height = height / gridY,
		normal = new THREE.Vector3();

		normal[ w ] = depth > 0 ? 1 : - 1;

		for ( iy = 0; iy < gridY1; iy ++ ) {

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var vector = new THREE.Vector3();
				vector[ u ] = ( ix * segment_width - width_half ) * udir;
				vector[ v ] = ( iy * segment_height - height_half ) * vdir;
				vector[ w ] = depth;

				scope.vertices.push( vector );

			}

		}

		for ( iy = 0; iy < gridY; iy++ ) {

			for ( ix = 0; ix < gridX; ix++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				var uva = new THREE.Vector2( ix / gridX, 1 - iy / gridY );
				var uvb = new THREE.Vector2( ix / gridX, 1 - ( iy + 1 ) / gridY );
				var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iy + 1 ) / gridY );
				var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iy / gridY );

				var face = new THREE.Face3( a + offset, b + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

				face = new THREE.Face3( b + offset, c + offset, d + offset );
				face.normal.copy( normal );
				face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );
				face.materialIndex = materialIndex;

				scope.faces.push( face );
				scope.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

			}

		}

	}

	this.computeCentroids();
	this.mergeVertices();

};

THREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author hughes
 */

THREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.radius = radius = radius || 50;
	this.segments = segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
	this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var i, uvs = [],
	center = new THREE.Vector3(), centerUV = new THREE.Vector2( 0.5, 0.5 );

	this.vertices.push(center);
	uvs.push( centerUV );

	for ( i = 0; i <= segments; i ++ ) {

		var vertex = new THREE.Vector3();
		var segment = thetaStart + i / segments * thetaLength;

		vertex.x = radius * Math.cos( segment );
		vertex.y = radius * Math.sin( segment );

		this.vertices.push( vertex );
		uvs.push( new THREE.Vector2( ( vertex.x / radius + 1 ) / 2, ( vertex.y / radius + 1 ) / 2 ) );

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 1; i <= segments; i ++ ) {

		var v1 = i;
		var v2 = i + 1 ;
		var v3 = 0;

		this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
		this.faceVertexUvs[ 0 ].push( [ uvs[ i ].clone(), uvs[ i + 1 ].clone(), centerUV.clone() ] );

	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );

// DEPRECATED

THREE.CubeGeometry = THREE.BoxGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded ) {

	THREE.Geometry.call( this );

	this.radiusTop = radiusTop = radiusTop !== undefined ? radiusTop : 20;
	this.radiusBottom = radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	this.height = height = height !== undefined ? height : 100;

	this.radialSegments = radialSegments = radialSegments || 8;
	this.heightSegments = heightSegments = heightSegments || 1;

	this.openEnded = openEnded = openEnded !== undefined ? openEnded : false;

	var heightHalf = height / 2;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		var v = y / heightSegments;
		var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;

			var vertex = new THREE.Vector3();
			vertex.x = radius * Math.sin( u * Math.PI * 2 );
			vertex.y = - v * height + heightHalf;
			vertex.z = radius * Math.cos( u * Math.PI * 2 );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	var tanTheta = ( radiusBottom - radiusTop ) / height;
	var na, nb;

	for ( x = 0; x < radialSegments; x ++ ) {

		if ( radiusTop !== 0 ) {

			na = this.vertices[ vertices[ 0 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 0 ][ x + 1 ] ].clone();

		} else {

			na = this.vertices[ vertices[ 1 ][ x ] ].clone();
			nb = this.vertices[ vertices[ 1 ][ x + 1 ] ].clone();

		}

		na.setY( Math.sqrt( na.x * na.x + na.z * na.z ) * tanTheta ).normalize();
		nb.setY( Math.sqrt( nb.x * nb.x + nb.z * nb.z ) * tanTheta ).normalize();

		for ( y = 0; y < heightSegments; y ++ ) {

			var v1 = vertices[ y ][ x ];
			var v2 = vertices[ y + 1 ][ x ];
			var v3 = vertices[ y + 1 ][ x + 1 ];
			var v4 = vertices[ y ][ x + 1 ];

			var n1 = na.clone();
			var n2 = na.clone();
			var n3 = nb.clone();
			var n4 = nb.clone();

			var uv1 = uvs[ y ][ x ].clone();
			var uv2 = uvs[ y + 1 ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x + 1 ].clone();
			var uv4 = uvs[ y ][ x + 1 ].clone();

			this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

			this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

		}

	}

	// top cap

	if ( openEnded === false && radiusTop > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ 0 ][ x ];
			var v2 = vertices[ 0 ][ x + 1 ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, 1, 0 );
			var n2 = new THREE.Vector3( 0, 1, 0 );
			var n3 = new THREE.Vector3( 0, 1, 0 );

			var uv1 = uvs[ 0 ][ x ].clone();
			var uv2 = uvs[ 0 ][ x + 1 ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 0 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	// bottom cap

	if ( openEnded === false && radiusBottom > 0 ) {

		this.vertices.push( new THREE.Vector3( 0, - heightHalf, 0 ) );

		for ( x = 0; x < radialSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = this.vertices.length - 1;

			var n1 = new THREE.Vector3( 0, - 1, 0 );
			var n2 = new THREE.Vector3( 0, - 1, 0 );
			var n3 = new THREE.Vector3( 0, - 1, 0 );

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = new THREE.Vector2( uv2.x, 1 );

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
			this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

}

THREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segements of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)
 *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals
 *
 *  material: <int> // material index for front and back faces
 *  extrudeMaterial: <int> // material index for extrusion and beveled faces
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ExtrudeGeometry = function ( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {
		shapes = [];
		return;
	}

	THREE.Geometry.call( this );

	shapes = shapes instanceof Array ? shapes : [ shapes ];

	this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();

	this.addShapeList( shapes, options );

	this.computeCentroids();
	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

};

THREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );

THREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {
		var shape = shapes[ s ];
		this.addShape( shape, options );
	}
};

THREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	var material = options.material;
	var extrudeMaterial = options.extrudeMaterial;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;

	var shapebb = this.shapebb;
	//shapebb = shape.getBoundingBox();



	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// Reuse TNB from TubeGeomtry for now.
		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames(extrudePath, steps, false);

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new THREE.Vector3();
		normal = new THREE.Vector3();
		position2 = new THREE.Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initalization

	var ahole, h, hl; // looping of holes
	var scope = this;
	var bevelPoints = [];

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = !THREE.Shape.Utils.isClockWise( vertices ) ;

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( THREE.Shape.Utils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = THREE.Shape.Utils.triangulateShape ( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2 ( pt, vec, size ) {

		if ( !vec ) console.log( "die" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length,
		cont, clen = contour.length;


	// Find directions for point movement

	var RAD_TO_DEGREES = 180 / Math.PI;


	function getBevelVec( inPt, inPrev, inNext ) {

		var EPSILON = 0.0000000001;
		var sign = THREE.Math.sign;
		
		// computes for inPt the corresponding point inPt' on a new contour
		//   shiftet by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.
		
		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
		
		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
		
		// check for colinear edges
		var colinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
		
		if ( Math.abs( colinear0 ) > EPSILON ) {		// not colinear
			
			// length of vectors for normalizing
	
			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
			
			// shift adjacent points by unit vectors to the left
	
			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
			
			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
			// scaling factor for v_prev to intersection point
	
			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
			// vector from inPt to intersection point
	
			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y )
			if ( v_trans_lensq <= 2 ) {
				return	new THREE.Vector2( v_trans_x, v_trans_y );
			} else {
				shrink_by = Math.sqrt( v_trans_lensq / 2 );
			}
			
		} else {		// handle special case of colinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > EPSILON ) {
				if ( v_next_x > EPSILON ) { direction_eq = true; }
			} else {
				if ( v_prev_x < -EPSILON ) {
					if ( v_next_x < -EPSILON ) { direction_eq = true; }
				} else {
					if ( sign(v_prev_y) == sign(v_next_y) ) { direction_eq = true; }
				}
			}

			if ( direction_eq ) {
				// console.log("Warning: lines are a straight sequence");
				v_trans_x = -v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );
			} else {
				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );
			}

		}

		return	new THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		var pt_i = contour[ i ];
		var pt_j = contour[ j ];
		var pt_k = contour[ k ];

		contourMovements[ i ]= getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ]= getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {
	//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );

		//z = bevelThickness * t;
		bs = bevelSize * ( Math.sin ( t * Math.PI/2 ) ) ; // curved
		//bs = bevelSize * t ; // linear

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			//vert = scalePt( contour[ i ], contourCentroid, bs, false );
			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
				//vert = scalePt( ahole[ i ], holesCentroids[ h ], bs, true );

				v( vert.x, vert.y,  -z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( !extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[0] ).multiplyScalar(vert.x);
			binormal.copy( splineTube.binormals[0] ).multiplyScalar(vert.y);

			position2.copy( extrudePts[0] ).add(normal).add(binormal);

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( !extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[s] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[s] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[s] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * ( 1 - t );
		//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );
		bs = bevelSize * Math.sin ( t * Math.PI/2 ) ;

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( !extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0 ; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ]+ offset, face[ 1 ]+ offset, face[ 0 ] + offset, true );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset, false );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ], true );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps, false );

			}
		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length;  h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( --i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}
		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new THREE.Vector3( x, y, z ) );

	}

	function f3( a, b, c, isBottom ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		// normal, color, material
		scope.faces.push( new THREE.Face3( a, b, c, null, null, material ) );

		var uvs = isBottom ? uvgen.generateBottomUV( scope, shape, options, a, b, c ) : uvgen.generateTopUV( scope, shape, options, a, b, c );

 		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

 		scope.faces.push( new THREE.Face3( a, b, d, null, null, extrudeMaterial ) );
 		scope.faces.push( new THREE.Face3( b, c, d, null, null, extrudeMaterial ) );

 		var uvs = uvgen.generateSideWallUV( scope, shape, wallContour, options, a, b, c, d,
 		                                    stepIndex, stepsLength, contourIndex1, contourIndex2 );

 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
 		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

THREE.ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {
		var ax = geometry.vertices[ indexA ].x,
			ay = geometry.vertices[ indexA ].y,

			bx = geometry.vertices[ indexB ].x,
			by = geometry.vertices[ indexB ].y,

			cx = geometry.vertices[ indexC ].x,
			cy = geometry.vertices[ indexC ].y;

		return [
			new THREE.Vector2( ax, ay ),
			new THREE.Vector2( bx, by ),
			new THREE.Vector2( cx, cy )
		];

	},

	generateBottomUV: function( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC ) {

		return this.generateTopUV( geometry, extrudedShape, extrudeOptions, indexA, indexB, indexC );

	},

	generateSideWallUV: function( geometry, extrudedShape, wallContour, extrudeOptions,
	                              indexA, indexB, indexC, indexD, stepIndex, stepsLength,
	                              contourIndex1, contourIndex2 ) {

		var ax = geometry.vertices[ indexA ].x,
			ay = geometry.vertices[ indexA ].y,
			az = geometry.vertices[ indexA ].z,

			bx = geometry.vertices[ indexB ].x,
			by = geometry.vertices[ indexB ].y,
			bz = geometry.vertices[ indexB ].z,

			cx = geometry.vertices[ indexC ].x,
			cy = geometry.vertices[ indexC ].y,
			cz = geometry.vertices[ indexC ].z,

			dx = geometry.vertices[ indexD ].x,
			dy = geometry.vertices[ indexD ].y,
			dz = geometry.vertices[ indexD ].z;

		if ( Math.abs( ay - by ) < 0.01 ) {
			return [
				new THREE.Vector2( ax, 1 - az ),
				new THREE.Vector2( bx, 1 - bz ),
				new THREE.Vector2( cx, 1 - cz ),
				new THREE.Vector2( dx, 1 - dz )
			];
		} else {
			return [
				new THREE.Vector2( ay, 1 - az ),
				new THREE.Vector2( by, 1 - bz ),
				new THREE.Vector2( cy, 1 - cz ),
				new THREE.Vector2( dy, 1 - dz )
			];
		}
	}
};

THREE.ExtrudeGeometry.__v1 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v2 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v3 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v4 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v5 = new THREE.Vector2();
THREE.ExtrudeGeometry.__v6 = new THREE.Vector2();

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape. Similar to
 * ExtrudeGeometry.
 *
 * parameters = {
 *
 *	curveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.
 *
 *	material: <int> // material index for front and back faces
 *	uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

THREE.ShapeGeometry = function ( shapes, options ) {

	THREE.Geometry.call( this );

	if ( shapes instanceof Array === false ) shapes = [ shapes ];

	this.shapebb = shapes[ shapes.length - 1 ].getBoundingBox();

	this.addShapeList( shapes, options );

	this.computeCentroids();
	this.computeFaceNormals();

};

THREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * Add an array of shapes to THREE.ShapeGeometry.
 */
THREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {

	for ( var i = 0, l = shapes.length; i < l; i++ ) {

		this.addShape( shapes[ i ], options );

	}

	return this;

};

/**
 * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.
 */
THREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {

	if ( options === undefined ) options = {};
	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var material = options.material;
	var uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;

	var shapebb = this.shapebb;

	//

	var i, l, hole, s;

	var shapesOffset = this.vertices.length;
	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = !THREE.Shape.Utils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe...

		for ( i = 0, l = holes.length; i < l; i++ ) {

			hole = holes[ i ];

			if ( THREE.Shape.Utils.isClockWise( hole ) ) {

				holes[ i ] = hole.reverse();

			}

		}

		reverse = false;

	}

	var faces = THREE.Shape.Utils.triangulateShape( vertices, holes );

	// Vertices

	var contour = vertices;

	for ( i = 0, l = holes.length; i < l; i++ ) {

		hole = holes[ i ];
		vertices = vertices.concat( hole );

	}

	//

	var vert, vlen = vertices.length;
	var face, flen = faces.length;
	var cont, clen = contour.length;

	for ( i = 0; i < vlen; i++ ) {

		vert = vertices[ i ];

		this.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );

	}

	for ( i = 0; i < flen; i++ ) {

		face = faces[ i ];

		var a = face[ 0 ] + shapesOffset;
		var b = face[ 1 ] + shapesOffset;
		var c = face[ 2 ] + shapesOffset;

		this.faces.push( new THREE.Face3( a, b, c, null, null, material ) );
		this.faceVertexUvs[ 0 ].push( uvgen.generateBottomUV( this, shape, options, a, b, c ) );

	}

};

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://exocortex.com
 */

// points - to create a closed torus, one must use a set of points 
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2*PI) range of the lathed section
//    2*pi is a closed lathe, less than 2PI is a portion.
THREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {

	THREE.Geometry.call( this );

	segments = segments || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || 2 * Math.PI;

	var inversePointLength = 1.0 / ( points.length - 1 );
	var inverseSegments = 1.0 / segments;

	for ( var i = 0, il = segments; i <= il; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var c = Math.cos( phi ),
			s = Math.sin( phi );

		for ( var j = 0, jl = points.length; j < jl; j ++ ) {

			var pt = points[ j ];

			var vertex = new THREE.Vector3();

			vertex.x = c * pt.x - s * pt.y;
			vertex.y = s * pt.x + c * pt.y;
			vertex.z = pt.z;

			this.vertices.push( vertex );

		}

	}

	var np = points.length;

	for ( var i = 0, il = segments; i < il; i ++ ) {

		for ( var j = 0, jl = points.length - 1; j < jl; j ++ ) {

			var base = j + np * i;
			var a = base;
			var b = base + np;
			var c = base + 1 + np;
			var d = base + 1;

			var u0 = i * inverseSegments;
			var v0 = j * inversePointLength;
			var u1 = u0 + inverseSegments;
			var v1 = v0 + inversePointLength;

			this.faces.push( new THREE.Face3( a, b, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u0, v0 ),
				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u0, v1 )

			] );

			this.faces.push( new THREE.Face3( b, c, d ) );

			this.faceVertexUvs[ 0 ].push( [

				new THREE.Vector2( u1, v0 ),
				new THREE.Vector2( u1, v1 ),
				new THREE.Vector2( u0, v1 )

			] );


		}

	}

	this.mergeVertices();
	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

THREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {

	THREE.Geometry.call( this );

	this.width = width;
	this.height = height;

	this.widthSegments = widthSegments || 1;
	this.heightSegments = heightSegments || 1;

	var ix, iz;
	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = this.widthSegments;
	var gridZ = this.heightSegments;

	var gridX1 = gridX + 1;
	var gridZ1 = gridZ + 1;

	var segment_width = this.width / gridX;
	var segment_height = this.height / gridZ;

	var normal = new THREE.Vector3( 0, 0, 1 );

	for ( iz = 0; iz < gridZ1; iz ++ ) {

		for ( ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;
			var y = iz * segment_height - height_half;

			this.vertices.push( new THREE.Vector3( x, - y, 0 ) );

		}

	}

	for ( iz = 0; iz < gridZ; iz ++ ) {

		for ( ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iz;
			var b = ix + gridX1 * ( iz + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iz + 1 );
			var d = ( ix + 1 ) + gridX1 * iz;

			var uva = new THREE.Vector2( ix / gridX, 1 - iz / gridZ );
			var uvb = new THREE.Vector2( ix / gridX, 1 - ( iz + 1 ) / gridZ );
			var uvc = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - ( iz + 1 ) / gridZ );
			var uvd = new THREE.Vector2( ( ix + 1 ) / gridX, 1 - iz / gridZ );

			var face = new THREE.Face3( a, b, d );
			face.normal.copy( normal );
			face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			face = new THREE.Face3( b, c, d );
			face.normal.copy( normal );
			face.vertexNormals.push( normal.clone(), normal.clone(), normal.clone() );

			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	this.computeCentroids();

};

THREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author Kaleb Murphy
 */

THREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	innerRadius = innerRadius || 0;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 3, phiSegments ) : 8;

	var i, o, uvs = [], radius = innerRadius, radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );

	for ( i = 0; i <= phiSegments; i ++ ) { // concentric circles inside ring

		for ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle

			var vertex = new THREE.Vector3();
			var segment = thetaStart + o / thetaSegments * thetaLength;

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			this.vertices.push( vertex );
			uvs.push( new THREE.Vector2( ( vertex.x / outerRadius + 1 ) / 2, ( vertex.y / outerRadius + 1 ) / 2 ) );
		}

		radius += radiusStep;

	}

	var n = new THREE.Vector3( 0, 0, 1 );

	for ( i = 0; i < phiSegments; i ++ ) { // concentric circles inside ring

		var thetaSegment = i * thetaSegments;

		for ( o = 0; o <= thetaSegments; o ++ ) { // number of segments per circle

			var segment = o + thetaSegment;

			var v1 = segment + i;
			var v2 = segment + thetaSegments + i;
			var v3 = segment + thetaSegments + 1 + i;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

			v1 = segment + i;
			v2 = segment + thetaSegments + 1 + i;
			v3 = segment + 1 + i;

			this.faces.push( new THREE.Face3( v1, v2, v3, [ n.clone(), n.clone(), n.clone() ] ) );
			this.faceVertexUvs[ 0 ].push( [ uvs[ v1 ].clone(), uvs[ v2 ].clone(), uvs[ v3 ].clone() ]);

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	THREE.Geometry.call( this );

	this.radius = radius = radius || 50;

	this.widthSegments = widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	this.heightSegments = heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	this.phiStart = phiStart = phiStart !== undefined ? phiStart : 0;
	this.phiLength = phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	this.thetaStart = thetaStart = thetaStart !== undefined ? thetaStart : 0;
	this.thetaLength = thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var x, y, vertices = [], uvs = [];

	for ( y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];
		var uvsRow = [];

		for ( x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;
			var v = y / heightSegments;

			var vertex = new THREE.Vector3();
			vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
			vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			this.vertices.push( vertex );

			verticesRow.push( this.vertices.length - 1 );
			uvsRow.push( new THREE.Vector2( u, 1 - v ) );

		}

		vertices.push( verticesRow );
		uvs.push( uvsRow );

	}

	for ( y = 0; y < this.heightSegments; y ++ ) {

		for ( x = 0; x < this.widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			var n1 = this.vertices[ v1 ].clone().normalize();
			var n2 = this.vertices[ v2 ].clone().normalize();
			var n3 = this.vertices[ v3 ].clone().normalize();
			var n4 = this.vertices[ v4 ].clone().normalize();

			var uv1 = uvs[ y ][ x + 1 ].clone();
			var uv2 = uvs[ y ][ x ].clone();
			var uv3 = uvs[ y + 1 ][ x ].clone();
			var uv4 = uvs[ y + 1 ][ x + 1 ].clone();

			if ( Math.abs( this.vertices[ v1 ].y ) === this.radius ) {

				uv1.x = ( uv1.x + uv2.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v3, v4, [ n1, n3, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv3, uv4 ] );

			} else if ( Math.abs( this.vertices[ v3 ].y ) === this.radius ) {

				uv3.x = ( uv3.x + uv4.x ) / 2;
				this.faces.push( new THREE.Face3( v1, v2, v3, [ n1, n2, n3 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv3 ] );

			} else {

				this.faces.push( new THREE.Face3( v1, v2, v4, [ n1, n2, n4 ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv1, uv2, uv4 ] );

				this.faces.push( new THREE.Face3( v2, v3, v4, [ n2.clone(), n3, n4.clone() ] ) );
				this.faceVertexUvs[ 0 ].push( [ uv2.clone(), uv3, uv4.clone() ] );

			}

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );

};

THREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * For creating 3D text geometry in three.js
 *
 * Text = 3D Text
 *
 * parameters = {
 *  size: 			<float>, 	// size of the text
 *  height: 		<float>, 	// thickness to extrude text
 *  curveSegments: 	<int>,		// number of points on the curves
 *
 *  font: 			<string>,		// font name
 *  weight: 		<string>,		// font weight (normal, bold)
 *  style: 			<string>,		// font style  (normal, italics)
 *
 *  bevelEnabled:	<bool>,			// turn on bevel
 *  bevelThickness: <float>, 		// how deep into text bevel goes
 *  bevelSize:		<float>, 		// how far from text outline is bevel
 *  }
 *
 */

/*	Usage Examples

	// TextGeometry wrapper

	var text3d = new TextGeometry( text, options );

	// Complete manner

	var textShapes = THREE.FontUtils.generateShapes( text, options );
	var text3d = new ExtrudeGeometry( textShapes, options );

*/


THREE.TextGeometry = function ( text, parameters ) {

	parameters = parameters || {};

	var textShapes = THREE.FontUtils.generateShapes( text, parameters );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	THREE.ExtrudeGeometry.call( this, textShapes, parameters );

};

THREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

THREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.radius = radius || 100;
	this.tube = tube || 40;
	this.radialSegments = radialSegments || 8;
	this.tubularSegments = tubularSegments || 6;
	this.arc = arc || Math.PI * 2;

	var center = new THREE.Vector3(), uvs = [], normals = [];

	for ( var j = 0; j <= this.radialSegments; j ++ ) {

		for ( var i = 0; i <= this.tubularSegments; i ++ ) {

			var u = i / this.tubularSegments * this.arc;
			var v = j / this.radialSegments * Math.PI * 2;

			center.x = this.radius * Math.cos( u );
			center.y = this.radius * Math.sin( u );

			var vertex = new THREE.Vector3();
			vertex.x = ( this.radius + this.tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( this.radius + this.tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = this.tube * Math.sin( v );

			this.vertices.push( vertex );

			uvs.push( new THREE.Vector2( i / this.tubularSegments, j / this.radialSegments ) );
			normals.push( vertex.clone().sub( center ).normalize() );

		}

	}


	for ( var j = 1; j <= this.radialSegments; j ++ ) {

		for ( var i = 1; i <= this.tubularSegments; i ++ ) {

			var a = ( this.tubularSegments + 1 ) * j + i - 1;
			var b = ( this.tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( this.tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( this.tubularSegments + 1 ) * j + i;

			var face = new THREE.Face3( a, b, d, [ normals[ a ].clone(), normals[ b ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ a ].clone(), uvs[ b ].clone(), uvs[ d ].clone() ] );

			face = new THREE.Face3( b, c, d, [ normals[ b ].clone(), normals[ c ].clone(), normals[ d ].clone() ] );
			this.faces.push( face );
			this.faceVertexUvs[ 0 ].push( [ uvs[ b ].clone(), uvs[ c ].clone(), uvs[ d ].clone() ] );

		}

	}

	this.computeCentroids();
	this.computeFaceNormals();

};

THREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author oosmoxiecode
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3D/src/away3d/primitives/TorusKnot.as?spec=svn2473&r=2473
 */

THREE.TorusKnotGeometry = function ( radius, tube, radialSegments, tubularSegments, p, q, heightScale ) {

	THREE.Geometry.call( this );

	var scope = this;

	this.radius = radius || 100;
	this.tube = tube || 40;
	this.radialSegments = radialSegments || 64;
	this.tubularSegments = tubularSegments || 8;
	this.p = p || 2;
	this.q = q || 3;
	this.heightScale = heightScale || 1;
	this.grid = new Array( this.radialSegments );

	var tang = new THREE.Vector3();
	var n = new THREE.Vector3();
	var bitan = new THREE.Vector3();

	for ( var i = 0; i < this.radialSegments; ++ i ) {

		this.grid[ i ] = new Array( this.tubularSegments );
		var u = i / this.radialSegments * 2 * this.p * Math.PI;
		var p1 = getPos( u, this.q, this.p, this.radius, this.heightScale );
		var p2 = getPos( u + 0.01, this.q, this.p, this.radius, this.heightScale );
		tang.subVectors( p2, p1 );
		n.addVectors( p2, p1 );

		bitan.crossVectors( tang, n );
		n.crossVectors( bitan, tang );
		bitan.normalize();
		n.normalize();

		for ( var j = 0; j < this.tubularSegments; ++ j ) {

			var v = j / this.tubularSegments * 2 * Math.PI;
			var cx = - this.tube * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			var cy = this.tube * Math.sin( v );

			var pos = new THREE.Vector3();
			pos.x = p1.x + cx * n.x + cy * bitan.x;
			pos.y = p1.y + cx * n.y + cy * bitan.y;
			pos.z = p1.z + cx * n.z + cy * bitan.z;

			this.grid[ i ][ j ] = scope.vertices.push( pos ) - 1;

		}

	}

	for ( var i = 0; i < this.radialSegments; ++ i ) {

		for ( var j = 0; j < this.tubularSegments; ++ j ) {

			var ip = ( i + 1 ) % this.radialSegments;
			var jp = ( j + 1 ) % this.tubularSegments;

			var a = this.grid[ i ][ j ];
			var b = this.grid[ ip ][ j ];
			var c = this.grid[ ip ][ jp ];
			var d = this.grid[ i ][ jp ];

			var uva = new THREE.Vector2( i / this.radialSegments, j / this.tubularSegments );
			var uvb = new THREE.Vector2( ( i + 1 ) / this.radialSegments, j / this.tubularSegments );
			var uvc = new THREE.Vector2( ( i + 1 ) / this.radialSegments, ( j + 1 ) / this.tubularSegments );
			var uvd = new THREE.Vector2( i / this.radialSegments, ( j + 1 ) / this.tubularSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

	function getPos( u, in_q, in_p, radius, heightScale ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = in_q / in_p * u;
		var cs = Math.cos( quOverP );

		var tx = radius * ( 2 + cs ) * 0.5 * cu;
		var ty = radius * ( 2 + cs ) * su * 0.5;
		var tz = heightScale * radius * Math.sin( quOverP ) * 0.5;

		return new THREE.Vector3( tx, ty, tz );

	}

};

THREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 *
 * Modified from the TorusKnotGeometry by @oosmoxiecode
 *
 * Creates a tube which extrudes along a 3d spline
 *
 * Uses parallel transport frames as described in
 * http://www.cs.indiana.edu/pub/techreports/TR425.pdf
 */

THREE.TubeGeometry = function( path, segments, radius, radialSegments, closed ) {

	THREE.Geometry.call( this );

	this.path = path;
	this.segments = segments || 64;
	this.radius = radius || 1;
	this.radialSegments = radialSegments || 8;
	this.closed = closed || false;

	this.grid = [];

	var scope = this,

		tangent,
		normal,
		binormal,

		numpoints = this.segments + 1,

		x, y, z,
		tx, ty, tz,
		u, v,

		cx, cy,
		pos, pos2 = new THREE.Vector3(),
		i, j,
		ip, jp,
		a, b, c, d,
		uva, uvb, uvc, uvd;

	var frames = new THREE.TubeGeometry.FrenetFrames( this.path, this.segments, this.closed ),
		tangents = frames.tangents,
		normals = frames.normals,
		binormals = frames.binormals;

	// proxy internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	function vert( x, y, z ) {

		return scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;

	}


	// consruct the grid

	for ( i = 0; i < numpoints; i++ ) {

		this.grid[ i ] = [];

		u = i / ( numpoints - 1 );

		pos = path.getPointAt( u );

		tangent = tangents[ i ];
		normal = normals[ i ];
		binormal = binormals[ i ];

		for ( j = 0; j < this.radialSegments; j++ ) {

			v = j / this.radialSegments * 2 * Math.PI;

			cx = -this.radius * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.
			cy = this.radius * Math.sin( v );

			pos2.copy( pos );
			pos2.x += cx * normal.x + cy * binormal.x;
			pos2.y += cx * normal.y + cy * binormal.y;
			pos2.z += cx * normal.z + cy * binormal.z;

			this.grid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );

		}
	}


	// construct the mesh

	for ( i = 0; i < this.segments; i++ ) {

		for ( j = 0; j < this.radialSegments; j++ ) {

			ip = ( this.closed ) ? (i + 1) % this.segments : i + 1;
			jp = (j + 1) % this.radialSegments;

			a = this.grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
			b = this.grid[ ip ][ j ];
			c = this.grid[ ip ][ jp ];
			d = this.grid[ i ][ jp ];

			uva = new THREE.Vector2( i / this.segments, j / this.radialSegments );
			uvb = new THREE.Vector2( ( i + 1 ) / this.segments, j / this.radialSegments );
			uvc = new THREE.Vector2( ( i + 1 ) / this.segments, ( j + 1 ) / this.radialSegments );
			uvd = new THREE.Vector2( i / this.segments, ( j + 1 ) / this.radialSegments );

			this.faces.push( new THREE.Face3( a, b, d ) );
			this.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );

			this.faces.push( new THREE.Face3( b, c, d ) );
			this.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );

		}
	}

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );


// For computing of Frenet frames, exposing the tangents, normals and binormals the spline
THREE.TubeGeometry.FrenetFrames = function(path, segments, closed) {

	var	tangent = new THREE.Vector3(),
		normal = new THREE.Vector3(),
		binormal = new THREE.Vector3(),

		tangents = [],
		normals = [],
		binormals = [],

		vec = new THREE.Vector3(),
		mat = new THREE.Matrix4(),

		numpoints = segments + 1,
		theta,
		epsilon = 0.0001,
		smallest,

		tx, ty, tz,
		i, u, v;


	// expose internals
	this.tangents = tangents;
	this.normals = normals;
	this.binormals = binormals;

	// compute the tangent vectors for each segment on the path

	for ( i = 0; i < numpoints; i++ ) {

		u = i / ( numpoints - 1 );

		tangents[ i ] = path.getTangentAt( u );
		tangents[ i ].normalize();

	}

	initialNormal3();

	function initialNormal1(lastBinormal) {
		// fixed start binormal. Has dangers of 0 vectors
		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		if (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );
		normals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();
	}

	function initialNormal2() {

		// This uses the Frenet-Serret formula for deriving binormal
		var t2 = path.getTangentAt( epsilon );

		normals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();
		binormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );

		normals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();

	}

	function initialNormal3() {
		// select an initial normal vector perpenicular to the first tangent vector,
		// and in the direction of the smallest tangent xyz component

		normals[ 0 ] = new THREE.Vector3();
		binormals[ 0 ] = new THREE.Vector3();
		smallest = Number.MAX_VALUE;
		tx = Math.abs( tangents[ 0 ].x );
		ty = Math.abs( tangents[ 0 ].y );
		tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= smallest ) {
			smallest = tx;
			normal.set( 1, 0, 0 );
		}

		if ( ty <= smallest ) {
			smallest = ty;
			normal.set( 0, 1, 0 );
		}

		if ( tz <= smallest ) {
			normal.set( 0, 0, 1 );
		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	}


	// compute the slowly-varying normal and binormal vectors for each segment on the path

	for ( i = 1; i < numpoints; i++ ) {

		normals[ i ] = normals[ i-1 ].clone();

		binormals[ i ] = binormals[ i-1 ].clone();

		vec.crossVectors( tangents[ i-1 ], tangents[ i ] );

		if ( vec.length() > epsilon ) {

			vec.normalize();

			theta = Math.acos( THREE.Math.clamp( tangents[ i-1 ].dot( tangents[ i ] ), -1, 1 ) ); // clamp for floating pt errors

			normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

		}

		binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

	}


	// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

	if ( closed ) {

		theta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints-1 ] ), -1, 1 ) );
		theta /= ( numpoints - 1 );

		if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints-1 ] ) ) > 0 ) {

			theta = -theta;

		}

		for ( i = 1; i < numpoints; i++ ) {

			// twist a little...
			normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

	}
};

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.PolyhedronGeometry = function ( vertices, faces, radius, detail ) {

	THREE.Geometry.call( this );

	radius = radius || 1;
	detail = detail || 0;

	var that = this;

	for ( var i = 0, l = vertices.length; i < l; i ++ ) {

		prepare( new THREE.Vector3( vertices[ i ][ 0 ], vertices[ i ][ 1 ], vertices[ i ][ 2 ] ) );

	}

	var midpoints = [], p = this.vertices;

	var f = [];
	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var v1 = p[ faces[ i ][ 0 ] ];
		var v2 = p[ faces[ i ][ 1 ] ];
		var v3 = p[ faces[ i ][ 2 ] ];

		f[ i ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );

	}

	for ( var i = 0, l = f.length; i < l; i ++ ) {

		subdivide(f[ i ], detail);

	}


	// Handle case when face straddles the seam

	for ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {

		var uvs = this.faceVertexUvs[ 0 ][ i ];

		var x0 = uvs[ 0 ].x;
		var x1 = uvs[ 1 ].x;
		var x2 = uvs[ 2 ].x;

		var max = Math.max( x0, Math.max( x1, x2 ) );
		var min = Math.min( x0, Math.min( x1, x2 ) );

		if ( max > 0.9 && min < 0.1 ) { // 0.9 is somewhat arbitrary

			if ( x0 < 0.2 ) uvs[ 0 ].x += 1;
			if ( x1 < 0.2 ) uvs[ 1 ].x += 1;
			if ( x2 < 0.2 ) uvs[ 2 ].x += 1;

		}

	}


	// Apply radius

	for ( var i = 0, l = this.vertices.length; i < l; i ++ ) {

		this.vertices[ i ].multiplyScalar( radius );

	}


	// Merge vertices

	this.mergeVertices();

	this.computeCentroids();

	this.computeFaceNormals();

	this.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );


	// Project vector onto sphere's surface

	function prepare( vector ) {

		var vertex = vector.normalize().clone();
		vertex.index = that.vertices.push( vertex ) - 1;

		// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.

		var u = azimuth( vector ) / 2 / Math.PI + 0.5;
		var v = inclination( vector ) / Math.PI + 0.5;
		vertex.uv = new THREE.Vector2( u, 1 - v );

		return vertex;

	}


	// Approximate a curved face with recursively sub-divided triangles.

	function make( v1, v2, v3 ) {

		var face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ] );
		face.centroid.add( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );
		that.faces.push( face );

		var azi = azimuth( face.centroid );

		that.faceVertexUvs[ 0 ].push( [
			correctUV( v1.uv, v1, azi ),
			correctUV( v2.uv, v2, azi ),
			correctUV( v3.uv, v3, azi )
		] );

	}


	// Analytically subdivide a face to the required detail level.

	function subdivide(face, detail ) {

		var cols = Math.pow(2, detail);
		var cells = Math.pow(4, detail);
		var a = prepare( that.vertices[ face.a ] );
		var b = prepare( that.vertices[ face.b ] );
		var c = prepare( that.vertices[ face.c ] );
		var v = [];

		// Construct all of the vertices for this subdivision.

		for ( var i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = prepare( a.clone().lerp( c, i / cols ) );
			var bj = prepare( b.clone().lerp( c, i / cols ) );
			var rows = cols - i;

			for ( var j = 0; j <= rows; j ++) {

				if ( j == 0 && i == cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );

				}

			}

		}

		// Construct all of the faces.

		for ( var i = 0; i < cols ; i ++ ) {

			for ( var j = 0; j < 2 * (cols - i) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 == 0 ) {

					make(
						v[ i ][ k + 1],
						v[ i + 1 ][ k ],
						v[ i ][ k ]
					);

				} else {

					make(
						v[ i ][ k + 1 ],
						v[ i + 1][ k + 1],
						v[ i + 1 ][ k ]
					);

				}

			}

		}

	}


	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, -vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( -vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}


	// Texture fixing helper. Spheres have some odd behaviours.

	function correctUV( uv, vector, azimuth ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );
		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );
		return uv.clone();

	}


};

THREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.IcosahedronGeometry = function ( radius, detail ) {

	this.radius = radius;
	this.detail = detail;

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		[ -1,  t,  0 ], [  1, t, 0 ], [ -1, -t,  0 ], [  1, -t,  0 ],
		[  0, -1,  t ], [  0, 1, t ], [  0, -1, -t ], [  0,  1, -t ],
		[  t,  0, -1 ], [  t, 0, 1 ], [ -t,  0, -1 ], [ -t,  0,  1 ]
	];

	var faces = [
		[ 0, 11,  5 ], [ 0,  5,  1 ], [  0,  1,  7 ], [  0,  7, 10 ], [  0, 10, 11 ],
		[ 1,  5,  9 ], [ 5, 11,  4 ], [ 11, 10,  2 ], [ 10,  7,  6 ], [  7,  1,  8 ],
		[ 3,  9,  4 ], [ 3,  4,  2 ], [  3,  2,  6 ], [  3,  6,  8 ], [  3,  8,  9 ],
		[ 4,  9,  5 ], [ 2,  4, 11 ], [  6,  2, 10 ], [  8,  6,  7 ], [  9,  8,  1 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );

};

THREE.IcosahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.OctahedronGeometry = function ( radius, detail ) {

	var vertices = [
		[ 1, 0, 0 ], [ -1, 0, 0 ], [ 0, 1, 0 ], [ 0, -1, 0 ], [ 0, 0, 1 ], [ 0, 0, -1 ]
	];

	var faces = [
		[ 0, 2, 4 ], [ 0, 4, 3 ], [ 0, 3, 5 ], [ 0, 5, 2 ], [ 1, 2, 5 ], [ 1, 5, 3 ], [ 1, 3, 4 ], [ 1, 4, 2 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );
};

THREE.OctahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author timothypratley / https://github.com/timothypratley
 */

THREE.TetrahedronGeometry = function ( radius, detail ) {

	var vertices = [
		[ 1,  1,  1 ], [ -1, -1, 1 ], [ -1, 1, -1 ], [ 1, -1, -1 ]
	];

	var faces = [
		[ 2, 1, 0 ], [ 0, 3, 2 ], [ 1, 3, 0 ], [ 2, 3, 1 ]
	];

	THREE.PolyhedronGeometry.call( this, vertices, faces, radius, detail );

};

THREE.TetrahedronGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author zz85 / https://github.com/zz85
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 *
 * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );
 *
 */

THREE.ParametricGeometry = function ( func, slices, stacks ) {

	THREE.Geometry.call( this );

	var verts = this.vertices;
	var faces = this.faces;
	var uvs = this.faceVertexUvs[ 0 ];

	var i, il, j, p;
	var u, v;

	var stackCount = stacks + 1;
	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			verts.push( p );

		}
	}

	var a, b, c, d;
	var uva, uvb, uvc, uvd;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = (i + 1) * sliceCount + j + 1;
			d = (i + 1) * sliceCount + j;

			uva = new THREE.Vector2( j / slices, i / stacks );
			uvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );
			uvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );
			uvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );

			faces.push( new THREE.Face3( a, b, d ) );
			uvs.push( [ uva, uvb, uvd ] );

			faces.push( new THREE.Face3( b, c, d ) );
			uvs.push( [ uvb.clone(), uvc, uvd.clone() ] );

		}

	}

	// console.log(this);

	// magic bullet
	// var diff = this.mergeVertices();
	// console.log('removed ', diff, ' vertices by merging');

	this.computeCentroids();
	this.computeFaceNormals();
	this.computeVertexNormals();

};

THREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.AxisHelper = function ( size ) {

	size = size || 1;

	var geometry = new THREE.Geometry();

	geometry.vertices.push(
		new THREE.Vector3(), new THREE.Vector3( size, 0, 0 ),
		new THREE.Vector3(), new THREE.Vector3( 0, size, 0 ),
		new THREE.Vector3(), new THREE.Vector3( 0, 0, size )
	);

	geometry.colors.push(
		new THREE.Color( 0xff0000 ), new THREE.Color( 0xffaa00 ),
		new THREE.Color( 0x00ff00 ), new THREE.Color( 0xaaff00 ),
		new THREE.Color( 0x0000ff ), new THREE.Color( 0x00aaff )
	);

	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.AxisHelper.prototype = Object.create( THREE.Line.prototype );

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://exocortex.com
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  hex - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

THREE.ArrowHelper = function ( dir, origin, length, hex, headLength, headWidth ) {

	// dir is assumed to be normalized

	THREE.Object3D.call( this );

	if ( hex === undefined ) hex = 0xffff00;
	if ( length === undefined ) length = 1;
	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.position = origin;

	var lineGeometry = new THREE.Geometry();
	lineGeometry.vertices.push( new THREE.Vector3( 0, 0, 0 ) );
	lineGeometry.vertices.push( new THREE.Vector3( 0, 1, 0 ) );

	this.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: hex } ) );
	this.line.matrixAutoUpdate = false;
	this.add( this.line );

	var coneGeometry = new THREE.CylinderGeometry( 0, 0.5, 1, 5, 1 );
	coneGeometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, - 0.5, 0 ) );

	this.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: hex } ) );
	this.cone.matrixAutoUpdate = false;
	this.add( this.cone );

	this.setDirection( dir );
	this.setLength( length, headLength, headWidth );

};

THREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.ArrowHelper.prototype.setDirection = function () {

	var axis = new THREE.Vector3();
	var radians;

	return function ( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}();

THREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, length, 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

THREE.ArrowHelper.prototype.setColor = function ( hex ) {

	this.line.material.color.setHex( hex );
	this.cone.material.color.setHex( hex );

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.BoxHelper = function ( object ) {

	//   5____4
	// 1/___0/|
	// | 6__|_7
	// 2/___3/

	var vertices = [
		new THREE.Vector3(   1,   1,   1 ),
		new THREE.Vector3( - 1,   1,   1 ),
		new THREE.Vector3( - 1, - 1,   1 ),
		new THREE.Vector3(   1, - 1,   1 ),

		new THREE.Vector3(   1,   1, - 1 ),
		new THREE.Vector3( - 1,   1, - 1 ),
		new THREE.Vector3( - 1, - 1, - 1 ),
		new THREE.Vector3(   1, - 1, - 1 )
	];

	this.vertices = vertices;

	// TODO: Wouldn't be nice if Line had .segments?

	var geometry = new THREE.Geometry();
	geometry.vertices.push(
		vertices[ 0 ], vertices[ 1 ],
		vertices[ 1 ], vertices[ 2 ],
		vertices[ 2 ], vertices[ 3 ],
		vertices[ 3 ], vertices[ 0 ],

		vertices[ 4 ], vertices[ 5 ],
		vertices[ 5 ], vertices[ 6 ],
		vertices[ 6 ], vertices[ 7 ],
		vertices[ 7 ], vertices[ 4 ],

		vertices[ 0 ], vertices[ 4 ],
		vertices[ 1 ], vertices[ 5 ],
		vertices[ 2 ], vertices[ 6 ],
		vertices[ 3 ], vertices[ 7 ]
	);

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ), THREE.LinePieces );

	if ( object !== undefined ) {

		this.update( object );

	}

};

THREE.BoxHelper.prototype = Object.create( THREE.Line.prototype );

THREE.BoxHelper.prototype.update = function ( object ) {

	var geometry = object.geometry;

	if ( geometry.boundingBox === null ) {

		geometry.computeBoundingBox();

	}

	var min = geometry.boundingBox.min;
	var max = geometry.boundingBox.max;
	var vertices = this.vertices;

	vertices[ 0 ].set( max.x, max.y, max.z );
	vertices[ 1 ].set( min.x, max.y, max.z );
	vertices[ 2 ].set( min.x, min.y, max.z );
	vertices[ 3 ].set( max.x, min.y, max.z );
	vertices[ 4 ].set( max.x, max.y, min.z );
	vertices[ 5 ].set( min.x, max.y, min.z );
	vertices[ 6 ].set( min.x, min.y, min.z );
	vertices[ 7 ].set( max.x, min.y, min.z );

	this.geometry.computeBoundingSphere();
	this.geometry.verticesNeedUpdate = true;

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 */

// a helper to show the world-axis-aligned bounding box for an object

THREE.BoundingBoxHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0x888888;

	this.object = object;

	this.box = new THREE.Box3();

	THREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );

};

THREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.BoundingBoxHelper.prototype.update = function () {

	this.box.setFromObject( this.object );

	this.box.size( this.scale );

	this.box.center( this.position );

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

THREE.CameraHelper = function ( camera ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );

	var pointMap = {};

	// colors

	var hexFrustum = 0xffaa00;
	var hexCone = 0xff0000;
	var hexUp = 0x00aaff;
	var hexTarget = 0xffffff;
	var hexCross = 0x333333;

	// near

	addLine( "n1", "n2", hexFrustum );
	addLine( "n2", "n4", hexFrustum );
	addLine( "n4", "n3", hexFrustum );
	addLine( "n3", "n1", hexFrustum );

	// far

	addLine( "f1", "f2", hexFrustum );
	addLine( "f2", "f4", hexFrustum );
	addLine( "f4", "f3", hexFrustum );
	addLine( "f3", "f1", hexFrustum );

	// sides

	addLine( "n1", "f1", hexFrustum );
	addLine( "n2", "f2", hexFrustum );
	addLine( "n3", "f3", hexFrustum );
	addLine( "n4", "f4", hexFrustum );

	// cone

	addLine( "p", "n1", hexCone );
	addLine( "p", "n2", hexCone );
	addLine( "p", "n3", hexCone );
	addLine( "p", "n4", hexCone );

	// up

	addLine( "u1", "u2", hexUp );
	addLine( "u2", "u3", hexUp );
	addLine( "u3", "u1", hexUp );

	// target

	addLine( "c", "t", hexTarget );
	addLine( "p", "c", hexCross );

	// cross

	addLine( "cn1", "cn2", hexCross );
	addLine( "cn3", "cn4", hexCross );

	addLine( "cf1", "cf2", hexCross );
	addLine( "cf3", "cf4", hexCross );

	function addLine( a, b, hex ) {

		addPoint( a, hex );
		addPoint( b, hex );

	}

	function addPoint( id, hex ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.colors.push( new THREE.Color( hex ) );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( geometry.vertices.length - 1 );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

	this.camera = camera;
	this.matrixWorld = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

};

THREE.CameraHelper.prototype = Object.create( THREE.Line.prototype );

THREE.CameraHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var camera = new THREE.Camera();
	var projector = new THREE.Projector();

	return function () {

		var scope = this;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, -1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", -w, -h, -1 );
		setPoint( "n2",  w, -h, -1 );
		setPoint( "n3", -w,  h, -1 );
		setPoint( "n4",  w,  h, -1 );

		// far

		setPoint( "f1", -w, -h, 1 );
		setPoint( "f2",  w, -h, 1 );
		setPoint( "f3", -w,  h, 1 );
		setPoint( "f4",  w,  h, 1 );

		// up

		setPoint( "u1",  w * 0.7, h * 1.1, -1 );
		setPoint( "u2", -w * 0.7, h * 1.1, -1 );
		setPoint( "u3",        0, h * 2,   -1 );

		// cross

		setPoint( "cf1", -w,  0, 1 );
		setPoint( "cf2",  w,  0, 1 );
		setPoint( "cf3",  0, -h, 1 );
		setPoint( "cf4",  0,  h, 1 );

		setPoint( "cn1", -w,  0, -1 );
		setPoint( "cn2",  w,  0, -1 );
		setPoint( "cn3",  0, -h, -1 );
		setPoint( "cn4",  0,  h, -1 );

		function setPoint( point, x, y, z ) {

			vector.set( x, y, z );
			projector.unprojectVector( vector, camera );

			var points = scope.pointMap[ point ];

			if ( points !== undefined ) {

				for ( var i = 0, il = points.length; i < il; i ++ ) {

					scope.geometry.vertices[ points[ i ] ].copy( vector );

				}

			}

		}

		this.geometry.verticesNeedUpdate = true;

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.DirectionalLightHelper = function ( light, size ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	size = size || 1;
	var geometry = new THREE.PlaneGeometry( size, size );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.lightPlane = new THREE.Mesh( geometry, material );
	this.add( this.lightPlane );

	geometry = new THREE.Geometry();
	geometry.vertices.push( new THREE.Vector3() );
	geometry.vertices.push( new THREE.Vector3() );

	material = new THREE.LineBasicMaterial( { fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	this.targetLine = new THREE.Line( geometry, material );
	this.add( this.targetLine );

	this.update();

};

THREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.DirectionalLightHelper.prototype.dispose = function () {
	
	this.lightPlane.geometry.dispose();
	this.lightPlane.material.dispose();
	this.targetLine.geometry.dispose();
	this.targetLine.material.dispose();
};

THREE.DirectionalLightHelper.prototype.update = function () {

	var v1 = new THREE.Vector3();
	var v2 = new THREE.Vector3();
	var v3 = new THREE.Vector3();

	return function () {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		this.lightPlane.lookAt( v3 );
		this.lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		this.targetLine.geometry.vertices[ 1 ].copy( v3 );
		this.targetLine.geometry.verticesNeedUpdate = true;
		this.targetLine.material.color.copy( this.lightPlane.material.color );

	}

}();


/**
 * @author WestLangley / http://github.com/WestLangley
 */

THREE.EdgesHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	var geometry2 = object.geometry.clone();

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;
	var numEdges = 0;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };
				numEdges ++;

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

	var coords = geometry.attributes.position.array;

	var index = 0;

	for ( var key in hash ) {

		var h = hash[ key ];

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) < 0.9999 ) { // hardwired const OK

			var vertex = vertices[ h.vert1 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

			vertex = vertices[ h.vert2 ];
			coords[ index ++ ] = vertex.x;
			coords[ index ++ ] = vertex.y;
			coords[ index ++ ] = vertex.z;

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

THREE.EdgesHelper.prototype = Object.create( THREE.Line.prototype );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var faces = this.object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		geometry.vertices.push( new THREE.Vector3() );
		geometry.vertices.push( new THREE.Vector3() );

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.FaceNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.FaceNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function ( object ) {

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			v1.copy( face.normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

			var idx = 2 * i;

			vertices[ idx ].copy( face.centroid ).applyMatrix4( worldMatrix );

			vertices[ idx + 1 ].addVectors( vertices[ idx ], v1 );

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());


/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.GridHelper = function ( size, step ) {

	var geometry = new THREE.Geometry();
	var material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

	this.color1 = new THREE.Color( 0x444444 );
	this.color2 = new THREE.Color( 0x888888 );

	for ( var i = - size; i <= size; i += step ) {

		geometry.vertices.push(
			new THREE.Vector3( - size, 0, i ), new THREE.Vector3( size, 0, i ),
			new THREE.Vector3( i, 0, - size ), new THREE.Vector3( i, 0, size )
		);

		var color = i === 0 ? this.color1 : this.color2;

		geometry.colors.push( color, color, color, color );

	}

	THREE.Line.call( this, geometry, material, THREE.LinePieces );

};

THREE.GridHelper.prototype = Object.create( THREE.Line.prototype );

THREE.GridHelper.prototype.setColors = function( colorCenterLine, colorGrid ) {

	this.color1.set( colorCenterLine );
	this.color2.set( colorGrid );

	this.geometry.colorsNeedUpdate = true;

}

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.HemisphereLightHelper = function ( light, sphereSize, arrowLength, domeSize ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	this.colors = [ new THREE.Color(), new THREE.Color() ];

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	for ( var i = 0, il = 8; i < il; i ++ ) {

		geometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];

	}

	var material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );

	this.lightSphere = new THREE.Mesh( geometry, material );
	this.add( this.lightSphere );

	this.update();

};

THREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.HemisphereLightHelper.prototype.dispose = function () {
	this.lightSphere.geometry.dispose();
	this.lightSphere.material.dispose();
};

THREE.HemisphereLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();

	return function () {

		this.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );
		this.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		this.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
		this.lightSphere.geometry.colorsNeedUpdate = true;

	}

}();


/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

THREE.PointLightHelper = function ( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );
	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	THREE.Mesh.call( this, geometry, material );

	this.matrixWorld = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

};

THREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );

THREE.PointLightHelper.prototype.dispose = function () {
	
	this.geometry.dispose();
	this.material.dispose();
};

THREE.PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};


/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.SpotLightHelper = function ( light ) {

	THREE.Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrixWorld = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new THREE.CylinderGeometry( 0, 1, 1, 8, 1, true );

	geometry.applyMatrix( new THREE.Matrix4().makeTranslation( 0, -0.5, 0 ) );
	geometry.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

	var material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );
	
	this.cone = new THREE.Mesh( geometry, material );
	this.add( this.cone );

	this.update();

};

THREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );

THREE.SpotLightHelper.prototype.dispose = function () {
	this.cone.geometry.dispose();
	this.cone.material.dispose();
};

THREE.SpotLightHelper.prototype.update = function () {

	var vector = new THREE.Vector3();
	var vector2 = new THREE.Vector3();

	return function () {

		var coneLength = this.light.distance ? this.light.distance : 10000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.normalMatrix = new THREE.Matrix3();

	this.update();

};

THREE.VertexNormalsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexNormalsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		this.normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var normal = face.vertexNormals[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( normal ).applyMatrix3( this.normalMatrix ).normalize().multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

THREE.VertexTangentsHelper = function ( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0x0000ff;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	var geometry = new THREE.Geometry();

	var vertices = object.geometry.vertices;

	var faces = object.geometry.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

			geometry.vertices.push( new THREE.Vector3() );
			geometry.vertices.push( new THREE.Vector3() );

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;

	this.update();

};

THREE.VertexTangentsHelper.prototype = Object.create( THREE.Line.prototype );

THREE.VertexTangentsHelper.prototype.update = ( function ( object ) {

	var v1 = new THREE.Vector3();

	return function( object ) {

		var keys = [ 'a', 'b', 'c', 'd' ];

		this.object.updateMatrixWorld( true );

		var vertices = this.geometry.vertices;

		var verts = this.object.geometry.vertices;

		var faces = this.object.geometry.faces;

		var worldMatrix = this.object.matrixWorld;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0, jl = face.vertexTangents.length; j < jl; j ++ ) {

				var vertexId = face[ keys[ j ] ];
				var vertex = verts[ vertexId ];

				var tangent = face.vertexTangents[ j ];

				vertices[ idx ].copy( vertex ).applyMatrix4( worldMatrix );

				v1.copy( tangent ).transformDirection( worldMatrix ).multiplyScalar( this.size );

				v1.add( vertices[ idx ] );
				idx = idx + 1;

				vertices[ idx ].copy( v1 );
				idx = idx + 1;

			}

		}

		this.geometry.verticesNeedUpdate = true;

		return this;

	}

}());

/**
 * @author mrdoob / http://mrdoob.com/
 */

THREE.WireframeHelper = function ( object, hex ) {

	var color = ( hex !== undefined ) ? hex : 0xffffff;

	var edge = [ 0, 0 ], hash = {};
	var sortFunction = function ( a, b ) { return a - b };

	var keys = [ 'a', 'b', 'c' ];
	var geometry = new THREE.BufferGeometry();

	if ( object.geometry instanceof THREE.Geometry ) {

		var vertices = object.geometry.vertices;
		var faces = object.geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

		var coords = geometry.attributes.position.array;

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

	} else if ( object.geometry instanceof THREE.BufferGeometry && object.geometry.attributes.index !== undefined ) { // indexed BufferGeometry

		var vertices = object.geometry.attributes.position.array;
		var indices = object.geometry.attributes.index.array;
		var offsets = object.geometry.offsets;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 2 * indices.length );

		for ( var o = 0, ol = offsets.length; o < ol; ++ o ) {

			var start = offsets[ o ].start;
			var count = offsets[ o ].count;
			var index = offsets[ o ].index;

			for ( var i = start, il = start + count; i < il; i += 3 ) {

				for ( var j = 0; j < 3; j ++ ) {

					edge[ 0 ] = index + indices[ i + j ];
					edge[ 1 ] = index + indices[ i + ( j + 1 ) % 3 ];
					edge.sort( sortFunction );

					var key = edge.toString();

					if ( hash[ key ] === undefined ) {

						edges[ 2 * numEdges ] = edge[ 0 ];
						edges[ 2 * numEdges + 1 ] = edge[ 1 ];
						hash[ key ] = true;
						numEdges ++;

					}

				}

			}

		}

		geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

		var coords = geometry.attributes.position.array;

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var index = 6 * i + 3 * j;
				var index2 = 3 * edges[ 2 * i + j];
				coords[ index + 0 ] = vertices[ index2 ];
				coords[ index + 1 ] = vertices[ index2 + 1 ];
				coords[ index + 2 ] = vertices[ index2 + 2 ];

			}

		}

	} else if ( object.geometry instanceof THREE.BufferGeometry	) { // non-indexed BufferGeometry

		var vertices = object.geometry.attributes.position.array;
		var numEdges = vertices.length / 3;
		var numTris = numEdges / 3;

		geometry.addAttribute( 'position', Float32Array, 2 * numEdges, 3 );

		var coords = geometry.attributes.position.array;

		for ( var i = 0, l = numTris; i < l; i ++ ) {

			for ( var j = 0; j < 3; j ++ ) {

				var index = 18 * i + 6 * j;

				var index1 = 9 * i + 3 * j;
				coords[ index + 0 ] = vertices[ index1 ];
				coords[ index + 1 ] = vertices[ index1 + 1 ];
				coords[ index + 2 ] = vertices[ index1 + 2 ];

				var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
				coords[ index + 3 ] = vertices[ index2 ];
				coords[ index + 4 ] = vertices[ index2 + 1 ];
				coords[ index + 5 ] = vertices[ index2 + 2 ];

			}

		}

	}

	THREE.Line.call( this, geometry, new THREE.LineBasicMaterial( { color: color } ), THREE.LinePieces );

	this.matrixAutoUpdate = false;
	this.matrixWorld = object.matrixWorld;

};

THREE.WireframeHelper.prototype = Object.create( THREE.Line.prototype );

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ImmediateRenderObject = function () {

	THREE.Object3D.call( this );

	this.render = function ( renderCallback ) { };

};

THREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlare = function ( texture, size, distance, blending, color ) {

	THREE.Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new THREE.Vector3();
	this.customUpdateCallback = undefined;

	if( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

};

THREE.LensFlare.prototype = Object.create( THREE.Object3D.prototype );


/*
 * Add: adds another flare
 */

THREE.LensFlare.prototype.add = function ( texture, size, distance, blending, color, opacity ) {

	if( size === undefined ) size = -1;
	if( distance === undefined ) distance = 0;
	if( opacity === undefined ) opacity = 1;
	if( color === undefined ) color = new THREE.Color( 0xffffff );
	if( blending === undefined ) blending = THREE.NormalBlending;

	distance = Math.min( distance, Math.max( 0, distance ) );

	this.lensFlares.push( { texture: texture, 			// THREE.Texture
		                    size: size, 				// size in pixels (-1 = use texture.width)
		                    distance: distance, 		// distance (0-1) from light source (0=at light source)
		                    x: 0, y: 0, z: 0,			// screen position (-1 => 1) z = 0 is ontop z = 1 is back
		                    scale: 1, 					// scale
		                    rotation: 1, 				// rotation
		                    opacity: opacity,			// opacity
							color: color,				// color
		                    blending: blending } );		// blending

};


/*
 * Update lens flares update positions on all flares based on the screen position
 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
 */

THREE.LensFlare.prototype.updateLensFlares = function () {

	var f, fl = this.lensFlares.length;
	var flare;
	var vecX = -this.positionScreen.x * 2;
	var vecY = -this.positionScreen.y * 2;

	for( f = 0; f < fl; f ++ ) {

		flare = this.lensFlares[ f ];

		flare.x = this.positionScreen.x + vecX * flare.distance;
		flare.y = this.positionScreen.y + vecY * flare.distance;

		flare.wantedRotation = flare.x * Math.PI * 0.25;
		flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

	}

};













/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.MorphBlendMesh = function( geometry, material ) {

	THREE.Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

};

THREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );

THREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		startFrame: start,
		endFrame: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

THREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)(\d+)/;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];
			var num = chunks[ 2 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: -Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = -1;
		animation.directionBackwards = true;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

THREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

THREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

THREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = -1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

THREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "animation[" + name + "] undefined" );

	}

};

THREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

THREE.MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= -1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.startFrame + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
		this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

	}

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.LensFlarePlugin = function () {

	var _gl, _renderer, _precision, _lensFlare = {};

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		_precision = renderer.getPrecision();

		_lensFlare.vertices = new Float32Array( 8 + 8 );
		_lensFlare.faces = new Uint16Array( 6 );

		var i = 0;
		_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = -1;	// vertex
		_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 0;	// uv... etc.

		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = -1;
		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 0;

		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;
		_lensFlare.vertices[ i++ ] = 1;  _lensFlare.vertices[ i++ ] = 1;

		_lensFlare.vertices[ i++ ] = -1; _lensFlare.vertices[ i++ ] = 1;
		_lensFlare.vertices[ i++ ] = 0;  _lensFlare.vertices[ i++ ] = 1;

		i = 0;
		_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 1; _lensFlare.faces[ i++ ] = 2;
		_lensFlare.faces[ i++ ] = 0; _lensFlare.faces[ i++ ] = 2; _lensFlare.faces[ i++ ] = 3;

		// buffers

		_lensFlare.vertexBuffer     = _gl.createBuffer();
		_lensFlare.elementBuffer    = _gl.createBuffer();

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
		_gl.bufferData( _gl.ARRAY_BUFFER, _lensFlare.vertices, _gl.STATIC_DRAW );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );
		_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.faces, _gl.STATIC_DRAW );

		// textures

		_lensFlare.tempTexture      = _gl.createTexture();
		_lensFlare.occlusionTexture = _gl.createTexture();

		_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
		_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, 16, 16, 0, _gl.RGB, _gl.UNSIGNED_BYTE, null );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );

		_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
		_gl.texImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, 16, 16, 0, _gl.RGBA, _gl.UNSIGNED_BYTE, null );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MAG_FILTER, _gl.NEAREST );
		_gl.texParameteri( _gl.TEXTURE_2D, _gl.TEXTURE_MIN_FILTER, _gl.NEAREST );

		if ( _gl.getParameter( _gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS ) <= 0 ) {

			_lensFlare.hasVertexTexture = false;
			_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlare" ], _precision );

		} else {

			_lensFlare.hasVertexTexture = true;
			_lensFlare.program = createProgram( THREE.ShaderFlares[ "lensFlareVertexTexture" ], _precision );

		}

		_lensFlare.attributes = {};
		_lensFlare.uniforms = {};

		_lensFlare.attributes.vertex       = _gl.getAttribLocation ( _lensFlare.program, "position" );
		_lensFlare.attributes.uv           = _gl.getAttribLocation ( _lensFlare.program, "uv" );

		_lensFlare.uniforms.renderType     = _gl.getUniformLocation( _lensFlare.program, "renderType" );
		_lensFlare.uniforms.map            = _gl.getUniformLocation( _lensFlare.program, "map" );
		_lensFlare.uniforms.occlusionMap   = _gl.getUniformLocation( _lensFlare.program, "occlusionMap" );
		_lensFlare.uniforms.opacity        = _gl.getUniformLocation( _lensFlare.program, "opacity" );
		_lensFlare.uniforms.color          = _gl.getUniformLocation( _lensFlare.program, "color" );
		_lensFlare.uniforms.scale          = _gl.getUniformLocation( _lensFlare.program, "scale" );
		_lensFlare.uniforms.rotation       = _gl.getUniformLocation( _lensFlare.program, "rotation" );
		_lensFlare.uniforms.screenPosition = _gl.getUniformLocation( _lensFlare.program, "screenPosition" );

	};


	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 *         Then _lensFlare.update_lensFlares() is called to re-position and
	 *         update transparency of flares. Then they are rendered.
	 *
	 */

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		var flares = scene.__webglFlares,
			nFlares = flares.length;

		if ( ! nFlares ) return;

		var tempPosition = new THREE.Vector3();

		var invAspect = viewportHeight / viewportWidth,
			halfViewportWidth = viewportWidth * 0.5,
			halfViewportHeight = viewportHeight * 0.5;

		var size = 16 / viewportHeight,
			scale = new THREE.Vector2( size * invAspect, size );

		var screenPosition = new THREE.Vector3( 1, 1, 0 ),
			screenPositionPixels = new THREE.Vector2( 1, 1 );

		var uniforms = _lensFlare.uniforms,
			attributes = _lensFlare.attributes;

		// set _lensFlare program and reset blending

		_gl.useProgram( _lensFlare.program );

		_gl.enableVertexAttribArray( _lensFlare.attributes.vertex );
		_gl.enableVertexAttribArray( _lensFlare.attributes.uv );

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/unforms

		_gl.uniform1i( uniforms.occlusionMap, 0 );
		_gl.uniform1i( uniforms.map, 1 );

		_gl.bindBuffer( _gl.ARRAY_BUFFER, _lensFlare.vertexBuffer );
		_gl.vertexAttribPointer( attributes.vertex, 2, _gl.FLOAT, false, 2 * 8, 0 );
		_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, _lensFlare.elementBuffer );

		_gl.disable( _gl.CULL_FACE );
		_gl.depthMask( false );

		var i, j, jl, flare, sprite;

		for ( i = 0; i < nFlares; i ++ ) {

			size = 16 / viewportHeight;
			scale.set( size * invAspect, size );

			// calc object screen position

			flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[12], flare.matrixWorld.elements[13], flare.matrixWorld.elements[14] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition )

			screenPositionPixels.x = screenPosition.x * halfViewportWidth + halfViewportWidth;
			screenPositionPixels.y = screenPosition.y * halfViewportHeight + halfViewportHeight;

			// screen cull

			if ( _lensFlare.hasVertexTexture || (
				screenPositionPixels.x > 0 &&
				screenPositionPixels.x < viewportWidth &&
				screenPositionPixels.y > 0 &&
				screenPositionPixels.y < viewportHeight ) ) {

				// save current RGB to temp texture

				_gl.activeTexture( _gl.TEXTURE1 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
				_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGB, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// render pink quad

				_gl.uniform1i( uniforms.renderType, 0 );
				_gl.uniform2f( uniforms.scale, scale.x, scale.y );
				_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				_gl.disable( _gl.BLEND );
				_gl.enable( _gl.DEPTH_TEST );

				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				_gl.activeTexture( _gl.TEXTURE0 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.occlusionTexture );
				_gl.copyTexImage2D( _gl.TEXTURE_2D, 0, _gl.RGBA, screenPositionPixels.x - 8, screenPositionPixels.y - 8, 16, 16, 0 );


				// restore graphics

				_gl.uniform1i( uniforms.renderType, 1 );
				_gl.disable( _gl.DEPTH_TEST );

				_gl.activeTexture( _gl.TEXTURE1 );
				_gl.bindTexture( _gl.TEXTURE_2D, _lensFlare.tempTexture );
				_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition )

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				_gl.uniform1i( uniforms.renderType, 2 );
				_gl.enable( _gl.BLEND );

				for ( j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewportHeight;

						scale.x = size * invAspect;
						scale.y = size;

						_gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						_gl.uniform2f( uniforms.scale, scale.x, scale.y );
						_gl.uniform1f( uniforms.rotation, sprite.rotation );

						_gl.uniform1f( uniforms.opacity, sprite.opacity );
						_gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						_renderer.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						_renderer.setTexture( sprite.texture, 1 );

						_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		_gl.enable( _gl.CULL_FACE );
		_gl.enable( _gl.DEPTH_TEST );
		_gl.depthMask( true );

	};

	function createProgram ( shader, precision ) {

		var program = _gl.createProgram();

		var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );
		var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );

		var prefix = "precision " + precision + " float;\n";

		_gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		_gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		_gl.compileShader( fragmentShader );
		_gl.compileShader( vertexShader );

		_gl.attachShader( program, fragmentShader );
		_gl.attachShader( program, vertexShader );

		_gl.linkProgram( program );

		return program;

	};

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.ShadowMapPlugin = function () {

	var _gl,
	_renderer,
	_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4(),

	_min = new THREE.Vector3(),
	_max = new THREE.Vector3(),

	_matrixPosition = new THREE.Vector3();

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
		_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
		_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

	};

	this.render = function ( scene, camera ) {

		if ( ! ( _renderer.shadowMapEnabled && _renderer.shadowMapAutoUpdate ) ) return;

		this.update( scene, camera );

	};

	this.update = function ( scene, camera ) {

		var i, il, j, jl, n,

		shadowMap, shadowMatrix, shadowCamera,
		program, buffer, material,
		webglObject, object, light,
		renderList,

		lights = [],
		k = 0,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_gl.enable( _gl.CULL_FACE );
		_gl.frontFace( _gl.CCW );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.FRONT );

		} else {

			_gl.cullFace( _gl.BACK );

		}

		_renderer.setDepthTest( true );

		// preprocess lights
		// 	- skip lights that are not casting shadows
		//	- create virtual lights for cascaded shadow maps

		for ( i = 0, il = scene.__lights.length; i < il; i ++ ) {

			light = scene.__lights[ i ];

			if ( ! light.castShadow ) continue;

			if ( ( light instanceof THREE.DirectionalLight ) && light.shadowCascade ) {

				for ( n = 0; n < light.shadowCascadeCount; n ++ ) {

					var virtualLight;

					if ( ! light.shadowCascadeArray[ n ] ) {

						virtualLight = createVirtualLight( light, n );
						virtualLight.originalCamera = camera;

						var gyro = new THREE.Gyroscope();
						gyro.position = light.shadowCascadeOffset;

						gyro.add( virtualLight );
						gyro.add( virtualLight.target );

						camera.add( gyro );

						light.shadowCascadeArray[ n ] = virtualLight;

						console.log( "Created virtualLight", virtualLight );

					} else {

						virtualLight = light.shadowCascadeArray[ n ];

					}

					updateVirtualLight( light, n );

					lights[ k ] = virtualLight;
					k ++;

				}

			} else {

				lights[ k ] = light;
				k ++;

			}

		}

		// render depth map

		for ( i = 0, il = lights.length; i < il; i ++ ) {

			light = lights[ i ];

			if ( ! light.shadowMap ) {

				var shadowFilter = THREE.LinearFilter;

				if ( _renderer.shadowMapType === THREE.PCFSoftShadowMap ) {

					shadowFilter = THREE.NearestFilter;

				}

				var pars = { minFilter: shadowFilter, magFilter: shadowFilter, format: THREE.RGBAFormat };

				light.shadowMap = new THREE.WebGLRenderTarget( light.shadowMapWidth, light.shadowMapHeight, pars );
				light.shadowMapSize = new THREE.Vector2( light.shadowMapWidth, light.shadowMapHeight );

				light.shadowMatrix = new THREE.Matrix4();

			}

			if ( ! light.shadowCamera ) {

				if ( light instanceof THREE.SpotLight ) {

					light.shadowCamera = new THREE.PerspectiveCamera( light.shadowCameraFov, light.shadowMapWidth / light.shadowMapHeight, light.shadowCameraNear, light.shadowCameraFar );

				} else if ( light instanceof THREE.DirectionalLight ) {

					light.shadowCamera = new THREE.OrthographicCamera( light.shadowCameraLeft, light.shadowCameraRight, light.shadowCameraTop, light.shadowCameraBottom, light.shadowCameraNear, light.shadowCameraFar );

				} else {

					console.error( "Unsupported light type for shadow" );
					continue;

				}

				scene.add( light.shadowCamera );

				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			}

			if ( light.shadowCameraVisible && ! light.cameraHelper ) {

				light.cameraHelper = new THREE.CameraHelper( light.shadowCamera );
				light.shadowCamera.add( light.cameraHelper );

			}

			if ( light.isVirtual && virtualLight.originalCamera == camera ) {

				updateShadowCamera( camera, light );

			}

			shadowMap = light.shadowMap;
			shadowMatrix = light.shadowMatrix;
			shadowCamera = light.shadowCamera;

			shadowCamera.position.setFromMatrixPosition( light.matrixWorld );
			_matrixPosition.setFromMatrixPosition( light.target.matrixWorld );
			shadowCamera.lookAt( _matrixPosition );
			shadowCamera.updateMatrixWorld();

			shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

			if ( light.cameraHelper ) light.cameraHelper.visible = light.shadowCameraVisible;
			if ( light.shadowCameraVisible ) light.cameraHelper.update();

			// compute shadow matrix

			shadowMatrix.set( 0.5, 0.0, 0.0, 0.5,
							  0.0, 0.5, 0.0, 0.5,
							  0.0, 0.0, 0.5, 0.5,
							  0.0, 0.0, 0.0, 1.0 );

			shadowMatrix.multiply( shadowCamera.projectionMatrix );
			shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

			// update camera matrices and frustum

			_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );

			// render shadow map

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// set object matrices & frustum culling

			renderList = scene.__webglObjects;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];
				object = webglObject.object;

				webglObject.render = false;

				if ( object.visible && object.castShadow ) {

					if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

						object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

						webglObject.render = true;

					}

				}

			}

			// render regular objects

			var objectMaterial, useMorphing, useSkinning;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];

				if ( webglObject.render ) {

					object = webglObject.object;
					buffer = webglObject.buffer;

					// culling is overriden globally for all objects
					// while rendering depth map

					// need to deal with MeshFaceMaterial somehow
					// in that case just use the first of material.materials for now
					// (proper solution would require to break objects by materials
					//  similarly to regular rendering and then set corresponding
					//  depth materials per each chunk instead of just once per object)

					objectMaterial = getObjectMaterial( object );

					useMorphing = object.geometry.morphTargets !== undefined && object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
					useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

					if ( object.customDepthMaterial ) {

						material = object.customDepthMaterial;

					} else if ( useSkinning ) {

						material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

					} else if ( useMorphing ) {

						material = _depthMaterialMorph;

					} else {

						material = _depthMaterial;

					}

					if ( buffer instanceof THREE.BufferGeometry ) {

						_renderer.renderBufferDirect( shadowCamera, scene.__lights, fog, material, buffer, object );

					} else {

						_renderer.renderBuffer( shadowCamera, scene.__lights, fog, material, buffer, object );

					}

				}

			}

			// set matrices and render immediate objects

			renderList = scene.__webglObjectsImmediate;

			for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

				webglObject = renderList[ j ];
				object = webglObject.object;

				if ( object.visible && object.castShadow ) {

					object._modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

					_renderer.renderImmediateObject( shadowCamera, scene.__lights, fog, _depthMaterial, object );

				}

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

		if ( _renderer.shadowMapCullFace === THREE.CullFaceFront ) {

			_gl.cullFace( _gl.BACK );

		}

	};

	function createVirtualLight( light, cascade ) {

		var virtualLight = new THREE.DirectionalLight();

		virtualLight.isVirtual = true;

		virtualLight.onlyShadow = true;
		virtualLight.castShadow = true;

		virtualLight.shadowCameraNear = light.shadowCameraNear;
		virtualLight.shadowCameraFar = light.shadowCameraFar;

		virtualLight.shadowCameraLeft = light.shadowCameraLeft;
		virtualLight.shadowCameraRight = light.shadowCameraRight;
		virtualLight.shadowCameraBottom = light.shadowCameraBottom;
		virtualLight.shadowCameraTop = light.shadowCameraTop;

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;

		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];
		virtualLight.shadowMapWidth = light.shadowCascadeWidth[ cascade ];
		virtualLight.shadowMapHeight = light.shadowCascadeHeight[ cascade ];

		virtualLight.pointsWorld = [];
		virtualLight.pointsFrustum = [];

		var pointsWorld = virtualLight.pointsWorld,
			pointsFrustum = virtualLight.pointsFrustum;

		for ( var i = 0; i < 8; i ++ ) {

			pointsWorld[ i ] = new THREE.Vector3();
			pointsFrustum[ i ] = new THREE.Vector3();

		}

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		pointsFrustum[ 0 ].set( -1, -1, nearZ );
		pointsFrustum[ 1 ].set(  1, -1, nearZ );
		pointsFrustum[ 2 ].set( -1,  1, nearZ );
		pointsFrustum[ 3 ].set(  1,  1, nearZ );

		pointsFrustum[ 4 ].set( -1, -1, farZ );
		pointsFrustum[ 5 ].set(  1, -1, farZ );
		pointsFrustum[ 6 ].set( -1,  1, farZ );
		pointsFrustum[ 7 ].set(  1,  1, farZ );

		return virtualLight;

	}

	// Synchronize virtual light with the original light

	function updateVirtualLight( light, cascade ) {

		var virtualLight = light.shadowCascadeArray[ cascade ];

		virtualLight.position.copy( light.position );
		virtualLight.target.position.copy( light.target.position );
		virtualLight.lookAt( virtualLight.target );

		virtualLight.shadowCameraVisible = light.shadowCameraVisible;
		virtualLight.shadowDarkness = light.shadowDarkness;

		virtualLight.shadowBias = light.shadowCascadeBias[ cascade ];

		var nearZ = light.shadowCascadeNearZ[ cascade ];
		var farZ = light.shadowCascadeFarZ[ cascade ];

		var pointsFrustum = virtualLight.pointsFrustum;

		pointsFrustum[ 0 ].z = nearZ;
		pointsFrustum[ 1 ].z = nearZ;
		pointsFrustum[ 2 ].z = nearZ;
		pointsFrustum[ 3 ].z = nearZ;

		pointsFrustum[ 4 ].z = farZ;
		pointsFrustum[ 5 ].z = farZ;
		pointsFrustum[ 6 ].z = farZ;
		pointsFrustum[ 7 ].z = farZ;

	}

	// Fit shadow camera's ortho frustum to camera frustum

	function updateShadowCamera( camera, light ) {

		var shadowCamera = light.shadowCamera,
			pointsFrustum = light.pointsFrustum,
			pointsWorld = light.pointsWorld;

		_min.set( Infinity, Infinity, Infinity );
		_max.set( -Infinity, -Infinity, -Infinity );

		for ( var i = 0; i < 8; i ++ ) {

			var p = pointsWorld[ i ];

			p.copy( pointsFrustum[ i ] );
			THREE.ShadowMapPlugin.__projector.unprojectVector( p, camera );

			p.applyMatrix4( shadowCamera.matrixWorldInverse );

			if ( p.x < _min.x ) _min.x = p.x;
			if ( p.x > _max.x ) _max.x = p.x;

			if ( p.y < _min.y ) _min.y = p.y;
			if ( p.y > _max.y ) _max.y = p.y;

			if ( p.z < _min.z ) _min.z = p.z;
			if ( p.z > _max.z ) _max.z = p.z;

		}

		shadowCamera.left = _min.x;
		shadowCamera.right = _max.x;
		shadowCamera.top = _max.y;
		shadowCamera.bottom = _min.y;

		// can't really fit near/far
		//shadowCamera.near = _min.z;
		//shadowCamera.far = _max.z;

		shadowCamera.updateProjectionMatrix();

	}

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use for shadow maps

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};

THREE.ShadowMapPlugin.__projector = new THREE.Projector();

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

THREE.SpritePlugin = function () {

	var _gl, _renderer, _texture;

	var vertices, faces, vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		vertices = new Float32Array( [
			- 0.5, - 0.5, 0, 0, 
			  0.5, - 0.5, 1, 0,
			  0.5,   0.5, 1, 1,
			- 0.5,   0.5, 0, 1
		] );

		faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = _gl.createBuffer();
		elementBuffer = _gl.createBuffer();

		_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
		_gl.bufferData( _gl.ARRAY_BUFFER, vertices, _gl.STATIC_DRAW );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		_gl.bufferData( _gl.ELEMENT_ARRAY_BUFFER, faces, _gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			_gl.getAttribLocation ( program, 'position' ),
			uv:					_gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			_gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			_gl.getUniformLocation( program, 'uvScale' ),

			rotation:			_gl.getUniformLocation( program, 'rotation' ),
			scale:				_gl.getUniformLocation( program, 'scale' ),

			color:				_gl.getUniformLocation( program, 'color' ),
			map:				_gl.getUniformLocation( program, 'map' ),
			opacity:			_gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	_gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	_gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			_gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			_gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			_gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				_gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			_gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			_gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElement( 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = '#ffffff';
		context.fillRect( 0, 0, canvas.width, canvas.height );

		_texture = new THREE.Texture( canvas );
		_texture.needsUpdate = true;

	};

	this.render = function ( scene, camera, viewportWidth, viewportHeight ) {

		var sprites = scene.__webglSprites,
			nSprites = sprites.length;

		if ( ! nSprites ) return;

		// setup gl

		_gl.useProgram( program );

		_gl.enableVertexAttribArray( attributes.position );
		_gl.enableVertexAttribArray( attributes.uv );

		_gl.disable( _gl.CULL_FACE );
		_gl.enable( _gl.BLEND );

		_gl.bindBuffer( _gl.ARRAY_BUFFER, vertexBuffer );
		_gl.vertexAttribPointer( attributes.position, 2, _gl.FLOAT, false, 2 * 8, 0 );
		_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 2 * 8, 8 );

		_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		_gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		_gl.activeTexture( _gl.TEXTURE0 );
		_gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			_gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog instanceof THREE.Fog ) {

				_gl.uniform1f( uniforms.fogNear, fog.near );
				_gl.uniform1f( uniforms.fogFar, fog.far );

				_gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog instanceof THREE.FogExp2 ) {

				_gl.uniform1f( uniforms.fogDensity, fog.density );

				_gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			_gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		var i, sprite, material, fogType, scale = [];

		for( i = 0; i < nSprites; i ++ ) {

			sprite = sprites[ i ];
			material = sprite.material;

			if ( sprite.visible === false ) continue;

			sprite._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite._modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		for( i = 0; i < nSprites; i ++ ) {

			sprite = sprites[ i ];

			if ( sprite.visible === false ) continue;

			material = sprite.material;

			_gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			_gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite._modelViewMatrix.elements );

			scale[ 0 ] = sprite.scale.x;
			scale[ 1 ] = sprite.scale.y;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			} else {

				fogType = 0;

			}

			if ( oldFogType !== fogType ) {

				_gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				_gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				_gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				_gl.uniform2f( uniforms.uvOffset, 0, 0 );
				_gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			_gl.uniform1f( uniforms.opacity, material.opacity );
			_gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			_gl.uniform1f( uniforms.rotation, material.rotation );
			_gl.uniform2fv( uniforms.scale, scale );

			_renderer.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			_renderer.setDepthTest( material.depthTest );
			_renderer.setDepthWrite( material.depthWrite );

			if ( material.map && material.map.image && material.map.image.width ) {

				_renderer.setTexture( material.map, 0 );

			} else {

				_renderer.setTexture( _texture, 0 );

			}

			_gl.drawElements( _gl.TRIANGLES, 6, _gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		_gl.enable( _gl.CULL_FACE );

	};

	function createProgram () {

		var program = _gl.createProgram();

		var vertexShader = _gl.createShader( _gl.VERTEX_SHADER );
		var fragmentShader = _gl.createShader( _gl.FRAGMENT_SHADER );

		_gl.shaderSource( vertexShader, [

			'precision ' + _renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		_gl.shaderSource( fragmentShader, [

			'precision ' + _renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'float fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		_gl.compileShader( vertexShader );
		_gl.compileShader( fragmentShader );

		_gl.attachShader( program, vertexShader );
		_gl.attachShader( program, fragmentShader );

		_gl.linkProgram( program );

		return program;

	};

	function painterSortStable ( a, b ) {

		if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	};

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

THREE.DepthPassPlugin = function () {

	this.enabled = false;
	this.renderTarget = null;

	var _gl,
	_renderer,
	_depthMaterial, _depthMaterialMorph, _depthMaterialSkin, _depthMaterialMorphSkin,

	_frustum = new THREE.Frustum(),
	_projScreenMatrix = new THREE.Matrix4();

	this.init = function ( renderer ) {

		_gl = renderer.context;
		_renderer = renderer;

		var depthShader = THREE.ShaderLib[ "depthRGBA" ];
		var depthUniforms = THREE.UniformsUtils.clone( depthShader.uniforms );

		_depthMaterial = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms } );
		_depthMaterialMorph = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true } );
		_depthMaterialSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, skinning: true } );
		_depthMaterialMorphSkin = new THREE.ShaderMaterial( { fragmentShader: depthShader.fragmentShader, vertexShader: depthShader.vertexShader, uniforms: depthUniforms, morphTargets: true, skinning: true } );

		_depthMaterial._shadowPass = true;
		_depthMaterialMorph._shadowPass = true;
		_depthMaterialSkin._shadowPass = true;
		_depthMaterialMorphSkin._shadowPass = true;

	};

	this.render = function ( scene, camera ) {

		if ( ! this.enabled ) return;

		this.update( scene, camera );

	};

	this.update = function ( scene, camera ) {

		var i, il, j, jl, n,

		program, buffer, material,
		webglObject, object, light,
		renderList,

		fog = null;

		// set GL state for depth map

		_gl.clearColor( 1, 1, 1, 1 );
		_gl.disable( _gl.BLEND );

		_renderer.setDepthTest( true );

		// update scene

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		// render depth map

		_renderer.setRenderTarget( this.renderTarget );
		_renderer.clear();

		// set object matrices & frustum culling

		renderList = scene.__webglObjects;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];
			object = webglObject.object;

			webglObject.render = false;

			if ( object.visible ) {

				if ( ! ( object instanceof THREE.Mesh || object instanceof THREE.ParticleSystem ) || ! ( object.frustumCulled ) || _frustum.intersectsObject( object ) ) {

					object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

					webglObject.render = true;

				}

			}

		}

		// render regular objects

		var objectMaterial, useMorphing, useSkinning;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];

			if ( webglObject.render ) {

				object = webglObject.object;
				buffer = webglObject.buffer;

				// todo: create proper depth material for particles

				if ( object instanceof THREE.ParticleSystem && !object.customDepthMaterial ) continue;

				objectMaterial = getObjectMaterial( object );

				if ( objectMaterial ) _renderer.setMaterialFaces( object.material );

				useMorphing = object.geometry.morphTargets.length > 0 && objectMaterial.morphTargets;
				useSkinning = object instanceof THREE.SkinnedMesh && objectMaterial.skinning;

				if ( object.customDepthMaterial ) {

					material = object.customDepthMaterial;

				} else if ( useSkinning ) {

					material = useMorphing ? _depthMaterialMorphSkin : _depthMaterialSkin;

				} else if ( useMorphing ) {

					material = _depthMaterialMorph;

				} else {

					material = _depthMaterial;

				}

				if ( buffer instanceof THREE.BufferGeometry ) {

					_renderer.renderBufferDirect( camera, scene.__lights, fog, material, buffer, object );

				} else {

					_renderer.renderBuffer( camera, scene.__lights, fog, material, buffer, object );

				}

			}

		}

		// set matrices and render immediate objects

		renderList = scene.__webglObjectsImmediate;

		for ( j = 0, jl = renderList.length; j < jl; j ++ ) {

			webglObject = renderList[ j ];
			object = webglObject.object;

			if ( object.visible ) {

				object._modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );

				_renderer.renderImmediateObject( camera, scene.__lights, fog, _depthMaterial, object );

			}

		}

		// restore GL state

		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();

		_gl.clearColor( clearColor.r, clearColor.g, clearColor.b, clearAlpha );
		_gl.enable( _gl.BLEND );

	};

	// For the moment just ignore objects that have multiple materials with different animation methods
	// Only the first material will be taken into account for deciding which depth material to use

	function getObjectMaterial( object ) {

		return object.material instanceof THREE.MeshFaceMaterial
			? object.material.materials[ 0 ]
			: object.material;

	};

};


/**
 * @author mikael emtinger / http://gomo.se/
 */

THREE.ShaderFlares = {

	'lensFlareVertexTexture': {

		vertexShader: [

			"uniform lowp int renderType;",

			"uniform vec3 screenPosition;",
			"uniform vec2 scale;",
			"uniform float rotation;",

			"uniform sampler2D occlusionMap;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",
			"varying float vVisibility;",

			"void main() {",

				"vUV = uv;",

				"vec2 pos = position;",

				"if( renderType == 2 ) {",

					"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

					"vVisibility =        visibility.r / 9.0;",
					"vVisibility *= 1.0 - visibility.g / 9.0;",
					"vVisibility *=       visibility.b / 9.0;",
					"vVisibility *= 1.0 - visibility.a / 9.0;",

					"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
					"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

				"}",

				"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"uniform lowp int renderType;",

			"uniform sampler2D map;",
			"uniform float opacity;",
			"uniform vec3 color;",

			"varying vec2 vUV;",
			"varying float vVisibility;",

			"void main() {",

				// pink square

				"if( renderType == 0 ) {",

					"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

				// restore

				"} else if( renderType == 1 ) {",

					"gl_FragColor = texture2D( map, vUV );",

				// flare

				"} else {",

					"vec4 texture = texture2D( map, vUV );",
					"texture.a *= opacity * vVisibility;",
					"gl_FragColor = texture;",
					"gl_FragColor.rgb *= color;",

				"}",

			"}"
		].join( "\n" )

	},


	'lensFlare': {

		vertexShader: [

			"uniform lowp int renderType;",

			"uniform vec3 screenPosition;",
			"uniform vec2 scale;",
			"uniform float rotation;",

			"attribute vec2 position;",
			"attribute vec2 uv;",

			"varying vec2 vUV;",

			"void main() {",

				"vUV = uv;",

				"vec2pos = position;",

				"if( renderType == 2 ) {",

					"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
					"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

				"}",

				"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

			"precision mediump float;",

			"uniform lowp int renderType;",

			"uniform sampler2D map;",
			"uniform sampler2D occlusionMap;",
			"uniform float opacity;",
			"uniform vec3 color;",

			"varying vec2 vUV;",

			"void main() {",

				// pink square

				"if( renderType == 0 ) {",

					"gl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );",

				// restore

				"} else if( renderType == 1 ) {",

					"gl_FragColor = texture2D( map, vUV );",

				// flare

				"} else {",

					"float visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;",
					"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;",
					"visibility = ( 1.0 - visibility / 4.0 );",

					"vec4 texture = texture2D( map, vUV );",
					"texture.a *= opacity * visibility;",
					"gl_FragColor = texture;",
					"gl_FragColor.rgb *= color;",

				"}",

			"}"

		].join( "\n" )

	}

};

;var inv255 = .003921569;

function Renderer() {
  // init large buffer geometry
  this.maxVertices = 31000;
  var geometry = new THREE.BufferGeometry();
  geometry.dynamic = true;
  geometry.addAttribute('position', Float32Array, this.maxVertices, 3);
  geometry.addAttribute('color', Float32Array, this.maxVertices, 3);
  this.positions = geometry.attributes.position.array;
  this.colors = geometry.attributes.color.array;
  this.currentVertex = 0;
  this.buffer = new THREE.Line(geometry,
    new THREE.LineBasicMaterial({ vertexColors: true }), THREE.LinePieces);

  this.circleVertices = [];
  this.circleResolution = 5;
  this.initCircleVertices(this.circleVertices, this.circleResolution);

  this.particleVertices = [];
  this.particleResolution = 3;
  this.initCircleVertices(this.particleVertices, this.particleResolution);

  scene.add(this.buffer);
}

Renderer.prototype.collapseBuffer = function() {
  var i = this.currentVertex * 3;
  for (; i < this.maxVertices * 3; i++) {
    this.positions[i] = 0;
    this.colors[i] = 0;
  }
};

Renderer.prototype.draw = function() {
  for (var i = 0, max = world.bodies.length; i < max; i++) {
    var body = world.bodies[i];
    var maxFixtures = body.fixtures.length;
    var transform = body.GetTransform();
    for (var j = 0; j < maxFixtures; j++) {
      var fixture = body.fixtures[j];
      fixture.shape.draw(transform);
    }
  }

  // draw particle systems
  for (var i = 0, max = world.particleSystems.length; i < max; i++) {
    drawParticleSystem(world.particleSystems[i]);
  }
  this.collapseBuffer();

  this.buffer.geometry.attributes.position.needsUpdate = true;
  this.buffer.geometry.attributes.color.needsUpdate = true;
};

Renderer.prototype.insertLine = function(x1, y1, x2, y2, r, g, b) {
  var i = this.currentVertex;
  var threeI = i * 3;
  this.positions[threeI] = x1;
  this.positions[threeI + 1] = y1;
  this.positions[threeI + 2] = 0;
  this.colors[threeI] = r;
  this.colors[threeI + 1] = g;
  this.colors[threeI + 2] = b;

  i++;
  threeI = i * 3;
  this.positions[threeI] = x2;
  this.positions[threeI + 1] = y2;
  this.positions[threeI + 2] = 0;
  this.colors[threeI] = r;
  this.colors[threeI + 1] = g;
  this.colors[threeI + 2] = b;
  this.currentVertex += 2;
};

// TODO remove one of the muls
Renderer.prototype.insertCircleVertices = function(transform, radius, x, y, r, g, b) {
  var vertices = this.circleVertices;
  for (var i = 0; i < this.circleResolution; i++) {
    var i4 = i * 4;
    var v1 = new b2Vec2(vertices[i4] * radius + x, vertices[i4 + 1] * radius + y);
    var v2 = new b2Vec2(vertices[i4 + 2] * radius + x, vertices[i4 + 3] * radius + y);

    b2Vec2.Mul(v1, transform, v1);
    b2Vec2.Mul(v2, transform, v2);

    this.insertLine(v1.x, v1.y, v2.x, v2.y, r, g, b);
  }
};

Renderer.prototype.insertParticleVertices = function(radius, x, y, r, g, b) {
  var vertices = this.particleVertices;
  for (var i = 0; i < this.particleResolution; i++) {
    var i4 = i * 4;
    var x1 = vertices[i4] * radius + x;
    var y1 = vertices[i4 + 1] * radius + y;
    var x2 = vertices[i4 + 2] * radius + x;
    var y2 = vertices[i4 + 3] * radius + y;

    this.insertLine(x1, y1, x2, y2, r, g, b);
  }
};

Renderer.prototype.initCircleVertices = function(v, resolution) {
  var size = 360 / resolution;

  for (var i = 0; i < resolution; i++) {
    var s1 = (i * size) * Math.PI / 180;
    var s2 = ((i + 1) * size) * Math.PI / 180;
    v.push(Math.cos(s1));
    v.push(Math.sin(s1));
    v.push(Math.cos(s2));
    v.push(Math.sin(s2));
  }
};


Renderer.prototype.transformAndInsert = function(v1, v2, transform, r, g, b) {
  var transformedV1 = new b2Vec2(),
    transformedV2 = new b2Vec2();

  b2Vec2.Mul(transformedV1, transform, v1);
  b2Vec2.Mul(transformedV2, transform, v2);
  renderer.insertLine(transformedV1.x, transformedV1.y,
    transformedV2.x, transformedV2.y,
    r, g, b);
};

Renderer.prototype.transformVerticesAndInsert = function(vertices, transform, r, g, b) {
  var vertexCount = vertices.length;

  for (var i = 1; i < vertexCount; i++) {
    renderer.transformAndInsert(vertices[i - 1], vertices[i], transform,
      r, g, b);
  }
};

b2CircleShape.prototype.draw = function(transform) {
  var circlePosition = this.position,
    center = new b2Vec2(circlePosition.x, circlePosition.y);
 // b2Vec2.Mul(center, transform, center);
  renderer.insertCircleVertices(transform, this.radius, center.x, center.y, 0, 0, 0, 5);
};

b2ChainShape.prototype.draw = function(transform) {
  renderer.transformVerticesAndInsert(this.vertices, transform, 0, 0, 0);
};


b2EdgeShape.prototype.draw = function(transform) {
  renderer.transformAndInsert(this.vertex1, this.vertex2, transform, 0, 0, 0);
};

b2PolygonShape.prototype.draw = function(transform) {
  var zPosition = renderer.currentVertex * 3;

  renderer.transformVerticesAndInsert(this.vertices, transform, 0, 0, 0);

  // create a loop
  var positions = renderer.positions;
  var last = (renderer.currentVertex - 1) * 3;
  renderer.insertLine(positions[last], positions[last + 1],
                      positions[zPosition], positions[zPosition + 1],
                      0, 0, 0);
};

function drawParticleSystem(system) {
  var particles = system.GetPositionBuffer();
  var color = system.GetColorBuffer();
  var maxParticles = particles.length,
    transform = new b2Transform();
  transform.SetIdentity();

  for (var i = 0, c = 0; i < maxParticles; i += 2, c += 4) {
    renderer.insertParticleVertices(system.radius, particles[i],
      particles[i + 1], color[c] * inv255, color[c + 1] * inv255, color[c + 2] * inv255, 3);
  }
}
;// Based heavily on the testbed.js code from google
var world = null;
var threeRenderer;
var renderer;
var camera;
var scene;
var timeStep = 1 / 60.0;
var velocityIterations = 8;
var positionIterations = 3;
var demo = {};
var projector = new THREE.Projector();
var planeZ = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);

var windowWidth = window.innerWidth;
var windowHeight = window.innerHeight;

function initDemo() {
  camera = new THREE.PerspectiveCamera(70
    , windowWidth / windowHeight
    , 1, 1000);

  try {
    threeRenderer = new THREE.WebGLRenderer();
  } catch( error ) {
    printErrorMsg('<p>Sorry, your browser does not support WebGL.</p>');
    return;
  }

  threeRenderer.setClearColor(0xEEEEEE);
  threeRenderer.setSize(windowWidth, windowHeight);

  camera.position.x = 0;
  camera.position.y = 0;
  camera.position.z = 100;
  scene = new THREE.Scene();
  camera.lookAt(scene.position);

  document.body.appendChild( this.threeRenderer.domElement);

  renderer = new Renderer();
  var gravity = new b2Vec2(0, 0);
  world = new b2World(gravity);
  demo = new window['BubbleDemo'];

  document.addEventListener('keypress', function(event) {
    // Switch to different type of smasher
    if (demo.KeyPress !== undefined) {
      demo.KeyPress();
    }
  });

  document.addEventListener('mousedown', function (event) {
    // Begin smash
    var p = getMouseCoords(event);
    if (event.button === 0 && demo.MouseDown !== undefined) {
      demo.MouseDown(p);
    }
  });

  document.addEventListener('mouseup', function(event) {
    // End smash
    if (demo.MouseUp !== undefined) {
      demo.MouseUp(getMouseCoords(event));
    }
  });

  render();
}

var render = function() {
  // bring objects into world
  renderer.currentVertex = 0;
  if (demo.Step !== undefined) {
    demo.Step();
  }
  Step();
  renderer.draw();

  threeRenderer.render(scene, camera);
  requestAnimationFrame(render);
};

var Step = function() {
  world.Step(timeStep, velocityIterations, positionIterations);
};

function getMouseCoords(event) {
  var mouse = new THREE.Vector3();
  mouse.x = (event.clientX / windowWidth) * 2 - 1;
  mouse.y = -(event.clientY / windowHeight) * 2 + 1;
  mouse.z = 0.5;

  projector.unprojectVector(mouse, camera);
  var dir = mouse.sub(camera.position).normalize();
  var distance = -camera.position.z / dir.z;
  var pos = camera.position.clone().add(dir.multiplyScalar(distance));
  var p = new b2Vec2(pos.x, pos.y);
  return p;
}
;/**
 * Class to represent burstable bubbles
 */
class Bubble {
  constructor(radius, pos) {
    this.radius = radius;
    this.pos = pos;
    this.broken = false;
    this.zombie = false;
    this.isScheduledForDestroy = false;
    this.particleSize = 0.05;
    this.skinThickness = 0.025;
    this.jointLimit = 1;
    this.dissipationTime = 3000;
    this.lifeSpan = 12000;

    const psd = new b2ParticleSystemDef();
    psd.radius = this.particleSize;
    this.particleSystem = world.CreateParticleSystem(psd);

    this.createContents();
    this.createMembrane();

    // Delete after a set time in case they drift off
    const that = this;
    setTimeout(function() {
      that.scheduleForDestroy();
    }, this.lifeSpan);
  }

  step() {
    if (this.zombie) {
      return;
    }

    this.checkBreak();

    if (this.broken) {
      this.scheduleForDestroy();
    }
  }

  /**
   * Check if any of the joints in this bubble are beyond their strength, if so, break
   */
  checkBreak() {
    if (this.joints) {
      const that = this;
      this.joints.forEach(function(joint) {
        if (joint._eu_broken) {
          return; // already broken, ignore
        }

        let angle = joint.GetJointAngle();
        if (angle > that.jointLimit) {
          that.breakJoint(joint);
          joint._eu_broken = true;
          that.broken = true;
        }
      });
    }
  }

  /* Once a bubble has been broken, it disappears after a given time. */
  scheduleForDestroy() {
    if (!this.isScheduledForDestroy) {
      const that = this;
      setTimeout(function() {
        that.joints.forEach(function(joint) {
          if (!joint._eu_broken) {
            world.DestroyJoint(joint);
          }
        });

        that.bodies.forEach(function(body) {
          world.DestroyBody(body);
        });

        world.DestroyParticleSystem(that.particleSystem);
        that.zombie = true;
      }, this.dissipationTime);
      this.isScheduledForDestroy = true;
    }
  }

  /**
   * Create the liquid contents of this bubble. They are a collection of particles
   * starting in a circle shape, but can separate after break.
   */
  createContents() {
    const circle = new b2CircleShape();
    circle.position.Set(this.pos.x, this.pos.y);
    circle.radius = this.radius * 0.9;
    const pgd = new b2ParticleGroupDef();
    pgd.groupFlags = b2_solidParticleGroup;
    pgd.shape = circle;
    pgd.color.Set(255, 110, 0, 255);
    this.contents = this.particleSystem.CreateParticleGroup(pgd);
  }

  /**
   * Create a series of particles that represent the membrane. They are connected until
   * a certain level of force is applied to their connection, causing a break.
   */
  createMembrane() {
    const stretch = 2.5;
    let count = Math.floor((this.radius * Math.PI * 2)/(this.skinThickness * 2 * stretch));
    const bd = new b2BodyDef();
    const rjoint = new b2RevoluteJointDef();

    const box = new b2PolygonShape();
    box.SetAsBoxXY(this.skinThickness * stretch, this.skinThickness * 1);
    const fd = new b2FixtureDef();
    fd.shape = box;
    fd.density = 20;
    fd.friction = 0.2;

    // The bodies that form the wall
    this.bodies = [];
    for (let i = 0; i < count; i++) {
      const angle = i * Math.PI * 2 / count;
      bd.type = b2_dynamicBody;
      bd.position.Set(this.pos.x + (Math.sin(angle) * this.radius), this.pos.y + (Math.cos(angle) * this.radius));
      bd.angle = -angle;
      const body = world.CreateBody(bd);
      body.CreateFixtureFromDef(fd);
      this.bodies.push(body);
    }

    // The connective tissue between the walls
    this.joints = [];
    for (let i = 0; i < count; i++) {
      const body = this.bodies[i];
      // Get next body, or wrap around to first
      const nextBody = (i + 1) < count ? this.bodies[i + 1] : this.bodies[0];
      const jointAngle = (i + 0.5) * Math.PI * 2 / count;

      const anchor = new b2Vec2(this.pos.x + (Math.sin(jointAngle) * this.radius), this.pos.y + (Math.cos(jointAngle) * this.radius));
      const joint = rjoint.InitializeAndCreate(body, nextBody, anchor);
      this.joints.push(joint);
    }
  }

  /**
   * Triggered when a certain threshold of pressure is applied to membrane joint
   */
  breakJoint(joint) {
    world.DestroyJoint(joint);
  }
}
;const bubbles = [];

function BubbleDemo() {
  camera.position.y = 3;
  camera.position.z = 6;
  const bounds = { minX: -6, maxX: 6, minY: -1, maxY: 7 };

  // Outer bounds
  // const bd = new b2BodyDef;
  // const ground = world.CreateBody(bd);
  // const shape = new b2ChainShape;
  // shape.vertices.push(new b2Vec2(bounds.minX, bounds.minY));
  // shape.vertices.push(new b2Vec2(bounds.maxX, bounds.minY));
  // shape.vertices.push(new b2Vec2(bounds.maxX, bounds.maxY));
  // shape.vertices.push(new b2Vec2(bounds.minX, bounds.maxY));
  // shape.CreateLoop();
  // ground.CreateFixtureFromShape(shape, 0.0);

  // 0 is piercer fingers, 1 is smasher fingers
  this.fingersType = 0;

  this.bubbleSpawner = new BubbleSpawner(bounds);
}

BubbleDemo.prototype.Step = function() {
  const that = this;

  this.bubbleSpawner.step();

  if (this.fingers) {
    this.fingers.step();
  }
};

BubbleDemo.prototype.MouseDown = function(pos) {
  // Create fingers
  this.fingers = new Fingers(pos, this.fingersType);
};

BubbleDemo.prototype.KeyPress = function(pos) {
  // Switch fingers type
  if (this.fingersType === 0) {
    this.fingersType = 1;
  } else {
    this.fingersType = 0;
  }
};

BubbleDemo.prototype.MouseUp = function(coords) {
  // Get rid of fingers
  if (this.fingers) {
    this.fingers.destroy();
    this.fingers = null;
  }
};


;/**
 * Class to spawn bubbles
 */
class BubbleSpawner {
  constructor(bounds) {
    this.bubbles = [];
    this.bounds = bounds;
    this.radiusBounds = { min: 0.15, max: 0.6 };
    this.spawnRate = 0.03;
    this.maxPop = 10;
    this.initPop = 4;

    // Create an initial pop
    for (let i = 0; i < this.initPop; i++) {
      this.spawn();
    }
  }

  step() {
    // Have all the bubbles update (i.e. check for breaks)
    this.bubbles.forEach(function(bubble) {
      bubble.step();
    });

    // Get rid of destroyed bubbles
    this.bubbles = this.bubbles.filter(function(bubble) {
      return !bubble.zombie;
    });

    // Make more bubbles if none left or we need more and there arent too many
    if (this.bubbles.length < 1 || (Math.random() < this.spawnRate && this.bubbles.length < this.maxPop)) {
      this.spawn();
    }
  }

  /* Make new bubbles that dont overlap previous bubbles */
  spawn() {
    let newBubbleData;
    let count = -1;
    do {
      newBubbleData = this.getPosAndRadius();
      count++;
    } while (!this.isLegal(newBubbleData) && count < 100);

    if (this.isLegal(newBubbleData)) {
      const bubble = new Bubble(newBubbleData.radius, newBubbleData.pos);
      this.bubbles.push(bubble);
    }
  }

  /* Return a random radius and position for a bubble within bounds */
  getPosAndRadius() {
    const radius = (Math.random() * this.radiusBounds.max) + this.radiusBounds.min;
    const x = (Math.random() * (this.bounds.maxX - this.bounds.minX - 3)) + (this.bounds.minX + 1.5);
    const y = (Math.random() * (this.bounds.maxY- this.bounds.minY - 3)) + (this.bounds.minY + 1.5);
    const pos = {x: x, y: y};

    return {radius, pos};
  }

  /* Check if the bubble is overlapping any existing bubble */
  isLegal(newBubble) {
    const that = this;
    let isLegal = true;
    this.bubbles.forEach(function(bubble) {
      if (that.hasOverlap(bubble, newBubble)) {
        isLegal = false; // too close
      }
    });

    return isLegal;
  }

  /* Check if bubble1 is overlapping a bubble2 */
  hasOverlap(bubble1, bubble2) {
    const distanceBetweenCenters = this.dist(bubble1.pos, bubble2.pos);
    const combinedRadii = bubble1.radius + bubble2.radius;
    if (distanceBetweenCenters < combinedRadii) {
      return true; // has overlap
    }
    return false;
  }

  // from: https://stackoverflow.com/questions/20916953/get-distance-between-two-points-in-canvas
  /* Get the distance between two points */
  dist(pos1, pos2) {
    const x1 = pos1.x;
    const y1 = pos1.y;
    const x2 = pos2.x;
    const y2 = pos2.y;
    return Math.sqrt( Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2) );
  }

}
;/**
 * Represents a pair of converging fingers that can pop bubbles
 */
class Fingers {
  constructor(pos, type) {
    this.defaultDistance = 4;
    this.length = 1;
    this.zombie = false;
    this.pos = pos;
    this.speed = 10;
    const height = 0.2;
    const halfDistance = this.defaultDistance / 2;

    const bd = new b2BodyDef;
    bd.type = b2_kinematicBody;
    bd.bullet = true;
    bd.position.Set(pos.x, pos.y);

    // Create first finger
    const shape0 = new b2PolygonShape();
    if (type === 1) {
      shape0.vertices[0] = new b2Vec2(-halfDistance, height);
      shape0.vertices[1] = new b2Vec2(-halfDistance-this.length, 0);
      shape0.vertices[2] = new b2Vec2(-halfDistance, -height);
    } else {
      shape0.vertices[0] = new b2Vec2(-halfDistance-this.length, height);
      shape0.vertices[1] = new b2Vec2(-halfDistance, 0);
      shape0.vertices[2] = new b2Vec2(-halfDistance-this.length, -height);
    }

    this.body0 = world.CreateBody(bd);
    this.body0.fixedRotation = true;
    this.body0.CreateFixtureFromShape(shape0, 10000.0);

    // Create second finger
    const shape1 = new b2PolygonShape();
    if (type === 1) {
      shape1.vertices[0] = new b2Vec2(halfDistance, height);
      shape1.vertices[1] = new b2Vec2(halfDistance+this.length, 0);
      shape1.vertices[2] = new b2Vec2(halfDistance, -height);
    } else {
      shape1.vertices[0] = new b2Vec2(halfDistance+this.length, height);
      shape1.vertices[1] = new b2Vec2(halfDistance, 0);
      shape1.vertices[2] = new b2Vec2(halfDistance+this.length, -height);
    }

    this.body1 = world.CreateBody(bd);
    this.body1.fixedRotation = true;
    this.body1.CreateFixtureFromShape(shape1, 10000.0);

    // Start the fingers moving towards eachother
    this.body0.SetLinearVelocity(new b2Vec2(this.speed, 0));
    this.body1.SetLinearVelocity(new b2Vec2(-this.speed, 0));
  }

  step() {
    // Check if the fingers are touching or have moved past each other
    const x0 = this.body0.GetPosition().x;
    const x1 = this.body1.GetPosition().x;
    if (Math.abs(x0 - x1) >= this.defaultDistance) {
      // If they have come together, freeze them touching
      this.body0.SetTransform(new b2Vec2(this.pos.x+this.defaultDistance/2, this.pos.y), 0);
      this.body1.SetTransform(new b2Vec2(this.pos.x-this.defaultDistance/2, this.pos.y), 0);
      this.body0.SetLinearVelocity(new b2Vec2(0, 0));
      this.body1.SetLinearVelocity(new b2Vec2(0, 0));
    }
  }

  /* Destroy these fingers */
  destroy() {
    if (!this.zombie) {
      world.DestroyBody(this.body0);
      world.DestroyBody(this.body1);
      this.zombie = true;
    }
  }

}
